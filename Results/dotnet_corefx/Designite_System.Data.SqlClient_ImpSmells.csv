Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,DetermineExtendedTypeCodeForUseWithSqlDbType,The method has 178 lines of code.
Long Method,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SmiMetaDataFromDataColumn,The method has 112 lines of code.
Long Method,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SmiMetaDataFromSchemaTableRow,The method has 229 lines of code.
Long Method,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The method has 110 lines of code.
Long Method,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetSqlValue,The method has 102 lines of code.
Long Method,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,FillCompatibleITypedSettersFromReader,The method has 121 lines of code.
Long Method,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,FillCompatibleSettersFromReader,The method has 198 lines of code.
Long Method,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,FillCompatibleSettersFromRecord,The method has 158 lines of code.
Long Method,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,InferFromValue,The method has 170 lines of code.
Long Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,AnalyzeTargetAndCreateUpdateBulkCommand,The method has 203 lines of code.
Long Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The method has 183 lines of code.
Long Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetColumnMetadata,The method has 110 lines of code.
Long Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ConvertValue,The method has 139 lines of code.
Long Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalRestContinuedAsync,The method has 107 lines of code.
Long Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalRestAsync,The method has 121 lines of code.
Long Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The method has 218 lines of code.
Long Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,The method has 192 lines of code.
Long Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildParamList,The method has 120 lines of code.
Long Method,System.Data.SqlClient,SqlConnectionString,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionString.cs,SqlConnectionString,The method has 158 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The method has 228 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCloseInternal,The method has 133 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryGetBytesInternal,The method has 170 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetChars,The method has 122 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryNextResult,The method has 123 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadInternal,The method has 143 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumnInternal,The method has 113 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsync,The method has 102 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,ReadAsync,The method has 137 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,IsDBNullAsync,The method has 112 lines of code.
Long Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetFieldValueAsync,The method has 109 lines of code.
Long Method,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,Start,The method has 100 lines of code.
Long Method,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetMetaTypeFromValue,The method has 138 lines of code.
Long Method,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,EnlistNonNull,The method has 130 lines of code.
Long Method,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ExecuteTransactionYukon,The method has 127 lines of code.
Long Method,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The method has 141 lines of code.
Long Method,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The method has 127 lines of code.
Long Method,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The method has 118 lines of code.
Long Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The method has 148 lines of code.
Long Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualSize,The method has 100 lines of code.
Long Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,CoerceValue,The method has 107 lines of code.
Long Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualFieldsAndProperties,The method has 275 lines of code.
Long Method,System.Data.SqlClient,SqlSequentialStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialStream.cs,ReadAsync,The method has 105 lines of code.
Long Method,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,ReadAsync,The method has 136 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The method has 123 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The method has 163 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,The method has 106 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The method has 105 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The method has 540 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The method has 259 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessDone,The method has 101 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessSessionState,The method has 115 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessReturnValue,The method has 194 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryCommonProcessMetaData,The method has 189 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The method has 197 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlVariant,The method has 155 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantValue,The method has 123 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The method has 125 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The method has 107 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The method has 288 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The method has 168 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteSQLBatch,The method has 101 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The method has 504 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSmiTypeInfo,The method has 172 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The method has 172 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The method has 146 lines of code.
Long Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The method has 202 lines of code.
Long Method,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,SNIWritePacket,The method has 120 lines of code.
Long Method,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,GetKeyValuePair,The method has 179 lines of code.
Long Method,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The method has 214 lines of code.
Long Method,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,TryGetConnection,The method has 154 lines of code.
Long Method,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,DeactivateObject,The method has 117 lines of code.
Long Method,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,TryGetConnection,The method has 131 lines of code.
Long Method,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,HandleReceiveComplete,The method has 117 lines of code.
Complex Method,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SmiMetaDataFromDataColumn,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CheckXetParameters,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Adjust,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,AnalyzeTargetAndCreateUpdateBulkCommand,Cyclomatic complexity of the method is 23
Complex Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteRowSourceToServerCommon,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CheckAndRaiseNotification,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyRowsAsync,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,Cyclomatic complexity of the method is 22
Complex Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,ValidateCommand,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,OnReturnValue,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildParamList,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlCommandSet,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommandSet.cs,Append,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,ValidateAndReconnect,Cyclomatic complexity of the method is 11
Complex Method,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnection,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlConnectionString,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionString.cs,SqlConnectionString,Cyclomatic complexity of the method is 21
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,Cyclomatic complexity of the method is 14
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCleanPartialRead,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryConsumeMetaData,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryGetBytesInternal,Cyclomatic complexity of the method is 26
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetChars,Cyclomatic complexity of the method is 14
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetCharsFromPlpData,Cyclomatic complexity of the method is 11
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryHasMoreResults,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryHasMoreRows,Cyclomatic complexity of the method is 13
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryNextResult,Cyclomatic complexity of the method is 11
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadInternal,Cyclomatic complexity of the method is 17
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,WillHaveEnoughData,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TrySetAltMetaDataSet,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TrySetMetaData,Cyclomatic complexity of the method is 13
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsync,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsyncReadDataStage,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,ReadAsync,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetFieldValueAsync,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ExecuteTransactionYukon,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,CompleteLogin,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,Cyclomatic complexity of the method is 14
Complex Method,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,Cyclomatic complexity of the method is 14
Complex Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,FixStreamDataForNonPLP,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualFieldsAndProperties,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,Validate,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ValueSize,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,Read,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,ReadBytes,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,SqlCachedStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,Read,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,SqlStreamingXml,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,GetChars,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,Connect,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,CheckResetConnection,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessDone,Cyclomatic complexity of the method is 17
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessSessionState,Cyclomatic complexity of the method is 13
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessError,Cyclomatic complexity of the method is 12
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessReturnValue,Cyclomatic complexity of the method is 33
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessAltMetaData,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryCommonProcessMetaData,Cyclomatic complexity of the method is 34
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,Cyclomatic complexity of the method is 14
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessColInfo,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,Cyclomatic complexity of the method is 21
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,Cyclomatic complexity of the method is 46
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,Cyclomatic complexity of the method is 13
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteXmlFeed,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeChars,Cyclomatic complexity of the method is 18
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ReadPlpAnsiChars,Cyclomatic complexity of the method is 11
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TrySkipPlpValue,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessUDTMetaData,Cyclomatic complexity of the method is 14
Complex Method,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadByteArray,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadPlpBytes,Cyclomatic complexity of the method is 14
Complex Method,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadNetworkPacket,Cyclomatic complexity of the method is 8
Complex Method,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadSni,Cyclomatic complexity of the method is 9
Complex Method,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,SNIWritePacket,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,RemoveStringQuotes,Cyclomatic complexity of the method is 8
Complex Method,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,Cyclomatic complexity of the method is 9
Complex Method,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,Cyclomatic complexity of the method is 8
Complex Method,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,CleanupCallback,Cyclomatic complexity of the method is 8
Complex Method,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,PoolCreateRequest,Cyclomatic complexity of the method is 10
Complex Method,System.Data.ProviderBase,DbMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbMetaDataFactory.cs,FindMetaDataCollectionRow,Cyclomatic complexity of the method is 10
Complex Method,System.Data.ProviderBase,DbMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbMetaDataFactory.cs,SupportedByCurrentVersion,Cyclomatic complexity of the method is 10
Complex Method,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferNamedPipesInformation,Cyclomatic complexity of the method is 10
Complex Method,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Format,Cyclomatic complexity of the method is 8
Complex Method,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,Cyclomatic complexity of the method is 9
Complex Method,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadSource,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.SqlServer.Server,ITypedGetters,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedGetters.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedGetters,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedGetters.cs,GetChars,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedGettersV3,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedGettersV3.cs,GetBytes,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedGettersV3,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedGettersV3.cs,GetChars,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedSetters,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedSetters.cs,SetBytes,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedSetters,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedSetters.cs,SetChars,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedSettersV3,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedSettersV3.cs,SetBytes,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedSettersV3,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedSettersV3.cs,SetChars,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ITypedSettersV3,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ITypedSettersV3.cs,SetString,The method has 5 parameters. Parameters: sink' ordinal' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,MemoryRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MemoryRecordBuffer.cs,GetBytes,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,MemoryRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MemoryRecordBuffer.cs,GetChars,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,MemoryRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MemoryRecordBuffer.cs,SetBytes,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,MemoryRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MemoryRecordBuffer.cs,SetChars,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,MemoryRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MemoryRecordBuffer.cs,SetString,The method has 5 parameters. Parameters: sink' ordinal' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The method has 7 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType
Long Parameter List,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The method has 10 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' isMultiValued' fieldTypes' extendedProperties
Long Parameter List,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The method has 11 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' udtAssemblyQualifiedName' isMultiValued' fieldTypes' extendedProperties
Long Parameter List,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The method has 5 parameters. Parameters: sqlDbType' maxLength' precision' scale' compareOptions
Long Parameter List,Microsoft.SqlServer.Server,SmiExtendedMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiExtendedMetaData,The method has 11 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3
Long Parameter List,Microsoft.SqlServer.Server,SmiExtendedMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiExtendedMetaData,The method has 14 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3
Long Parameter List,Microsoft.SqlServer.Server,SmiExtendedMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiExtendedMetaData,The method has 15 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' udtAssemblyQualifiedName' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3
Long Parameter List,Microsoft.SqlServer.Server,SmiParameterMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiParameterMetaData,The method has 15 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' direction
Long Parameter List,Microsoft.SqlServer.Server,SmiParameterMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiParameterMetaData,The method has 16 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' udtAssemblyQualifiedName' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' direction
Long Parameter List,Microsoft.SqlServer.Server,SmiStorageMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiStorageMetaData,The method has 19 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' allowsDBNull' serverName' catalogName' schemaName' tableName' columnName' isKey' isIdentity
Long Parameter List,Microsoft.SqlServer.Server,SmiStorageMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiStorageMetaData,The method has 22 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' allowsDBNull' serverName' catalogName' schemaName' tableName' columnName' isKey' isIdentity
Long Parameter List,Microsoft.SqlServer.Server,SmiStorageMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiStorageMetaData,The method has 24 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' udtAssemblyQualifiedName' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' allowsDBNull' serverName' catalogName' schemaName' tableName' columnName' isKey' isIdentity' isColumnSet
Long Parameter List,Microsoft.SqlServer.Server,SmiQueryMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiQueryMetaData,The method has 23 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' allowsDBNull' serverName' catalogName' schemaName' tableName' columnName' isKey' isIdentity' isReadOnly' isExpression' isAliased' isHidden
Long Parameter List,Microsoft.SqlServer.Server,SmiQueryMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiQueryMetaData,The method has 26 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' allowsDBNull' serverName' catalogName' schemaName' tableName' columnName' isKey' isIdentity' isReadOnly' isExpression' isAliased' isHidden
Long Parameter List,Microsoft.SqlServer.Server,SmiQueryMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiQueryMetaData,The method has 28 parameters. Parameters: dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' udtAssemblyQualifiedName' isMultiValued' fieldMetaData' extendedProperties' name' typeSpecificNamePart1' typeSpecificNamePart2' typeSpecificNamePart3' allowsDBNull' serverName' catalogName' schemaName' tableName' columnName' isKey' isIdentity' isColumnSet' isReadOnly' isExpression' isAliased' isHidden
Long Parameter List,Microsoft.SqlServer.Server,SmiRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiRecordBuffer.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiRecordBuffer.cs,GetChars,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiRecordBuffer.cs,SetBytes,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiRecordBuffer.cs,SetChars,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiTypedGetterSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiTypedGetterSetter.cs,GetBytes,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiTypedGetterSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiTypedGetterSetter.cs,GetChars,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiTypedGetterSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiTypedGetterSetter.cs,SetBytes,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiTypedGetterSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiTypedGetterSetter.cs,SetChars,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SmiTypedGetterSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiTypedGetterSetter.cs,SetString,The method has 5 parameters. Parameters: sink' ordinal' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,GetBytes,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,GetChars,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,SetBytes,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,SetChars,The method has 5 parameters. Parameters: ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetBytesConversion,The method has 9 parameters. Parameters: sink' getters' ordinal' metaData' fieldOffset' buffer' bufferOffset' length' throwOnNull
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetBytes,The method has 9 parameters. Parameters: sink' getters' ordinal' metaData' fieldOffset' buffer' bufferOffset' length' throwOnNull
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetBytesInternal,The method has 9 parameters. Parameters: sink' getters' ordinal' metaData' fieldOffset' buffer' bufferOffset' length' throwOnNull
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetChars,The method has 8 parameters. Parameters: sink' getters' ordinal' metaData' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetDateTimeOffset,The method has 5 parameters. Parameters: sink' getters' ordinal' metaData' gettersSupportKatmaiDateTime
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBoolean,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetByte,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes,The method has 8 parameters. Parameters: sink' setters' ordinal' metaData' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytesLength,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars,The method has 8 parameters. Parameters: sink' setters' ordinal' metaData' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDateTime,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDateTimeOffset,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDecimal,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDouble,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetGuid,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetInt16,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetInt32,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetInt64,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSingle,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBinary,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBoolean,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlByte,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBytes,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlChars,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlDateTime,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlDecimal,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlDouble,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlGuid,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlInt16,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlInt32,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlInt64,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlMoney,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlSingle,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlString,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlXml,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetString,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetTimeSpan,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The method has 7 parameters. Parameters: sink' setters' ordinal' metaData' value' typeCode' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValueV200,The method has 10 parameters. Parameters: sink' setters' ordinal' metaData' value' typeCode' offset' length' peekAhead' storageType
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValueV200,The method has 9 parameters. Parameters: sink' setters' ordinal' metaData' value' typeCode' offset' length' peekAhead
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDataTable_Unchecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,FillCompatibleSettersFromRecord,The method has 5 parameters. Parameters: sink' setters' metaData' record' useDefaultValues
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDecimal_PossiblyMoney,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDateTime_Checked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetTimeSpan_Checked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlDateTime_Checked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDateTime2_Checked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDate_Checked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlMoney_Checked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetByteArray_LengthChecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' buffer' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCharArray_LengthChecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' buffer' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBinary_LengthChecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' value' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes_FromRecord,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' record' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes_FromReader,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' reader' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBytes_LengthChecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' value' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars_FromRecord,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' record' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCharsOrString_FromReader,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' reader' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars_FromReader,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' reader' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetString_FromReader,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' reader' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlChars_LengthChecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' value' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlString_LengthChecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' value' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetString_LengthChecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' value' offset
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetUdt_LengthChecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CheckXetParameters,The method has 7 parameters. Parameters: dbType' maxLength' actualLength' fieldOffset' bufferLength' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetBytes_Unchecked,The method has 7 parameters. Parameters: sink' getters' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetChars_Unchecked,The method has 7 parameters. Parameters: sink' getters' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetByteArray_Unchecked,The method has 6 parameters. Parameters: sink' setters' ordinal' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetStream_Unchecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metadata' feed
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetTextReader_Unchecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metadata' feed
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes_Unchecked,The method has 7 parameters. Parameters: sink' setters' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCharArray_Unchecked,The method has 6 parameters. Parameters: sink' setters' ordinal' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars_Unchecked,The method has 7 parameters. Parameters: sink' setters' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDateTime2_Unchecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDate_Unchecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBinary_Unchecked,The method has 6 parameters. Parameters: sink' setters' ordinal' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBytes_Unchecked,The method has 6 parameters. Parameters: sink' setters' ordinal' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlChars_Unchecked,The method has 6 parameters. Parameters: sink' setters' ordinal' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlMoney_Unchecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlString_Unchecked,The method has 7 parameters. Parameters: sink' setters' ordinal' metaData' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetString_Unchecked,The method has 6 parameters. Parameters: sink' setters' ordinal' value' offset' length
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDbDataReader_Unchecked,The method has 5 parameters. Parameters: sink' setters' ordinal' metaData' value
Long Parameter List,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetIEnumerableOfSqlDataRecord_Unchecked,The method has 6 parameters. Parameters: sink' setters' ordinal' metaData' value' peekAhead
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 6 parameters. Parameters: name' dbType' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 7 parameters. Parameters: name' dbType' maxLength' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 8 parameters. Parameters: name' dbType' userDefinedType' serverTypeName' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 8 parameters. Parameters: name' dbType' precision' scale' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 5 parameters. Parameters: name' dbType' maxLength' locale' compareOptions
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 9 parameters. Parameters: name' dbType' maxLength' locale' compareOptions' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 9 parameters. Parameters: name' dbType' database' owningSchema' objectName' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 8 parameters. Parameters: name' dbType' maxLength' precision' scale' locale' compareOptions' userDefinedType
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 12 parameters. Parameters: name' dbType' maxLength' precision' scale' localeId' compareOptions' userDefinedType' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 5 parameters. Parameters: name' dbType' database' owningSchema' objectName
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 12 parameters. Parameters: name' sqlDBType' maxLength' precision' scale' localeId' compareOptions' xmlSchemaCollectionDatabase' xmlSchemaCollectionOwningSchema' xmlSchemaCollectionName' partialLength' udtType
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The method has 8 parameters. Parameters: name' sqlDbType' maxLength' precision' scale' localeId' compareOptions' partialLength
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The method has 6 parameters. Parameters: name' dbType' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The method has 7 parameters. Parameters: name' dbType' maxLength' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The method has 9 parameters. Parameters: name' dbType' maxLength' locale' compareOptions' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The method has 8 parameters. Parameters: name' dbType' precision' scale' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The method has 8 parameters. Parameters: name' dbType' userDefinedType' serverTypeName' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The method has 9 parameters. Parameters: name' dbType' database' owningSchema' objectName' useServerDefault' isUniqueKey' columnSortOrder' sortOrdinal
Long Parameter List,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ConvertValue,The method has 5 parameters. Parameters: value' metadata' isNull' isSqlType' coercedToDataFeed
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteCommandError,The method has 5 parameters. Parameters: this' operationId' sqlCommand' ex' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteConnectionOpenError,The method has 5 parameters. Parameters: this' operationId' sqlConnection' ex' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteConnectionCloseAfter,The method has 5 parameters. Parameters: this' operationId' clientConnectionId' sqlConnection' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteConnectionCloseError,The method has 6 parameters. Parameters: this' operationId' clientConnectionId' sqlConnection' ex' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteTransactionCommitAfter,The method has 5 parameters. Parameters: this' operationId' isolationLevel' connection' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteTransactionCommitError,The method has 6 parameters. Parameters: this' operationId' isolationLevel' connection' ex' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteTransactionRollbackBefore,The method has 5 parameters. Parameters: this' isolationLevel' connection' transactionName' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteTransactionRollbackAfter,The method has 6 parameters. Parameters: this' operationId' isolationLevel' connection' transactionName' operation
Long Parameter List,System.Data.SqlClient,SqlClientDiagnosticListenerExtensions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlClientDiagnosticListenerExtensions.cs,WriteTransactionRollbackError,The method has 7 parameters. Parameters: this' operationId' isolationLevel' connection' transactionName' ex' operation
Long Parameter List,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,InternalExecuteNonQuery,The method has 5 parameters. Parameters: completion' sendToPipe' timeout' asyncWrite' methodName
Long Parameter List,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReader,The method has 8 parameters. Parameters: cmdBehavior' runBehavior' returnStream' completion' timeout' task' asyncWrite' method
Long Parameter List,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,The method has 8 parameters. Parameters: cmdBehavior' runBehavior' returnStream' async' timeout' task' asyncWrite' ds
Long Parameter List,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnection,The method has 5 parameters. Parameters: options' poolKey' poolGroupProviderInfo' pool' owningConnection
Long Parameter List,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnection,The method has 6 parameters. Parameters: options' poolKey' poolGroupProviderInfo' pool' owningConnection' userOptions
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytes,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesInternal,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryGetBytesInternal,The method has 6 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length' remaining
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesInternalSequential,The method has 5 parameters. Parameters: i' buffer' index' length' timeoutMilliseconds
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryGetBytesInternalSequential,The method has 5 parameters. Parameters: i' buffer' index' length' bytesRead
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetChars,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetCharsFromPlpData,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetStreamingXmlChars,The method has 5 parameters. Parameters: i' dataIndex' buffer' bufferIndex' length
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsync,The method has 7 parameters. Parameters: i' buffer' index' length' timeout' cancellationToken' bytesRead
Long Parameter List,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsyncReadDataStage,The method has 9 parameters. Parameters: i' buffer' index' length' timeout' isContinuation' cancellationToken' timeoutToken' bytesRead
Long Parameter List,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,MetaType,The method has 14 parameters. Parameters: precision' scale' fixedLength' isFixed' isLong' isPlp' tdsType' nullableTdsType' typeName' classType' sqlType' sqldbType' dbType' propBytes
Long Parameter List,System.Data.SqlClient,SqlError,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlError.cs,SqlError,The method has 9 parameters. Parameters: infoNumber' errorState' errorClass' server' errorMessage' procedure' lineNumber' win32ErrorCode' exception
Long Parameter List,System.Data.SqlClient,SqlError,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlError.cs,SqlError,The method has 8 parameters. Parameters: infoNumber' errorState' errorClass' server' errorMessage' procedure' lineNumber' exception
Long Parameter List,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,ExecuteTransaction,The method has 5 parameters. Parameters: transactionRequest' name' iso' internalTransaction' isDelegateControlRequest
Long Parameter List,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,SqlInternalConnectionTds,The method has 7 parameters. Parameters: identity' connectionOptions' providerInfo' redirectedUserInstance' userConnectionOptions' reconnectSessionData' applyTransientFaultHandling
Long Parameter List,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ExecuteTransaction,The method has 5 parameters. Parameters: transactionRequest' name' iso' internalTransaction' isDelegateControlRequest
Long Parameter List,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ExecuteTransactionYukon,The method has 5 parameters. Parameters: transactionRequest' transactionName' iso' internalTransaction' isDelegateControlRequest
Long Parameter List,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The method has 6 parameters. Parameters: useFailoverHost' primaryServerInfo' failoverHost' redirectedUserInstance' connectionOptions' timeout
Long Parameter List,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,SqlParameter,The method has 10 parameters. Parameters: parameterName' dbType' size' direction' isNullable' precision' scale' sourceColumn' sourceVersion' value
Long Parameter List,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,SqlParameter,The method has 13 parameters. Parameters: parameterName' dbType' size' direction' precision' scale' sourceColumn' sourceVersion' sourceColumnNullMapping' value' xmlSchemaCollectionDatabase' xmlSchemaCollectionOwningSchema' xmlSchemaCollectionName
Long Parameter List,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,CoerceValue,The method has 5 parameters. Parameters: value' destinationType' coercedToDataFeed' typeChanged' allowStreaming
Long Parameter List,System.Data.SqlClient,SqlSequentialStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialStream.cs,BeginRead,The method has 5 parameters. Parameters: array' offset' count' asyncCallback' asyncState
Long Parameter List,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,DecodeBytesToChars,The method has 5 parameters. Parameters: inBuffer' inBufferCount' outBuffer' outBufferOffset' outBufferCount
Long Parameter List,System.Data.SqlClient,SqlUnicodeDecoder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,System.Data.SqlClient,SqlUnicodeDecoder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,Convert,The method has 10 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex' charCount' flush' bytesUsed' charsUsed' completed
Long Parameter List,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,SqlStream,The method has 5 parameters. Parameters: columnOrdinal' reader' addByteOrderMark' processAllRows' advanceReader
Long Parameter List,System.Data.SqlClient,AsyncHelper,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,CreateContinuationTask,The method has 6 parameters. Parameters: task' onSuccess' arg1' arg2' connectionToDoom' onFailure
Long Parameter List,System.Data.SqlClient,AsyncHelper,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,ContinueTask,The method has 8 parameters. Parameters: task' completion' onSuccess' connectionToDoom' onFailure' onCancellation' exceptionConverter' connectionToAbort
Long Parameter List,System.Data.SqlClient,SQLMessage,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,Duration_PostLogin,The method has 5 parameters. Parameters: PreLoginBeginDuration' PreLoginHandshakeDuration' LoginBeginDuration' LoginAuthDuration' PostLoginDuration
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,Connect,The method has 8 parameters. Parameters: serverInfo' connHandler' ignoreSniOpenTimeout' timerExpire' encrypt' trustServerCert' integratedSecurity' withFailover
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,Run,The method has 5 parameters. Parameters: runBehavior' cmdHandler' dataStream' bulkCopyHandler' stateObj
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The method has 6 parameters. Parameters: runBehavior' cmdHandler' dataStream' bulkCopyHandler' stateObj' dataReady
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUDTMetaData,The method has 5 parameters. Parameters: value' database' schema' type' stateObj
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessColumnHeader,The method has 5 parameters. Parameters: col' stateObj' columnOrdinal' isNull' length
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlStringValue,The method has 6 parameters. Parameters: value' type' length' encoding' isPlp' stateObj
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The method has 5 parameters. Parameters: value' tdsType' length' scale' stateObj
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantValue,The method has 5 parameters. Parameters: value' length' offset' stateObj' canAccumulate
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDecimal,The method has 5 parameters. Parameters: value' length' precision' scale' stateObj
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteCharArray,The method has 5 parameters. Parameters: carr' length' offset' stateObj' canAccumulate
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteString,The method has 5 parameters. Parameters: s' length' offset' stateObj' canAccumulate
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,CopyCharsToBytes,The method has 5 parameters. Parameters: source' sourceOffset' dest' destOffset' charLength
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,CopyStringToBytes,The method has 5 parameters. Parameters: source' sourceOffset' dest' destOffset' charLength
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteEncodingChar,The method has 6 parameters. Parameters: s' numChars' offset' encoding' stateObj' canAccumulate
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The method has 8 parameters. Parameters: buffer' request' transactionName' isoLevel' timeout' transaction' stateObj' isDelegateControlRequest
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteSQLBatch,The method has 6 parameters. Parameters: text' timeout' notificationRequest' stateObj' sync' callerHasConnectionLock
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The method has 10 parameters. Parameters: rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion' startRpc' startParam
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The method has 6 parameters. Parameters: value' metadata' stateObj' isSqlType' isDataFeed' isNull
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValueSetupContinuation,The method has 5 parameters. Parameters: internalWriteTask' saveEncoding' saveCollation' saveCodePage' saveLCID
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetTerminationTask,The method has 6 parameters. Parameters: unterminatedWriteTask' value' type' actualLength' stateObj' isDataFeed
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlValue,The method has 6 parameters. Parameters: value' type' actualLength' codePageByteSize' offset' stateObj
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The method has 6 parameters. Parameters: value' type' actualLength' codePageByteSize' offset' stateObj
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteXmlFeed,The method has 5 parameters. Parameters: feed' stateObj' needBom' encoding' size
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTextFeed,The method has 5 parameters. Parameters: feed' encoding' needBom' stateObj' size
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteValue,The method has 9 parameters. Parameters: value' type' scale' actualLength' encodingByteSize' offset' stateObj' paramSize' isDataFeed
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The method has 9 parameters. Parameters: value' type' scale' actualLength' encodingByteSize' offset' stateObj' paramSize' isDataFeed
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteParameterVarLen,The method has 5 parameters. Parameters: type' size' isNull' stateObj' unknownLength
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeCharsChunk,The method has 5 parameters. Parameters: buff' offst' len' stateObj' charsRead
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeChars,The method has 5 parameters. Parameters: buff' offst' len' stateObj' totalCharsRead
Long Parameter List,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ReadPlpAnsiChars,The method has 5 parameters. Parameters: buff' offst' len' metadata' stateObj
Long Parameter List,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,CreatePhysicalSNIHandle,The method has 9 parameters. Parameters: serverName' ignoreSniOpenTimeout' timerExpire' instanceName' spnBuffer' flushCache' async' fParallel' isIntegratedSecurity
Long Parameter List,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,GenerateSspiClientContext,The method has 5 parameters. Parameters: receivedBuff' receivedLength' sendBuff' sendLength' _sniSpnBuffer
Long Parameter List,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WriteByteArray,The method has 5 parameters. Parameters: b' len' offsetBuffer' canAccumulate' completion
Long Parameter List,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WriteByteArraySetupContinuation,The method has 5 parameters. Parameters: b' len' completion' offset' packetTask
Long Parameter List,System.Data.SqlClient,TdsRecordBufferSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsRecordBufferSetter.cs,SetBytes,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,System.Data.SqlClient,TdsRecordBufferSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsRecordBufferSetter.cs,SetChars,The method has 6 parameters. Parameters: sink' ordinal' fieldOffset' buffer' bufferOffset' length
Long Parameter List,System.Data.SqlClient,TdsRecordBufferSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsRecordBufferSetter.cs,SetString,The method has 5 parameters. Parameters: sink' ordinal' value' offset' length
Long Parameter List,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,GetKeyValuePair,The method has 6 parameters. Parameters: connectionString' currentPosition' buffer' useOdbcRules' keyname' keyvalue
Long Parameter List,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,ParseComparison,The method has 5 parameters. Parameters: parsetable' connectionString' synonyms' firstKey' e
Long Parameter List,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,ParseInternal,The method has 5 parameters. Parameters: parsetable' connectionString' buildChain' synonyms' firstKey
Long Parameter List,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The method has 5 parameters. Parameters: name' leftQuote' rightQuote' property' ThrowOnEmptyMultipartName
Long Parameter List,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The method has 8 parameters. Parameters: name' leftQuote' rightQuote' separator' limit' removequotes' property' ThrowOnEmptyMultipartName
Long Parameter List,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,CreatePooledConnection,The method has 5 parameters. Parameters: pool' owningObject' options' poolKey' userOptions
Long Parameter List,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,TryGetConnection,The method has 5 parameters. Parameters: owningConnection' retry' userOptions' oldConnection' connection
Long Parameter List,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,CreateConnection,The method has 6 parameters. Parameters: options' poolKey' poolGroupProviderInfo' pool' owningConnection' userOptions
Long Parameter List,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,CreateConnection,The method has 5 parameters. Parameters: options' poolKey' poolGroupProviderInfo' pool' owningConnection
Long Parameter List,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,GetSchema,The method has 5 parameters. Parameters: factory' poolGroup' outerConnection' collectionName' restrictions
Long Parameter List,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,TryGetConnection,The method has 6 parameters. Parameters: owningObject' waitForMultipleObjectsTimeout' allowCreate' onlyOneCheckConnection' userOptions' connection
Long Parameter List,System.Data.ProviderBase,DbConnectionPoolGroupOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPoolOptions.cs,DbConnectionPoolGroupOptions,The method has 6 parameters. Parameters: poolByIdentity' minPoolSize' maxPoolSize' creationTimeout' loadBalanceTimeout' hasTransactionAffinity
Long Parameter List,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDecimalExtractData,The method has 5 parameters. Parameters: d' data1' data2' data3' data4
Long Parameter List,System.Data.SqlClient.SNI,SNIProxy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,CreateConnectionHandle,The method has 10 parameters. Parameters: callbackObject' fullServerName' ignoreSniOpenTimeout' timerExpire' instanceName' spnBuffer' flushCache' async' parallel' isIntegratedSecurity
Long Parameter List,System.Data.SqlClient.SNI,SNITCPHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNITcpHandle.cs,SNITCPHandle,The method has 5 parameters. Parameters: serverName' port' timerExpire' callbackObject' parallel
Long Parameter List,System.Data.SqlClient.SNI,SNITCPHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNITcpHandle.cs,ParallelConnectHelper,The method has 6 parameters. Parameters: socket' connectTask' tcs' pendingCompleteCount' lastError' sockets
Long Parameter List,System.Data.SqlClient.SNI,SNICommon,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNICommon.cs,ValidateSslServerCertificate,The method has 5 parameters. Parameters: targetServerName' sender' cert' chain' policyErrors
Long Parameter List,System.Data.SqlClient.SNI,TdsParserStateObjectManaged,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObjectManaged.cs,CreatePhysicalSNIHandle,The method has 9 parameters. Parameters: serverName' ignoreSniOpenTimeout' timerExpire' instanceName' spnBuffer' flushCache' async' parallel' isIntegratedSecurity
Long Parameter List,System.Data.SqlClient.SNI,TdsParserStateObjectManaged,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObjectManaged.cs,GenerateSspiClientContext,The method has 5 parameters. Parameters: receivedBuff' receivedLength' sendBuff' sendLength' _sniSpnBuffer
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Enter,The method has 5 parameters. Parameters: thisOrContextObject' arg0' arg1' arg2' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,DumpBuffer,The method has 5 parameters. Parameters: thisOrContextObject' buffer' offset' count' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,GssWrap,The method has 5 parameters. Parameters: context' encrypt' buffer' offset' count
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,GssInitSecurityContext,The method has 9 parameters. Parameters: context' credential' isNtlm' targetName' inFlags' buffer' outputBuffer' outFlags' isNtlmUsed
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,EstablishSecurityContext,The method has 7 parameters. Parameters: credential' context' targetName' inFlags' inputBuffer' outputBuffer' outFlags
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,InitializeSecurityContext,The method has 7 parameters. Parameters: credentialsHandle' securityContext' spn' requestedContextFlags' inSecurityBufferArray' outSecurityBuffer' contextFlags
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,AcceptSecurityContext,The method has 6 parameters. Parameters: credentialsHandle' securityContext' requestedContextFlags' inSecurityBufferArray' outSecurityBuffer' contextFlags
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The method has 8 parameters. Parameters: securityContext' buffer' offset' count' isConfidential' isNtlm' output' sequenceNumber
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Decrypt,The method has 8 parameters. Parameters: securityContext' buffer' offset' count' isConfidential' isNtlm' newOffset' sequenceNumber
Long Parameter List,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The method has 5 parameters. Parameters: securityContext' buffer' offset' count' output
Long Identifier,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,,The length of the parameter s_extendedTypeCodeToSqlDbTypeMap is 32.
Long Identifier,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,,The length of the parameter s_maxVarTimeLenOffsetFromScale is 30.
Long Identifier,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,SqlMetaData,The length of the parameter xmlSchemaCollectionOwningSchema is 31.
Long Identifier,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,,The length of the parameter _xmlSchemaCollectionOwningSchema is 32.
Long Identifier,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,,The length of the parameter x_eDefaultStringCompareOptions is 30.
Long Identifier,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,,The length of the parameter s_maxVarTimeLenOffsetFromScale is 30.
Long Identifier,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,,The length of the parameter s_katmaiDateTimeOffsetFormatByScale is 35.
Long Identifier,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,,The length of the parameter s_katmaiDateTime2FormatByScale is 30.
Long Identifier,System.Data.SqlClient,SqlBulkCopyColumnMapping,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopyColumnMapping.cs,,The length of the parameter _internalDestinationColumnOrdinal is 33.
Long Identifier,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,,The length of the parameter _preparedConnectionReconnectCount is 33.
Long Identifier,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,,The length of the parameter _statementCompletedEventHandler is 31.
Long Identifier,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,,The length of the parameter _fireInfoMessageEventOnUserErrors is 33.
Long Identifier,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,,The length of the parameter _reconnectionCancellationSource is 31.
Long Identifier,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,,The length of the parameter _suppressStateChangeForReconnection is 35.
Long Identifier,System.Data.SqlClient,SqlConnectionStringBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionStringBuilder.cs,,The length of the parameter s_notSupportedNetworkLibraryKeywords is 36.
Long Identifier,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the parameter xmlSchemaCollectionOwningSchema is 31.
Long Identifier,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,,The length of the parameter _cancelAsyncOnCloseTokenSource is 30.
Long Identifier,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,,The length of the parameter _notificationIdToDependenciesHash is 33.
Long Identifier,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,,The length of the parameter _sqlDependencyTimeOutTimerStarted is 33.
Long Identifier,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,,The length of the parameter _globalTransactionsTokenVersionSizeInBytes is 42.
Long Identifier,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,,The length of the parameter _isGlobalTransactionEnabledForServer is 36.
Long Identifier,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,CheckEnlistedTransactionBinding,The length of the parameter requireExplicitTransactionUnbind is 32.
Long Identifier,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,SqlParameter,The length of the parameter xmlSchemaCollectionOwningSchema is 31.
Long Identifier,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,,The length of the parameter _xmlSchemaCollectionOwningSchema is 32.
Long Identifier,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,,The length of the parameter SqlNotificationStoredProcedureDefault is 37.
Long Identifier,System.Data.SqlClient,SysTxForGlobalTransactions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,,The length of the parameter _setDistributedTransactionIdentifier is 36.
Long Identifier,System.Data.SqlClient,TdsEnums,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsEnums.cs,,The length of the parameter MAX_USER_CORRECTABLE_ERROR_CLASS is 32.
Long Identifier,System.Data.SqlClient,TdsEnums,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsEnums.cs,,The length of the parameter ST_RESET_CONNECTION_PRESERVE_TRANSACTION is 40.
Long Identifier,System.Data.SqlClient,TdsEnums,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsEnums.cs,,The length of the parameter SPHINX_DEFAULT_NUMERIC_PRECISION is 32.
Long Identifier,System.Data.SqlClient,TdsEnums,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsEnums.cs,,The length of the parameter SNI_SSL_IGNORE_CHANNEL_BINDINGS is 31.
Long Identifier,System.Data.SqlClient,TdsEnums,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsEnums.cs,,The length of the parameter DEFAULT_ENGLISH_CODE_PAGE_STRING is 32.
Long Identifier,System.Data.SqlClient,TdsEnums,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsEnums.cs,,The length of the parameter DEFAULT_ENGLISH_CODE_PAGE_VALUE is 31.
Long Identifier,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,The length of the parameter threadAlreadyHadParserLockForClose is 34.
Long Identifier,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the parameter encryptedPasswordLengthInBytes is 30.
Long Identifier,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,,The length of the parameter s_sniSupportedEncryptionOption is 30.
Long Identifier,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,,The length of the parameter s_xmlMetadataSubstituteSequence is 31.
Long Identifier,System.Data.SqlClient,SqlMetaDataPriv,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,,The length of the parameter xmlSchemaCollectionOwningSchema is 31.
Long Identifier,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _waitForCancellationLockPollTimeout is 35.
Long Identifier,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _permitReplayStackTraceToDiffer is 31.
Long Identifier,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _delayedWriteAsyncCallbackException is 35.
Long Identifier,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _forceSyncOverAsyncAfterFirstPend is 33.
Long Identifier,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _forcePendingReadsToWaitForUser is 31.
Long Identifier,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _checkNetworkPacketRetryStacks is 30.
Long Identifier,System.Data.SqlClient,StateSnapshot,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _snapshotReceivedColumnMetadata is 31.
Long Identifier,System.Data.SqlClient,StateSnapshot,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,,The length of the parameter _snapshotCleanupAltMetaDataSetArray is 35.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,ParseComparison,The length of the parameter KeywordNotSupportedMessagePrefix is 32.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringValidKeyPattern is 31.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringValidValuePattern is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringQuoteValuePattern is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter ConnectionStringQuoteOdbcValuePattern is 37.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringValidKeyRegex is 31.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringValidValueRegex is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringQuoteValueRegex is 33.
Long Identifier,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,,The length of the parameter s_connectionStringQuoteOdbcValueRegex is 37.
Long Identifier,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,,The length of the parameter ApplicationIntentReadWriteString is 32.
Long Identifier,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,,The length of the parameter ApplicationIntentReadOnlyString is 31.
Long Identifier,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,TryGetConnection,The length of the parameter timeBetweenRetriesMilliseconds is 30.
Long Identifier,System.Data.ProviderBase,DbMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbMetaDataFactory.cs,,The length of the parameter _dataSourceProductVersionNormalized is 35.
Long Identifier,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,,The length of the parameter s_defaultXmlReaderSettingsCloseInput is 36.
Long Identifier,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,,The length of the parameter s_defaultXmlReaderSettingsAsyncCloseInput is 41.
Long Identifier,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,,The length of the parameter SqlStringValidSqlCompareOptionMask is 34.
Long Identifier,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,,The length of the parameter _dataSourceAfterTrimmingProtocol is 32.
Long Identifier,System.Data.SqlClient.SNI,SNICommon,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNICommon.cs,,The length of the parameter MultiSubnetFailoverWithMoreThan64IPs is 36.
Long Identifier,System.Data.SqlClient.SNI,SNICommon,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNICommon.cs,,The length of the parameter MultiSubnetFailoverWithInstanceSpecified is 40.
Long Identifier,System.Data.SqlClient.SNI,SNICommon,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNICommon.cs,,The length of the parameter MultiSubnetFailoverWithNonTcpProtocol is 37.
Long Identifier,System.Data.SqlClient.SNI,SNICommon,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNICommon.cs,,The length of the parameter LocalDBNoSqlUserInstanceDllPath is 31.
Long Identifier,System.Data.SqlClient.SNI,SNICommon,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNICommon.cs,,The length of the parameter LocalDBInvalidSqlUserInstanceDllPath is 36.
Long Identifier,System.Data.SqlClient.SNI,TdsParserStateObjectManaged,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObjectManaged.cs,CreatePhysicalSNIHandle,The length of the parameter ReceiveAsyncCallbackDispatcher is 30.
Long Statement,Microsoft.SqlServer.Server,MemoryRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MemoryRecordBuffer.cs,SetString,The length of the statement  "            Debug.Assert(offset == 0 && length <= value.Length' "Invalid string length or offset"); // for sqlvariant' length could be less than value.Length " is 145.
Long Statement,Microsoft.SqlServer.Server,MemoryRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MemoryRecordBuffer.cs,SetString,The length of the statement  "            _buffer[ordinal].String = value.Substring(offset' length); // Perf test shows that Substring method has already optimized the case where length = value.Length " is 158.
Long Statement,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,InferSqlDbTypeFromTypeCode,The length of the statement  "            Debug.Assert(typeCode >= ExtendedClrTypeCode.Invalid && typeCode <= ExtendedClrTypeCode.Last' "Someone added a typecode without adding support here!"); " is 151.
Long Statement,Microsoft.SqlServer.Server,SmiEventSink_Default,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiEventSink_Default.cs,ProcessMessages,The length of the statement  "            SqlErrorCollection temp = null;  // temp variable to store that which is being thrown - so that local copies can be deleted " is 123.
Long Statement,Microsoft.SqlServer.Server,SmiEventSink_Default,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiEventSink_Default.cs,ProcessMessages,The length of the statement  "                Debug.Assert(null == _warnings || 0 != _warnings.Count' "empty warning collection?");// must be something in the collection " is 123.
Long Statement,Microsoft.SqlServer.Server,SmiGettersStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiGettersStream.cs,Read,The length of the statement  "            long bytesRead = ValueUtilsSmi.GetBytesInternal(_sink' _getters' _ordinal' _metaData' _readPosition' buffer' offset' count' false); " is 131.
Long Statement,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,GetBytes,The length of the statement  "            return ValueUtilsSmi.GetBytes(_eventSink' _recordBuffer' ordinal' GetSmiMetaData(ordinal)' fieldOffset' buffer' bufferOffset' length' true); " is 140.
Long Statement,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,GetChars,The length of the statement  "            return ValueUtilsSmi.GetChars(_eventSink' _recordBuffer' ordinal' GetSmiMetaData(ordinal)' fieldOffset' buffer' bufferOffset' length); " is 134.
Long Statement,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,SetValues,The length of the statement  "                ValueUtilsSmi.SetCompatibleValueV200(_eventSink' _recordBuffer' i' GetSmiMetaData(i)' values[i]' typeCodes[i]' 0' 0' null); " is 123.
Long Statement,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,SetValue,The length of the statement  "            ValueUtilsSmi.SetCompatibleValueV200(_eventSink' _recordBuffer' ordinal' GetSmiMetaData(ordinal)' value' typeCode' 0' 0' null); " is 127.
Long Statement,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,SetBytes,The length of the statement  "            ValueUtilsSmi.SetBytes(_eventSink' _recordBuffer' ordinal' GetSmiMetaData(ordinal)' fieldOffset' buffer' bufferOffset' length); " is 127.
Long Statement,Microsoft.SqlServer.Server,SqlDataRecord,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlDataRecord.cs,SetChars,The length of the statement  "            ValueUtilsSmi.SetChars(_eventSink' _recordBuffer' ordinal' GetSmiMetaData(ordinal)' fieldOffset' buffer' bufferOffset' length); " is 127.
Long Statement,Microsoft.SqlServer.Server,SqlRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlRecordBuffer.cs,ConvertXmlStringToByteArray,The length of the statement  "            Debug.Assert(StorageType.String == _type' "ConvertXmlStringToByteArray: Invalid storage type for conversion: " + _type.ToString()); " is 131.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetBytesInternal,The length of the statement  "                    length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' actualLength' fieldOffset' buffer.Length' bufferOffset' length); " is 132.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetChars,The length of the statement  "                length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' actualLength' fieldOffset' buffer.Length' bufferOffset' length); " is 132.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,NullUdtInstance,The length of the statement  "            return t.InvokeMember("Null"' BindingFlags.Public | BindingFlags.GetProperty | BindingFlags.Static' null' null' new Object[] { }' CultureInfo.InvariantCulture); " is 160.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes,The length of the statement  "            length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' fieldOffset' buffer.Length' bufferOffset' length); " is 146.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars,The length of the statement  "            length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' fieldOffset' buffer.Length' bufferOffset' length); " is 146.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.String: SetString_LengthChecked(sink' setters' ordinal' metaData' (string)value' offset); break; " is 121.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.ByteArray: SetByteArray_LengthChecked(sink' setters' ordinal' metaData' (byte[])value' offset); break; " is 127.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.CharArray: SetCharArray_LengthChecked(sink' setters' ordinal' metaData' (char[])value' offset); break; " is 127.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.SqlBinary: SetSqlBinary_LengthChecked(sink' setters' ordinal' metaData' (SqlBinary)value' offset); break; " is 130.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.SqlDateTime: SetSqlDateTime_Checked(sink' setters' ordinal' metaData' (SqlDateTime)value); break; " is 122.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.SqlString: SetSqlString_LengthChecked(sink' setters' ordinal' metaData' (SqlString)value' offset); break; " is 130.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.SqlChars: SetSqlChars_LengthChecked(sink' setters' ordinal' metaData' (SqlChars)value' offset); break; " is 127.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.SqlBytes: SetSqlBytes_LengthChecked(sink' setters' ordinal' metaData' (SqlBytes)value' offset); break; " is 127.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.TextReader: SetTextReader_Unchecked(sink' setters' ordinal' metaData' (TextDataFeed)value); break; " is 123.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValue,The length of the statement  "                case ExtendedClrTypeCode.XmlReader: SetXmlReader_Unchecked(sink' setters' ordinal' ((XmlDataFeed)value)._source); break; " is 120.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValueV200,The length of the statement  "                        CanAccessSetterDirectly(metaData' typeCode)' "Un-validated type '" + typeCode + "' for metaData: " + metaData.SqlDbType); " is 121.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValueV200,The length of the statement  "                        CanAccessSetterDirectly(metaData' typeCode)' "Un-validated type '" + typeCode + "' for metaData: " + metaData.SqlDbType); " is 121.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCompatibleValueV200,The length of the statement  "                    SetIEnumerableOfSqlDataRecord_Unchecked(sink' setters' ordinal' metaData' (IEnumerable<SqlDataRecord>)value' peekAhead); " is 120.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,FillCompatibleSettersFromReader,The length of the statement  "                                ExtendedClrTypeCode typeCode = MetaDataUtilsSmi.DetermineExtendedTypeCodeForUseWithSqlDbType(metaData[i].SqlDbType' metaData[i].IsMultiValued' o' null); " is 152.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,FillCompatibleSettersFromRecord,The length of the statement  "                            SetCompatibleValueV200(sink' setters' i' metaData[i]' o' typeCode' 0' -1 /* no length restriction */' null /* no peekahead */); " is 127.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetUdt_LengthChecked,The length of the statement  "                result = t.InvokeMember("Null"' BindingFlags.Public | BindingFlags.GetProperty | BindingFlags.Static' null' null' new Object[] { }' CultureInfo.InvariantCulture); " is 162.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetByteArray_LengthChecked,The length of the statement  "            int length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' buffer.Length' offset' buffer.Length - offset); " is 150.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetCharArray_LengthChecked,The length of the statement  "            int length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' buffer.Length' offset' buffer.Length - offset); " is 150.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBinary_LengthChecked,The length of the statement  "                length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' value.Length' offset' value.Length - offset); " is 144.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes_FromRecord,The length of the statement  "            length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' checked((int)bufferLength)' offset' checked((int)bufferLength)); " is 163.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes_FromReader,The length of the statement  "            length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' NoLengthLimit /* buffer length */' offset' NoLengthLimit /* requested length */ ); " is 181.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBytes_LengthChecked,The length of the statement  "                length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' checked((int)bufferLength)' offset' checked((int)bufferLength)); " is 163.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars_FromRecord,The length of the statement  "            length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' checked((int)bufferLength)' offset' checked((int)bufferLength - offset)); " is 172.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars_FromReader,The length of the statement  "            length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' NoLengthLimit /* buffer length */' offset' NoLengthLimit /* requested length */ ); " is 181.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetString_FromReader,The length of the statement  "            int length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' value.Length' 0' NoLengthLimit /* buffer */' offset' NoLengthLimit /* request */); " is 154.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlChars_LengthChecked,The length of the statement  "                length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' checked((int)bufferLength)' offset' checked((int)bufferLength - offset)); " is 172.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlString_LengthChecked,The length of the statement  "                int length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' stringValue.Length' offset' stringValue.Length - offset); " is 160.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetString_LengthChecked,The length of the statement  "            int length = CheckXetParameters(metaData.SqlDbType' metaData.MaxLength' NoLengthLimit /* actual */' 0' value.Length' offset' checked(value.Length - offset)); " is 157.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CanAccessGetterDirectly,The length of the statement  "            Debug.Assert(ExtendedClrTypeCode.First == 0 && (int)ExtendedClrTypeCode.Last == s_canAccessGetterDirectly.GetLength(0) - 1' "ExtendedClrTypeCodes does not match with __canAccessGetterDirectly"); " is 194.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CanAccessGetterDirectly,The length of the statement  "            Debug.Assert(SqlDbType.BigInt == 0 && (int)SqlDbType.DateTimeOffset == s_canAccessGetterDirectly.GetLength(1) - 1' "SqlDbType does not match with __canAccessGetterDirectly"); " is 174.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CanAccessSetterDirectly,The length of the statement  "            Debug.Assert(ExtendedClrTypeCode.First == 0 && (int)ExtendedClrTypeCode.Last == s_canAccessSetterDirectly.GetLength(0) - 1' "ExtendedClrTypeCodes does not match with __canAccessSetterDirectly"); " is 194.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CanAccessSetterDirectly,The length of the statement  "            Debug.Assert(SqlDbType.BigInt == 0 && (int)SqlDbType.DateTimeOffset == s_canAccessSetterDirectly.GetLength(1) - 1' "SqlDbType does not match with __canAccessSetterDirectly"); " is 174.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetBytes_Unchecked,The length of the statement  "            Debug.Assert(bufferOffset >= 0 && length >= 0 && bufferOffset + length <= buffer.Length' string.Format("Bad offset or length. bufferOffset: {0}' length: {1}' buffer.Length{2}"' bufferOffset' length' buffer.Length)); " is 215.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetChars_Unchecked,The length of the statement  "            Debug.Assert(bufferOffset >= 0 && length >= 0 && bufferOffset + length <= buffer.Length' string.Format("Bad offset or length. bufferOffset: {0}' length: {1}' buffer.Length{2}"' bufferOffset' length' buffer.Length)); " is 215.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDateTime2_Unchecked,The length of the statement  "            Debug.Assert(SqlDbType.Variant == metaData.SqlDbType' "Invalid type. This should be called only when the type is variant."); " is 124.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetDate_Unchecked,The length of the statement  "            Debug.Assert(SqlDbType.Variant == metaData.SqlDbType' "Invalid type. This should be called only when the type is variant."); " is 124.
Long Statement,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetIEnumerableOfSqlDataRecord_Unchecked,The length of the statement  "                SmiDefaultFieldsProperty defaults = (SmiDefaultFieldsProperty)metaData.ExtendedProperties[SmiPropertySelector.DefaultFields]; " is 125.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The length of the statement  "                    throw ADP.Argument(SR.GetString(SR.ADP_InvalidDataLength2' maxLength.ToString(CultureInfo.InvariantCulture))' nameof(maxLength)); " is 129.
Long Statement,System.Data,Win32NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Interop\SNINativeMethodWrapper.Unix.cs,IsTokenRestrictedWrapper,The length of the statement  "            throw new PlatformNotSupportedException("Win32NativeMethods.IsTokenRestrictedWrapper is not supported on non-Windows platforms"); " is 129.
Long Statement,System.Data,Win32NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Interop\SNINativeMethodWrapper.Unix.cs,IsTokenRestrictedWrapper,The length of the statement  "            throw new PlatformNotSupportedException("Win32NativeMethods.IsTokenRestrictedWrapper is not supported on non-Windows platforms"); " is 129.
Long Statement,System.Data.SqlClient,SqlDbColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDbColumn.cs,Populate,The length of the statement  "            ColumnSize = (_metadata.metaType.IsSizeInCharacters && (_metadata.length != 0x7fffffff)) ? (_metadata.length / 2) : _metadata.length; " is 133.
Long Statement,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTimeOffset,The length of the statement  "            FillInTimeInfo(ref _value._dateTimeOffsetInfo.dateTime2Info.timeInfo' bytes' length - 5' scale); // remaining 5 bytes are for date and offset " is 141.
Long Statement,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTimeOffset,The length of the statement  "            _value._dateTimeOffsetInfo.offset = (Int16)(bytes[length - 2] + (bytes[length - 1] << 8)); // 2 bytes for offset (Int16) " is 120.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CreateInitialQuery,The length of the statement  "                parts = MultipartIdentifier.ParseMultipartIdentifier(this.DestinationTableName' "[\""' "]\""' SR.SQL_BulkCopyDestinationTableName' true); " is 137.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CreateAndExecuteInitialQueryAsync,The length of the statement  "            Task executeTask = _parser.TdsExecuteSQLBatch(TDSCommand' this.BulkCopyTimeout' null' _stateObj' sync: !_isAsyncBulkCopy' callerHasConnectionLock: true); " is 153.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,AnalyzeTargetAndCreateUpdateBulkCommand,The length of the statement  "            if (isInTransaction && null == _externalTransaction && null == _internalTransaction && (_connection.Parser != null && _connection.Parser.CurrentTransaction != null && _connection.Parser.CurrentTransaction.IsLocal)) " is 214.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,AnalyzeTargetAndCreateUpdateBulkCommand,The length of the statement  "                                        throw SQL.BulkLoadLcidMismatch(sourceLcid' _SqlDataReaderRowSource.GetName(sourceColumnId)' destinationLcid' metadata.column); " is 126.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,SubmitUpdateBulkCommand,The length of the statement  "            Task executeTask = _parser.TdsExecuteSQLBatch(TDSCommand' this.BulkCopyTimeout' null' _stateObj' sync: !_isAsyncBulkCopy' callerHasConnectionLock: true); " is 153.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The length of the statement  "                                    // There is no GetXmlReader on DbDataReader' however if GetValue returns XmlReader we will read it as stream if it is assigned to XML field " is 139.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The length of the statement  "                                    Debug.Assert(_SqlDataReaderRowSource != null' "Should not be reading row as an XmlReader if bulk copy source is not a SqlDataReader"); " is 134.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The length of the statement  "                                    Debug.Fail(string.Format("Current column is marked as being a DataFeed' but no DataFeed compatible method was provided. Method: {0}"' _currentRowMetadata[destRowIndex].Method)); " is 177.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The length of the statement  "                                    Debug.Fail(string.Format("Current column is marked as being a SqlType' but no SqlType compatible method was provided. Method: {0}"' _currentRowMetadata[destRowIndex].Method)); " is 175.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The length of the statement  "                                Debug.Assert(!(value is INullable) || !((INullable)value).IsNull' "IsDBNull returned false' but GetValue returned a null INullable"); " is 133.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The length of the statement  "                                        Debug.Fail(string.Format("Current column is marked as being a SqlType' but no SqlType compatible method was provided. Method: {0}"' _currentRowMetadata[destRowIndex].Method)); " is 175.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetValueFromSourceRow,The length of the statement  "                        // If we are here then either the value is null' there was no special storage type for this column or the special storage type wasn't handled (e.g. if the currentRowValue is NaN) " is 178.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ReadFromRowSourceAsync,The length of the statement  "                // This will call ReadAsync for DbDataReader (for SqlDataReader it will be truly async read; for non-SqlDataReader it may block.) " is 129.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ReadFromRowSourceAsync,The length of the statement  "                    _hasMoreRowToCopy = ReadFromRowSource(); // Synchronous calls for DataRows and DataTable won't block. For IDataReader' it may block. " is 132.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetColumnMetadata,The length of the statement  "            if (((_SqlDataReaderRowSource != null) || (_dataTableSource != null)) && ((metadata.metaType.NullableType == TdsEnums.SQLDECIMALN) || (metadata.metaType.NullableType == TdsEnums.SQLNUMERICN))) " is 192.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetColumnMetadata,The length of the statement  "                    if ((metadata.type == SqlDbType.VarBinary) && (mtSource.IsBinType) && (mtSource.SqlDbType != SqlDbType.Timestamp) && _SqlDataReaderRowSource.IsCommandBehavior(CommandBehavior.SequentialAccess)) " is 193.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetColumnMetadata,The length of the statement  "                    else if (((metadata.type == SqlDbType.VarChar) || (metadata.type == SqlDbType.NVarChar)) && (mtSource.IsCharType) && (mtSource.SqlDbType != SqlDbType.Xml)) " is 155.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CommitTransaction,The length of the statement  "                internalConnection.ThreadHasParserLockForClose = true; // In case of error' let the connection know that we have the lock " is 121.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,AbortTransaction,The length of the statement  "                    internalConnection.ThreadHasParserLockForClose = true; // In case of error' let the connection know that we have the lock " is 121.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ConvertValue,The length of the statement  "                        // Perf: It is more efficient to write a SqlDecimal than a decimal since we need to break it into its 'bits' when writing " is 121.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ConvertValue,The length of the statement  "                        typeChanged = false; // Setting this to false as SqlParameter.CoerceValue will only set it to true when converting to a CLR type " is 128.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ConvertValue,The length of the statement  "                        Debug.Assert((value is XmlReader) || (value is SqlCachedBuffer) || (value is string) || (value is SqlString) || (value is XmlDataFeed)' "Invalid value type of Xml datatype"); " is 174.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServer,The length of the statement  "                WriteRowSourceToServerAsync(reader.FieldCount' CancellationToken.None); //It returns null since _isAsyncBulkCopy = false; " is 121.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServer,The length of the statement  "                WriteRowSourceToServerAsync(reader.FieldCount' CancellationToken.None); //It returns null since _isAsyncBulkCopy = false; " is 121.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServer,The length of the statement  "                _rowStateToSkip = ((rowState == 0) || (rowState == DataRowState.Deleted)) ? DataRowState.Deleted : ~rowState | DataRowState.Deleted; " is 132.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServer,The length of the statement  "                WriteRowSourceToServerAsync(table.Columns.Count' CancellationToken.None); //It returns null since _isAsyncBulkCopy = false; " is 123.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServer,The length of the statement  "                WriteRowSourceToServerAsync(table.Columns.Count' CancellationToken.None); //It returns null since _isAsyncBulkCopy = false; " is 123.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerAsync,The length of the statement  "                resultTask = WriteRowSourceToServerAsync(table.Columns.Count' cancellationToken); // It returns Task since _isAsyncBulkCopy = true; " is 131.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerAsync,The length of the statement  "                resultTask = WriteRowSourceToServerAsync(reader.FieldCount' cancellationToken); // It returns Task since _isAsyncBulkCopy = true; " is 129.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerAsync,The length of the statement  "                resultTask = WriteRowSourceToServerAsync(reader.FieldCount' cancellationToken); // It returns Task since _isAsyncBulkCopy = true; " is 129.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerAsync,The length of the statement  "                _rowStateToSkip = ((rowState == 0) || (rowState == DataRowState.Deleted)) ? DataRowState.Deleted : ~rowState | DataRowState.Deleted; " is 132.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerAsync,The length of the statement  "                resultTask = WriteRowSourceToServerAsync(table.Columns.Count' cancellationToken); // It returns Task since _isAsyncBulkCopy = true; " is 131.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteRowSourceToServerAsync,The length of the statement  "                    AsyncHelper.WaitForCompletion(reconnectTask' BulkCopyTimeout' () => { throw SQL.CR_ReconnectTimeout(); }' rethrowExceptions: false); " is 132.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ReadWriteColumnValueAsync,The length of the statement  "            Object value = GetValueFromSourceRow(col' out isSqlType' out isDataFeed' out isNull); //this will return Task/null in future: as rTask " is 134.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ReadWriteColumnValueAsync,The length of the statement  "                    variantInternalType = _SqlDataReaderRowSource.GetVariantInternalStorageType(_sortedColumnMappings[col]._sourceColumnOrdinal); " is 125.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyColumnsAsync,The length of the statement  "                    task = ReadWriteColumnValueAsync(i); //First reads and then writes one cell value. Task 'task' is completed when reading task and writing task both are complete. " is 161.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyRowsAsync,The length of the statement  "                // totalRows is batchsize which is 0 by default. In that case' we keep copying till the end (until _hasMoreRowToCopy == false). " is 127.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyRowsAsync,The length of the statement  "                        Task readTask = ReadFromRowSourceAsync(cts); // Read the next row. Caution: more is only valid if the task returns null. Otherwise' we wait for Task.Result " is 155.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyRowsAsync,The length of the statement  "                            AsyncHelper.ContinueTask(readTask' source' () => CopyRowsAsync(i + 1' totalRows' cts' source)' connectionToDoom: _connection.GetOpenTdsConnection()); " is 149.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyRowsAsync,The length of the statement  "                                AsyncHelper.ContinueTask(readTask' source' onSuccess: () => CopyRowsAsync(i + 1' totalRows' cts' source)' connectionToDoom: _connection.GetOpenTdsConnection()); " is 160.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyRowsAsync,The length of the statement  "                    source.TrySetResult(null); // This is set only on the last call of async copy. But may not be set if everything runs synchronously. " is 131.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyBatchesAsync,The length of the statement  "                        internalConnection.ThreadHasParserLockForClose = true;     // In case of error' tell the connection we already have the parser lock " is 131.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyBatchesAsyncContinued,The length of the statement  "                Task task = CopyRowsAsync(0' _savedBatchSize' cts); // This is copying 1 batch of rows and setting _hasMoreRowToCopy = true/false. " is 130.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyBatchesAsyncContinued,The length of the statement  "                    }' _connection.GetOpenTdsConnection()' _ => CopyBatchesAsyncContinuedOnError(cleanupParser: false)' () => CopyBatchesAsyncContinuedOnError(cleanupParser: true)); " is 161.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,CopyBatchesAsyncContinuedOnSuccess,The length of the statement  "                    }' connectionToDoom: _connection.GetOpenTdsConnection()' onFailure: _ => CopyBatchesAsyncContinuedOnError(cleanupParser: false)); " is 129.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalRestContinuedAsync,The length of the statement  "                    _savedBatchSize = _batchSize; // For safety. If someone changes the batchsize during copy we still be using _savedBatchSize. " is 124.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalRestAsync,The length of the statement  "                                () => { return SQL.BulkLoadInvalidDestinationTable(_destinationTableName' SQL.CR_ReconnectTimeout()); }' CancellationToken.None); " is 129.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalRestAsync,The length of the statement  "                            throw SQL.BulkLoadInvalidDestinationTable(_destinationTableName' ex); // Preserve behavior (throw InvalidOperationException on failure to connect) " is 146.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalRestAsync,The length of the statement  "                internalConnection.ThreadHasParserLockForClose = true;    // In case of error' let the connection know that we already have the parser lock. " is 140.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalRestAsync,The length of the statement  "                    AsyncHelper.ContinueTask(internalResultsTask' source' () => WriteToServerInternalRestContinuedAsync(internalResultsTask.Result' cts' source)' _connection.GetOpenTdsConnection()); " is 178.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalAsync,The length of the statement  "                Task readTask = ReadFromRowSourceAsync(ctoken); // readTask == reading task. This is the first read call. "more" is valid only if readTask == null; " is 147.
Long Statement,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteToServerInternalAsync,The length of the statement  "                        WriteToServerInternalRestAsync(ctoken' source); //rest of the method' passing the same completion and returning the incomplete task (ret). " is 138.
Long Statement,System.Data.SqlClient,SqlBulkCopyColumnMappingCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopyColumnMappingCollection.cs,Add,The length of the statement  "            Debug.Assert(string.IsNullOrEmpty(bulkCopyColumnMapping.SourceColumn) || bulkCopyColumnMapping._internalSourceColumnOrdinal == -1' "BulkLoadAmbiguousSourceColumn"); " is 164.
Long Statement,System.Data.SqlClient,SqlBulkCopyColumnMappingCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopyColumnMappingCollection.cs,Add,The length of the statement  "                || ((string.IsNullOrEmpty(bulkCopyColumnMapping.DestinationColumn)) && (bulkCopyColumnMapping.DestinationOrdinal == -1))) " is 121.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,Prepare,The length of the statement  "                    // NOTE: The state object isn't actually needed for this' but it is still here for back-compat (since it does a bunch of checks) " is 128.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,InternalPrepare,The length of the statement  "                Debug.Assert(_cachedMetaData == null || !_dirty' "dirty query should not have cached metadata!"); // can have cached metadata if dirty because of parameters " is 156.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,InternalPrepare,The length of the statement  "            // Note the current close count of the connection - this will tell us if the connection has been closed between calls to Prepare() and Execute " is 142.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,Unprepare,The length of the statement  "            if ((_activeConnection.CloseCount != _preparedConnectionCloseCount) || (_activeConnection.ReconnectCount != _preparedConnectionReconnectCount)) " is 143.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,Cancel,The length of the statement  "                // the command will no longer be cancelable.  It might be desirable to be able to cancel the close operation' but this is " is 121.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,Cancel,The length of the statement  "                    { // make sure the connection held on the active connection is what we have stored in our temp connection variable' if not between getting "connection" and taking the lock' the connection has been closed " is 203.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,VerifyEndExecuteState,The length of the statement  "                    Debug.Assert(_reconnectionCompletionSource == null || _reconnectionCompletionSource.Task.IsCanceled' "ReconnectCompletionSource should be null or cancelled"); " is 158.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,VerifyEndExecuteState,The length of the statement  "            if ((_activeConnection.State != ConnectionState.Open) || (!cachedAsyncState.IsActiveConnectionValid(_activeConnection))) " is 120.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,InternalExecuteNonQuery,The length of the statement  "                SqlDataReader reader = RunExecuteReader(0' RunBehavior.UntilDone' false' completion' timeout' out task' asyncWrite' methodName); " is 128.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BeginExecuteXmlReader,The length of the statement  "                    RunExecuteReader(CommandBehavior.SequentialAccess' RunBehavior.ReturnImmediately' true' completion' CommandTimeout' out writeTask' asyncWrite: true); " is 149.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,CompleteXmlReader,The length of the statement  "                    SqlStream sqlBuf = new SqlStream(ds' true /*addByteOrderMark*/' (md[0].SqlDbType == SqlDbType.Xml) ? false : true /*process all rows*/); " is 136.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BeginExecuteReader,The length of the statement  "                    RunExecuteReader(behavior' RunBehavior.ReturnImmediately' true' completion' CommandTimeout' out writeTask' asyncWrite: true); " is 125.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,ExecuteDbDataReaderAsync,The length of the statement  "            }' CancellationToken.None' TaskContinuationOptions.ExecuteSynchronously | TaskContinuationOptions.NotOnCanceled' TaskScheduler.Default); " is 136.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The length of the statement  "            string[] parsedSProc = MultipartIdentifier.ParseMultipartIdentifier(CommandText' "[\""' "]\""' SR.SQL_SqlCommandCommandText' false); " is 132.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The length of the statement  "            // [user server' if provided].[user catalog' else current database].[sys if Yukon' else blank].[sp_procedure_params_rowset] " is 123.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The length of the statement  "            paramsCmd.Parameters[0].Value = UnquoteProcedureName(parsedSProc[3]' out groupNumber); // ProcedureName is 4rd element in parsed array " is 134.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteNonQueryTds,The length of the statement  "                                Task subTask = RunExecuteNonQueryTds(methodName' async' TdsParserStaticMethods.GetRemainingTimeout(timeout' reconnectionStart)' asyncWrite); " is 140.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteNonQueryTds,The length of the statement  "                Task executeTask = _stateObj.Parser.TdsExecuteSQLBatch(this.CommandText' timeout' this.Notification' _stateObj' sync: true); " is 124.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReader,The length of the statement  "            SqlDataReader reader = RunExecuteReader(cmdBehavior' runBehavior' returnStream' completion: null' timeout: CommandTimeout' task: out unused' method: method); " is 157.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,The length of the statement  "                            RunExecuteReaderTds(cmdBehavior' runBehavior' returnStream' async' TdsParserStaticMethods.GetRemainingTimeout(timeout' reconnectionStart)' out subTask' asyncWrite' ds); " is 168.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,The length of the statement  "                        Debug.Assert(_cachedMetaData == null || !_dirty' "dirty query should not have cached metadata!"); // can have cached metadata if dirty because of parameters " is 156.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,The length of the statement  "                    writeTask = _stateObj.Parser.TdsExecuteRPC(_rpcArrayOf1' timeout' inSchema' this.Notification' _stateObj' CommandType.StoredProcedure == CommandType' sync: !asyncWrite); " is 169.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,The length of the statement  "                        Task executeTask = _stateObj.Parser.TdsExecuteSQLBatch(optionSettings' timeout' this.Notification' _stateObj' sync: true); " is 122.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReaderTds,The length of the statement  "                    writeTask = _stateObj.Parser.TdsExecuteRPC(_rpcArrayOf1' timeout' inSchema' this.Notification' _stateObj' CommandType.StoredProcedure == CommandType' sync: !asyncWrite); " is 169.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,FinishExecuteReader,The length of the statement  "                                Debug.WriteLine("Received this exception from SqlDataReader.Close() while in another catch block: " + exClose.ToString()); " is 122.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,FinishExecuteReader,The length of the statement  "                            Debug.WriteLine("Received this exception from SqlDataReader.Close() while in another catch block: " + exClose.ToString()); " is 122.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,GetParameterForOutputValueExtraction,The length of the statement  "                    if (thisParam.Direction != ParameterDirection.Input && thisParam.Direction != ParameterDirection.ReturnValue && paramName == thisParam.ParameterNameFixed) " is 154.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildPrepExec,The length of the statement  "            Debug.Assert(System.Data.CommandType.Text == this.CommandType' "invalid use of sp_prepexec for stored proc invocation!"); " is 121.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildPrepExec,The length of the statement  "            sqlParam = new SqlParameter(null' ((paramList.Length << 1) <= TdsEnums.TYPE_SIZE_LIMIT) ? SqlDbType.NVarChar : SqlDbType.NText' paramList.Length); " is 146.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildPrepExec,The length of the statement  "            sqlParam = new SqlParameter(null' ((text.Length << 1) <= TdsEnums.TYPE_SIZE_LIMIT) ? SqlDbType.NVarChar : SqlDbType.NText' text.Length); " is 136.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildRPC,The length of the statement  "            Debug.Assert(this.CommandType == System.Data.CommandType.StoredProcedure' "Command must be a stored proc to execute an RPC"); " is 125.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildExecuteSql,The length of the statement  "            sqlParam = new SqlParameter(null' ((commandText.Length << 1) <= TdsEnums.TYPE_SIZE_LIMIT) ? SqlDbType.NVarChar : SqlDbType.NText' commandText.Length); " is 150.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildExecuteSql,The length of the statement  "                sqlParam = new SqlParameter(null' ((paramList.Length << 1) <= TdsEnums.TYPE_SIZE_LIMIT) ? SqlDbType.NVarChar : SqlDbType.NText' paramList.Length); " is 146.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildParamList,The length of the statement  "                else if (!mt.IsFixed && !mt.IsLong && mt.SqlDbType != SqlDbType.Timestamp && mt.SqlDbType != SqlDbType.Udt && SqlDbType.Structured != mt.SqlDbType) " is 147.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,GetCommandText,The length of the statement  "            // build the batch string we send over' since we execute within a stored proc (sp_executesql)' the SET options never need to be " is 127.
Long Statement,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,GetErrors,The length of the statement  "                for (int i = _SqlRPCBatchArray[commandIndex].warningsIndexStart; i < _SqlRPCBatchArray[commandIndex].warningsIndexEnd; ++i) " is 123.
Long Statement,System.Data.SqlClient,SqlCommandSet,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommandSet.cs,ValidateCommandBehavior,The length of the statement  "                throw ADP.NotSupportedCommandBehavior(behavior & ~(CommandBehavior.SequentialAccess | CommandBehavior.CloseConnection)' method); " is 128.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,BeginTransaction,The length of the statement  "                    transaction = GetOpenTdsConnection().BeginSqlTransaction(iso' transactionName' isFirstAttempt); // do not reconnect twice " is 121.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,BeginTransaction,The length of the statement  "                    Debug.Assert(isFirstAttempt || !transaction.InternalTransaction.ConnectionHasBeenRestored' "Restored connection on non-first attempt"); " is 135.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,CloseInnerConnection,The length of the statement  "            // the command will no longer be cancelable.  It might be desirable to be able to cancel the close operation' but this is " is 121.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,Close,The length of the statement  "                    AsyncHelper.WaitForCompletion(reconnectTask' 0' null' rethrowExceptions: false); // we do not need to deal with possible exceptions in reconnection " is 147.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,CancelOpenAndWait,The length of the statement  "            Debug.Assert(_currentCompletion == null' "After waiting for an async call to complete' there should be no completion source"); " is 126.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,OpenAsync,The length of the statement  "                        registration = cancellationToken.Register(s => ((TaskCompletionSource<DbConnectionInternal>)s).TrySetCanceled()' completion); " is 125.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,OnError,The length of the statement  "            Debug.Assert(exception != null && exception.Errors.Count != 0' "SqlConnection: OnError called with null or empty exception!"); " is 126.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,CheckGetExtendedUDTInfo,The length of the statement  "                    Type.GetType(typeName: metaData.udtAssemblyQualifiedName' assemblyResolver: asmRef => ResolveTypeAssembly(asmRef' fThrow)' typeResolver: null' throwOnError: fThrow); " is 165.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,GetUdtValue,The length of the statement  "                o = t.InvokeMember("Null"' BindingFlags.Public | BindingFlags.GetProperty | BindingFlags.Static' null' null' new object[] { }' CultureInfo.InvariantCulture); " is 157.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,ConnectionString_Set,The length of the statement  "            System.Data.ProviderBase.DbConnectionPoolGroup poolGroup = ConnectionFactory.GetConnectionPoolGroup(key' null' ref connectionOptions); " is 134.
Long Statement,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,Abort,The length of the statement  "                Interlocked.CompareExchange(ref _innerConnection' DbConnectionClosedPreviouslyOpened.SingletonInstance' innerConnection); " is 121.
Long Statement,System.Data.SqlClient,OpenAsyncRetry,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,Retry,The length of the statement  "                                _result.SetException(ADP.ExceptionWithStackTrace(ADP.InternalError(ADP.InternalErrorCode.CompletedConnectReturnedPending))); " is 124.
Long Statement,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnection,The length of the statement  "            bool applyTransientFaultHandling = sqlOwningConnection != null ? sqlOwningConnection._applyTransientFaultHandling : false; " is 122.
Long Statement,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnection,The length of the statement  "                        sseConnection = new SqlInternalConnectionTds(identity' sseopt' null' false' applyTransientFaultHandling: applyTransientFaultHandling); " is 134.
Long Statement,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnection,The length of the statement  "                        // NOTE: Retrieve <UserInstanceName> here. This user instance name will be used below to connect to the Sql Express User Instance. " is 130.
Long Statement,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnection,The length of the statement  "            result = new SqlInternalConnectionTds(identity' opt' poolGroupProviderInfo' redirectedUserInstance' userOpt' recoverySessionData' applyTransientFaultHandling: applyTransientFaultHandling); " is 188.
Long Statement,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateMetaDataFactory,The length of the statement  "            Stream xmlStream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream("System.Data.SqlClient.SqlMetaData.xml"); " is 136.
Long Statement,System.Data.SqlClient,SqlConnectionString,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionString.cs,GetParseSynonyms,The length of the statement  "                int count = SqlConnectionStringBuilder.KeywordsCount + SqlConnectionStringBuilder.DeprecatedKeywordsCount + SynonymCount + DeprecatedSynonymCount; " is 146.
Long Statement,System.Data.SqlClient,SqlConnectionString,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionString.cs,ConvertValueToApplicationIntent,The length of the statement  "            // wrap Format and Overflow exceptions with Argument one' to be consistent with rest of the keyword types (like int and bool) " is 125.
Long Statement,System.Data.SqlClient,SqlConnectionStringBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionStringBuilder.cs,CreateKeywordsDictionary,The length of the statement  "            Dictionary<string' Keywords> hash = new Dictionary<string' Keywords>(KeywordsCount + SqlConnectionString.SynonymCount' StringComparer.OrdinalIgnoreCase); " is 153.
Long Statement,System.Data.SqlClient,SqlConnectionTimeoutPhaseDuration,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionTimeoutErrorInternal.cs,StopCapture,The length of the statement  "            //Debug.Assert(swDuration.IsRunning == true' "The stop operation of the stopwatch cannot be called when it is not running."); " is 125.
Long Statement,System.Data.SqlClient,SqlConnectionTimeoutErrorInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionTimeoutErrorInternal.cs,SetInternalSourceType,The length of the statement  "                Debug.Assert(_currentPhase == SqlConnectionTimeoutErrorPhase.PostLogin' "Should not be switching to the routing destination until Post Login is completed"); " is 156.
Long Statement,System.Data.SqlClient,SqlConnectionTimeoutErrorInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionTimeoutErrorInternal.cs,EndPhase,The length of the statement  "            Debug.Assert(_phaseDurations[(int)timeoutErrorPhase] != null' "End phase capture cannot be invoked when the phase duration object is a null."); " is 143.
Long Statement,System.Data.SqlClient,SqlConnectionTimeoutErrorInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionTimeoutErrorInternal.cs,GetErrorMessage,The length of the statement  "            if ((_currentPhase != SqlConnectionTimeoutErrorPhase.Undefined) && (_currentPhase != SqlConnectionTimeoutErrorPhase.Complete)) " is 126.
Long Statement,System.Data.SqlClient,SqlConnectionTimeoutErrorInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionTimeoutErrorInternal.cs,GetErrorMessage,The length of the statement  "                // NOTE: In case of a failover scenario' add a string that this failure occurred as part of the primary or secondary server " is 123.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the statement  "            DataColumn providerSpecificDataType = new DataColumn(SchemaTableOptionalColumn.ProviderSpecificDataType' typeof(System.Type)); " is 126.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the statement  "                            Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for Time column: " + col.scale); " is 145.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the statement  "                            schemaRow[size] = TdsEnums.WHIDBEY_TIME_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale]; " is 127.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the statement  "                            Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTime2 column: " + col.scale); " is 150.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the statement  "                            schemaRow[size] = TdsEnums.WHIDBEY_DATETIME2_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale]; " is 132.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the statement  "                            Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTimeOffset column: " + col.scale); " is 155.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The length of the statement  "                            schemaRow[size] = TdsEnums.WHIDBEY_DATETIMEOFFSET_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale]; " is 137.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCleanPartialRead,The length of the statement  "                Debug.Assert(TdsParser.IsValidTdsToken(token)' string.Format("Invalid token after performing CleanPartialRead: {0'-2:X2}"' token)); " is 131.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,Close,The length of the statement  "                        // If we receive any exceptions while waiting' something has gone horribly wrong and we need to doom the connection and fast-fail the reader " is 140.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,Close,The length of the statement  "                // NOTE: This must be done outside of the lock on the stateObj otherwise it will deadlock with CleanupAfterAsyncInvocation " is 122.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,Close,The length of the statement  "                            // DO NOT USE stateObj after this point - it has been returned to the TdsParser's session pool and potentially handed out to another thread " is 139.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCloseInternal,The length of the statement  "                        Debug.Assert(SniContext.Snix_Read == stateObj.SniContext' String.Format((IFormatProvider)null' "The SniContext should be Snix_Read but it actually is {0}"' stateObj.SniContext)); " is 178.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCloseInternal,The length of the statement  "                            Debug.Assert(TdsParser.IsValidTdsToken(token)' string.Format("DataReady is false' but next token is invalid: {0'-2:X2}"' token)); " is 129.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCloseInternal,The length of the statement  "                        Connection.RemoveWeakReference(this);  // This doesn't catch everything -- the connection may be closed' but it prevents dead readers from clogging the collection " is 162.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCloseInternal,The length of the statement  "                                parser.State = TdsParserState.Broken; // We failed while draining data' so TDS pointer can be between tokens - cannot recover " is 125.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCloseInternal,The length of the statement  "                    // DO NOT USE stateObj after this point - it has been returned to the TdsParser's session pool and potentially handed out to another thread " is 139.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CloseReaderFromConnection,The length of the statement  "            Debug.Assert(parser == null || parser.State != TdsParserState.OpenNotLoggedIn' "Reader on a connection that is not logged in"); " is 127.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryConsumeMetaData,The length of the statement  "                    // Happened for DEVDIV2:180509	(SqlDataReader.ConsumeMetaData Hangs In 100% CPU Loop Forever When TdsParser._state == TdsParserState.Broken) " is 140.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryConsumeMetaData,The length of the statement  "                    // NOTE: We doom connection for TdsParserState.Closed since it indicates that it is in some abnormal and unstable state' probably as a result of " is 144.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetXmlReader,The length of the statement  "                // Need to call ReadColumn' since we want to access the internal data structures (i.e. SqlBinary) rather than calling anther Get*() method " is 138.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetXmlReader,The length of the statement  "                    return SqlTypeWorkarounds.SqlXmlCreateSqlXmlReader(new MemoryStream(Array.Empty<byte>()' writable: false)' closeInput: true); " is 125.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetStream,The length of the statement  "                // Need to call ReadColumn' since we want to access the internal data structures (i.e. SqlBinary) rather than calling anther Get*() method " is 138.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryGetBytesInternalSequential,The length of the statement  "            Debug.Assert(_sharedState._nextColumnHeaderToRead == i + 1 && _sharedState._nextColumnDataToRead == i' "Non sequential access"); " is 128.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetTextReader,The length of the statement  "                // Need to call ReadColumn' since we want to access the internal data structures (i.e. SqlString) rather than calling anther Get*() method " is 138.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetChars,The length of the statement  "                            // We need to wrap all exceptions inside a TargetInvocationException to simulate calling CreateSqlReader via MethodInfo.Invoke " is 126.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetChars,The length of the statement  "                if ((_sharedState._nextColumnDataToRead == (i + 1)) && (_sharedState._nextColumnHeaderToRead == (i + 1)) && (_columnDataChars != null) && (IsCommandBehavior(CommandBehavior.SequentialAccess)) && (dataIndex < _columnDataCharsRead)) " is 230.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetCharsFromPlpData,The length of the statement  "            Debug.Assert(IsCommandBehavior(CommandBehavior.SequentialAccess)' "GetCharsFromPlpData called for non-Sequential access"); " is 122.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetSqlValueFromSqlBufferInternal,The length of the statement  "            Debug.Assert(!data.IsEmpty || data.IsNull || metaData.type == SqlDbType.Timestamp' "Data has been read' but the buffer is empty"); " is 130.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetValueFromSqlBufferInternal,The length of the statement  "            Debug.Assert(!data.IsEmpty || data.IsNull || metaData.type == SqlDbType.Timestamp' "Data has been read' but the buffer is empty"); " is 130.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetFieldValueFromSqlBufferInternal,The length of the statement  "                // SqlXml can not be typecast into a SqlString' but we need to support SqlString on XML Types - so do a manual conversion " is 121.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetVersionedMetaType,The length of the statement  "            Debug.Assert(_typeSystem == SqlConnectionString.TypeSystem.SQLServer2000' "Should not be in this function under anything else but SQLServer2000"); " is 146.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadInternal,The length of the statement  "                    Debug.Assert(TdsParser.IsValidTdsToken(token)' string.Format("DataReady is false' but next token is invalid: {0'-2:X2}"' token)); " is 129.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumn,The length of the statement  "            CheckDataIsReady(columnIndex: i' permitAsync: true' allowPartiallyReadColumn: allowPartiallyReadColumn' methodName: null); " is 122.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumn,The length of the statement  "            Debug.Assert(_sharedState._nextColumnHeaderToRead <= _metaData.Length' "_sharedState._nextColumnHeaderToRead too large"); " is 121.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumnData,The length of the statement  "                if (!_parser.TryReadSqlValue(_data[_sharedState._nextColumnDataToRead]' columnMetaData' (int)_sharedState._columnDataBytesRemaining' _stateObj)) " is 144.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumnInternal,The length of the statement  "                    Debug.Assert(i == _sharedState._nextColumnDataToRead ||                                                          // Either we haven't read the column yet " is 153.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumnInternal,The length of the statement  "                        ((i + 1 < _sharedState._nextColumnDataToRead) && (IsCommandBehavior(CommandBehavior.SequentialAccess))) ||   // Or we're in sequential mode and we've read way past the column (i.e. it was not the last column we read) " is 216.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumnInternal,The length of the statement  "                        (!_data[i].IsEmpty || _data[i].IsNull) ||                                                       // Or we should have data stored for the column (unless the column was null) " is 172.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumnInternal,The length of the statement  "                        (_metaData[i].type == SqlDbType.Timestamp)'                                                     // Or SqlClient: IsDBNull always returns false for timestamp datatype " is 165.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryReadColumnInternal,The length of the statement  "                    if (!_parser.TryProcessColumnHeader(columnMetaData' _stateObj' _sharedState._nextColumnHeaderToRead' out isNull' out dataLength)) " is 129.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,WillHaveEnoughData,The length of the statement  "            if ((_lastColumnWithDataChunkRead == _sharedState._nextColumnDataToRead) && (_metaData[_lastColumnWithDataChunkRead].metaType.IsPlp)) " is 133.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,WillHaveEnoughData,The length of the statement  "            if ((targetColumn >= _sharedState._nextColumnDataToRead) && (_sharedState._nextColumnDataToRead < _sharedState._nextColumnHeaderToRead)) " is 136.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,WillHaveEnoughData,The length of the statement  "                    if ((metaType.IsLong) || (metaType.IsPlp) || (metaType.SqlDbType == SqlDbType.Udt) || (metaType.SqlDbType == SqlDbType.Structured)) " is 131.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryResetBlobState,The length of the statement  "            Debug.Assert(_sharedState._nextColumnHeaderToRead <= _metaData.Length' "_sharedState._nextColumnHeaderToRead too large"); " is 121.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryResetBlobState,The length of the statement  "                Debug.Assert((_sharedState._columnDataBytesRemaining == 0 || _sharedState._columnDataBytesRemaining == -1) && _stateObj._longlen == 0' "Haven't read header yet' but column is partially read?"); " is 193.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,RestoreServerSettings,The length of the statement  "                    Task executeTask = parser.TdsExecuteSQLBatch(_resetOptionsString' (_command != null) ? _command.CommandTimeout : 0' null' stateObj' sync: true); " is 144.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CheckHeaderIsReady,The length of the statement  "            if ((IsCommandBehavior(CommandBehavior.SequentialAccess)) &&                                          // Only for sequential access " is 131.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CheckHeaderIsReady,The length of the statement  "                throw ADP.NonSequentialColumnAccess(columnIndex' Math.Max(_sharedState._nextColumnHeaderToRead - 1' _lastColumnWithDataChunkRead)); " is 131.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CheckDataIsReady,The length of the statement  "            if ((IsCommandBehavior(CommandBehavior.SequentialAccess)) &&                                    // Only for sequential access " is 125.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CheckDataIsReady,The length of the statement  "                ((_sharedState._nextColumnDataToRead > columnIndex) || (_lastColumnWithDataChunkRead > columnIndex) ||   // Read past column " is 124.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CheckDataIsReady,The length of the statement  "                throw ADP.NonSequentialColumnAccess(columnIndex' Math.Max(_sharedState._nextColumnDataToRead' _lastColumnWithDataChunkRead + 1)); " is 129.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,AssertReaderState,The length of the statement  "                Debug.Assert((!enforceSequentialAccess) || (!IsCommandBehavior(CommandBehavior.SequentialAccess)) || ((_sharedState._nextColumnDataToRead <= columnIndex) && (_lastColumnWithDataChunkRead <= columnIndex))' "Already read past column"); " is 233.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsync,The length of the statement  "            if ((_sharedState._nextColumnHeaderToRead <= _lastColumnWithDataChunkRead) || (_sharedState._nextColumnDataToRead < _lastColumnWithDataChunkRead)) " is 146.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsync,The length of the statement  "                        // Only once we have read up to where we need to be can we check the cancellation tokens (otherwise we will be in an unknown state) " is 131.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsync,The length of the statement  "                            var readTask = GetBytesAsyncReadDataStage(i' buffer' index' length' timeout' true' cancellationToken' timeoutToken' out totalBytesRead); " is 136.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsync,The length of the statement  "                    return GetBytesAsyncReadDataStage(i' buffer' index' length' timeout' false' cancellationToken' CancellationToken.None' out bytesRead); " is 134.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsyncReadDataStage,The length of the statement  "                    Debug.Assert(timeoutToken == CancellationToken.None' "TimeoutToken is set when GetBytesAsyncReadDataStage is not a continuation"); " is 130.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetBytesAsyncReadDataStage,The length of the statement  "                        bool result = TryGetBytesInternalSequential(i' buffer' index + totalBytesRead' length - totalBytesRead' out bytesReadThisIteration); " is 132.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,IsDBNullAsync,The length of the statement  "            if ((_sharedState._nextColumnHeaderToRead > i) && (!cancellationToken.IsCancellationRequested) && (_currentTask == null)) " is 121.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetFieldValueAsync,The length of the statement  "                if ((!IsCommandBehavior(CommandBehavior.SequentialAccess)) && (_sharedState._nextColumnDataToRead > i) && (!cancellationToken.IsCancellationRequested) && (_currentTask == null)) " is 177.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CompleteRetryable,The length of the statement  "            // If something has forced us to switch to SyncOverAsync mode while in an async task then we need to guarantee that we do the cleanup " is 133.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CompleteRetryable,The length of the statement  "            Debug.Assert(current == source.Task' "Should not be able to change the _currentTask while an asynchronous operation is pending"); " is 129.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,PrepareAsyncInvocation,The length of the statement  "                Debug.Assert(!_stateObj._asyncReadWithoutSnapshot' "Can't prepare async invocation with snapshot if doing async without snapshots"); " is 132.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CleanupAfterAsyncInvocation,The length of the statement  "                // NOTE: There are some cases where we wish to ignore the close token' such as when we've read some data that is not replayable (e.g. DONE or ENV_CHANGE token) " is 159.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CleanupAfterAsyncInvocation,The length of the statement  "                            Debug.Assert(_snapshot == null && !_stateObj._asyncReadWithoutSnapshot' "Snapshot not null or async without snapshot still enabled after cleaning async state"); " is 160.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CleanupAfterAsyncInvocationInternal,The length of the statement  "            // We are setting this to null inside the if-statement because stateObj==null means that the reader hasn't been initialized or has been closed (either way _snapshot should already be null) " is 188.
Long Statement,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,PrepareForAsyncContinuation,The length of the statement  "            Debug.Assert(((_snapshot != null) || (_stateObj._asyncReadWithoutSnapshot))' "Can not prepare for an async continuation if no async if setup"); " is 143.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,Stop,The length of the statement  "                                    Debug.Assert(!string.IsNullOrEmpty(server) && !string.IsNullOrEmpty(database)' "Server or Database null/Empty upon successfull Stop()!"); " is 137.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,AddToServerList,The length of the statement  "                    index = ~index; // BinarySearch returns the 2's compliment of where the item should be inserted to preserver a sorted list after insertion. " is 139.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,ComputeHashAndAddToDispatcher,The length of the statement  "            // Create a string representing the concatenation of the connection string' command text and .ToString on all parameter values. " is 127.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,ComputeHashAndAddToDispatcher,The length of the statement  "            // This string will then be mapped to unique notification ID (new GUID).  We add the guid and the hash to the app domain " is 120.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,ComputeHashAndAddToDispatcher,The length of the statement  "            // Add Connection string to prevent redundant notifications when same command is running against different databases or SQL servers " is 131.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,ComputeHashAndAddToDispatcher,The length of the statement  "            string commandHash = ComputeCommandHash(command.Connection.ConnectionString' command); // calculate the string representation of command " is 136.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,ComputeHashAndAddToDispatcher,The length of the statement  "            string idString = SqlDependencyPerAppDomainDispatcher.SingletonInstance.AddCommandEntry(commandHash' this); // Add to map. " is 122.
Long Statement,System.Data.SqlClient,SqlDependency,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependency.cs,ComputeCommandHash,The length of the statement  "            // Create a string representing the concatenation of the connection string' the command text and .ToString on all its parameter values. " is 135.
Long Statement,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,AddCommandEntry,The length of the statement  "                            Debug.Fail("_commandHashToNotificationId has entries that were removed from _notificationIdToDependenciesHash. Remember to keep them in sync"); " is 143.
Long Statement,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,AddCommandEntry,The length of the statement  "                    Debug.Assert(_notificationIdToDependenciesHash.Count == _commandHashToNotificationId.Count' "always keep these maps in sync!"); " is 127.
Long Statement,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,LookupCommandEntryWithRemove,The length of the statement  "                Debug.Assert(_notificationIdToDependenciesHash.Count == _commandHashToNotificationId.Count' "always keep these maps in sync!"); " is 127.
Long Statement,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,RemoveDependencyFromCommandToDependenciesHash,The length of the statement  "                Debug.Assert(_notificationIdToDependenciesHash.Count == _commandHashToNotificationId.Count' "always keep these maps in sync!"); " is 127.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,Initialize,The length of the statement  "                connection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.Begin' null' _isolationLevel' _internalTransaction' true); " is 129.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,Promote,The length of the statement  "                        connection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.Promote' null' IsolationLevel.Unspecified' _internalTransaction' true); " is 142.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,Promote,The length of the statement  "                            SysTxForGlobalTransactions.SetDistributedTransactionIdentifier.Invoke(_atomicTransaction' new object[] { this' GetGlobalTxnIdentifierFromToken() }); " is 148.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,Promote,The length of the statement  "                        // VSTS 144562: doom the connection while having the lock on it to prevent race condition with "Transaction Ended" Event " is 120.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,Rollback,The length of the statement  "                            connection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.Rollback' null' IsolationLevel.Unspecified' _internalTransaction' true); " is 143.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,Rollback,The length of the statement  "                        // VSTS 144562: doom the connection while having the lock on it to prevent race condition with "Transaction Ended" Event " is 120.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,SinglePhaseCommit,The length of the statement  "                            connection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.Commit' null' IsolationLevel.Unspecified' _internalTransaction' true); " is 141.
Long Statement,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,SinglePhaseCommit,The length of the statement  "                            // VSTS 144562: doom the connection while having the lock on it to prevent race condition with "Transaction Ended" Event " is 120.
Long Statement,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,AssertIsUserDefinedTypeInstance,The length of the statement  "            Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute[] attributes = (Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute[])type.GetCustomAttributes(typeof(Microsoft.SqlServer.Server.SqlUserDefinedTypeAttribute)' true); " is 223.
Long Statement,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetSqlDataType,The length of the statement  "                case TdsEnums.SQLINTN: return ((4 <= length) ? ((4 == length) ? s_metaInt : s_metaBigInt) : ((2 == length) ? s_metaSmallInt : s_metaTinyInt)); " is 142.
Long Statement,System.Data.SqlClient,SqlException,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlException.cs,CreateException,The length of the statement  "                if ((internalConnection.OriginalClientConnectionId != Guid.Empty) && (internalConnection.OriginalClientConnectionId != internalConnection.ClientConnectionId)) " is 158.
Long Statement,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,Enlist,The length of the statement  "            Debug.Assert(!IsNonPoolableTransactionRoot' "cannot defect an active delegated transaction!");  // potential race condition' but it's an assert " is 143.
Long Statement,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,Enlist,The length of the statement  "                    // However' no exception is thrown as this was the precedent (and this case is silently ignored' no error' but no enlistment either). " is 133.
Long Statement,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,Enlist,The length of the statement  "                    // 1. SqlConnection.EnlistTransaction checks that the enlisted transaction has completed before allowing a different enlistment. " is 128.
Long Statement,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,Enlist,The length of the statement  "                    // 2. For debug builds' the assert at the beginning of this method checks for an enlistment in an active delegated transaction. " is 127.
Long Statement,System.Data.SqlClient,SqlInternalConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnection.cs,EnlistNonNull,The length of the statement  "                        hasDelegatedTransaction = (bool)SysTxForGlobalTransactions.EnlistPromotableSinglePhase.Invoke(tx' new object[] { delegatedTransaction' _globalTransactionTMID }); " is 161.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ChangeDatabaseInternal,The length of the statement  "            Task executeTask = _parser.TdsExecuteSQLBatch("use " + database' ConnectionOptions.ConnectTimeout' null' _parser._physicalStateObj' sync: true); " is 144.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,Dispose,The length of the statement  "                TdsParser parser = Interlocked.Exchange(ref _parser' null);  // guard against multiple concurrent dispose calls -- Delegated Transactions might cause this. " is 155.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,CheckEnlistedTransactionBinding,The length of the statement  "                bool requireExplicitTransactionUnbind = ConnectionOptions.TransactionBinding == SqlConnectionString.TransactionBindingEnum.ExplicitUnbind; " is 138.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,CheckEnlistedTransactionBinding,The length of the statement  "                    if (TransactionStatus.Active != enlistedTransaction.TransactionInformation.Status || !enlistedTransaction.Equals(currentTransaction)) " is 133.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ResetConnection,The length of the statement  "            Debug.Assert(!HasLocalTransactionFromAPI' "Upon ResetConnection SqlInternalConnectionTds has a currently ongoing local transaction."); " is 134.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ResetConnection,The length of the statement  "            Debug.Assert(!_parser._physicalStateObj._pendingData' "Upon ResetConnection SqlInternalConnectionTds has pending data."); " is 121.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ExecuteTransactionYukon,The length of the statement  "            Debug.Assert(!ThreadHasParserLockForClose || _parserLock.ThreadMayHaveLock()' "Thread claims to have parser lock' but lock is not taken"); " is 138.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,ExecuteTransactionYukon,The length of the statement  "                        AsyncHelper.WaitForCompletion(reconnectTask' 0); // there is no specific timeout for BeginTransaction' uses ConnectTimeout " is 122.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,CompleteLogin,The length of the statement  "            Debug.Assert(SniContext.Snix_Login == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Snix_Login; actual Value: {0}"' Parser._physicalStateObj.SniContext)); " is 204.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,OpenLoginEnlist,The length of the statement  "            _timeoutErrorInternal.SetInternalSourceType(useFailoverPartner ? SqlConnectionInternalSourceType.Failover : SqlConnectionInternalSourceType.Principle); " is 151.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The length of the statement  "            Debug.Assert(object.ReferenceEquals(connectionOptions' this.ConnectionOptions)' "ConnectionOptions argument and property must be the same"); // consider removing the argument " is 174.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The length of the statement  "            ServerInfo originalServerInfo = serverInfo; // serverInfo may end up pointing to new object due to routing' original object is used to set CurrentDatasource " is 156.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The length of the statement  "                Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext)); " is 202.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The length of the statement  "                    Debug.Assert(ConnectionOptions.ApplicationIntent != ApplicationIntent.ReadOnly' "FAILOVER+AppIntent=RO: Should already fail (at LOGSHIPNODE in OnEnvChange)"); " is 158.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The length of the statement  "            Debug.Assert(!connectionOptions.MultiSubnetFailover' "MultiSubnetFailover should not be set if failover partner is used"); " is 122.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The length of the statement  "                ResolveExtendedServerName(failoverServerInfo' !redirectedUserInstance && failoverHost != primaryServerInfo.UserServerName' connectionOptions); " is 142.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The length of the statement  "                Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext)); " is 202.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,OnEnvChange,The length of the statement  "                    if (string.IsNullOrEmpty(rec.newRoutingInfo.ServerName) || rec.newRoutingInfo.Protocol != 0 || rec.newRoutingInfo.Port == 0) " is 124.
Long Statement,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,OnFeatureExtAck,The length of the statement  "                                _currentSessionData._delta[stateId] = new SessionStateRecord { _data = stateData' _dataLength = len' _recoverable = true' _version = 0 }; " is 137.
Long Statement,System.Data.SqlClient,SyncAsyncLock,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,Wait,The length of the statement  "                    Monitor.TryEnter(_semaphore' timeout' ref hasMonitor); // semaphore is used as lock object' no relation to SemaphoreSlim.Wait/Release methods " is 141.
Long Statement,System.Data.SqlClient,SqlInternalTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\sqlinternaltransaction.cs,CloseFromConnection,The length of the statement  "                innerConnection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.IfRollback' null' IsolationLevel.Unspecified' null' false); " is 135.
Long Statement,System.Data.SqlClient,SqlInternalTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\sqlinternaltransaction.cs,Commit,The length of the statement  "                _innerConnection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.Commit' null' IsolationLevel.Unspecified' null' false); " is 132.
Long Statement,System.Data.SqlClient,SqlInternalTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\sqlinternaltransaction.cs,GetServerTransactionLevel,The length of the statement  "            using (SqlCommand transactionLevelCommand = new SqlCommand("set @out = @@trancount"' (SqlConnection)(_innerConnection.Owner))) " is 126.
Long Statement,System.Data.SqlClient,SqlInternalTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\sqlinternaltransaction.cs,Rollback,The length of the statement  "                _innerConnection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.IfRollback' null' IsolationLevel.Unspecified' null' false); " is 136.
Long Statement,System.Data.SqlClient,SqlInternalTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\sqlinternaltransaction.cs,Rollback,The length of the statement  "                _innerConnection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.Rollback' transactionName' IsolationLevel.Unspecified' null' false); " is 145.
Long Statement,System.Data.SqlClient,SqlInternalTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\sqlinternaltransaction.cs,Save,The length of the statement  "                _innerConnection.ExecuteTransaction(SqlInternalConnection.TransactionRequest.Save' savePointName' IsolationLevel.Unspecified' null' false); " is 139.
Long Statement,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The length of the statement  "            else if ((maxLen > MSS.SmiMetaData.MaxBinaryLength && (SqlDbType.Binary == mt.SqlDbType || SqlDbType.VarBinary == mt.SqlDbType)) " is 128.
Long Statement,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The length of the statement  "                  || (maxLen > MSS.SmiMetaData.MaxANSICharacters && (SqlDbType.Char == mt.SqlDbType || SqlDbType.VarChar == mt.SqlDbType)) " is 120.
Long Statement,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The length of the statement  "                  || (maxLen > MSS.SmiMetaData.MaxUnicodeCharacters && (SqlDbType.NChar == mt.SqlDbType || SqlDbType.NVarChar == mt.SqlDbType))) " is 126.
Long Statement,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The length of the statement  "            else if (SqlDbType.Udt == mt.SqlDbType || (SqlDbType.Structured == mt.SqlDbType && !string.IsNullOrEmpty(this.TypeName))) " is 121.
Long Statement,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualSize,The length of the statement  "                                // for these types' ActualSize is the num of chars' not actual bytes - since non-unicode chars are not always uniform size " is 122.
Long Statement,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetCoercedValue,The length of the statement  "                    _coercedValueIsSqlType = (_coercedValue == null) ? false : _isSqlParameterSqlType; // set to null for output parameters that keeps _isSqlParameterSqlType " is 153.
Long Statement,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ValidateTypeLengths,The length of the statement  "                    maxSizeInBytes = ((sizeInCharacters * sizeof(char)) > actualSizeInBytes) ? sizeInCharacters * sizeof(char) : actualSizeInBytes; " is 127.
Long Statement,System.Data.SqlClient,SqlReferenceCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlReferenceCollection.cs,FindLiveReader,The length of the statement  "                return FindItem<SqlDataReader>(DataReaderTag' (dataReader) => ((!dataReader.IsClosed) && (command == dataReader.Command))); " is 123.
Long Statement,System.Data.SqlClient,SqlReferenceCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlReferenceCollection.cs,Remove,The length of the statement  "            Debug.Assert(value is SqlDataReader || value is SqlCommand || value is SqlBulkCopy' "SqlReferenceCollection.Remove expected a SqlDataReader or SqlCommand or SqlBulkCopy"); " is 171.
Long Statement,System.Data.SqlClient,SqlSequentialStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialStream.cs,ReadAsync,The length of the statement  "                        if ((reader != null) && (!cancellationToken.IsCancellationRequested) && (!_disposalTokenSource.Token.IsCancellationRequested)) " is 126.
Long Statement,System.Data.SqlClient,SqlSequentialStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialStream.cs,ReadAsync,The length of the statement  "                            getBytesTask = reader.GetBytesAsync(_columnIndex' buffer' offset' count' _readTimeout' combinedTokenSource.Token' out bytesRead); " is 129.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,Peek,The length of the statement  "            Debug.Assert(_peekedChar == -1 || ((_peekedChar >= char.MinValue) && (_peekedChar <= char.MaxValue))' string.Format("Bad peeked character: {0}"' _peekedChar)); " is 159.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,Read,The length of the statement  "            Debug.Assert(readChar == -1 || ((readChar >= char.MinValue) && (readChar <= char.MaxValue))' string.Format("Bad read character: {0}"' readChar)); " is 145.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,Read,The length of the statement  "                Debug.Assert((_peekedChar >= char.MinValue) && (_peekedChar <= char.MaxValue)' string.Format("Bad peeked character: {0}"' _peekedChar)); " is 136.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,ReadAsync,The length of the statement  "                                Debug.Assert((_peekedChar >= char.MinValue) && (_peekedChar <= char.MaxValue)' string.Format("Bad peeked character: {0}"' _peekedChar)); " is 136.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,ReadAsync,The length of the statement  "                                Task<int> getBytesTask = reader.GetBytesAsync(_columnIndex' byteBuffer' byteBufferUsed' byteBuffer.Length - byteBufferUsed' Timeout.Infinite' _disposalTokenSource.Token' out bytesRead); " is 185.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,InternalRead,The length of the statement  "            Debug.Assert((index >= 0) && (count >= 0) && (index + count <= buffer.Length)' string.Format("Bad count: {0} or index: {1}"' count' index)); " is 140.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,InternalRead,The length of the statement  "                byteBufferUsed += _reader.GetBytesInternalSequential(_columnIndex' byteBuffer' byteBufferUsed' byteBuffer.Length - byteBufferUsed); " is 131.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,DecodeBytesToChars,The length of the statement  "            Debug.Assert((inBufferCount > 0) && (inBufferCount <= inBuffer.Length)' string.Format("Bad inBufferCount: {0}"' inBufferCount)); " is 128.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,DecodeBytesToChars,The length of the statement  "            Debug.Assert((outBufferOffset >= 0) && (outBufferCount > 0) && (outBufferOffset + outBufferCount <= outBuffer.Length)' string.Format("Bad outBufferCount: {0} or outBufferOffset: {1}"' outBufferCount' outBufferOffset)); " is 218.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,DecodeBytesToChars,The length of the statement  "            _decoder.Convert(inBuffer' 0' inBufferCount' outBuffer' outBufferOffset' outBufferCount' false' out bytesUsed' out charsRead' out completed); " is 141.
Long Statement,System.Data.SqlClient,SqlSequentialTextReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,DecodeBytesToChars,The length of the statement  "            Debug.Assert(((_reader == null) || (_reader.ColumnDataBytesRemaining() > 0) || (!completed) || (_leftOverBytes == null))' "Stream has run out of data and the decoder finished' but there are leftover bytes"); " is 207.
Long Statement,System.Data.SqlClient,SqlUnicodeDecoder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,GetChars,The length of the statement  "                Convert(bytes' byteIndex' byteCount' chars' charIndex' chars.Length - charIndex' true' out bytesUsed' out charsUsed' out completed); " is 132.
Long Statement,System.Data.SqlClient,SqlStreamingXml,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,GetChars,The length of the statement  "                SqlStream sqlStream = new SqlStream(_columnOrdinal' _reader' true /* addByteOrderMark */' false /* processAllRows*/' false /*advanceReader*/); " is 142.
Long Statement,System.Data.SqlClient,SqlStreamingXml,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,WriteXmlElement,The length of the statement  "                    _xmlWriter.WriteDocType(_xmlReader.Name' _xmlReader.GetAttribute("PUBLIC")' _xmlReader.GetAttribute("SYSTEM")' _xmlReader.Value); " is 129.
Long Statement,System.Data.SqlClient,AsyncHelper,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,ContinueTask,The length of the statement  "            Debug.Assert((connectionToAbort == null) || (connectionToDoom == null)' "Should not specify both connectionToDoom and connectionToAbort"); " is 138.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,NotSupportedEnumerationValue,The length of the statement  "            return ADP.ArgumentOutOfRange(SR.GetString(SR.SQL_NotSupportedEnumerationValue' type.Name' value.ToString(System.Globalization.CultureInfo.InvariantCulture))' type.Name); " is 170.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,PromotionFailed,The length of the statement  "            TransactionPromotionException e = new TransactionPromotionException(SR.GetString(SR.SqlDelegatedTransaction_PromotionFailed)' inner); " is 133.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,BulkLoadLcidMismatch,The length of the statement  "            return ADP.InvalidOperation(SR.GetString(SR.Sql_BulkLoadLcidMismatch' sourceLcid' sourceColumnName' destinationLcid' destinationColumnName)); " is 141.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,InvalidTableDerivedPrecisionForTvp,The length of the statement  "            return ADP.InvalidOperation(SR.GetString(SR.SqlParameter_InvalidTableDerivedPrecisionForTvp' precision' columnName' System.Data.SqlTypes.SqlDecimal.MaxPrecision)); " is 163.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,ROR_FailoverNotSupportedServer,The length of the statement  "            errors.Add(new SqlError(0' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' null' (SR.GetString(SR.SQLROR_FailoverNotSupported))' ""' 0)); " is 129.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,ROR_RecursiveRoutingNotSupported,The length of the statement  "            errors.Add(new SqlError(0' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' null' (SR.GetString(SR.SQLROR_RecursiveRoutingNotSupported))' ""' 0)); " is 137.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,ROR_UnexpectedRoutingInfo,The length of the statement  "            errors.Add(new SqlError(0' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' null' (SR.GetString(SR.SQLROR_UnexpectedRoutingInfo))' ""' 0)); " is 130.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,ROR_InvalidRoutingInfo,The length of the statement  "            errors.Add(new SqlError(0' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' null' (SR.GetString(SR.SQLROR_InvalidRoutingInfo))' ""' 0)); " is 127.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,ROR_TimeoutAfterRoutingInfo,The length of the statement  "            errors.Add(new SqlError(0' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' null' (SR.GetString(SR.SQLROR_TimeoutAfterRoutingInfo))' ""' 0)); " is 132.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,CR_ReconnectTimeout,The length of the statement  "            errors.Add(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' null' SQLMessage.Timeout()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT)); " is 151.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,CR_NextAttemptWillExceedQueryTimeout,The length of the statement  "            errors.Add(new SqlError(0' 0' TdsEnums.MIN_ERROR_CLASS' null' SR.GetString(SR.SQLCR_NextAttemptWillExceedQueryTimeout)' ""' 0)); " is 128.
Long Statement,System.Data.SqlClient,SQL,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,GetSNIErrorMessage,The length of the statement  "            Debug.Assert(sniError > 0 && sniError <= (int)SNINativeMethodWrapper.SniSpecialErrors.MaxErrorValue' "SNI error is out of range"); " is 130.
Long Statement,System.Data.SqlClient,SQLMessage,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,Duration_Login_ProcessConnectionAuth,The length of the statement  "            return SR.GetString(SR.SQL_Duration_Login_ProcessConnectionAuth' PreLoginBeginDuration' PreLoginHandshakeDuration' LoginBeginDuration' LoginAuthDuration); " is 154.
Long Statement,System.Data.SqlClient,SQLMessage,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,Duration_PostLogin,The length of the statement  "            return SR.GetString(SR.SQL_Duration_PostLogin' PreLoginBeginDuration' PreLoginHandshakeDuration' LoginBeginDuration' LoginAuthDuration' PostLoginDuration); " is 155.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,Connect,The length of the statement  "            PreLoginHandshakeStatus status = ConsumePreLoginHandshake(encrypt' trustServerCert' integratedSecurity' out marsCapable); " is 121.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,Connect,The length of the statement  "                _physicalStateObj.CreatePhysicalSNIHandle(serverInfo.ExtendedServerName' ignoreSniOpenTimeout' timerExpire' out instanceName' ref _sniSpnBuffer' true' true' fParallel' integratedSecurity); " is 188.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The length of the statement  "                _physicalStateObj.AddError(new SqlError(0' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.PreloginError()' ""' 0)); " is 128.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The length of the statement  "                                    _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0)); " is 177.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The length of the statement  "                                    _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0)); " is 177.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The length of the statement  "                        Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!"); " is 137.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,Disconnect,The length of the statement  "                //Debug.Assert(_physicalStateObj._inBytesUsed == _physicalStateObj._inBytesRead && _physicalStateObj._outBytesUsed == _physicalStateObj._inputHeaderLen' "TDSParser closed with data not fully sent or consumed."); " is 211.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,DisconnectTransaction,The length of the statement  "            Debug.Assert(_currentTransaction != null && _currentTransaction == internalTransaction' "disconnecting different transaction"); " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,The length of the statement  "            Debug.Assert(!callerHasConnectionLock || _connHandler._parserLock.ThreadMayHaveLock()' "Caller claims to have lock' but connection lock is not taken"); " is 151.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,The length of the statement  "                if ((_state == TdsParserState.OpenNotLoggedIn) && (_connHandler.ConnectionOptions.MultiSubnetFailover || _loginWithFailover) && (temp.Count == 1) && ((temp[0].Number == TdsEnums.TIMEOUT_EXPIRED) || (temp[0].Number == TdsEnums.SNI_WAIT_TIMEOUT))) " is 245.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,The length of the statement  "                    // For Multisubnet Failover we slice the timeout to make reconnecting faster (with the assumption that the server will not failover instantaneously) " is 148.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,The length of the statement  "                    // However' when timeout occurs we need to not doom the internal connection and also to mark the TdsParser as closed such that the login will be will retried " is 157.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The length of the statement  "            // There is an exception here for MARS as its possible that another thread has closed the connection just as we see an error " is 124.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The length of the statement  "            Debug.Assert(SniContext.Undefined != stateObj.DebugOnlyCopyOfSniContext || ((_fMARS) && ((_state == TdsParserState.Closed) || (_state == TdsParserState.Broken)))' "SniContext must not be None"); " is 194.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The length of the statement  "                        // Connecting with the MultiSubnetFailover connection option to a SQL Server instance configured with more than 64 IP addresses is not supported. " is 145.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The length of the statement  "                        // Connecting to a SQL Server instance using the MultiSubnetFailover connection option is only supported when using the TCP protocol. " is 133.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The length of the statement  "                Debug.Assert(!string.IsNullOrEmpty(details.errorMessage) || details.sniErrorNumber != 0' "Empty error message received from SNI"); " is 130.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The length of the statement  "            Debug.Assert(!string.IsNullOrEmpty(providerName)' String.Format((IFormatProvider)null' "invalid providerResourceId '{0}'"' providerRid)); " is 137.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The length of the statement  "                Debug.Assert(errorMessage.Length > iColon + 1 && errorMessage[iColon + 1] == ' '' "Expecting a space after the ':' character"); " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,CheckResetConnection,The length of the statement  "                Debug.Assert(stateObj._outputPacketNumber == 1 || stateObj._outputPacketNumber == 2' "In ResetConnection logic unexpectedly!"); " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,CheckResetConnection,The length of the statement  "                            stateObj.AddError(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' _server' _connHandler.TimeoutErrorInternal.GetErrorMessage()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT)); " is 192.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The length of the statement  "                ((stateObj._attentionSent) || ((SniContext.Snix_Execute != stateObj.SniContext) && (SniContext.Snix_SendRows != stateObj.SniContext)))'  // SniContext should not be Execute or SendRows unless attention was sent (and' therefore' we are looking for an ACK) " is 254.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The length of the statement  "                        // We are omitting checks for error.Class in the code below (see processing of INFO) since we know (and assert) that error class " is 128.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The length of the statement  "                                                _currentTransaction.TransactionId = env[ii].newLongValue;   // this is defined as a ULongLong in the server and in the TDS Spec. " is 128.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The length of the statement  "                                if (!dataStream.TrySetMetaData(stateObj._cleanupMetaData' (TdsEnums.SQLTABNAME == peekedToken || TdsEnums.SQLCOLINFO == peekedToken))) " is 134.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The length of the statement  "                                if (!TryProcessRow(stateObj._cleanupMetaData' bulkCopyHandler.CreateRowBuffer()' bulkCopyHandler.CreateIndexMap()' stateObj)) " is 125.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The length of the statement  "                Debug.Assert(IsValidTdsToken(token)' string.Format("DataReady is false' but next token is not valid: {0'-2:X2}"' token)); " is 121.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryRun,The length of the statement  "                // Spin until SendAttention has cleared _attentionSending' this prevents a race condition between receiving the attention ACK and setting _attentionSent " is 152.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The length of the statement  "                            Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10"); " is 143.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The length of the statement  "                            Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id. " is 171.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The length of the statement  "                            env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id. " is 125.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The length of the statement  "                            Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id. " is 171.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The length of the statement  "                            env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id. " is 125.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessDone,The length of the statement  "                Debug.Assert(stateObj._inBytesUsed == stateObj._inBytesRead && stateObj._inBytesPacket == 0' "DONE_ATTN received with more data left on wire"); " is 143.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessSessionState,The length of the statement  "                        sdata._delta[stateId] = new SessionStateRecord { _version = seqNum' _dataLength = stateLen' _data = buffer' _recoverable = recoverable }; " is 137.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The length of the statement  "            a.tdsVersion = (UInt32)((((((b[0] << 8) | b[1]) << 8) | b[2]) << 8) | b[3]); // bytes are in motorola order (high byte first) " is 125.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The length of the statement  "            Debug.Assert(_state == TdsParserState.OpenNotLoggedIn' "ProcessLoginAck called with state not TdsParserState.OpenNotLoggedIn"); " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetCodePage,The length of the statement  "                Debug.Assert(0 != codePage' "GetCodePage accessed codepage array and produced 0!' sortID =" + ((Byte)(collation.sortId)).ToString((IFormatProvider)null)); " is 154.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValue,The length of the statement  "            Debug.Assert((stateObj._longlen == 0) && (stateObj._longlenleft == 0)' "ReadSqlValue did not read plp field completely' longlen =" + stateObj._longlen.ToString((IFormatProvider)null) + "'longlenleft=" + stateObj._longlenleft.ToString((IFormatProvider)null)); " is 258.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDate,The length of the statement  "            // NOTE: 2 bytes added here to support additional header information for variant - internal type' scale prop (ignoring scale here) " is 130.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteDateTime2,The length of the statement  "            long time = value.TimeOfDay.Ticks / TdsEnums.TICKS_FROM_SCALE[scale]; // DateTime.TimeOfDay always returns a valid TimeSpan for Time " is 132.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database)); " is 161.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language)); " is 161.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1; " is 144.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                        if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength) " is 123.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                    WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD)) " is 138.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                    WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj); " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                    WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj); " is 149.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The length of the statement  "                    WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj); " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(recoverySessionData == null || (requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0' "Recovery session data without session recovery feature request"); " is 180.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(TdsEnums.MAXLEN_HOSTNAME >= rec.hostName.Length' "_workstationId.Length exceeds the max length for this value"); " is 125.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(rec.userName == null || (rec.userName != null && TdsEnums.MAXLEN_USERNAME >= rec.userName.Length)' "_userID.Length exceeds the max length for this value"); " is 168.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(rec.password == null || (rec.password != null && TdsEnums.MAXLEN_PASSWORD >= rec.password.Length)' "_password.Length exceeds the max length for this value"); " is 170.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(TdsEnums.MAXLEN_APPNAME >= rec.applicationName.Length' "_applicationName.Length exceeds the max length for this value"); " is 133.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(TdsEnums.MAXLEN_SERVERNAME >= rec.serverName.Length' "_dataSource.Length exceeds the max length for this value"); " is 126.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(TdsEnums.MAXLEN_LANGUAGE >= rec.language.Length' "_currentLanguage .Length exceeds the max length for this value"); " is 128.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(TdsEnums.MAXLEN_DATABASE >= rec.database.Length' "_initialCatalog.Length exceeds the max length for this value"); " is 126.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(TdsEnums.MAXLEN_ATTACHDBFILE >= rec.attachDBFilename.Length' "_attachDBFileName.Length exceeds the max length for this value"); " is 140.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            encryptedPasswordLengthInBytes = encryptedPassword.Length;  // password in clear text is already encrypted and its length is in byte " is 132.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "            Debug.Assert(TdsEnums.MAXLEN_CLIENTINTERFACE >= clientInterfaceName.Length' "cchCltIntName can specify at most 128 unicode characters. See Tds spec"); " is 150.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "                    Debug.Assert(SniContext.Snix_Login == _physicalStateObj.SniContext' String.Format((IFormatProvider)null' "Unexpected SniContext. Expecting Snix_Login' actual value is '{0}'"' _physicalStateObj.SniContext)); " is 206.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The length of the statement  "                // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SNISSPIData,The length of the statement  "                if (0 != _physicalStateObj.GenerateSspiClientContext(receivedBuff' receivedLength' ref sendBuff' ref sendLength' _sniSpnBuffer)) " is 128.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetDTCAddress,The length of the statement  "                Debug.Assert(SniContext.Snix_Read == stateObj.SniContext' String.Format((IFormatProvider)null' "The SniContext should be Snix_Read but it actually is {0}"' stateObj.SniContext)); " is 178.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "            Debug.Assert(!_connHandler.ThreadHasParserLockForClose || _connHandler._parserLock.ThreadMayHaveLock()' "Thread claims to have parser lock' but lock is not taken"); " is 164.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "            bool callerHasConnectionLock = _connHandler.ThreadHasParserLockForClose;   // If the thread already claims to have the parser lock' then we will let the caller handle releasing it " is 179.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "                        Debug.Assert(null != transaction' "Should have specified an internalTransaction when doing a BeginTransaction request!"); " is 121.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "                            Debug.Assert(_currentTransaction == null || true == _fResetConnection' "We should not have a current Tx at this point"); " is 120.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "                        Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!"); " is 149.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "                        Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!"); " is 149.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "                // If the retained ID is no longer valid (because we are enlisting in null or a new transaction) then it should be cleared " is 122.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The length of the statement  "                if (((request == TdsEnums.TransactionManagerRequestType.Begin) || (request == TdsEnums.TransactionManagerRequestType.Propagate)) && ((transaction == null) || (transaction.TransactionId != _retainedTransactionId))) " is 213.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,FailureCleanup,The length of the statement  "                Debug.Assert(_connHandler._parserLock.ThreadMayHaveLock()' "Should not be calling into FailureCleanup without first taking the parser lock"); " is 141.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteSQLBatch,The length of the statement  "            Debug.Assert(!_connHandler.ThreadHasParserLockForClose || sync' "Thread shouldn't claim to have the parser lock if we are doing async writes");     // Since we have the possibility of pending with async writes' make sure the thread doesn't claim to already have the lock " is 270.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteSQLBatch,The length of the statement  "            Debug.Assert(needToTakeParserLock || _connHandler._parserLock.ThreadMayHaveLock()' "Thread or caller claims to have connection lock' but lock is not taken"); " is 157.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteSQLBatch,The length of the statement  "            // NOTE: We are not turning off async writes when we complete since SqlBulkCopy uses this method and expects _asyncWrite to not change " is 134.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "            Debug.Assert(!firstCall || !_connHandler.ThreadHasParserLockForClose' "Thread should not already have connection lock"); " is 120.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "            Debug.Assert(firstCall || _connHandler._parserLock.ThreadMayHaveLock()' "Connection lock not taken after the first call"); " is 122.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "                            // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here) " is 126.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "                                isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing. " is 210.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "                                WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj); " is 130.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "                                // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter " is 120.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "                                    writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed); " is 141.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The length of the statement  "                        execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default); " is 137.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSmiParameter,The length of the statement  "                bool isCLRType = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing. " is 216.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSmiParameter,The length of the statement  "                typeCode = MSS.MetaDataUtilsSmi.DetermineExtendedTypeCodeForUseWithSqlDbType(metaData.SqlDbType' metaData.IsMultiValued' value' null); " is 134.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSmiParameter,The length of the statement  "                                        new MSS.SmiEventSink_Default()'  // TDS Errors/events dealt with at lower level for now' just need an object for processing " is 123.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSmiTypeInfo,The length of the statement  "                    stateObj.WriteByte(checked((byte)MetaType.MetaDecimal.FixedLength));   // SmiMetaData's length and actual wire format's length are different " is 140.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTvpTypeInfo,The length of the statement  "                MSS.SmiDefaultFieldsProperty defaults = (MSS.SmiDefaultFieldsProperty)metaData.ExtendedProperties[MSS.SmiPropertySelector.DefaultFields]; " is 137.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTvpOrderUnique,The length of the statement  "            MSS.SmiOrderProperty orderProperty = (MSS.SmiOrderProperty)metaData.ExtendedProperties[MSS.SmiPropertySelector.SortOrder]; " is 122.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTvpOrderUnique,The length of the statement  "            MSS.SmiUniqueKeyProperty uniqueKeyProperty = (MSS.SmiUniqueKeyProperty)metaData.ExtendedProperties[MSS.SmiPropertySelector.UniqueKey]; " is 134.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The length of the statement  "                   "Stream data feed should only be assigned to VarBinary(max)' Text data feed should only be assigned to [N]VarChar(max)' Xml data feed should only be assigned to XML(max)"); " is 172.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The length of the statement  "                    internalWriteTask = WriteValue(value' metatype' metadata.scale' ccb' ccbStringBytes' 0' stateObj' metadata.length' isDataFeed); " is 127.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The length of the statement  "                    Debug.Assert(_asyncWrite || stateObj.WaitForAccumulatedWrites() == null' "Should not have accumulated writes when writing sync"); " is 129.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The length of the statement  "                    resultTask = WriteBulkCopyValueSetupContinuation(internalWriteTask' saveEncoding' saveCollation' saveCodePage' saveLCID); " is 121.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteMarsHeaderData,The length of the statement  "            // Debug.Assert(!(null != sqlTransaction && null != distributedTransaction)' "Error to have local (api started) and distributed transaction at the same time!"); " is 160.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteMarsHeaderData,The length of the statement  "            // Debug.Assert(!(null != _userStartedLocalTransaction && null != distributedTransaction)' "Error to have local (started outside of the api) and distributed transaction at the same time!"); " is 189.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The length of the statement  "                        Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The length of the statement  "                        return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false); " is 123.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteXmlFeed,The length of the statement  "            ConstrainedTextWriter writer = new ConstrainedTextWriter(new StreamWriter(new TdsOutputStream(this' stateObj' preambleToSkip)' encoding)' size); " is 144.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTextFeed,The length of the statement  "            ConstrainedTextWriter writer = new ConstrainedTextWriter(new StreamWriter(new TdsOutputStream(this' stateObj' null)' encoding)' size); " is 134.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteValue,The length of the statement  "            return GetTerminationTask(WriteUnterminatedValue(value' type' scale' actualLength' encodingByteSize' offset' stateObj' paramSize' isDataFeed)' " is 142.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The length of the statement  "                        Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture)); " is 132.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The length of the statement  "                        Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader"); " is 120.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The length of the statement  "                                return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize)); " is 136.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The length of the statement  "                        Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader"); " is 120.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The length of the statement  "                                return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize)); " is 131.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeCharsChunk,The length of the statement  "            Debug.Assert((buff == null && len == 0) || (buff.Length >= offst + len)' "Invalid length sent to ReadPlpUnicodeChars()!"); " is 122.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeChars,The length of the statement  "            Debug.Assert((buff == null && offst == 0) || (buff.Length >= offst + len)' "Invalid length sent to ReadPlpUnicodeChars()!"); " is 124.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeChars,The length of the statement  "            // If total length is known up front' allocate the whole buffer in one shot instead of realloc'ing and copying over each time " is 125.
Long Statement,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ReadPlpAnsiChars,The length of the statement  "            Debug.Assert((buff == null && offst == 0) || (buff.Length >= offst + len)' "Invalid length sent to ReadPlpAnsiChars()!"); " is 121.
Long Statement,System.Data.SqlClient,ConstrainedTextWriter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,Write,The length of the statement  "                Debug.Assert(_size < 0 || _written <= _size' string.Format("Length of data written exceeds specified length.  Written: {0}' specified: {1}"' _written' _size)); " is 159.
Long Statement,System.Data.SqlClient,MultiPartTableName,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,ParseMultipartName,The length of the statement  "                string[] parts = MultipartIdentifier.ParseMultipartIdentifier(_multipartName' "[\""' "]\""' SR.SQL_TDSParserTableName' false); " is 126.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,IsRowTokenReady,The length of the statement  "            // Removing one byte since TryReadByteArray\TryReadByte will aggressively read the next packet if there is no data left - so we need to ensure there is a spare byte " is 164.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,Activate,The length of the statement  "            int result = Interlocked.Increment(ref _activateCount);   // must have non-zero activation count for reclamation to work too. " is 125.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,Cancel,The length of the statement  "            Debug.Assert(caller is SqlCommand || caller is SqlDataReader' "Calling API with invalid caller type: " + caller.GetType()); " is 123.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,Cancel,The length of the statement  "                                        _parser.Connection._parserLock.Wait(canReleaseFromAnyThread: false' timeout: _waitForCancellationLockPollTimeout' lockTaken: ref hasParserLock); " is 144.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,RemoveOwner,The length of the statement  "                int result = Interlocked.Decrement(ref _activateCount);   // must have non-zero activation count for reclamation to work too. " is 125.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,DecrementPendingCallbacks,The length of the statement  "            Debug.Assert((remaining == -1 && SessionHandle == null) || (0 <= remaining && remaining < 3)' string.Format("_pendingCallbacks values is invalid after decrementing: {0}"' remaining)); " is 183.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,IncrementPendingCallbacks,The length of the statement  "            Debug.Assert(0 < remaining && remaining <= 3' string.Format("_pendingCallbacks values is invalid after incrementing: {0}"' remaining)); " is 135.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryProcessHeader,The length of the statement  "                // VSTS 219884: when some kind of MITM (man-in-the-middle) tool splits the network packets' the message header can be split over  " is 128.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,SetPacketSize,The length of the statement  "                            string errormessage = SR.GetString(SR.SQL_InvalidInternalPacketSize) + ' ' + temp.Length + "' " + _inBytesUsed + "' " + remainingData + "' " + _inBuff.Length; " is 158.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadByte,The length of the statement  "            Debug.Assert(_inBytesUsed >= 0 && _inBytesUsed <= _inBytesRead' "ERROR - TDSParser: _inBytesUsed < 0 or _inBytesUsed > _inBytesRead"); " is 134.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadChar,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt16,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt32,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt16,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadSingle,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadDouble,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadString,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadStringWithEncoding,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadStringWithEncoding,The length of the statement  "                // Need to skip the current column before throwing the error - this ensures that the state shared between this and the data reader is consistent when calling DrainData " is 167.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadPlpBytes,The length of the statement  "            // If total length is known up front' allocate the whole buffer in one shot instead of realloc'ing and copying over each time " is 125.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TrySkipLongBytes,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TrySkipBytes,The length of the statement  "            Debug.Assert(_syncOverAsync || !_asyncReadWithoutSnapshot' "This method is not safe to call when doing sync over async"); " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadNetworkPacket,The length of the statement  "            Debug.Assert(!_shouldHaveEnoughData || _attentionSent' "Caller said there should be enough data' but we are currently reading a packet"); " is 137.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadNetworkPacket,The length of the statement  "            Debug.Assert((_snapshot != null) ^ _asyncReadWithoutSnapshot' "Must have either _snapshot set up or _asyncReadWithoutSnapshot enabled (but not both) to pend a read"); " is 166.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,OnTimeout,The length of the statement  "                        AddError(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' _parser.Server' _parser.Connection.TimeoutErrorInternal.GetErrorMessage()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT)); " is 196.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,OnTimeout,The length of the statement  "                            // We should never timeout if the connection is currently in the pool: the safest thing to do here is to doom the connection to avoid corruption " is 144.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,OnTimeout,The length of the statement  "                                        // So it is safe for us to break the connection and cancel the Task (since we are not sure that ReadAsyncCallback will ever be called) " is 134.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,OnTimeout,The length of the statement  "                                            Debug.Assert(source == _networkPacketTaskSource' "_networkPacketTaskSource which is being timed is not the current task source"); " is 129.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadSni,The length of the statement  "            Debug.Assert(_networkPacketTaskSource == null || ((_asyncReadWithoutSnapshot) && (_networkPacketTaskSource.Task.IsCompleted))' "Pending async call or failed to replay snapshot when calling ReadSni"); " is 199.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadSni,The length of the statement  "                //  0 == Already timed out (NOTE: To simulate the same behavior as sync we will only timeout on 0 if we receive an IO Pending from SNI) " is 135.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadSni,The length of the statement  "                    // Evaluate this condition for MANAGED_SNI. This may not be needed because the network call is happening Async and only the callback can receive a success. " is 155.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,IsConnectionAlive,The length of the statement  "            Debug.Assert(_parser.Connection == null || _parser.Connection.Pool != null' "Shouldn't be calling IsConnectionAlive on non-pooled connections"); " is 144.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadSniError,The length of the statement  "                    AddError(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' _parser.Server' _parser.Connection.TimeoutErrorInternal.GetErrorMessage()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT)); " is 196.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadSniError,The length of the statement  "                            else if ((_parser.State == TdsParserState.OpenNotLoggedIn) && (_parser.Connection.ConnectionOptions.MultiSubnetFailover)) " is 121.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadAsyncCallback,The length of the statement  "                // pendingCallbacks may be 2 after decrementing' this indicates that a fatal timeout is occurring' and therefore we shouldn't complete the task " is 143.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadAsyncCallbackCaptureException,The length of the statement  "                // This is unusual' but possible if a fatal timeout occurred on another thread (which should mean that the connection is now broken) " is 132.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadAsyncCallbackCaptureException,The length of the statement  "                Debug.Assert(_parser.State == TdsParserState.Broken || _parser.State == TdsParserState.Closed || _parser.Connection.IsConnectionDoomed' "Failed to capture exception while the connection was still healthy"); " is 206.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WaitForAccumulatedWrites,The length of the statement  "#pragma warning disable 420 // A reference to a volatile field will not be treated as volatile - Disabling since the Interlocked APIs are volatile aware " is 152.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WaitForAccumulatedWrites,The length of the statement  "#pragma warning disable 420 // A reference to a volatile field will not be treated as volatile - Disabling since the Interlocked APIs are volatile aware " is 152.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WriteByteArray,The length of the statement  "                bool async = _parser._asyncWrite;  // NOTE: We are capturing this now for the assert after the Task is returned' since WritePacket will turn off async if there is an exception " is 175.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The length of the statement  "                // So removing the IsYukonOrNewer check causes issues since the login packet happens to meet the rest of the conditions below " is 125.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,CancelWritePacket,The length of the statement  "            _parser.Connection.ThreadHasParserLockForClose = true;      // In case of error' let the connection know that we are holding the lock " is 133.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,SNIWritePacket,The length of the statement  "                        Debug.Assert(IsValidPacket(packetPointer)' "Packet added to list has an invalid pointer' can not remove from pending list"); " is 124.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WriteSni,The length of the statement  "            Debug.Assert(Parser.Connection._parserLock.ThreadMayHaveLock()' "Thread is writing without taking the connection lock"); " is 120.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WriteSni,The length of the statement  "            // Check to see if the timeout has occurred.  This time out code is special case code to allow BCP writes to timeout. Eventually we should make all writes timeout. " is 163.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WriteSni,The length of the statement  "                    AddError(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' _parser.Server' _parser.Connection.TimeoutErrorInternal.GetErrorMessage()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT)); " is 196.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,GetFullErrorAndWarningCollection,The length of the statement  "                // We also process the pre-attention error lists here since' if we are here and they are populated' then an error occurred while sending attention so we should show the errors now (otherwise they'd be lost) " is 206.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,StoreErrorAndWarningForAttention,The length of the statement  "                Debug.Assert(_preAttentionErrors == null && _preAttentionWarnings == null' "Can't store errors for attention because there are already errors stored"); " is 151.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,RestoreErrorAndWarningAfterAttention,The length of the statement  "                Debug.Assert(_errors == null && _warnings == null' "Can't restore errors after attention because there are already other errors"); " is 130.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,RestoreErrorAndWarningAfterAttention,The length of the statement  "                _hasErrorOrWarning = (((_preAttentionErrors != null) && (_preAttentionErrors.Count > 0)) || ((_preAttentionWarnings != null) && (_preAttentionWarnings.Count > 0))); " is 164.
Long Statement,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,AssertStateIsClean,The length of the statement  "                Debug.Assert(!_attentionReceived && !_attentionSent && !_attentionSending' string.Format("StateObj is still dealing with attention: Sent: {0}' Received: {1}' Sending: {2}"' _attentionSent' _attentionReceived' _attentionSending)); " is 229.
Long Statement,System.Data.SqlClient,StateSnapshot,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,CloneCleanupAltMetaDataSetArray,The length of the statement  "                if (_stateObj._cleanupAltMetaDataSetArray != null && object.ReferenceEquals(_snapshotCleanupAltMetaDataSetArray' _stateObj._cleanupAltMetaDataSetArray)) " is 152.
Long Statement,System.Data.SqlClient,StateSnapshot,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,AssertCurrent,The length of the statement  "                Debug.Assert(_snapshotInBuffCurrent == _snapshotInBuffs.Count' "Should not be reading new packets when not replaying last packet"); " is 131.
Long Statement,System.Data.SqlClient,StateSnapshot,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,CheckStack,The length of the statement  "                    Debug.Assert(_stateObj._permitReplayStackTraceToDiffer || prev.Stack.ToString() == trace.ToString()' "The stack trace on subsequent replays should be the same"); " is 161.
Long Statement,System.Data.SqlClient,TdsRecordBufferSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsRecordBufferSetter.cs,CheckWritingToColumn,The length of the statement  "            Debug.Assert(0 <= _currentField && _metaData.FieldMetaData.Count > _currentField' "_currentField out of range for setting a column:" + _currentField); " is 150.
Long Statement,System.Data.SqlClient,TdsRecordBufferSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsRecordBufferSetter.cs,CheckWritingToColumn,The length of the statement  "            Debug.Assert(ordinal == _currentField' "Setter called out of order.  Should be " + _currentField + "' but was " + ordinal); " is 123.
Long Statement,System.Data.SqlClient,TdsRecordBufferSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsRecordBufferSetter.cs,SkipPossibleDefaultedColumns,The length of the statement  "            Debug.Assert(targetColumn < _metaData.FieldMetaData.Count && targetColumn >= ReadyForToken' "TdsRecordBufferSetter.SkipPossibleDefaultedColumns: Invalid target column: " + targetColumn); " is 186.
Long Statement,System.Data.SqlClient,TdsRecordBufferSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsRecordBufferSetter.cs,SkipPossibleDefaultedColumns,The length of the statement  "                Debug.Assert(((SmiDefaultFieldsProperty)_metaData.ExtendedProperties[SmiPropertySelector.DefaultFields])[_currentField]' " is 120.
Long Statement,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetSqlDecimal,The length of the statement  "                _stateObj.WriteByte(checked((byte)MetaType.MetaDecimal.FixedLength)); // SmiMetaData's length and actual wire format's length are different " is 139.
Long Statement,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetSqlDecimal,The length of the statement  "                _stateObj.Parser.WriteSqlDecimal(SqlDecimal.ConvertToPrecScale(value' _metaData.Precision' _metaData.Scale)' _stateObj); " is 120.
Long Statement,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetGuid,The length of the statement  "            Debug.Assert(SmiMetaData.DefaultUniqueIdentifier.MaxLength == bytes.Length' "Invalid length for guid bytes: " + bytes.Length); " is 126.
Long Statement,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTimeOffset,The length of the statement  "                // VSTFDevDiv #885208 - DateTimeOffset throws ArgumentException for when passing DateTimeOffset value to a sql_variant TVP  " is 122.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,RemoveStringQuotes,The length of the statement  "                unquotedString = quotedString.Substring(prefixLength' quotedStringLength - (prefixLength + suffixLength)).Replace(quoteSuffix + quoteSuffix' quoteSuffix); " is 154.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidEnumerationValue,The length of the statement  "            return ArgumentOutOfRange(SR.Format(SR.ADP_InvalidEnumerationValue' type.Name' value.ToString(CultureInfo.InvariantCulture))' type.Name); " is 137.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,CollectionIndexInt32,The length of the statement  "            return IndexOutOfRange(SR.Format(SR.ADP_CollectionIndexInt32' index.ToString(CultureInfo.InvariantCulture)' collection.Name' count.ToString(CultureInfo.InvariantCulture))); " is 172.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,CollectionIndexString,The length of the statement  "            return IndexOutOfRange(SR.Format(SR.ADP_CollectionIndexString' itemType.Name' propertyName' propertyValue' collection.Name)); " is 125.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,CollectionInvalidType,The length of the statement  "            return InvalidCast(SR.Format(SR.ADP_CollectionInvalidType' collection.Name' itemType.Name' invalidValue.GetType().Name)); " is 121.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidSourceBufferIndex,The length of the statement  "            return ArgumentOutOfRange(SR.Format(SR.ADP_InvalidSourceBufferIndex' maxLen.ToString(CultureInfo.InvariantCulture)' srcOffset.ToString(CultureInfo.InvariantCulture))' parameterName); " is 182.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidDestinationBufferIndex,The length of the statement  "            return ArgumentOutOfRange(SR.Format(SR.ADP_InvalidDestinationBufferIndex' maxLen.ToString(CultureInfo.InvariantCulture)' dstOffset.ToString(CultureInfo.InvariantCulture))' parameterName); " is 187.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidBufferSizeOrIndex,The length of the statement  "            return IndexOutOfRange(SR.Format(SR.SQL_InvalidBufferSizeOrIndex' numBytes.ToString(CultureInfo.InvariantCulture)' bufferIndex.ToString(CultureInfo.InvariantCulture))); " is 168.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,DbTypeNotSupported,The length of the statement  "            PlatformNotSupportedException e = new PlatformNotSupportedException(SR.GetString(SR.SQL_DbTypeNotSupportedOnThisPlatform' dbType)); " is 131.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,NonSeqByteAccess,The length of the statement  "            return InvalidOperation(SR.GetString(SR.ADP_NonSeqByteAccess' badIndex.ToString(CultureInfo.InvariantCulture)' currIndex.ToString(CultureInfo.InvariantCulture)' method)); " is 170.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,NonSequentialColumnAccess,The length of the statement  "            return InvalidOperation(SR.GetString(SR.ADP_NonSequentialColumnAccess' badCol.ToString(CultureInfo.InvariantCulture)' currCol.ToString(CultureInfo.InvariantCulture))); " is 167.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,UninitializedParameterSize,The length of the statement  "            return InvalidOperation(SR.GetString(SR.ADP_UninitializedParameterSize' index.ToString(CultureInfo.InvariantCulture)' dataType.Name)); " is 134.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,UnknownDataTypeCode,The length of the statement  "            return Argument(SR.GetString(SR.ADP_UnknownDataTypeCode' ((int)typeCode).ToString(CultureInfo.InvariantCulture)' dataType.FullName)); " is 133.
Long Statement,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,DeriveParametersNotSupported,The length of the statement  "            return DataAdapter(SR.GetString(SR.ADP_DeriveParametersNotSupported' value.GetType().Name' value.CommandType.ToString())); " is 122.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,ConvertValueToIntegratedSecurityInternal,The length of the statement  "            if (CompareInsensitiveInvariant(stringValue' "sspi") || CompareInsensitiveInvariant(stringValue' "true") || CompareInsensitiveInvariant(stringValue' "yes")) " is 156.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,ConvertValueToIntegratedSecurityInternal,The length of the statement  "                if (CompareInsensitiveInvariant(tmp' "sspi") || CompareInsensitiveInvariant(tmp' "true") || CompareInsensitiveInvariant(tmp' "yes")) " is 132.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,IsKeyNameValid,The length of the statement  "                Debug.Assert(((0 < keyname.Length) && (';' != keyname[0]) && !Char.IsWhiteSpace(keyname[0]) && (-1 == keyname.IndexOf('\u0000'))) == compValue' "IsValueValid mismatch with regex"); " is 180.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,IsKeyNameValid,The length of the statement  "                return ((0 < keyname.Length) && (';' != keyname[0]) && !Char.IsWhiteSpace(keyname[0]) && (-1 == keyname.IndexOf('\u0000'))); " is 124.
Long Statement,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,ParseComparison,The length of the statement  "                            if (msg1.StartsWith(KeywordNotSupportedMessagePrefix' StringComparison.Ordinal) || msg1.StartsWith(WrongFormatMessagePrefix' StringComparison.Ordinal)) " is 151.
Long Statement,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,ConvertToBoolean,The length of the statement  "                else if (StringComparer.OrdinalIgnoreCase.Equals(svalue' "false") || StringComparer.OrdinalIgnoreCase.Equals(svalue' "no")) " is 123.
Long Statement,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,ConvertToIntegratedSecurity,The length of the statement  "                if (StringComparer.OrdinalIgnoreCase.Equals(svalue' "sspi") || StringComparer.OrdinalIgnoreCase.Equals(svalue' "true") || StringComparer.OrdinalIgnoreCase.Equals(svalue' "yes")) " is 177.
Long Statement,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,ConvertToIntegratedSecurity,The length of the statement  "                else if (StringComparer.OrdinalIgnoreCase.Equals(svalue' "false") || StringComparer.OrdinalIgnoreCase.Equals(svalue' "no")) " is 123.
Long Statement,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,ConvertToIntegratedSecurity,The length of the statement  "                    if (StringComparer.OrdinalIgnoreCase.Equals(tmp' "sspi") || StringComparer.OrdinalIgnoreCase.Equals(tmp' "true") || StringComparer.OrdinalIgnoreCase.Equals(tmp' "yes")) " is 168.
Long Statement,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,TryConvertToApplicationIntent,The length of the statement  "            Debug.Assert(Enum.GetNames(typeof(ApplicationIntent)).Length == 2' "ApplicationIntent enum has changed' update needed"); " is 120.
Long Statement,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,IsValidApplicationIntentValue,The length of the statement  "            Debug.Assert(Enum.GetNames(typeof(ApplicationIntent)).Length == 2' "ApplicationIntent enum has changed' update needed"); " is 120.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "            StringBuilder sb = new StringBuilder(name.Length); // String buffer to hold the string being currently built' init the string builder so it will never be resized " is 161.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "            StringBuilder whitespaceSB = null;                  // String buffer to hold whitespace used when parsing nonquoted strings  'a b .  c d' = 'a b' and 'c d' " is 155.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "            char rightQuoteChar = ' ';                          // Right quote character to use given the left quote character found. " is 121.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                            {  // If we found a separator' no string was found' initialize the string we are parsing to Empty and the next one to Empty. " is 124.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                               // This is NOT a redundant setting of string.Empty it solves the case where we are parsing ".foo" and we should be returning null' null' empty' foo " is 147.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                                whitespaceSB.Append(testchar);  // start to record the whitespace' if we are parsing a name like "foo bar" we should return "foo bar" " is 133.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                            {                          // It is a whitespace character so the following char should be whitespace' separator' or end of string anything else is bad " is 151.
Long Statement,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The length of the statement  "                // Shuffle the parsed name' from left justification to right justification' i.e. [a][b][null][null] goes to [null][null][a][b] " is 126.
Long Statement,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,CreateNonPooledConnection,The length of the statement  "            DbConnectionInternal newConnection = CreateConnection(connectionOptions' poolKey' poolGroupProviderInfo' null' owningConnection' userOptions); " is 142.
Long Statement,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,CreatePooledConnection,The length of the statement  "            DbConnectionInternal newConnection = CreateConnection(options' poolKey' poolGroupProviderInfo' pool' owningObject' userOptions); " is 128.
Long Statement,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,GetConnectionPoolGroup,The length of the statement  "            if (!connectionPoolGroups.TryGetValue(key' out connectionPoolGroup) || (connectionPoolGroup.IsDisabled && (null != connectionPoolGroup.PoolGroupOptions))) " is 154.
Long Statement,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,GetConnectionPoolGroup,The length of the statement  "                        Dictionary<DbConnectionPoolKey' DbConnectionPoolGroup> newConnectionPoolGroups = new Dictionary<DbConnectionPoolKey' DbConnectionPoolGroup>(1 + connectionPoolGroups.Count); " is 172.
Long Statement,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,PruneConnectionPoolGroups,The length of the statement  "                Dictionary<DbConnectionPoolKey' DbConnectionPoolGroup> newConnectionPoolGroups = new Dictionary<DbConnectionPoolKey' DbConnectionPoolGroup>(connectionPoolGroups.Count); " is 168.
Long Statement,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,CloseConnection,The length of the statement  "                            Deactivate();   // ensure we de-activate non-pooled connections' or the data readers and transactions may not get cleaned up... " is 127.
Long Statement,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,PrePush,The length of the statement  "                throw ADP.InternalError(ADP.InternalErrorCode.PushingObjectSecondTime);         // pushing object onto stack a second time " is 122.
Long Statement,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,PrePush,The length of the statement  "            _owningObject.Target = null; // NOTE: doing this and checking for InternalError.PooledObjectHasOwner degrades the close by 2% " is 125.
Long Statement,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,PostPop,The length of the statement  "                    throw ADP.InternalError(ADP.InternalErrorCode.PooledObjectInPoolMoreThanOnce);  // popping object off stack with multiple pooledCount " is 133.
Long Statement,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,PostPop,The length of the statement  "                throw ADP.InternalError(ADP.InternalErrorCode.NonPooledObjectUsedMoreThanOnce); // popping object off stack with multiple pooledCount " is 133.
Long Statement,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,DetachCurrentTransactionIfEnded,The length of the statement  "                    // If the transaction is being processed (i.e. is part way through a rollback\commit\etc then TransactionInformation.Status will throw an exception) " is 148.
Long Statement,System.Data.ProviderBase,DbConnectionInternal,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionInternal.cs,DetachTransaction,The length of the statement  "            // transaction between compare and assignment. No need to short circuit outside of lock' since failed comparisons should " is 120.
Long Statement,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,CreateObject,The length of the statement  "                newObj = _connectionFactory.CreatePooledConnection(this' owningObject' _connectionPoolGroup.ConnectionOptions' _connectionPoolGroup.PoolKey' userOptions); " is 154.
Long Statement,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,CreateObject,The length of the statement  "                    throw ADP.InternalError(ADP.InternalErrorCode.NewObjectCannotBePooled);        // CreateObject succeeded' but non-poolable object " is 129.
Long Statement,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,CreateObject,The length of the statement  "                    // the timer will restart. Otherwise' the timer callback (ErrorCallback) destroys the timer after resetting the error to avoid second callback. " is 143.
Long Statement,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,TryGetConnection,The length of the statement  "            if (TryGetConnection(owningObject' waitForMultipleObjectsTimeout' allowCreate' onlyOneCheckConnection' userOptions' out connection)) " is 132.
Long Statement,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,PrepareConnection,The length of the statement  "            {   // Protect against Clear and ReclaimEmancipatedObjects' which call IsEmancipated' which is affected by PrePush and PostPop " is 126.
Long Statement,System.Data.ProviderBase,TransactedConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,PutTransactedObject,The length of the statement  "                        newConnections = new TransactedConnectionList(2' transactionClone); // start with only two connections in the list; most times we won't need that many. " is 151.
Long Statement,System.Data.ProviderBase,DbConnectionPoolGroup,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPoolGroup.cs,GetConnectionPool,The length of the statement  "                                DbConnectionPoolProviderInfo connectionPoolProviderInfo = connectionFactory.CreateConnectionPoolProviderInfo(this.ConnectionOptions); " is 133.
Long Statement,System.Data.ProviderBase,DbConnectionPoolIdentity,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPoolIdentity.cs,GetCurrentManaged,The length of the statement  "            string sidString = (!string.IsNullOrWhiteSpace(System.Environment.UserDomainName) ? System.Environment.UserDomainName + "\\" : "") " is 130.
Long Statement,System.Threading.Tasks,TaskToApm,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Threading\Tasks\TaskToApm.cs,Begin,The length of the statement  "                asyncResult = task.AsyncState == state ? (IAsyncResult)task : new TaskWrapperAsyncResult(task' state' completedSynchronously: false); " is 133.
Long Statement,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,HandleReceiveComplete,The length of the statement  "                            int bytesTaken = packet.TakeData(_headerBytes' _currentHeaderByteCount' SNISMUXHeader.HEADER_LENGTH - _currentHeaderByteCount); " is 127.
Long Statement,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,HandleReceiveComplete,The length of the statement  "                        SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.SMUX_PROV' 0' SNICommon.InvalidParameterError' string.Empty); " is 131.
Long Statement,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXHeaderBytes,The length of the statement  "            _currentHeader.sequenceNumber = ((flags == (byte)SNISMUXFlags.SMUX_FIN) || (flags == (byte)SNISMUXFlags.SMUX_ACK)) ? _sequenceNumber - 1 : _sequenceNumber++; " is 157.
Long Statement,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXEncapsulatedPacket,The length of the statement  "            smuxPacket.Description = string.Format("({0}) SMUX packet {1}"' packet.Description == null ? "" : packet.Description' xSequenceNumber); " is 135.
Long Statement,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,Receive,The length of the statement  "                    SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.SMUX_PROV' 0' SNICommon.ConnTimeoutError' string.Empty); " is 126.
Long Statement,System.Data.SqlClient.SNI,SNIPacket,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIPacket.cs,ReadFromStreamAsync,The length of the statement  "                        SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.TCP_PROV' 0' SNICommon.ConnTerminatedError' string.Empty); " is 128.
Long Statement,System.Data.SqlClient.SNI,SNIProxy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,CreateTcpHandle,The length of the statement  "                SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.TCP_PROV' 0' SNICommon.InvalidConnStringError' string.Empty); " is 131.
Long Statement,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,GetLocalDBInstance,The length of the statement  "                    SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.INVALID_PROV' 0' SNICommon.LocalDBNoInstanceName' string.Empty); " is 134.
Long Statement,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferConnectionDetails,The length of the statement  "            // Check the parameters. The parameters are Comma separated in the Data Source. The parameter we really care about is the port " is 126.
Long Statement,System.Data.SqlClient.SNI,SNITCPHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNITcpHandle.cs,Receive,The length of the statement  "                    if (ioe.InnerException is SocketException && ((SocketException)(ioe.InnerException)).SocketErrorCode == SocketError.TimedOut) " is 125.
Long Statement,System.Data.SqlClient.SNI,SNICommon,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNICommon.cs,ValidateSslServerCertificate,The length of the statement  "                    if (string.Compare(targetServerName' 0' certServerName' 0' targetServerName.Length' StringComparison.OrdinalIgnoreCase) != 0) " is 125.
Long Statement,System.Data.SqlClient.SNI,TdsParserStateObjectManaged,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObjectManaged.cs,CreatePhysicalSNIHandle,The length of the statement  "            _sessionHandle = SNIProxy.Singleton.CreateConnectionHandle(this' serverName' ignoreSniOpenTimeout' timerExpire' out instanceName' ref spnBuffer' flushCache' async' parallel' isIntegratedSecurity); " is 196.
Long Statement,System.Data.SqlClient.SNI,TdsParserStateObjectManaged,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObjectManaged.cs,ClearAllWritePackets,The length of the statement  "                Debug.Assert(_pendingWritePackets.Count == 0 && _asyncWriteCount == 0' "Should not clear all write packets if there are packets pending"); " is 138.
Long Statement,System.Data.SqlClient.SNI,LocalDB,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\LocalDB.Unix.cs,GetLocalDBConnectionString,The length of the statement  "            throw new PlatformNotSupportedException(SR.LocalDBNotSupported); // LocalDB is not available for Unix and hence it cannot be supported. " is 135.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Enter,The length of the statement  "            if (IsEnabled) Log.Enter(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 134.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Exit,The length of the statement  "            if (IsEnabled) Log.Exit(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Info,The length of the statement  "            if (IsEnabled) Log.Info(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,DumpBuffer,The length of the statement  "                    Fail(thisOrContextObject' $"Invalid {nameof(DumpBuffer)} Args. Length={buffer.Length}' Offset={offset}' Count={count}"' memberName); " is 132.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is ValueType)' $"Should not be passing value type {arg?.GetType()} to logging without IsEnabled check"); " is 123.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is FormattableString)' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 124.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,DebugValidateArg,The length of the statement  "            Debug.Assert(IsEnabled || arg == null' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 121.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread changed from User to System; user's thread shouldn't be hijacked."); " is 133.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread changed from Async to Sync' may block an Async thread."); " is 122.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread from a limited resource changed to Sync' may deadlock or bottleneck."); " is 136.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadSource,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "SetThreadSource must be called at the base of the stack' or the stack has been corrupted."); " is 150.
Long Statement,System.Net,ContextFlagsAdapterPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\ContextFlagsAdapterPal.Unix.cs,GetContextFlagsPalFromInterop,The length of the statement  "            // GSS_C_INTEG_FLAG is handled separately as its value can either be AcceptIntegrity (used by server) or InitIntegrity (used by client) " is 135.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,GssWrap,The length of the statement  "                Interop.NetSecurityNative.Status status = Interop.NetSecurityNative.WrapBuffer(out minorStatus' context' encrypt' buffer' offset' count' ref encryptedBuffer); " is 158.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,GssUnwrap,The length of the statement  "                Interop.NetSecurityNative.Status status = Interop.NetSecurityNative.UnwrapBuffer(out minorStatus' context' buffer' offset' count' ref decryptedBuffer); " is 151.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,GssInitSecurityContext,The length of the statement  "                if ((status != Interop.NetSecurityNative.Status.GSS_S_COMPLETE) && (status != Interop.NetSecurityNative.Status.GSS_S_CONTINUE_NEEDED)) " is 134.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,EstablishSecurityContext,The length of the statement  "                context = isNtlmOnly ? new SafeDeleteNegoContext(credential' credential.UserName) : new SafeDeleteNegoContext(credential' targetName); " is 134.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,EstablishSecurityContext,The length of the statement  "                Interop.NetSecurityNative.GssFlags inputFlags = ContextFlagsAdapterPal.GetInteropFromContextFlagsPal(inFlags' isServer: false); " is 127.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,EstablishSecurityContext,The length of the statement  "                outFlags = ContextFlagsAdapterPal.GetContextFlagsPalFromInterop((Interop.NetSecurityNative.GssFlags)outputFlags' isServer: false); " is 130.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,EstablishSecurityContext,The length of the statement  "                    (negoContext.IsNtlmUsed && outputBuffer.size > 0 ? SecurityStatusPalErrorCode.OK : SecurityStatusPalErrorCode.CompleteNeeded) : " is 127.
Long Statement,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,CreateExceptionFromError,The length of the statement  "            return new Win32Exception(NTE_FAIL' (statusCode.Exception != null) ? statusCode.Exception.Message : statusCode.ErrorCode.ToString()); " is 133.
Long Statement,Microsoft.Win32.SafeHandles,SafeGssCredHandle,C:\selectedRepos\dotnet_corefx\src\Common\src\Microsoft\Win32\SafeHandles\GssSafeHandles.cs,Create,The length of the statement  "                    status = Interop.NetSecurityNative.InitiateCredWithPassword(out minorStatus' isNtlmOnly' userHandle' password' Encoding.UTF8.GetByteCount(password)' out retHandle); " is 164.
Complex Conditional,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SqlMetaDataToSmiExtendedMetaData,The conditional expression  "(!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length)"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SmiMetaDataFromSchemaTableRow,The conditional expression  "precision < SmiMetaData.MinPrecision ||                              precision > SqlDecimal.MaxPrecision ||                              scale < SmiMetaData.MinScale ||                              scale > SqlDecimal.MaxScale ||                              scale > precision"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetBytes,The conditional expression  "(SmiMetaData.UnlimitedMaxLengthIndicator != metaData.MaxLength &&                      (SqlDbType.VarChar == metaData.SqlDbType ||                       SqlDbType.NVarChar == metaData.SqlDbType ||                       SqlDbType.Char == metaData.SqlDbType ||                       SqlDbType.NChar == metaData.SqlDbType)) ||                      SqlDbType.Xml == metaData.SqlDbType"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes_FromRecord,The conditional expression  "(length < 0 || lengthWritten < length) &&                      0 != (bytesRead = record.GetBytes(ordinal' currentOffset' buffer' 0' chunkSize)) &&                      0 != bytesWritten"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetBytes_FromReader,The conditional expression  "(length < 0 || lengthWritten < length) &&                      0 != (bytesRead = reader.GetBytes(ordinal' currentOffset' buffer' 0' chunkSize)) &&                      0 != bytesWritten"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars_FromRecord,The conditional expression  "(length < 0 || lengthWritten < length) &&                      0 != (charsRead = record.GetChars(ordinal' currentOffset' buffer' 0' chunkSize)) &&                      0 != charsWritten"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetChars_FromReader,The conditional expression  "(length < 0 || lengthWritten < length) &&                      0 != (charsRead = reader.GetChars(ordinal' currentOffset' buffer' 0' chunkSize)) &&                      0 != charsWritten"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CanAccessGetterDirectly,The conditional expression  "returnValue &&                     (ExtendedClrTypeCode.DataTable == setterTypeCode ||                      ExtendedClrTypeCode.DbDataReader == setterTypeCode ||                      ExtendedClrTypeCode.IEnumerableOfSqlDataRecord == setterTypeCode)"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,CanAccessSetterDirectly,The conditional expression  "returnValue &&                     (ExtendedClrTypeCode.DataTable == setterTypeCode ||                      ExtendedClrTypeCode.DbDataReader == setterTypeCode ||                      ExtendedClrTypeCode.IEnumerableOfSqlDataRecord == setterTypeCode)"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlBytes_Unchecked,The conditional expression  "(length < 0 || lengthWritten < length) &&                          0 != (bytesRead = value.Read(currentOffset' buffer' 0' chunkSize)) &&                          0 != bytesWritten"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,SetSqlChars_Unchecked,The conditional expression  "(length < 0 || lengthWritten < length) &&                          0 != (charsRead = value.Read(currentOffset' buffer' 0' chunkSize)) &&                          0 != charsWritten"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Construct,The conditional expression  "!(SqlDbType.BigInt == dbType ||                      SqlDbType.Bit == dbType ||                      SqlDbType.DateTime == dbType ||                      SqlDbType.Date == dbType ||                      SqlDbType.DateTime2 == dbType ||                      SqlDbType.DateTimeOffset == dbType ||                      SqlDbType.Decimal == dbType ||                      SqlDbType.Float == dbType ||                      SqlDbType.Image == dbType ||                      SqlDbType.Int == dbType ||                      SqlDbType.Money == dbType ||                      SqlDbType.NText == dbType ||                      SqlDbType.Real == dbType ||                      SqlDbType.SmallDateTime == dbType ||                      SqlDbType.SmallInt == dbType ||                      SqlDbType.SmallMoney == dbType ||                      SqlDbType.Text == dbType ||                      SqlDbType.Time == dbType ||                      SqlDbType.Timestamp == dbType ||                      SqlDbType.TinyInt == dbType ||                      SqlDbType.UniqueIdentifier == dbType ||                      SqlDbType.Variant == dbType ||                      SqlDbType.Xml == dbType)"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Adjust,The conditional expression  "SqlDbType.VarChar != SqlDbType &&                       SqlDbType.NVarChar != SqlDbType &&                       SqlDbType.Text != SqlDbType &&                       SqlDbType.NText != SqlDbType"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Adjust,The conditional expression  "SqlDbType.VarChar != SqlDbType && SqlDbType.NVarChar != SqlDbType &&                      SqlDbType.Text != SqlDbType && SqlDbType.NText != SqlDbType"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Adjust,The conditional expression  "SqlDbType.VarChar != SqlDbType && SqlDbType.NVarChar != SqlDbType &&                      SqlDbType.Text != SqlDbType && SqlDbType.NText != SqlDbType"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Adjust,The conditional expression  "(1 > MaxLength) ||  // char must have max length of at least 1                      (SqlDbType.VarChar != SqlDbType && SqlDbType.NVarChar != SqlDbType &&                      SqlDbType.Text != SqlDbType && SqlDbType.NText != SqlDbType)"  is complex.
Complex Conditional,Microsoft.SqlServer.Server,SqlMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlMetaData.cs,Adjust,The conditional expression  "SqlDbType.VarChar != SqlDbType && SqlDbType.NVarChar != SqlDbType &&                      SqlDbType.Text != SqlDbType && SqlDbType.NText != SqlDbType"  is complex.
Complex Conditional,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,AnalyzeTargetAndCreateUpdateBulkCommand,The conditional expression  "isInTransaction && null == _externalTransaction && null == _internalTransaction && (_connection.Parser != null && _connection.Parser.CurrentTransaction != null && _connection.Parser.CurrentTransaction.IsLocal)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetColumnMetadata,The conditional expression  "((_SqlDataReaderRowSource != null) || (_dataTableSource != null)) && ((metadata.metaType.NullableType == TdsEnums.SQLDECIMALN) || (metadata.metaType.NullableType == TdsEnums.SQLNUMERICN))"  is complex.
Complex Conditional,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetColumnMetadata,The conditional expression  "(metadata.type == SqlDbType.VarBinary) && (mtSource.IsBinType) && (mtSource.SqlDbType != SqlDbType.Timestamp) && _SqlDataReaderRowSource.IsCommandBehavior(CommandBehavior.SequentialAccess)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,GetColumnMetadata,The conditional expression  "((metadata.type == SqlDbType.VarChar) || (metadata.type == SqlDbType.NVarChar)) && (mtSource.IsCharType) && (mtSource.SqlDbType != SqlDbType.Xml)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlBulkCopyColumnMappingCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopyColumnMappingCollection.cs,Add,The conditional expression  "((string.IsNullOrEmpty(bulkCopyColumnMapping.SourceColumn)) && (bulkCopyColumnMapping.SourceOrdinal == -1))                  || ((string.IsNullOrEmpty(bulkCopyColumnMapping.DestinationColumn)) && (bulkCopyColumnMapping.DestinationOrdinal == -1))"  is complex.
Complex Conditional,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,Prepare,The conditional expression  "this.IsPrepared && !this.IsDirty                  || (this.CommandType == CommandType.StoredProcedure)                  || (                          (System.Data.CommandType.Text == this.CommandType)                          && (0 == GetParameterCount(_parameters))                      )"  is complex.
Complex Conditional,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The conditional expression  "0 == size &&                                  (p.SqlDbType == SqlDbType.NVarChar ||                                   p.SqlDbType == SqlDbType.VarBinary ||                                   p.SqlDbType == SqlDbType.VarChar)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,RunExecuteReader,The conditional expression  "(!this.IsDirty && this.IsPrepared && !_hiddenPrepare)                      || (this.IsPrepared && _execType == EXECTYPE.PREPAREPENDING)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildParamList,The conditional expression  "!mt.IsFixed && !mt.IsLong && mt.SqlDbType != SqlDbType.Timestamp && mt.SqlDbType != SqlDbType.Udt && SqlDbType.Structured != mt.SqlDbType"  is complex.
Complex Conditional,System.Data.SqlClient,SqlCommandBuilder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommandBuilder.cs,ConsistentQuoteDelimiters,The conditional expression  "(("\"" == quotePrefix) && ("\"" != quoteSuffix)) ||                  (("[" == quotePrefix) && ("]" != quoteSuffix))"  is complex.
Complex Conditional,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryCloseInternal,The conditional expression  "(!_isClosed) && (parser != null) && (stateObj != null) && (stateObj._pendingData)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryConsumeMetaData,The conditional expression  "_parser != null && _stateObj != null && _stateObj._pendingData && !_metaDataConsumed"  is complex.
Complex Conditional,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetChars,The conditional expression  "(_sharedState._nextColumnDataToRead == (i + 1)) && (_sharedState._nextColumnHeaderToRead == (i + 1)) && (_columnDataChars != null) && (IsCommandBehavior(CommandBehavior.SequentialAccess)) && (dataIndex < _columnDataCharsRead)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryHasMoreRows,The conditional expression  "b == TdsEnums.SQLDONE ||                              b == TdsEnums.SQLDONEPROC ||                              b == TdsEnums.SQLDONEINPROC ||                              !ParsedDoneToken && (                                  b == TdsEnums.SQLSESSIONSTATE ||                                  b == TdsEnums.SQLENVCHANGE ||                                  b == TdsEnums.SQLORDER ||                                  b == TdsEnums.SQLERROR ||                                  b == TdsEnums.SQLINFO)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,WillHaveEnoughData,The conditional expression  "(metaType.IsLong) || (metaType.IsPlp) || (metaType.SqlDbType == SqlDbType.Udt) || (metaType.SqlDbType == SqlDbType.Structured)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,CheckDataIsReady,The conditional expression  "(IsCommandBehavior(CommandBehavior.SequentialAccess)) &&                                    // Only for sequential access                  ((_sharedState._nextColumnDataToRead > columnIndex) || (_lastColumnWithDataChunkRead > columnIndex) ||   // Read past column                  ((!allowPartiallyReadColumn) && (_lastColumnWithDataChunkRead == columnIndex)) ||           // Partially read column                  ((allowPartiallyReadColumn) && (HasActiveStreamOrTextReaderOnColumn(columnIndex))))"  is complex.
Complex Conditional,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,GetFieldValueAsync,The conditional expression  "(!IsCommandBehavior(CommandBehavior.SequentialAccess)) && (_sharedState._nextColumnDataToRead > i) && (!cancellationToken.IsCancellationRequested) && (_currentTask == null)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,SqlInternalConnectionTds,The conditional expression  "i + 1 == connectionEstablishCount                              || !applyTransientFaultHandling                              || timeout.IsExpired                              || timeout.MillisecondsRemaining < transientRetryIntervalInMilliSeconds                              || !IsTransientError(sqlex)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The conditional expression  "null == _parser                              || TdsParserState.Closed != _parser.State                              || IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired"  is complex.
Complex Conditional,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The conditional expression  "(providerDbtype == null) ||                  (columnSize == null) ||                  (isFixedLength == null) ||                  (isSearchable == null) ||                  (isLiteralSupported == null) ||                  (typeName == null) ||                  (isNullable == null)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The conditional expression  "(values[assemblyNameIndex] != DBNull.Value) &&                          (values[assemblyClassIndex] != DBNull.Value) &&                          (values[versionMajorIndex] != DBNull.Value) &&                          (values[versionMinorIndex] != DBNull.Value) &&                          (values[versionBuildIndex] != DBNull.Value) &&                          (values[versionRevisionIndex] != DBNull.Value)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,AddTVPsToDataTypesTable,The conditional expression  "(providerDbtype == null) ||                  (columnSize == null) ||                  (isSearchable == null) ||                  (isLiteralSupported == null) ||                  (typeName == null) ||                  (isNullable == null)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The conditional expression  "(maxLen > MSS.SmiMetaData.MaxBinaryLength && (SqlDbType.Binary == mt.SqlDbType || SqlDbType.VarBinary == mt.SqlDbType))                    || (maxLen > MSS.SmiMetaData.MaxANSICharacters && (SqlDbType.Char == mt.SqlDbType || SqlDbType.VarChar == mt.SqlDbType))                    || (maxLen > MSS.SmiMetaData.MaxUnicodeCharacters && (SqlDbType.NChar == mt.SqlDbType || SqlDbType.NVarChar == mt.SqlDbType))"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The conditional expression  "(!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,CoerceValue,The conditional expression  "(typeof(object) != destinationType.ClassType) &&                      (currentType != destinationType.ClassType) &&                      ((currentType != destinationType.SqlType) || (SqlDbType.Xml == destinationType.SqlDbType))"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,CoerceValue,The conditional expression  "TdsEnums.SQLTABLE == destinationType.TDSType && (                                  value is DataTable ||                                  value is DbDataReader ||                                  value is System.Collections.Generic.IEnumerable<SqlDataRecord>)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,Validate,The conditional expression  "ADP.IsDirection(this' ParameterDirection.Output) &&                  !ADP.IsDirection(this' ParameterDirection.ReturnValue) &&                  (!metaType.IsFixed) &&                  !ShouldSerializeSize() &&                  ((null == _value) || Convert.IsDBNull(_value)) &&                  (SqlDbType != SqlDbType.Timestamp) &&                  (SqlDbType != SqlDbType.Udt) &&                  (SqlDbType != SqlDbType.Xml) &&                  !metaType.IsVarTime"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ValidateTypeLengths,The conditional expression  "(maxSizeInBytes > TdsEnums.TYPE_SIZE_LIMIT) || (_coercedValueIsDataFeed) ||                      (sizeInCharacters == -1) || (actualSizeInBytes == -1)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The conditional expression  "(ParameterDirection.Input != p.Direction) || p.IsNullable                      || p.ShouldSerializePrecision() || p.ShouldSerializeScale()                      || (DataRowVersion.Current != p.SourceVersion)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The conditional expression  "p.SourceColumnNullMapping || !string.IsNullOrEmpty(p.XmlSchemaCollectionDatabase) ||                      !string.IsNullOrEmpty(p.XmlSchemaCollectionOwningSchema) || !string.IsNullOrEmpty(p.XmlSchemaCollectionName)"  is complex.
Complex Conditional,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,Dispose,The conditional expression  "disposing && _advanceReader && _reader != null && !_reader.IsClosed"  is complex.
Complex Conditional,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ThrowExceptionAndWarning,The conditional expression  "(_state == TdsParserState.OpenNotLoggedIn) && (_connHandler.ConnectionOptions.MultiSubnetFailover || _loginWithFailover) && (temp.Count == 1) && ((temp[0].Number == TdsEnums.TIMEOUT_EXPIRED) || (temp[0].Number == TdsEnums.SNI_WAIT_TIMEOUT))"  is complex.
Complex Conditional,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessDone,The conditional expression  "(TdsEnums.DONE_ERROR == (TdsEnums.DONE_ERROR & status)) && stateObj.ErrorCount == 0 &&                    stateObj._errorTokenReceived == false && (RunBehavior.Clean != (RunBehavior.Clean & run))"  is complex.
Complex Conditional,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The conditional expression  "((request == TdsEnums.TransactionManagerRequestType.Begin) || (request == TdsEnums.TransactionManagerRequestType.Propagate)) && ((transaction == null) || (transaction.TransactionId != _retainedTransactionId))"  is complex.
Complex Conditional,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The conditional expression  "(!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported)"  is complex.
Complex Conditional,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The conditional expression  "((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))"  is complex.
Complex Conditional,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The conditional expression  "_parser.State == TdsParserState.OpenLoggedIn &&                  !_bulkCopyOpperationInProgress && // ignore the condition checking for bulk copy                      _outBytesUsed == (_outputHeaderLen + BitConverter.ToInt32(_outBuff' _outputHeaderLen))                      && _outputPacketNumber == 1                  || _outBytesUsed == _outputHeaderLen                      && _outputPacketNumber == 1"  is complex.
Complex Conditional,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,UsersConnectionString,The conditional expression  "_hasPasswordKeyword && (forceHidePassword || (hidePassword && !HasPersistablePassword))"  is complex.
Complex Conditional,System.Data.ProviderBase,DbMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbMetaDataFactory.cs,GetParameterName,The conditional expression  "(parameterName == null) || (collectionName == null) || (restrictionName == null) || (restrictionNumber == null)"  is complex.
Complex Conditional,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The conditional expression  "daypart < MinDay || daypart > MaxDay || timepart < MinTime || timepart > MaxTime"  is complex.
Complex Conditional,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetPortByInstanceName,The conditional expression  "responsePacket == null || responsePacket.Length <= 3 || responsePacket[0] != SvrResp ||                  BitConverter.ToUInt16(responsePacket' 1) != responsePacket.Length - 3"  is complex.
Complex Conditional,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetDacPortByInstanceName,The conditional expression  "responsePacket == null || responsePacket.Length <= 4 || responsePacket[0] != SvrResp ||                  BitConverter.ToUInt16(responsePacket' 1) != RespSize || responsePacket[3] != ProtocolVersion"  is complex.
Virtual Method Call from Constructor,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TdsParserStateObject,The constructor "TdsParserStateObject" calls a virtual method "CreateSessionHandle".
Virtual Method Call from Constructor,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TdsParserStateObject,The constructor "TdsParserStateObject" calls a virtual method "IsFailedHandle".
Virtual Method Call from Constructor,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,SNIMarsConnection,The constructor "SNIMarsConnection" calls a virtual method "SetAsyncCallbacks".
Empty Catch Block,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,CancelIgnoreFailure,The method has an empty catch block.
Empty Catch Block,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,ValidateAndReconnect,The method has an empty catch block.
Empty Catch Block,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetCodePage,The method has an empty catch block.
Empty Catch Block,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetCodePage,The method has an empty catch block.
Empty Catch Block,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetCodePage,The method has an empty catch block.
Empty Catch Block,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ChangeNetworkPacketTimeout,The method has an empty catch block.
Magic Number,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,CreateTypeToExtendedTypeCodeMap,The following statement contains a magic number: int Count = 42;
Magic Number,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SqlMetaDataToSmiExtendedMetaData,The following statement contains a magic number: if (SqlDbType.Xml == source.SqlDbType)              {                  typeSpecificNamePart1 = source.XmlSchemaCollectionDatabase;                  typeSpecificNamePart2 = source.XmlSchemaCollectionOwningSchema;                  typeSpecificNamePart3 = source.XmlSchemaCollectionName;              }              else if (SqlDbType.Udt == source.SqlDbType)              {                  // Split the input name. UdtTypeName is specified as single 3 part name.                  // NOTE: ParseUdtTypeName throws if format is incorrect                  string typeName = source.ServerTypeName;                  if (null != typeName)                  {                      string[] names = SqlParameter.ParseTypeName(typeName' true /* isUdtTypeName */);                        if (1 == names.Length)                      {                          typeSpecificNamePart3 = names[0];                      }                      else if (2 == names.Length)                      {                          typeSpecificNamePart2 = names[0];                          typeSpecificNamePart3 = names[1];                      }                      else if (3 == names.Length)                      {                          typeSpecificNamePart1 = names[0];                          typeSpecificNamePart2 = names[1];                          typeSpecificNamePart3 = names[2];                      }                      else                      {                          throw ADP.ArgumentOutOfRange(nameof(typeName));                      }                        if ((!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length))                      {                          throw ADP.ArgumentOutOfRange(nameof(typeName));                      }                  }              }
Magic Number,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SqlMetaDataToSmiExtendedMetaData,The following statement contains a magic number: if (SqlDbType.Xml == source.SqlDbType)              {                  typeSpecificNamePart1 = source.XmlSchemaCollectionDatabase;                  typeSpecificNamePart2 = source.XmlSchemaCollectionOwningSchema;                  typeSpecificNamePart3 = source.XmlSchemaCollectionName;              }              else if (SqlDbType.Udt == source.SqlDbType)              {                  // Split the input name. UdtTypeName is specified as single 3 part name.                  // NOTE: ParseUdtTypeName throws if format is incorrect                  string typeName = source.ServerTypeName;                  if (null != typeName)                  {                      string[] names = SqlParameter.ParseTypeName(typeName' true /* isUdtTypeName */);                        if (1 == names.Length)                      {                          typeSpecificNamePart3 = names[0];                      }                      else if (2 == names.Length)                      {                          typeSpecificNamePart2 = names[0];                          typeSpecificNamePart3 = names[1];                      }                      else if (3 == names.Length)                      {                          typeSpecificNamePart1 = names[0];                          typeSpecificNamePart2 = names[1];                          typeSpecificNamePart3 = names[2];                      }                      else                      {                          throw ADP.ArgumentOutOfRange(nameof(typeName));                      }                        if ((!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length))                      {                          throw ADP.ArgumentOutOfRange(nameof(typeName));                      }                  }              }
Magic Number,Microsoft.SqlServer.Server,MetaDataUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\MetadataUtilsSmi.cs,SqlMetaDataToSmiExtendedMetaData,The following statement contains a magic number: if (SqlDbType.Xml == source.SqlDbType)              {                  typeSpecificNamePart1 = source.XmlSchemaCollectionDatabase;                  typeSpecificNamePart2 = source.XmlSchemaCollectionOwningSchema;                  typeSpecificNamePart3 = source.XmlSchemaCollectionName;              }              else if (SqlDbType.Udt == source.SqlDbType)              {                  // Split the input name. UdtTypeName is specified as single 3 part name.                  // NOTE: ParseUdtTypeName throws if format is incorrect                  string typeName = source.ServerTypeName;                  if (null != typeName)                  {                      string[] names = SqlParameter.ParseTypeName(typeName' true /* isUdtTypeName */);                        if (1 == names.Length)                      {                          typeSpecificNamePart3 = names[0];                      }                      else if (2 == names.Length)                      {                          typeSpecificNamePart2 = names[0];                          typeSpecificNamePart3 = names[1];                      }                      else if (3 == names.Length)                      {                          typeSpecificNamePart1 = names[0];                          typeSpecificNamePart2 = names[1];                          typeSpecificNamePart3 = names[2];                      }                      else                      {                          throw ADP.ArgumentOutOfRange(nameof(typeName));                      }                        if ((!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                          || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length))                      {                          throw ADP.ArgumentOutOfRange(nameof(typeName));                      }                  }              }
Magic Number,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The following statement contains a magic number: switch (dbType)              {                  case SqlDbType.BigInt:                  case SqlDbType.Bit:                  case SqlDbType.DateTime:                  case SqlDbType.Float:                  case SqlDbType.Image:                  case SqlDbType.Int:                  case SqlDbType.Money:                  case SqlDbType.Real:                  case SqlDbType.SmallDateTime:                  case SqlDbType.SmallInt:                  case SqlDbType.SmallMoney:                  case SqlDbType.Timestamp:                  case SqlDbType.TinyInt:                  case SqlDbType.UniqueIdentifier:                  case SqlDbType.Variant:                  case SqlDbType.Xml:                  case SqlDbType.Date:                      break;                  case SqlDbType.Binary:                  case SqlDbType.VarBinary:                      _maxLength = maxLength;                      break;                  case SqlDbType.Char:                  case SqlDbType.NChar:                  case SqlDbType.NVarChar:                  case SqlDbType.VarChar:                      // locale and compare options are not validated until they get to the server                      _maxLength = maxLength;                      _localeId = localeId;                      _compareOptions = compareOptions;                      break;                  case SqlDbType.NText:                  case SqlDbType.Text:                      _localeId = localeId;                      _compareOptions = compareOptions;                      break;                  case SqlDbType.Decimal:                      Debug.Assert(MinPrecision <= precision && SqlDecimal.MaxPrecision >= precision' "Invalid precision: " + precision);                      Debug.Assert(MinScale <= scale && SqlDecimal.MaxScale >= scale' "Invalid scale: " + scale);                      Debug.Assert(scale <= precision' "Precision: " + precision + " greater than scale: " + scale);                      _precision = precision;                      _scale = scale;                      _maxLength = s_maxLenFromPrecision[precision - 1];                      break;                  case SqlDbType.Udt:                      // For SqlParameter' both userDefinedType and udtAssemblyQualifiedName can be NULL'                      // so we are checking only maxLength if it will be used (i.e. userDefinedType is NULL)                      Debug.Assert((null != userDefinedType) || (0 <= maxLength || UnlimitedMaxLengthIndicator == maxLength)'                              string.Format(null' "SmiMetaData.ctor: Udt name={0}' maxLength={1}"' udtAssemblyQualifiedName' maxLength));                      // Type not validated until matched to a server.  Could be null if extended metadata supplies three-part name!                      _clrType = userDefinedType;                      if (null != userDefinedType)                      {                          _maxLength = SerializationHelperSql9.GetUdtMaxLength(userDefinedType);                      }                      else                      {                          _maxLength = maxLength;                      }                      _udtAssemblyQualifiedName = udtAssemblyQualifiedName;                      break;                  case SqlDbType.Structured:                      if (null != fieldTypes)                      {                          _fieldMetaData = (new List<SmiExtendedMetaData>(fieldTypes)).AsReadOnly();                      }                      _isMultiValued = isMultiValued;                      _maxLength = _fieldMetaData.Count;                      break;                  case SqlDbType.Time:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 5 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  case SqlDbType.DateTime2:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 8 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  case SqlDbType.DateTimeOffset:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 10 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  default:                      Debug.Assert(false' "How in the world did we get here? :" + dbType);                      break;              }
Magic Number,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The following statement contains a magic number: switch (dbType)              {                  case SqlDbType.BigInt:                  case SqlDbType.Bit:                  case SqlDbType.DateTime:                  case SqlDbType.Float:                  case SqlDbType.Image:                  case SqlDbType.Int:                  case SqlDbType.Money:                  case SqlDbType.Real:                  case SqlDbType.SmallDateTime:                  case SqlDbType.SmallInt:                  case SqlDbType.SmallMoney:                  case SqlDbType.Timestamp:                  case SqlDbType.TinyInt:                  case SqlDbType.UniqueIdentifier:                  case SqlDbType.Variant:                  case SqlDbType.Xml:                  case SqlDbType.Date:                      break;                  case SqlDbType.Binary:                  case SqlDbType.VarBinary:                      _maxLength = maxLength;                      break;                  case SqlDbType.Char:                  case SqlDbType.NChar:                  case SqlDbType.NVarChar:                  case SqlDbType.VarChar:                      // locale and compare options are not validated until they get to the server                      _maxLength = maxLength;                      _localeId = localeId;                      _compareOptions = compareOptions;                      break;                  case SqlDbType.NText:                  case SqlDbType.Text:                      _localeId = localeId;                      _compareOptions = compareOptions;                      break;                  case SqlDbType.Decimal:                      Debug.Assert(MinPrecision <= precision && SqlDecimal.MaxPrecision >= precision' "Invalid precision: " + precision);                      Debug.Assert(MinScale <= scale && SqlDecimal.MaxScale >= scale' "Invalid scale: " + scale);                      Debug.Assert(scale <= precision' "Precision: " + precision + " greater than scale: " + scale);                      _precision = precision;                      _scale = scale;                      _maxLength = s_maxLenFromPrecision[precision - 1];                      break;                  case SqlDbType.Udt:                      // For SqlParameter' both userDefinedType and udtAssemblyQualifiedName can be NULL'                      // so we are checking only maxLength if it will be used (i.e. userDefinedType is NULL)                      Debug.Assert((null != userDefinedType) || (0 <= maxLength || UnlimitedMaxLengthIndicator == maxLength)'                              string.Format(null' "SmiMetaData.ctor: Udt name={0}' maxLength={1}"' udtAssemblyQualifiedName' maxLength));                      // Type not validated until matched to a server.  Could be null if extended metadata supplies three-part name!                      _clrType = userDefinedType;                      if (null != userDefinedType)                      {                          _maxLength = SerializationHelperSql9.GetUdtMaxLength(userDefinedType);                      }                      else                      {                          _maxLength = maxLength;                      }                      _udtAssemblyQualifiedName = udtAssemblyQualifiedName;                      break;                  case SqlDbType.Structured:                      if (null != fieldTypes)                      {                          _fieldMetaData = (new List<SmiExtendedMetaData>(fieldTypes)).AsReadOnly();                      }                      _isMultiValued = isMultiValued;                      _maxLength = _fieldMetaData.Count;                      break;                  case SqlDbType.Time:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 5 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  case SqlDbType.DateTime2:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 8 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  case SqlDbType.DateTimeOffset:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 10 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  default:                      Debug.Assert(false' "How in the world did we get here? :" + dbType);                      break;              }
Magic Number,Microsoft.SqlServer.Server,SmiMetaData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SmiMetaData.cs,SmiMetaData,The following statement contains a magic number: switch (dbType)              {                  case SqlDbType.BigInt:                  case SqlDbType.Bit:                  case SqlDbType.DateTime:                  case SqlDbType.Float:                  case SqlDbType.Image:                  case SqlDbType.Int:                  case SqlDbType.Money:                  case SqlDbType.Real:                  case SqlDbType.SmallDateTime:                  case SqlDbType.SmallInt:                  case SqlDbType.SmallMoney:                  case SqlDbType.Timestamp:                  case SqlDbType.TinyInt:                  case SqlDbType.UniqueIdentifier:                  case SqlDbType.Variant:                  case SqlDbType.Xml:                  case SqlDbType.Date:                      break;                  case SqlDbType.Binary:                  case SqlDbType.VarBinary:                      _maxLength = maxLength;                      break;                  case SqlDbType.Char:                  case SqlDbType.NChar:                  case SqlDbType.NVarChar:                  case SqlDbType.VarChar:                      // locale and compare options are not validated until they get to the server                      _maxLength = maxLength;                      _localeId = localeId;                      _compareOptions = compareOptions;                      break;                  case SqlDbType.NText:                  case SqlDbType.Text:                      _localeId = localeId;                      _compareOptions = compareOptions;                      break;                  case SqlDbType.Decimal:                      Debug.Assert(MinPrecision <= precision && SqlDecimal.MaxPrecision >= precision' "Invalid precision: " + precision);                      Debug.Assert(MinScale <= scale && SqlDecimal.MaxScale >= scale' "Invalid scale: " + scale);                      Debug.Assert(scale <= precision' "Precision: " + precision + " greater than scale: " + scale);                      _precision = precision;                      _scale = scale;                      _maxLength = s_maxLenFromPrecision[precision - 1];                      break;                  case SqlDbType.Udt:                      // For SqlParameter' both userDefinedType and udtAssemblyQualifiedName can be NULL'                      // so we are checking only maxLength if it will be used (i.e. userDefinedType is NULL)                      Debug.Assert((null != userDefinedType) || (0 <= maxLength || UnlimitedMaxLengthIndicator == maxLength)'                              string.Format(null' "SmiMetaData.ctor: Udt name={0}' maxLength={1}"' udtAssemblyQualifiedName' maxLength));                      // Type not validated until matched to a server.  Could be null if extended metadata supplies three-part name!                      _clrType = userDefinedType;                      if (null != userDefinedType)                      {                          _maxLength = SerializationHelperSql9.GetUdtMaxLength(userDefinedType);                      }                      else                      {                          _maxLength = maxLength;                      }                      _udtAssemblyQualifiedName = udtAssemblyQualifiedName;                      break;                  case SqlDbType.Structured:                      if (null != fieldTypes)                      {                          _fieldMetaData = (new List<SmiExtendedMetaData>(fieldTypes)).AsReadOnly();                      }                      _isMultiValued = isMultiValued;                      _maxLength = _fieldMetaData.Count;                      break;                  case SqlDbType.Time:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 5 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  case SqlDbType.DateTime2:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 8 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  case SqlDbType.DateTimeOffset:                      Debug.Assert(MinScale <= scale && scale <= MaxTimeScale' "Invalid time scale: " + scale);                      _scale = scale;                      _maxLength = 10 - s_maxVarTimeLenOffsetFromScale[scale];                      break;                  default:                      Debug.Assert(false' "How in the world did we get here? :" + dbType);                      break;              }
Magic Number,Microsoft.SqlServer.Server,SqlRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlRecordBuffer.cs,SetBytes,The following statement contains a magic number: if (IsNull || StorageType.ByteArray != _type)              {                  if (ndataIndex != 0)                  {    // set the first time: should start from the beginning                      throw ADP.ArgumentOutOfRange(nameof(fieldOffset));                  }                  _object = new byte[length];                  _type = StorageType.ByteArray;                  _isNull = false;                  BytesLength = length;              }              else              {                  if (ndataIndex > BytesLength)                  {    // no gap is allowed                      throw ADP.ArgumentOutOfRange(nameof(fieldOffset));                  }                  if (ndataIndex + length > BytesLength)                  {    // beyond the current length                      int cbytes = ((byte[])_object).Length;                        if (ndataIndex + length > cbytes)                      {    // dynamic expansion                          byte[] data = new byte[Math.Max(ndataIndex + length' 2 * cbytes)];                          Buffer.BlockCopy((byte[])_object' 0' data' 0' (int)BytesLength);                          _object = data;                      }                      BytesLength = ndataIndex + length;                  }              }
Magic Number,Microsoft.SqlServer.Server,SqlRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlRecordBuffer.cs,SetChars,The following statement contains a magic number: if (IsNull || (StorageType.CharArray != _type && StorageType.String != _type))              {                  if (ndataIndex != 0)                  {    // set the first time: should start from the beginning                      throw ADP.ArgumentOutOfRange(nameof(fieldOffset));                  }                  _object = new char[length];                  _type = StorageType.CharArray;                  _isNull = false;                  CharsLength = length;              }              else              {                  if (ndataIndex > CharsLength)                  {    // no gap is allowed                      throw ADP.ArgumentOutOfRange(nameof(fieldOffset));                  }                  if (StorageType.String == _type)                  {    // convert string to char[]                      _object = ((string)_object).ToCharArray();                      _type = StorageType.CharArray;                  }                  if (ndataIndex + length > CharsLength)                  {    // beyond the current length                      int cchars = ((char[])_object).Length;                        if (ndataIndex + length > cchars)                      {    // dynamic expansion                          char[] data = new char[Math.Max(ndataIndex + length' 2 * cchars)];                          Debug.Assert(CharsLength < Int32.MaxValue);                          Array.Copy((char[])_object' 0' data' 0' (int)CharsLength);                          _object = data;                      }                      CharsLength = ndataIndex + length;                  }              }
Magic Number,Microsoft.SqlServer.Server,SqlRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlRecordBuffer.cs,ConvertXmlStringToByteArray,The following statement contains a magic number: byte[] bytes = new byte[2 + System.Text.Encoding.Unicode.GetByteCount(value)];
Magic Number,Microsoft.SqlServer.Server,SqlRecordBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\SqlRecordBuffer.cs,ConvertXmlStringToByteArray,The following statement contains a magic number: System.Text.Encoding.Unicode.GetBytes(value' 0' value.Length' bytes' 2);
Magic Number,Microsoft.SqlServer.Server,ShortNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[2];
Magic Number,Microsoft.SqlServer.Server,UShortNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[2];
Magic Number,Microsoft.SqlServer.Server,IntNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[4];
Magic Number,Microsoft.SqlServer.Server,UIntNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[4];
Magic Number,Microsoft.SqlServer.Server,LongNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[8];
Magic Number,Microsoft.SqlServer.Server,ULongNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[8];
Magic Number,Microsoft.SqlServer.Server,FloatNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[4];
Magic Number,Microsoft.SqlServer.Server,DoubleNormalizer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Sql\SqlNorm.cs,DeNormalize,The following statement contains a magic number: byte[] b = new byte[8];
Magic Number,System.Data.SqlClient,SqlDbColumn,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDbColumn.cs,Populate,The following statement contains a magic number: ColumnSize = (_metadata.metaType.IsSizeInCharacters && (_metadata.length != 0x7fffffff)) ? (_metadata.length / 2) : _metadata.length;
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDecimal,The following statement contains a magic number: _value._numericInfo.data3 = bits[2];
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDecimal,The following statement contains a magic number: _value._numericInfo.data4 = bits[3];
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTime2,The following statement contains a magic number: FillInTimeInfo(ref _value._dateTime2Info.timeInfo' bytes' length - 3' scale);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTime2,The following statement contains a magic number: _value._dateTime2Info.date = GetDateFromByteArray(bytes' length - 3);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTimeOffset,The following statement contains a magic number: FillInTimeInfo(ref _value._dateTimeOffsetInfo.dateTime2Info.timeInfo' bytes' length - 5' scale);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTimeOffset,The following statement contains a magic number: _value._dateTimeOffsetInfo.dateTime2Info.date = GetDateFromByteArray(bytes' length - 5);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTimeOffset,The following statement contains a magic number: _value._dateTimeOffsetInfo.offset = (Int16)(bytes[length - 2] + (bytes[length - 1] << 8));
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,SetToDateTimeOffset,The following statement contains a magic number: _value._dateTimeOffsetInfo.offset = (Int16)(bytes[length - 2] + (bytes[length - 1] << 8));
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: Debug.Assert(3 <= length && length <= 5' "invalid data length for timeInfo: " + length);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: Debug.Assert(3 <= length && length <= 5' "invalid data length for timeInfo: " + length);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: Debug.Assert(0 <= scale && scale <= 7' "invalid scale: " + scale);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: Int64 tickUnits = (Int64)timeBytes[0] + ((Int64)timeBytes[1] << 8) + ((Int64)timeBytes[2] << 16);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: Int64 tickUnits = (Int64)timeBytes[0] + ((Int64)timeBytes[1] << 8) + ((Int64)timeBytes[2] << 16);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: Int64 tickUnits = (Int64)timeBytes[0] + ((Int64)timeBytes[1] << 8) + ((Int64)timeBytes[2] << 16);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: if (length > 3)              {                  tickUnits += ((Int64)timeBytes[3] << 24);              }
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: if (length > 3)              {                  tickUnits += ((Int64)timeBytes[3] << 24);              }
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: if (length > 3)              {                  tickUnits += ((Int64)timeBytes[3] << 24);              }
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: if (length > 4)              {                  tickUnits += ((Int64)timeBytes[4] << 32);              }
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: if (length > 4)              {                  tickUnits += ((Int64)timeBytes[4] << 32);              }
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,FillInTimeInfo,The following statement contains a magic number: if (length > 4)              {                  tickUnits += ((Int64)timeBytes[4] << 32);              }
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,GetDateFromByteArray,The following statement contains a magic number: return buf[offset] + (buf[offset + 1] << 8) + (buf[offset + 2] << 16);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,GetDateFromByteArray,The following statement contains a magic number: return buf[offset] + (buf[offset + 1] << 8) + (buf[offset + 2] << 16);
Magic Number,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,GetDateFromByteArray,The following statement contains a magic number: return buf[offset] + (buf[offset + 1] << 8) + (buf[offset + 2] << 16);
Magic Number,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,AnalyzeTargetAndCreateUpdateBulkCommand,The following statement contains a magic number: for (int i = 0; i < metaDataSet.Length; i++)              {                  _SqlMetaData metadata = metaDataSet[i];                  rejectColumn = false;                    // Check for excluded types                  if ((metadata.type == SqlDbType.Timestamp)                      || ((metadata.isIdentity) && !IsCopyOption(SqlBulkCopyOptions.KeepIdentity)))                  {                      // Remove metadata for excluded columns                      metaDataSet[i] = null;                      rejectColumn = true;                      // We still need to find a matching column association                  }                    // Find out if this column is associated                  int assocId;                  for (assocId = 0; assocId < _localColumnMappings.Count; assocId++)                  {                      if ((_localColumnMappings[assocId]._destinationColumnOrdinal == metadata.ordinal) ||                          (UnquotedName(_localColumnMappings[assocId]._destinationColumnName) == metadata.column))                      {                          if (rejectColumn)                          {                              nrejected++; // Count matched columns only                              break;                          }                            _sortedColumnMappings.Add(new _ColumnMapping(_localColumnMappings[assocId]._internalSourceColumnOrdinal' metadata));                          nmatched++;                            if (nmatched > 1)                          {                              updateBulkCommandText.Append("' "); // A leading comma for all but the first one                          }                            // Some datatypes need special handling ...                          if (metadata.type == SqlDbType.Variant)                          {                              AppendColumnNameAndTypeName(updateBulkCommandText' metadata.column' "sql_variant");                          }                          else if (metadata.type == SqlDbType.Udt)                          {                              AppendColumnNameAndTypeName(updateBulkCommandText' metadata.column' "varbinary");                          }                          else                          {                              AppendColumnNameAndTypeName(updateBulkCommandText' metadata.column' metadata.type.ToString());                          }                            switch (metadata.metaType.NullableType)                          {                              case TdsEnums.SQLNUMERICN:                              case TdsEnums.SQLDECIMALN:                                  // Decimal and numeric need to include precision and scale                                  updateBulkCommandText.AppendFormat((IFormatProvider)null' "({0}'{1})"' metadata.precision' metadata.scale);                                  break;                              case TdsEnums.SQLUDT:                                  {                                      if (metadata.IsLargeUdt)                                      {                                          updateBulkCommandText.Append("(max)");                                      }                                      else                                      {                                          int size = metadata.length;                                          updateBulkCommandText.AppendFormat((IFormatProvider)null' "({0})"' size);                                      }                                      break;                                  }                              case TdsEnums.SQLTIME:                              case TdsEnums.SQLDATETIME2:                              case TdsEnums.SQLDATETIMEOFFSET:                                  // date' dateime2' and datetimeoffset need to include scale                                  updateBulkCommandText.AppendFormat((IFormatProvider)null' "({0})"' metadata.scale);                                  break;                              default:                                  {                                      // For non-long non-fixed types we need to add the Size                                      if (!metadata.metaType.IsFixed && !metadata.metaType.IsLong)                                      {                                          int size = metadata.length;                                          switch (metadata.metaType.NullableType)                                          {                                              case TdsEnums.SQLNCHAR:                                              case TdsEnums.SQLNVARCHAR:                                              case TdsEnums.SQLNTEXT:                                                  size /= 2;                                                  break;                                              default:                                                  break;                                          }                                          updateBulkCommandText.AppendFormat((IFormatProvider)null' "({0})"' size);                                      }                                      else if (metadata.metaType.IsPlp && metadata.metaType.SqlDbType != SqlDbType.Xml)                                      {                                          // Partial length column prefix (max)                                          updateBulkCommandText.Append("(max)");                                      }                                      break;                                  }                          }                            // Get collation for column i                          Result rowset = internalResults[CollationResultId];                          object rowvalue = rowset[i][CollationId];                            bool shouldSendCollation;                          switch (metadata.type)                          {                              case SqlDbType.Char:                              case SqlDbType.NChar:                              case SqlDbType.VarChar:                              case SqlDbType.NVarChar:                              case SqlDbType.Text:                              case SqlDbType.NText:                                  shouldSendCollation = true;                                  break;                                default:                                  shouldSendCollation = false;                                  break;                          }                            if (rowvalue != null && shouldSendCollation)                          {                              Debug.Assert(rowvalue is SqlString);                              SqlString collation_name = (SqlString)rowvalue;                              if (!collation_name.IsNull)                              {                                  updateBulkCommandText.Append(" COLLATE " + collation_name.Value);                                  // Compare collations only if the collation value was set on the metadata                                  if (null != _SqlDataReaderRowSource && metadata.collation != null)                                  {                                      // On SqlDataReader we can verify the sourcecolumn collation!                                      int sourceColumnId = _localColumnMappings[assocId]._internalSourceColumnOrdinal;                                      int destinationLcid = metadata.collation.LCID;                                      int sourceLcid = _SqlDataReaderRowSource.GetLocaleId(sourceColumnId);                                      if (sourceLcid != destinationLcid)                                      {                                          throw SQL.BulkLoadLcidMismatch(sourceLcid' _SqlDataReaderRowSource.GetName(sourceColumnId)' destinationLcid' metadata.column);                                      }                                  }                              }                          }                          break;                      }                  }                  if (assocId == _localColumnMappings.Count)                  {                      // Remove metadata for unmatched columns                      metaDataSet[i] = null;                  }              }
Magic Number,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,UnquotedName,The following statement contains a magic number: if (name[0] == '[')              {                  int l = name.Length;                  Debug.Assert(name[l - 1] == ']'' "Name starts with [ but does not end with ]");                  name = name.Substring(1' l - 2);              }
Magic Number,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,ConvertValue,The following statement contains a magic number: try              {                  MetaType mt;                  switch (type.NullableType)                  {                      case TdsEnums.SQLNUMERICN:                      case TdsEnums.SQLDECIMALN:                          mt = MetaType.GetMetaTypeFromSqlDbType(type.SqlDbType' false);                          value = SqlParameter.CoerceValue(value' mt' out coercedToDataFeed' out typeChanged' false);                            // Convert Source Decimal Precision and Scale to Destination Precision and Scale                          // Sql decimal data could get corrupted on insert if the scale of                          // the source and destination weren't the same. The BCP protocol' specifies the                          // scale of the incoming data in the insert statement' we just tell the server we                          // are inserting the same scale back.                          SqlDecimal sqlValue;                          if ((isSqlType) && (!typeChanged))                          {                              sqlValue = (SqlDecimal)value;                          }                          else                          {                              sqlValue = new SqlDecimal((Decimal)value);                          }                            if (sqlValue.Scale != metadata.scale)                          {                              sqlValue = TdsParser.AdjustSqlDecimalScale(sqlValue' metadata.scale);                          }                            if (sqlValue.Precision > metadata.precision)                          {                              try                              {                                  sqlValue = SqlDecimal.ConvertToPrecScale(sqlValue' metadata.precision' sqlValue.Scale);                              }                              catch (SqlTruncateException)                              {                                  throw SQL.BulkLoadCannotConvertValue(value.GetType()' mt' ADP.ParameterValueOutOfRange(sqlValue));                              }                          }                            // Perf: It is more efficient to write a SqlDecimal than a decimal since we need to break it into its 'bits' when writing                          value = sqlValue;                          isSqlType = true;                          typeChanged = false; // Setting this to false as SqlParameter.CoerceValue will only set it to true when converting to a CLR type                          break;                        case TdsEnums.SQLINTN:                      case TdsEnums.SQLFLTN:                      case TdsEnums.SQLFLT4:                      case TdsEnums.SQLFLT8:                      case TdsEnums.SQLMONEYN:                      case TdsEnums.SQLDATETIM4:                      case TdsEnums.SQLDATETIME:                      case TdsEnums.SQLDATETIMN:                      case TdsEnums.SQLBIT:                      case TdsEnums.SQLBITN:                      case TdsEnums.SQLUNIQUEID:                      case TdsEnums.SQLBIGBINARY:                      case TdsEnums.SQLBIGVARBINARY:                      case TdsEnums.SQLIMAGE:                      case TdsEnums.SQLBIGCHAR:                      case TdsEnums.SQLBIGVARCHAR:                      case TdsEnums.SQLTEXT:                      case TdsEnums.SQLDATE:                      case TdsEnums.SQLTIME:                      case TdsEnums.SQLDATETIME2:                      case TdsEnums.SQLDATETIMEOFFSET:                          mt = MetaType.GetMetaTypeFromSqlDbType(type.SqlDbType' false);                          value = SqlParameter.CoerceValue(value' mt' out coercedToDataFeed' out typeChanged' false);                          break;                      case TdsEnums.SQLNCHAR:                      case TdsEnums.SQLNVARCHAR:                      case TdsEnums.SQLNTEXT:                          mt = MetaType.GetMetaTypeFromSqlDbType(type.SqlDbType' false);                          value = SqlParameter.CoerceValue(value' mt' out coercedToDataFeed' out typeChanged' false);                          if (!coercedToDataFeed)                          {   // We do not need to test for TextDataFeed as it is only assigned to (N)VARCHAR(MAX)                              int len = ((isSqlType) && (!typeChanged)) ? ((SqlString)value).Value.Length : ((string)value).Length;                              if (len > metadata.length / 2)                              {                                  throw SQL.BulkLoadStringTooLong();                              }                          }                          break;                      case TdsEnums.SQLVARIANT:                          value = ValidateBulkCopyVariant(value);                          typeChanged = true;                          break;                      case TdsEnums.SQLUDT:                          // UDTs are sent as varbinary so we need to get the raw bytes                          // unlike other types the parser does not like SQLUDT in form of SqlType                          // so we cast to a CLR type.                            // Hack for type system version knob - only call GetBytes if the value is not already                          // in byte[] form.                          if (!(value is byte[]))                          {                              value = _connection.GetBytes(value);                              typeChanged = true;                          }                          break;                      case TdsEnums.SQLXMLTYPE:                          // Could be either string' SqlCachedBuffer' XmlReader or XmlDataFeed                          Debug.Assert((value is XmlReader) || (value is SqlCachedBuffer) || (value is string) || (value is SqlString) || (value is XmlDataFeed)' "Invalid value type of Xml datatype");                          if (value is XmlReader)                          {                              value = new XmlDataFeed((XmlReader)value);                              typeChanged = true;                              coercedToDataFeed = true;                          }                          break;                        default:                          Debug.Fail("Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                          throw SQL.BulkLoadCannotConvertValue(value.GetType()' metadata.metaType' null);                  }                    if (typeChanged)                  {                      // All type changes change to CLR types                      isSqlType = false;                  }                    return value;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                  throw SQL.BulkLoadCannotConvertValue(value.GetType()' metadata.metaType' e);              }
Magic Number,System.Data.SqlClient,SqlCachedBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCachedBuffer.cs,AddByteOrderMark,The following statement contains a magic number: if ((byteArr.Length < 2) || (byteArr[0] != 0xDF) || (byteArr[1] != 0xFF))              {                  Debug.Assert(cachedBytes.Count == 0);                  cachedBytes.Add(TdsEnums.XMLUNICODEBOMBYTES);              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,UnquoteProcedurePart,The following statement contains a magic number: if ((null != part) && (2 <= part.Length))              {                  if ('[' == part[0] && ']' == part[part.Length - 1])                  {                      part = part.Substring(1' part.Length - 2); // strip outer '[' & ']'                      part = part.Replace("]]"' "]"); // undo quoted "]" from "]]" to "]"                  }              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,UnquoteProcedurePart,The following statement contains a magic number: if ((null != part) && (2 <= part.Length))              {                  if ('[' == part[0] && ']' == part[part.Length - 1])                  {                      part = part.Substring(1' part.Length - 2); // strip outer '[' & ']'                      part = part.Replace("]]"' "]"); // undo quoted "]" from "]]" to "]"                  }              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: if (null == parsedSProc[3] || string.IsNullOrEmpty(parsedSProc[3]))              {                  throw ADP.NoStoredProcedureExists(CommandText);              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: if (null == parsedSProc[3] || string.IsNullOrEmpty(parsedSProc[3]))              {                  throw ADP.NoStoredProcedureExists(CommandText);              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: Debug.Assert(parsedSProc.Length == 4' "Invalid array length result from SqlCommandBuilder.ParseProcedureName");
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: paramsCmd.Parameters.Add(new SqlParameter("@procedure_name"' SqlDbType.NVarChar' 255));
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: paramsCmd.Parameters[0].Value = UnquoteProcedureName(parsedSProc[3]' out groupNumber);
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: if (!string.IsNullOrEmpty(parsedSProc[2]))              { // SchemaName is 3rd element in parsed array                  SqlParameter param = paramsCmd.Parameters.Add(new SqlParameter("@procedure_schema"' SqlDbType.NVarChar' 255));                  param.Value = UnquoteProcedurePart(parsedSProc[2]);              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: if (!string.IsNullOrEmpty(parsedSProc[2]))              { // SchemaName is 3rd element in parsed array                  SqlParameter param = paramsCmd.Parameters.Add(new SqlParameter("@procedure_schema"' SqlDbType.NVarChar' 255));                  param.Value = UnquoteProcedurePart(parsedSProc[2]);              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,DeriveParameters,The following statement contains a magic number: if (!string.IsNullOrEmpty(parsedSProc[2]))              { // SchemaName is 3rd element in parsed array                  SqlParameter param = paramsCmd.Parameters.Add(new SqlParameter("@procedure_schema"' SqlDbType.NVarChar' 255));                  param.Value = UnquoteProcedurePart(parsedSProc[2]);              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,ParameterDirectionFromOleDbDirection,The following statement contains a magic number: Debug.Assert(oledbDirection >= 1 && oledbDirection <= 4' "invalid parameter direction from params_rowset!");
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,ParameterDirectionFromOleDbDirection,The following statement contains a magic number: switch (oledbDirection)              {                  case 2:                      return ParameterDirection.InputOutput;                  case 3:                      return ParameterDirection.Output;                  case 4:                      return ParameterDirection.ReturnValue;                  default:                      return ParameterDirection.Input;              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,ParameterDirectionFromOleDbDirection,The following statement contains a magic number: switch (oledbDirection)              {                  case 2:                      return ParameterDirection.InputOutput;                  case 3:                      return ParameterDirection.Output;                  case 4:                      return ParameterDirection.ReturnValue;                  default:                      return ParameterDirection.Input;              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,ParameterDirectionFromOleDbDirection,The following statement contains a magic number: switch (oledbDirection)              {                  case 2:                      return ParameterDirection.InputOutput;                  case 3:                      return ParameterDirection.Output;                  case 4:                      return ParameterDirection.ReturnValue;                  default:                      return ParameterDirection.Input;              }
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildPrepExec,The following statement contains a magic number: int j = 3;
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildPrepExec,The following statement contains a magic number: rpc.parameters[2] = sqlParam;
Magic Number,System.Data.SqlClient,SqlCommand,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommand.cs,BuildExecuteSql,The following statement contains a magic number: if (cParams > 0)              {                  j = 2;              }              else              {                  j = 1;              }
Magic Number,System.Data.SqlClient,SqlCommandSet,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommandSet.cs,Append,The following statement contains a magic number: if (0 < collection.Count)              {                  parameters = new SqlParameterCollection();                    // clone parameters so they aren't destroyed                  for (int i = 0; i < collection.Count; ++i)                  {                      SqlParameter p = new SqlParameter();                      collection[i].CopyTo(p);                      parameters.Add(p);                        // SQL Injection awareness                      if (!s_sqlIdentifierParser.IsMatch(p.ParameterName))                      {                          throw ADP.BadParameterName(p.ParameterName);                      }                  }                    foreach (SqlParameter p in parameters)                  {                      // deep clone the parameter value if byte[] or char[]                      object obj = p.Value;                      byte[] byteValues = (obj as byte[]);                      if (null != byteValues)                      {                          int offset = p.Offset;                          int size = p.Size;                          int countOfBytes = byteValues.Length - offset;                          if ((0 != size) && (size < countOfBytes))                          {                              countOfBytes = size;                          }                          byte[] copy = new byte[Math.Max(countOfBytes' 0)];                          Buffer.BlockCopy(byteValues' offset' copy' 0' copy.Length);                          p.Offset = 0;                          p.Value = copy;                      }                      else                      {                          char[] charValues = (obj as char[]);                          if (null != charValues)                          {                              int offset = p.Offset;                              int size = p.Size;                              int countOfChars = charValues.Length - offset;                              if ((0 != size) && (size < countOfChars))                              {                                  countOfChars = size;                              }                              char[] copy = new char[Math.Max(countOfChars' 0)];                              Buffer.BlockCopy(charValues' offset' copy' 0' copy.Length * 2);                              p.Offset = 0;                              p.Value = copy;                          }                          else                          {                              ICloneable cloneable = (obj as ICloneable);                              if (null != cloneable)                              {                                  p.Value = cloneable.Clone();                              }                          }                      }                  }              }
Magic Number,System.Data.SqlClient,SqlCommandSet,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlCommandSet.cs,BuildStoredProcedureName,The following statement contains a magic number: if ((null != part) && (0 < part.Length))              {                  if ('[' == part[0])                  {                      int count = 0;                      foreach (char c in part)                      {                          if (']' == c)                          {                              count++;                          }                      }                      if (1 == (count % 2))                      {                          builder.Append(part);                          return;                      }                  }                    // the part is not escaped' escape it now                  SqlServerEscapeHelper.EscapeIdentifier(builder' part);              }
Magic Number,System.Data.SqlClient,SqlConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnection.cs,ReconnectAsync,The following statement contains a magic number: try              {                  long commandTimeoutExpiration = 0;                  if (timeout > 0)                  {                      commandTimeoutExpiration = ADP.TimerCurrent() + ADP.TimerFromSeconds(timeout);                  }                  CancellationTokenSource cts = new CancellationTokenSource();                  _reconnectionCancellationSource = cts;                  CancellationToken ctoken = cts.Token;                  int retryCount = _connectRetryCount; // take a snapshot: could be changed by modifying the connection string                  for (int attempt = 0; attempt < retryCount; attempt++)                  {                      if (ctoken.IsCancellationRequested)                      {                          return;                      }                      try                      {                          try                          {                              ForceNewConnection = true;                              await OpenAsync(ctoken).ConfigureAwait(false);                              // On success' increment the reconnect count - we don't really care if it rolls over since it is approx.                              _reconnectCount = unchecked(_reconnectCount + 1);  #if DEBUG                              Debug.Assert(_recoverySessionData._debugReconnectDataApplied' "Reconnect data was not applied !");  #endif                          }                          finally                          {                              ForceNewConnection = false;                          }                          return;                      }                      catch (SqlException e)                      {                          if (attempt == retryCount - 1)                          {                              throw SQL.CR_AllAttemptsFailed(e' _originalConnectionId);                          }                          if (timeout > 0 && ADP.TimerRemaining(commandTimeoutExpiration) < ADP.TimerFromSeconds(ConnectRetryInterval))                          {                              throw SQL.CR_NextAttemptWillExceedQueryTimeout(e' _originalConnectionId);                          }                      }                      await Task.Delay(1000 * ConnectRetryInterval' ctoken).ConfigureAwait(false);                  }              }              finally              {                  _recoverySessionData = null;                  _suppressStateChangeForReconnection = false;              }
Magic Number,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnectionPoolGroupOptions,The following statement contains a magic number: if (opt.Pooling)              {    // never pool context connections.                  int connectionTimeout = opt.ConnectTimeout;                    if ((0 < connectionTimeout) && (connectionTimeout < Int32.MaxValue / 1000))                      connectionTimeout *= 1000;                  else if (connectionTimeout >= Int32.MaxValue / 1000)                      connectionTimeout = Int32.MaxValue;                    poolingOptions = new DbConnectionPoolGroupOptions(                                                      opt.IntegratedSecurity'                                                      opt.MinPoolSize'                                                      opt.MaxPoolSize'                                                      connectionTimeout'                                                      opt.LoadBalanceTimeout'                                                      opt.Enlist);              }
Magic Number,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnectionPoolGroupOptions,The following statement contains a magic number: if (opt.Pooling)              {    // never pool context connections.                  int connectionTimeout = opt.ConnectTimeout;                    if ((0 < connectionTimeout) && (connectionTimeout < Int32.MaxValue / 1000))                      connectionTimeout *= 1000;                  else if (connectionTimeout >= Int32.MaxValue / 1000)                      connectionTimeout = Int32.MaxValue;                    poolingOptions = new DbConnectionPoolGroupOptions(                                                      opt.IntegratedSecurity'                                                      opt.MinPoolSize'                                                      opt.MaxPoolSize'                                                      connectionTimeout'                                                      opt.LoadBalanceTimeout'                                                      opt.Enlist);              }
Magic Number,System.Data.SqlClient,SqlConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionFactory.cs,CreateConnectionPoolGroupOptions,The following statement contains a magic number: if (opt.Pooling)              {    // never pool context connections.                  int connectionTimeout = opt.ConnectTimeout;                    if ((0 < connectionTimeout) && (connectionTimeout < Int32.MaxValue / 1000))                      connectionTimeout *= 1000;                  else if (connectionTimeout >= Int32.MaxValue / 1000)                      connectionTimeout = Int32.MaxValue;                    poolingOptions = new DbConnectionPoolGroupOptions(                                                      opt.IntegratedSecurity'                                                      opt.MinPoolSize'                                                      opt.MaxPoolSize'                                                      connectionTimeout'                                                      opt.LoadBalanceTimeout'                                                      opt.Enlist);              }
Magic Number,System.Data.SqlClient,SqlConnectionString,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionString.cs,SqlConnectionString,The following statement contains a magic number: if ((_connectRetryCount < 0) || (_connectRetryCount > 255))              {                  throw ADP.InvalidConnectRetryCountValue();              }
Magic Number,System.Data.SqlClient,SqlConnectionString,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlConnectionString.cs,SqlConnectionString,The following statement contains a magic number: if ((_connectRetryInterval < 1) || (_connectRetryInterval > 60))              {                  throw ADP.InvalidConnectRetryIntervalValue();              }
Magic Number,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The following statement contains a magic number: for (int i = 0; i < md.Length; i++)              {                  _SqlMetaData col = md[i];                  DataRow schemaRow = schemaTable.NewRow();                    schemaRow[columnName] = col.column;                  schemaRow[ordinal] = col.ordinal;                  //                  // be sure to return character count for string types' byte count otherwise                  // col.length is always byte count so for unicode types' half the length                  //                  // For MAX and XML datatypes' we get 0x7fffffff from the server. Do not divide this.                  schemaRow[size] = (col.metaType.IsSizeInCharacters && (col.length != 0x7fffffff)) ? (col.length / 2) : col.length;                    schemaRow[dataType] = GetFieldTypeInternal(col);                  schemaRow[providerSpecificDataType] = GetProviderSpecificFieldTypeInternal(col);                  schemaRow[nonVersionedProviderType] = (int)col.type; // SqlDbType enum value - does not change with TypeSystem.                  schemaRow[dataTypeName] = GetDataTypeNameInternal(col);                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[providerType] = SqlDbType.NVarChar;                      switch (col.type)                      {                          case SqlDbType.Date:                              schemaRow[size] = TdsEnums.WHIDBEY_DATE_LENGTH;                              break;                          case SqlDbType.Time:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for Time column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_TIME_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTime2:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTime2 column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIME2_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTimeOffset:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTimeOffset column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIMEOFFSET_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                      }                  }                  else if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsLargeUdt)                  {                      if (_typeSystem == SqlConnectionString.TypeSystem.SQLServer2005)                      {                          schemaRow[providerType] = SqlDbType.VarBinary;                      }                      else                      {                          // TypeSystem.SQLServer2000                          schemaRow[providerType] = SqlDbType.Image;                      }                  }                  else if (_typeSystem != SqlConnectionString.TypeSystem.SQLServer2000)                  {                      // TypeSystem.SQLServer2005 and above                        // SqlDbType enum value - always the actual type for SQLServer2005.                      schemaRow[providerType] = (int)col.type;                        if (col.type == SqlDbType.Udt)                      { // Additional metadata for UDTs.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid Column type received from the server");                          schemaRow[udtAssemblyQualifiedName] = col.udtAssemblyQualifiedName;                      }                      else if (col.type == SqlDbType.Xml)                      { // Additional metadata for Xml.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid DataType (Xml) for the column");                          schemaRow[xmlSchemaCollectionDatabase] = col.xmlSchemaCollectionDatabase;                          schemaRow[xmlSchemaCollectionOwningSchema] = col.xmlSchemaCollectionOwningSchema;                          schemaRow[xmlSchemaCollectionName] = col.xmlSchemaCollectionName;                      }                  }                  else                  {                      // TypeSystem.SQLServer2000                        // SqlDbType enum value - variable for certain types when SQLServer2000.                      schemaRow[providerType] = GetVersionedMetaType(col.metaType).SqlDbType;                  }                    if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.precision)                  {                      schemaRow[precision] = col.precision;                  }                  else                  {                      schemaRow[precision] = col.metaType.Precision;                  }                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[scale] = MetaType.MetaNVarChar.Scale;                  }                  else if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale)                  {                      schemaRow[scale] = col.scale;                  }                  else                  {                      schemaRow[scale] = col.metaType.Scale;                  }                    schemaRow[allowDBNull] = col.isNullable;                    // If no ColInfo token received' do not set value' leave as null.                  if (_browseModeInfoConsumed)                  {                      schemaRow[isAliased] = col.isDifferentName;                      schemaRow[isKey] = col.isKey;                      schemaRow[isHidden] = col.isHidden;                      schemaRow[isExpression] = col.isExpression;                  }                    schemaRow[isIdentity] = col.isIdentity;                  schemaRow[isAutoIncrement] = col.isIdentity;                    schemaRow[isLong] = col.metaType.IsLong;                    // mark unique for timestamp columns                  if (SqlDbType.Timestamp == col.type)                  {                      schemaRow[isUnique] = true;                      schemaRow[isRowVersion] = true;                  }                  else                  {                      schemaRow[isUnique] = false;                      schemaRow[isRowVersion] = false;                  }                    schemaRow[isReadOnly] = (0 == col.updatability);                  schemaRow[isColumnSet] = col.isColumnSet;                    if (!string.IsNullOrEmpty(col.serverName))                  {                      schemaRow[baseServerName] = col.serverName;                  }                  if (!string.IsNullOrEmpty(col.catalogName))                  {                      schemaRow[baseCatalogName] = col.catalogName;                  }                  if (!string.IsNullOrEmpty(col.schemaName))                  {                      schemaRow[baseSchemaName] = col.schemaName;                  }                  if (!string.IsNullOrEmpty(col.tableName))                  {                      schemaRow[baseTableName] = col.tableName;                  }                  if (!string.IsNullOrEmpty(col.baseColumn))                  {                      schemaRow[baseColumnName] = col.baseColumn;                  }                  else if (!string.IsNullOrEmpty(col.column))                  {                      schemaRow[baseColumnName] = col.column;                  }                    schemaTable.Rows.Add(schemaRow);                  schemaRow.AcceptChanges();              }
Magic Number,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The following statement contains a magic number: for (int i = 0; i < md.Length; i++)              {                  _SqlMetaData col = md[i];                  DataRow schemaRow = schemaTable.NewRow();                    schemaRow[columnName] = col.column;                  schemaRow[ordinal] = col.ordinal;                  //                  // be sure to return character count for string types' byte count otherwise                  // col.length is always byte count so for unicode types' half the length                  //                  // For MAX and XML datatypes' we get 0x7fffffff from the server. Do not divide this.                  schemaRow[size] = (col.metaType.IsSizeInCharacters && (col.length != 0x7fffffff)) ? (col.length / 2) : col.length;                    schemaRow[dataType] = GetFieldTypeInternal(col);                  schemaRow[providerSpecificDataType] = GetProviderSpecificFieldTypeInternal(col);                  schemaRow[nonVersionedProviderType] = (int)col.type; // SqlDbType enum value - does not change with TypeSystem.                  schemaRow[dataTypeName] = GetDataTypeNameInternal(col);                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[providerType] = SqlDbType.NVarChar;                      switch (col.type)                      {                          case SqlDbType.Date:                              schemaRow[size] = TdsEnums.WHIDBEY_DATE_LENGTH;                              break;                          case SqlDbType.Time:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for Time column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_TIME_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTime2:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTime2 column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIME2_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTimeOffset:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTimeOffset column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIMEOFFSET_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                      }                  }                  else if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsLargeUdt)                  {                      if (_typeSystem == SqlConnectionString.TypeSystem.SQLServer2005)                      {                          schemaRow[providerType] = SqlDbType.VarBinary;                      }                      else                      {                          // TypeSystem.SQLServer2000                          schemaRow[providerType] = SqlDbType.Image;                      }                  }                  else if (_typeSystem != SqlConnectionString.TypeSystem.SQLServer2000)                  {                      // TypeSystem.SQLServer2005 and above                        // SqlDbType enum value - always the actual type for SQLServer2005.                      schemaRow[providerType] = (int)col.type;                        if (col.type == SqlDbType.Udt)                      { // Additional metadata for UDTs.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid Column type received from the server");                          schemaRow[udtAssemblyQualifiedName] = col.udtAssemblyQualifiedName;                      }                      else if (col.type == SqlDbType.Xml)                      { // Additional metadata for Xml.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid DataType (Xml) for the column");                          schemaRow[xmlSchemaCollectionDatabase] = col.xmlSchemaCollectionDatabase;                          schemaRow[xmlSchemaCollectionOwningSchema] = col.xmlSchemaCollectionOwningSchema;                          schemaRow[xmlSchemaCollectionName] = col.xmlSchemaCollectionName;                      }                  }                  else                  {                      // TypeSystem.SQLServer2000                        // SqlDbType enum value - variable for certain types when SQLServer2000.                      schemaRow[providerType] = GetVersionedMetaType(col.metaType).SqlDbType;                  }                    if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.precision)                  {                      schemaRow[precision] = col.precision;                  }                  else                  {                      schemaRow[precision] = col.metaType.Precision;                  }                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[scale] = MetaType.MetaNVarChar.Scale;                  }                  else if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale)                  {                      schemaRow[scale] = col.scale;                  }                  else                  {                      schemaRow[scale] = col.metaType.Scale;                  }                    schemaRow[allowDBNull] = col.isNullable;                    // If no ColInfo token received' do not set value' leave as null.                  if (_browseModeInfoConsumed)                  {                      schemaRow[isAliased] = col.isDifferentName;                      schemaRow[isKey] = col.isKey;                      schemaRow[isHidden] = col.isHidden;                      schemaRow[isExpression] = col.isExpression;                  }                    schemaRow[isIdentity] = col.isIdentity;                  schemaRow[isAutoIncrement] = col.isIdentity;                    schemaRow[isLong] = col.metaType.IsLong;                    // mark unique for timestamp columns                  if (SqlDbType.Timestamp == col.type)                  {                      schemaRow[isUnique] = true;                      schemaRow[isRowVersion] = true;                  }                  else                  {                      schemaRow[isUnique] = false;                      schemaRow[isRowVersion] = false;                  }                    schemaRow[isReadOnly] = (0 == col.updatability);                  schemaRow[isColumnSet] = col.isColumnSet;                    if (!string.IsNullOrEmpty(col.serverName))                  {                      schemaRow[baseServerName] = col.serverName;                  }                  if (!string.IsNullOrEmpty(col.catalogName))                  {                      schemaRow[baseCatalogName] = col.catalogName;                  }                  if (!string.IsNullOrEmpty(col.schemaName))                  {                      schemaRow[baseSchemaName] = col.schemaName;                  }                  if (!string.IsNullOrEmpty(col.tableName))                  {                      schemaRow[baseTableName] = col.tableName;                  }                  if (!string.IsNullOrEmpty(col.baseColumn))                  {                      schemaRow[baseColumnName] = col.baseColumn;                  }                  else if (!string.IsNullOrEmpty(col.column))                  {                      schemaRow[baseColumnName] = col.column;                  }                    schemaTable.Rows.Add(schemaRow);                  schemaRow.AcceptChanges();              }
Magic Number,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The following statement contains a magic number: for (int i = 0; i < md.Length; i++)              {                  _SqlMetaData col = md[i];                  DataRow schemaRow = schemaTable.NewRow();                    schemaRow[columnName] = col.column;                  schemaRow[ordinal] = col.ordinal;                  //                  // be sure to return character count for string types' byte count otherwise                  // col.length is always byte count so for unicode types' half the length                  //                  // For MAX and XML datatypes' we get 0x7fffffff from the server. Do not divide this.                  schemaRow[size] = (col.metaType.IsSizeInCharacters && (col.length != 0x7fffffff)) ? (col.length / 2) : col.length;                    schemaRow[dataType] = GetFieldTypeInternal(col);                  schemaRow[providerSpecificDataType] = GetProviderSpecificFieldTypeInternal(col);                  schemaRow[nonVersionedProviderType] = (int)col.type; // SqlDbType enum value - does not change with TypeSystem.                  schemaRow[dataTypeName] = GetDataTypeNameInternal(col);                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[providerType] = SqlDbType.NVarChar;                      switch (col.type)                      {                          case SqlDbType.Date:                              schemaRow[size] = TdsEnums.WHIDBEY_DATE_LENGTH;                              break;                          case SqlDbType.Time:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for Time column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_TIME_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTime2:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTime2 column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIME2_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTimeOffset:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTimeOffset column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIMEOFFSET_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                      }                  }                  else if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsLargeUdt)                  {                      if (_typeSystem == SqlConnectionString.TypeSystem.SQLServer2005)                      {                          schemaRow[providerType] = SqlDbType.VarBinary;                      }                      else                      {                          // TypeSystem.SQLServer2000                          schemaRow[providerType] = SqlDbType.Image;                      }                  }                  else if (_typeSystem != SqlConnectionString.TypeSystem.SQLServer2000)                  {                      // TypeSystem.SQLServer2005 and above                        // SqlDbType enum value - always the actual type for SQLServer2005.                      schemaRow[providerType] = (int)col.type;                        if (col.type == SqlDbType.Udt)                      { // Additional metadata for UDTs.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid Column type received from the server");                          schemaRow[udtAssemblyQualifiedName] = col.udtAssemblyQualifiedName;                      }                      else if (col.type == SqlDbType.Xml)                      { // Additional metadata for Xml.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid DataType (Xml) for the column");                          schemaRow[xmlSchemaCollectionDatabase] = col.xmlSchemaCollectionDatabase;                          schemaRow[xmlSchemaCollectionOwningSchema] = col.xmlSchemaCollectionOwningSchema;                          schemaRow[xmlSchemaCollectionName] = col.xmlSchemaCollectionName;                      }                  }                  else                  {                      // TypeSystem.SQLServer2000                        // SqlDbType enum value - variable for certain types when SQLServer2000.                      schemaRow[providerType] = GetVersionedMetaType(col.metaType).SqlDbType;                  }                    if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.precision)                  {                      schemaRow[precision] = col.precision;                  }                  else                  {                      schemaRow[precision] = col.metaType.Precision;                  }                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[scale] = MetaType.MetaNVarChar.Scale;                  }                  else if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale)                  {                      schemaRow[scale] = col.scale;                  }                  else                  {                      schemaRow[scale] = col.metaType.Scale;                  }                    schemaRow[allowDBNull] = col.isNullable;                    // If no ColInfo token received' do not set value' leave as null.                  if (_browseModeInfoConsumed)                  {                      schemaRow[isAliased] = col.isDifferentName;                      schemaRow[isKey] = col.isKey;                      schemaRow[isHidden] = col.isHidden;                      schemaRow[isExpression] = col.isExpression;                  }                    schemaRow[isIdentity] = col.isIdentity;                  schemaRow[isAutoIncrement] = col.isIdentity;                    schemaRow[isLong] = col.metaType.IsLong;                    // mark unique for timestamp columns                  if (SqlDbType.Timestamp == col.type)                  {                      schemaRow[isUnique] = true;                      schemaRow[isRowVersion] = true;                  }                  else                  {                      schemaRow[isUnique] = false;                      schemaRow[isRowVersion] = false;                  }                    schemaRow[isReadOnly] = (0 == col.updatability);                  schemaRow[isColumnSet] = col.isColumnSet;                    if (!string.IsNullOrEmpty(col.serverName))                  {                      schemaRow[baseServerName] = col.serverName;                  }                  if (!string.IsNullOrEmpty(col.catalogName))                  {                      schemaRow[baseCatalogName] = col.catalogName;                  }                  if (!string.IsNullOrEmpty(col.schemaName))                  {                      schemaRow[baseSchemaName] = col.schemaName;                  }                  if (!string.IsNullOrEmpty(col.tableName))                  {                      schemaRow[baseTableName] = col.tableName;                  }                  if (!string.IsNullOrEmpty(col.baseColumn))                  {                      schemaRow[baseColumnName] = col.baseColumn;                  }                  else if (!string.IsNullOrEmpty(col.column))                  {                      schemaRow[baseColumnName] = col.column;                  }                    schemaTable.Rows.Add(schemaRow);                  schemaRow.AcceptChanges();              }
Magic Number,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The following statement contains a magic number: for (int i = 0; i < md.Length; i++)              {                  _SqlMetaData col = md[i];                  DataRow schemaRow = schemaTable.NewRow();                    schemaRow[columnName] = col.column;                  schemaRow[ordinal] = col.ordinal;                  //                  // be sure to return character count for string types' byte count otherwise                  // col.length is always byte count so for unicode types' half the length                  //                  // For MAX and XML datatypes' we get 0x7fffffff from the server. Do not divide this.                  schemaRow[size] = (col.metaType.IsSizeInCharacters && (col.length != 0x7fffffff)) ? (col.length / 2) : col.length;                    schemaRow[dataType] = GetFieldTypeInternal(col);                  schemaRow[providerSpecificDataType] = GetProviderSpecificFieldTypeInternal(col);                  schemaRow[nonVersionedProviderType] = (int)col.type; // SqlDbType enum value - does not change with TypeSystem.                  schemaRow[dataTypeName] = GetDataTypeNameInternal(col);                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[providerType] = SqlDbType.NVarChar;                      switch (col.type)                      {                          case SqlDbType.Date:                              schemaRow[size] = TdsEnums.WHIDBEY_DATE_LENGTH;                              break;                          case SqlDbType.Time:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for Time column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_TIME_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTime2:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTime2 column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIME2_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTimeOffset:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTimeOffset column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIMEOFFSET_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                      }                  }                  else if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsLargeUdt)                  {                      if (_typeSystem == SqlConnectionString.TypeSystem.SQLServer2005)                      {                          schemaRow[providerType] = SqlDbType.VarBinary;                      }                      else                      {                          // TypeSystem.SQLServer2000                          schemaRow[providerType] = SqlDbType.Image;                      }                  }                  else if (_typeSystem != SqlConnectionString.TypeSystem.SQLServer2000)                  {                      // TypeSystem.SQLServer2005 and above                        // SqlDbType enum value - always the actual type for SQLServer2005.                      schemaRow[providerType] = (int)col.type;                        if (col.type == SqlDbType.Udt)                      { // Additional metadata for UDTs.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid Column type received from the server");                          schemaRow[udtAssemblyQualifiedName] = col.udtAssemblyQualifiedName;                      }                      else if (col.type == SqlDbType.Xml)                      { // Additional metadata for Xml.                          Debug.Assert(Connection.IsKatmaiOrNewer' "Invalid DataType (Xml) for the column");                          schemaRow[xmlSchemaCollectionDatabase] = col.xmlSchemaCollectionDatabase;                          schemaRow[xmlSchemaCollectionOwningSchema] = col.xmlSchemaCollectionOwningSchema;                          schemaRow[xmlSchemaCollectionName] = col.xmlSchemaCollectionName;                      }                  }                  else                  {                      // TypeSystem.SQLServer2000                        // SqlDbType enum value - variable for certain types when SQLServer2000.                      schemaRow[providerType] = GetVersionedMetaType(col.metaType).SqlDbType;                  }                    if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.precision)                  {                      schemaRow[precision] = col.precision;                  }                  else                  {                      schemaRow[precision] = col.metaType.Precision;                  }                    if (_typeSystem <= SqlConnectionString.TypeSystem.SQLServer2005 && col.IsNewKatmaiDateTimeType)                  {                      schemaRow[scale] = MetaType.MetaNVarChar.Scale;                  }                  else if (TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale)                  {                      schemaRow[scale] = col.scale;                  }                  else                  {                      schemaRow[scale] = col.metaType.Scale;                  }                    schemaRow[allowDBNull] = col.isNullable;                    // If no ColInfo token received' do not set value' leave as null.                  if (_browseModeInfoConsumed)                  {                      schemaRow[isAliased] = col.isDifferentName;                      schemaRow[isKey] = col.isKey;                      schemaRow[isHidden] = col.isHidden;                      schemaRow[isExpression] = col.isExpression;                  }                    schemaRow[isIdentity] = col.isIdentity;                  schemaRow[isAutoIncrement] = col.isIdentity;                    schemaRow[isLong] = col.metaType.IsLong;                    // mark unique for timestamp columns                  if (SqlDbType.Timestamp == col.type)                  {                      schemaRow[isUnique] = true;                      schemaRow[isRowVersion] = true;                  }                  else                  {                      schemaRow[isUnique] = false;                      schemaRow[isRowVersion] = false;                  }                    schemaRow[isReadOnly] = (0 == col.updatability);                  schemaRow[isColumnSet] = col.isColumnSet;                    if (!string.IsNullOrEmpty(col.serverName))                  {                      schemaRow[baseServerName] = col.serverName;                  }                  if (!string.IsNullOrEmpty(col.catalogName))                  {                      schemaRow[baseCatalogName] = col.catalogName;                  }                  if (!string.IsNullOrEmpty(col.schemaName))                  {                      schemaRow[baseSchemaName] = col.schemaName;                  }                  if (!string.IsNullOrEmpty(col.tableName))                  {                      schemaRow[baseTableName] = col.tableName;                  }                  if (!string.IsNullOrEmpty(col.baseColumn))                  {                      schemaRow[baseColumnName] = col.baseColumn;                  }                  else if (!string.IsNullOrEmpty(col.column))                  {                      schemaRow[baseColumnName] = col.column;                  }                    schemaTable.Rows.Add(schemaRow);                  schemaRow.AcceptChanges();              }
Magic Number,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,WillHaveEnoughData,The following statement contains a magic number: while ((bytesRemaining >= 0) && (currentColumn <= targetColumn))              {                  // Check NBC first                  if (!_stateObj.IsNullCompressionBitSet(currentColumn))                  {                      // NOTE: This is mostly duplicated from TryProcessColumnHeaderNoNBC and TryGetTokenLength                      var metaType = _metaData[currentColumn].metaType;                      if ((metaType.IsLong) || (metaType.IsPlp) || (metaType.SqlDbType == SqlDbType.Udt) || (metaType.SqlDbType == SqlDbType.Structured))                      {                          // Plp' Udt and TVP types have an unknowable size - so return that the estimate failed                          return false;                      }                      int maxHeaderSize;                      byte typeAndMask = (byte)(_metaData[currentColumn].tdsType & TdsEnums.SQLLenMask);                      if ((typeAndMask == TdsEnums.SQLVarLen) || (typeAndMask == TdsEnums.SQLVarCnt))                      {                          if (0 != (_metaData[currentColumn].tdsType & 0x80))                          {                              // UInt16 represents size                              maxHeaderSize = 2;                          }                          else if (0 == (_metaData[currentColumn].tdsType & 0x0c))                          {                              // UInt32 represents size                              maxHeaderSize = 4;                          }                          else                          {                              // Byte represents size                              maxHeaderSize = 1;                          }                      }                      else                      {                          maxHeaderSize = 0;                      }                        bytesRemaining = checked(bytesRemaining - maxHeaderSize);                      if ((currentColumn < targetColumn) || (!headerOnly))                      {                          bytesRemaining = checked(bytesRemaining - _metaData[currentColumn].length);                      }                  }                    currentColumn++;              }
Magic Number,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,WillHaveEnoughData,The following statement contains a magic number: while ((bytesRemaining >= 0) && (currentColumn <= targetColumn))              {                  // Check NBC first                  if (!_stateObj.IsNullCompressionBitSet(currentColumn))                  {                      // NOTE: This is mostly duplicated from TryProcessColumnHeaderNoNBC and TryGetTokenLength                      var metaType = _metaData[currentColumn].metaType;                      if ((metaType.IsLong) || (metaType.IsPlp) || (metaType.SqlDbType == SqlDbType.Udt) || (metaType.SqlDbType == SqlDbType.Structured))                      {                          // Plp' Udt and TVP types have an unknowable size - so return that the estimate failed                          return false;                      }                      int maxHeaderSize;                      byte typeAndMask = (byte)(_metaData[currentColumn].tdsType & TdsEnums.SQLLenMask);                      if ((typeAndMask == TdsEnums.SQLVarLen) || (typeAndMask == TdsEnums.SQLVarCnt))                      {                          if (0 != (_metaData[currentColumn].tdsType & 0x80))                          {                              // UInt16 represents size                              maxHeaderSize = 2;                          }                          else if (0 == (_metaData[currentColumn].tdsType & 0x0c))                          {                              // UInt32 represents size                              maxHeaderSize = 4;                          }                          else                          {                              // Byte represents size                              maxHeaderSize = 1;                          }                      }                      else                      {                          maxHeaderSize = 0;                      }                        bytesRemaining = checked(bytesRemaining - maxHeaderSize);                      if ((currentColumn < targetColumn) || (!headerOnly))                      {                          bytesRemaining = checked(bytesRemaining - _metaData[currentColumn].length);                      }                  }                    currentColumn++;              }
Magic Number,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,StartTimer,The following statement contains a magic number: lock (_instanceLock)              {                  // Enable the timer if needed (disable when empty' enable on the first addition).                  if (!_sqlDependencyTimeOutTimerStarted)                  {                      _timeoutTimer.Change(15000 /* 15 secs */' 15000 /* 15 secs */);                        // Save this as the earlier timeout to come.                      _nextTimeout = dep.ExpirationTime;                      _sqlDependencyTimeOutTimerStarted = true;                  }                  else if (_nextTimeout > dep.ExpirationTime)                  {                      // Save this as the earlier timeout to come.                      _nextTimeout = dep.ExpirationTime;                  }              }
Magic Number,System.Data.SqlClient,SqlDependencyPerAppDomainDispatcher,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDependencyUtils.cs,StartTimer,The following statement contains a magic number: lock (_instanceLock)              {                  // Enable the timer if needed (disable when empty' enable on the first addition).                  if (!_sqlDependencyTimeOutTimerStarted)                  {                      _timeoutTimer.Change(15000 /* 15 secs */' 15000 /* 15 secs */);                        // Save this as the earlier timeout to come.                      _nextTimeout = dep.ExpirationTime;                      _sqlDependencyTimeOutTimerStarted = true;                  }                  else if (_nextTimeout > dep.ExpirationTime)                  {                      // Save this as the earlier timeout to come.                      _nextTimeout = dep.ExpirationTime;                  }              }
Magic Number,System.Data.SqlClient,SqlDelegatedTransaction,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDelegatedTransaction.cs,GetGlobalTxnIdentifierFromToken,The following statement contains a magic number: byte[] txnGuid = new byte[16];
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,_IsBinType,The following statement contains a magic number: return (type == SqlDbType.Image ||                     type == SqlDbType.Binary ||                     type == SqlDbType.VarBinary ||                     type == SqlDbType.Timestamp ||                     type == SqlDbType.Udt ||                     (int)type == 24 /*SqlSmallVarBinary*/);
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetSqlDataType,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLMONEYN: return ((4 == length) ? s_metaSmallMoney : s_metaMoney);                  case TdsEnums.SQLDATETIMN: return ((4 == length) ? s_metaSmallDateTime : s_metaDateTime);                  case TdsEnums.SQLINTN: return ((4 <= length) ? ((4 == length) ? s_metaInt : s_metaBigInt) : ((2 == length) ? s_metaSmallInt : s_metaTinyInt));                  case TdsEnums.SQLFLTN: return ((4 == length) ? s_metaReal : s_metaFloat);                  case TdsEnums.SQLTEXT: return MetaText;                  case TdsEnums.SQLVARBINARY: return s_metaSmallVarBinary;                  case TdsEnums.SQLBIGVARBINARY: return MetaVarBinary;                    case TdsEnums.SQLVARCHAR:                  case TdsEnums.SQLBIGVARCHAR: return s_metaVarChar;                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY: return ((TdsEnums.SQLTIMESTAMP == userType) ? s_metaTimestamp : s_metaBinary);                    case TdsEnums.SQLIMAGE: return MetaImage;                    case TdsEnums.SQLCHAR:                  case TdsEnums.SQLBIGCHAR: return s_metaChar;                    case TdsEnums.SQLINT1: return s_metaTinyInt;                    case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN: return s_metaBit;                    case TdsEnums.SQLINT2: return s_metaSmallInt;                  case TdsEnums.SQLINT4: return s_metaInt;                  case TdsEnums.SQLINT8: return s_metaBigInt;                  case TdsEnums.SQLMONEY: return s_metaMoney;                  case TdsEnums.SQLDATETIME: return s_metaDateTime;                  case TdsEnums.SQLFLT8: return s_metaFloat;                  case TdsEnums.SQLFLT4: return s_metaReal;                  case TdsEnums.SQLMONEY4: return s_metaSmallMoney;                  case TdsEnums.SQLDATETIM4: return s_metaSmallDateTime;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN: return MetaDecimal;                    case TdsEnums.SQLUNIQUEID: return s_metaUniqueId;                  case TdsEnums.SQLNCHAR: return s_metaNChar;                  case TdsEnums.SQLNVARCHAR: return MetaNVarChar;                  case TdsEnums.SQLNTEXT: return MetaNText;                  case TdsEnums.SQLVARIANT: return s_metaVariant;                  case TdsEnums.SQLUDT: return MetaUdt;                  case TdsEnums.SQLXMLTYPE: return MetaXml;                  case TdsEnums.SQLTABLE: return s_metaTable;                  case TdsEnums.SQLDATE: return s_metaDate;                  case TdsEnums.SQLTIME: return MetaTime;                  case TdsEnums.SQLDATETIME2: return s_metaDateTime2;                  case TdsEnums.SQLDATETIMEOFFSET: return MetaDateTimeOffset;                    case TdsEnums.SQLVOID:                  default:                      Debug.Fail("Unknown type " + tdsType.ToString(CultureInfo.InvariantCulture));                      throw SQL.InvalidSqlDbType((SqlDbType)tdsType);              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetSqlDataType,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLMONEYN: return ((4 == length) ? s_metaSmallMoney : s_metaMoney);                  case TdsEnums.SQLDATETIMN: return ((4 == length) ? s_metaSmallDateTime : s_metaDateTime);                  case TdsEnums.SQLINTN: return ((4 <= length) ? ((4 == length) ? s_metaInt : s_metaBigInt) : ((2 == length) ? s_metaSmallInt : s_metaTinyInt));                  case TdsEnums.SQLFLTN: return ((4 == length) ? s_metaReal : s_metaFloat);                  case TdsEnums.SQLTEXT: return MetaText;                  case TdsEnums.SQLVARBINARY: return s_metaSmallVarBinary;                  case TdsEnums.SQLBIGVARBINARY: return MetaVarBinary;                    case TdsEnums.SQLVARCHAR:                  case TdsEnums.SQLBIGVARCHAR: return s_metaVarChar;                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY: return ((TdsEnums.SQLTIMESTAMP == userType) ? s_metaTimestamp : s_metaBinary);                    case TdsEnums.SQLIMAGE: return MetaImage;                    case TdsEnums.SQLCHAR:                  case TdsEnums.SQLBIGCHAR: return s_metaChar;                    case TdsEnums.SQLINT1: return s_metaTinyInt;                    case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN: return s_metaBit;                    case TdsEnums.SQLINT2: return s_metaSmallInt;                  case TdsEnums.SQLINT4: return s_metaInt;                  case TdsEnums.SQLINT8: return s_metaBigInt;                  case TdsEnums.SQLMONEY: return s_metaMoney;                  case TdsEnums.SQLDATETIME: return s_metaDateTime;                  case TdsEnums.SQLFLT8: return s_metaFloat;                  case TdsEnums.SQLFLT4: return s_metaReal;                  case TdsEnums.SQLMONEY4: return s_metaSmallMoney;                  case TdsEnums.SQLDATETIM4: return s_metaSmallDateTime;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN: return MetaDecimal;                    case TdsEnums.SQLUNIQUEID: return s_metaUniqueId;                  case TdsEnums.SQLNCHAR: return s_metaNChar;                  case TdsEnums.SQLNVARCHAR: return MetaNVarChar;                  case TdsEnums.SQLNTEXT: return MetaNText;                  case TdsEnums.SQLVARIANT: return s_metaVariant;                  case TdsEnums.SQLUDT: return MetaUdt;                  case TdsEnums.SQLXMLTYPE: return MetaXml;                  case TdsEnums.SQLTABLE: return s_metaTable;                  case TdsEnums.SQLDATE: return s_metaDate;                  case TdsEnums.SQLTIME: return MetaTime;                  case TdsEnums.SQLDATETIME2: return s_metaDateTime2;                  case TdsEnums.SQLDATETIMEOFFSET: return MetaDateTimeOffset;                    case TdsEnums.SQLVOID:                  default:                      Debug.Fail("Unknown type " + tdsType.ToString(CultureInfo.InvariantCulture));                      throw SQL.InvalidSqlDbType((SqlDbType)tdsType);              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetSqlDataType,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLMONEYN: return ((4 == length) ? s_metaSmallMoney : s_metaMoney);                  case TdsEnums.SQLDATETIMN: return ((4 == length) ? s_metaSmallDateTime : s_metaDateTime);                  case TdsEnums.SQLINTN: return ((4 <= length) ? ((4 == length) ? s_metaInt : s_metaBigInt) : ((2 == length) ? s_metaSmallInt : s_metaTinyInt));                  case TdsEnums.SQLFLTN: return ((4 == length) ? s_metaReal : s_metaFloat);                  case TdsEnums.SQLTEXT: return MetaText;                  case TdsEnums.SQLVARBINARY: return s_metaSmallVarBinary;                  case TdsEnums.SQLBIGVARBINARY: return MetaVarBinary;                    case TdsEnums.SQLVARCHAR:                  case TdsEnums.SQLBIGVARCHAR: return s_metaVarChar;                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY: return ((TdsEnums.SQLTIMESTAMP == userType) ? s_metaTimestamp : s_metaBinary);                    case TdsEnums.SQLIMAGE: return MetaImage;                    case TdsEnums.SQLCHAR:                  case TdsEnums.SQLBIGCHAR: return s_metaChar;                    case TdsEnums.SQLINT1: return s_metaTinyInt;                    case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN: return s_metaBit;                    case TdsEnums.SQLINT2: return s_metaSmallInt;                  case TdsEnums.SQLINT4: return s_metaInt;                  case TdsEnums.SQLINT8: return s_metaBigInt;                  case TdsEnums.SQLMONEY: return s_metaMoney;                  case TdsEnums.SQLDATETIME: return s_metaDateTime;                  case TdsEnums.SQLFLT8: return s_metaFloat;                  case TdsEnums.SQLFLT4: return s_metaReal;                  case TdsEnums.SQLMONEY4: return s_metaSmallMoney;                  case TdsEnums.SQLDATETIM4: return s_metaSmallDateTime;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN: return MetaDecimal;                    case TdsEnums.SQLUNIQUEID: return s_metaUniqueId;                  case TdsEnums.SQLNCHAR: return s_metaNChar;                  case TdsEnums.SQLNVARCHAR: return MetaNVarChar;                  case TdsEnums.SQLNTEXT: return MetaNText;                  case TdsEnums.SQLVARIANT: return s_metaVariant;                  case TdsEnums.SQLUDT: return MetaUdt;                  case TdsEnums.SQLXMLTYPE: return MetaXml;                  case TdsEnums.SQLTABLE: return s_metaTable;                  case TdsEnums.SQLDATE: return s_metaDate;                  case TdsEnums.SQLTIME: return MetaTime;                  case TdsEnums.SQLDATETIME2: return s_metaDateTime2;                  case TdsEnums.SQLDATETIMEOFFSET: return MetaDateTimeOffset;                    case TdsEnums.SQLVOID:                  default:                      Debug.Fail("Unknown type " + tdsType.ToString(CultureInfo.InvariantCulture));                      throw SQL.InvalidSqlDbType((SqlDbType)tdsType);              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetSqlDataType,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLMONEYN: return ((4 == length) ? s_metaSmallMoney : s_metaMoney);                  case TdsEnums.SQLDATETIMN: return ((4 == length) ? s_metaSmallDateTime : s_metaDateTime);                  case TdsEnums.SQLINTN: return ((4 <= length) ? ((4 == length) ? s_metaInt : s_metaBigInt) : ((2 == length) ? s_metaSmallInt : s_metaTinyInt));                  case TdsEnums.SQLFLTN: return ((4 == length) ? s_metaReal : s_metaFloat);                  case TdsEnums.SQLTEXT: return MetaText;                  case TdsEnums.SQLVARBINARY: return s_metaSmallVarBinary;                  case TdsEnums.SQLBIGVARBINARY: return MetaVarBinary;                    case TdsEnums.SQLVARCHAR:                  case TdsEnums.SQLBIGVARCHAR: return s_metaVarChar;                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY: return ((TdsEnums.SQLTIMESTAMP == userType) ? s_metaTimestamp : s_metaBinary);                    case TdsEnums.SQLIMAGE: return MetaImage;                    case TdsEnums.SQLCHAR:                  case TdsEnums.SQLBIGCHAR: return s_metaChar;                    case TdsEnums.SQLINT1: return s_metaTinyInt;                    case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN: return s_metaBit;                    case TdsEnums.SQLINT2: return s_metaSmallInt;                  case TdsEnums.SQLINT4: return s_metaInt;                  case TdsEnums.SQLINT8: return s_metaBigInt;                  case TdsEnums.SQLMONEY: return s_metaMoney;                  case TdsEnums.SQLDATETIME: return s_metaDateTime;                  case TdsEnums.SQLFLT8: return s_metaFloat;                  case TdsEnums.SQLFLT4: return s_metaReal;                  case TdsEnums.SQLMONEY4: return s_metaSmallMoney;                  case TdsEnums.SQLDATETIM4: return s_metaSmallDateTime;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN: return MetaDecimal;                    case TdsEnums.SQLUNIQUEID: return s_metaUniqueId;                  case TdsEnums.SQLNCHAR: return s_metaNChar;                  case TdsEnums.SQLNVARCHAR: return MetaNVarChar;                  case TdsEnums.SQLNTEXT: return MetaNText;                  case TdsEnums.SQLVARIANT: return s_metaVariant;                  case TdsEnums.SQLUDT: return MetaUdt;                  case TdsEnums.SQLXMLTYPE: return MetaXml;                  case TdsEnums.SQLTABLE: return s_metaTable;                  case TdsEnums.SQLDATE: return s_metaDate;                  case TdsEnums.SQLTIME: return MetaTime;                  case TdsEnums.SQLDATETIME2: return s_metaDateTime2;                  case TdsEnums.SQLDATETIMEOFFSET: return MetaDateTimeOffset;                    case TdsEnums.SQLVOID:                  default:                      Debug.Fail("Unknown type " + tdsType.ToString(CultureInfo.InvariantCulture));                      throw SQL.InvalidSqlDbType((SqlDbType)tdsType);              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetSqlDataType,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLMONEYN: return ((4 == length) ? s_metaSmallMoney : s_metaMoney);                  case TdsEnums.SQLDATETIMN: return ((4 == length) ? s_metaSmallDateTime : s_metaDateTime);                  case TdsEnums.SQLINTN: return ((4 <= length) ? ((4 == length) ? s_metaInt : s_metaBigInt) : ((2 == length) ? s_metaSmallInt : s_metaTinyInt));                  case TdsEnums.SQLFLTN: return ((4 == length) ? s_metaReal : s_metaFloat);                  case TdsEnums.SQLTEXT: return MetaText;                  case TdsEnums.SQLVARBINARY: return s_metaSmallVarBinary;                  case TdsEnums.SQLBIGVARBINARY: return MetaVarBinary;                    case TdsEnums.SQLVARCHAR:                  case TdsEnums.SQLBIGVARCHAR: return s_metaVarChar;                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY: return ((TdsEnums.SQLTIMESTAMP == userType) ? s_metaTimestamp : s_metaBinary);                    case TdsEnums.SQLIMAGE: return MetaImage;                    case TdsEnums.SQLCHAR:                  case TdsEnums.SQLBIGCHAR: return s_metaChar;                    case TdsEnums.SQLINT1: return s_metaTinyInt;                    case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN: return s_metaBit;                    case TdsEnums.SQLINT2: return s_metaSmallInt;                  case TdsEnums.SQLINT4: return s_metaInt;                  case TdsEnums.SQLINT8: return s_metaBigInt;                  case TdsEnums.SQLMONEY: return s_metaMoney;                  case TdsEnums.SQLDATETIME: return s_metaDateTime;                  case TdsEnums.SQLFLT8: return s_metaFloat;                  case TdsEnums.SQLFLT4: return s_metaReal;                  case TdsEnums.SQLMONEY4: return s_metaSmallMoney;                  case TdsEnums.SQLDATETIM4: return s_metaSmallDateTime;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN: return MetaDecimal;                    case TdsEnums.SQLUNIQUEID: return s_metaUniqueId;                  case TdsEnums.SQLNCHAR: return s_metaNChar;                  case TdsEnums.SQLNVARCHAR: return MetaNVarChar;                  case TdsEnums.SQLNTEXT: return MetaNText;                  case TdsEnums.SQLVARIANT: return s_metaVariant;                  case TdsEnums.SQLUDT: return MetaUdt;                  case TdsEnums.SQLXMLTYPE: return MetaXml;                  case TdsEnums.SQLTABLE: return s_metaTable;                  case TdsEnums.SQLDATE: return s_metaDate;                  case TdsEnums.SQLTIME: return MetaTime;                  case TdsEnums.SQLDATETIME2: return s_metaDateTime2;                  case TdsEnums.SQLDATETIMEOFFSET: return MetaDateTimeOffset;                    case TdsEnums.SQLVOID:                  default:                      Debug.Fail("Unknown type " + tdsType.ToString(CultureInfo.InvariantCulture));                      throw SQL.InvalidSqlDbType((SqlDbType)tdsType);              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetSqlDataType,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLMONEYN: return ((4 == length) ? s_metaSmallMoney : s_metaMoney);                  case TdsEnums.SQLDATETIMN: return ((4 == length) ? s_metaSmallDateTime : s_metaDateTime);                  case TdsEnums.SQLINTN: return ((4 <= length) ? ((4 == length) ? s_metaInt : s_metaBigInt) : ((2 == length) ? s_metaSmallInt : s_metaTinyInt));                  case TdsEnums.SQLFLTN: return ((4 == length) ? s_metaReal : s_metaFloat);                  case TdsEnums.SQLTEXT: return MetaText;                  case TdsEnums.SQLVARBINARY: return s_metaSmallVarBinary;                  case TdsEnums.SQLBIGVARBINARY: return MetaVarBinary;                    case TdsEnums.SQLVARCHAR:                  case TdsEnums.SQLBIGVARCHAR: return s_metaVarChar;                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY: return ((TdsEnums.SQLTIMESTAMP == userType) ? s_metaTimestamp : s_metaBinary);                    case TdsEnums.SQLIMAGE: return MetaImage;                    case TdsEnums.SQLCHAR:                  case TdsEnums.SQLBIGCHAR: return s_metaChar;                    case TdsEnums.SQLINT1: return s_metaTinyInt;                    case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN: return s_metaBit;                    case TdsEnums.SQLINT2: return s_metaSmallInt;                  case TdsEnums.SQLINT4: return s_metaInt;                  case TdsEnums.SQLINT8: return s_metaBigInt;                  case TdsEnums.SQLMONEY: return s_metaMoney;                  case TdsEnums.SQLDATETIME: return s_metaDateTime;                  case TdsEnums.SQLFLT8: return s_metaFloat;                  case TdsEnums.SQLFLT4: return s_metaReal;                  case TdsEnums.SQLMONEY4: return s_metaSmallMoney;                  case TdsEnums.SQLDATETIM4: return s_metaSmallDateTime;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN: return MetaDecimal;                    case TdsEnums.SQLUNIQUEID: return s_metaUniqueId;                  case TdsEnums.SQLNCHAR: return s_metaNChar;                  case TdsEnums.SQLNVARCHAR: return MetaNVarChar;                  case TdsEnums.SQLNTEXT: return MetaNText;                  case TdsEnums.SQLVARIANT: return s_metaVariant;                  case TdsEnums.SQLUDT: return MetaUdt;                  case TdsEnums.SQLXMLTYPE: return MetaXml;                  case TdsEnums.SQLTABLE: return s_metaTable;                  case TdsEnums.SQLDATE: return s_metaDate;                  case TdsEnums.SQLTIME: return MetaTime;                  case TdsEnums.SQLDATETIME2: return s_metaDateTime2;                  case TdsEnums.SQLDATETIMEOFFSET: return MetaDateTimeOffset;                    case TdsEnums.SQLVOID:                  default:                      Debug.Fail("Unknown type " + tdsType.ToString(CultureInfo.InvariantCulture));                      throw SQL.InvalidSqlDbType((SqlDbType)tdsType);              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,FromDateTime,The following statement contains a magic number: Debug.Assert(cb == 8 || cb == 4' "Invalid date time size!");
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,FromDateTime,The following statement contains a magic number: Debug.Assert(cb == 8 || cb == 4' "Invalid date time size!");
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,FromDateTime,The following statement contains a magic number: if (cb == 8)              {                  sqlDateTime = new SqlDateTime(dateTime);                  tdsDateTime.time = sqlDateTime.TimeTicks;              }              else              {                  // note that smalldatetime is days & minutes.                  // Adding 30 seconds ensures proper roundup if the seconds are >= 30                  // The AddSeconds function handles eventual carryover                  sqlDateTime = new SqlDateTime(dateTime.AddSeconds(30));                  tdsDateTime.time = sqlDateTime.TimeTicks / SqlDateTime.SQLTicksPerMinute;              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,FromDateTime,The following statement contains a magic number: if (cb == 8)              {                  sqlDateTime = new SqlDateTime(dateTime);                  tdsDateTime.time = sqlDateTime.TimeTicks;              }              else              {                  // note that smalldatetime is days & minutes.                  // Adding 30 seconds ensures proper roundup if the seconds are >= 30                  // The AddSeconds function handles eventual carryover                  sqlDateTime = new SqlDateTime(dateTime.AddSeconds(30));                  tdsDateTime.time = sqlDateTime.TimeTicks / SqlDateTime.SQLTicksPerMinute;              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,ToDateTime,The following statement contains a magic number: if (length == 4)              {                  return new SqlDateTime(sqlDays' sqlTime * SqlDateTime.SQLTicksPerMinute).Value;              }              else              {                  Debug.Assert(length == 8' "invalid length for DateTime");                  return new SqlDateTime(sqlDays' sqlTime).Value;              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,ToDateTime,The following statement contains a magic number: if (length == 4)              {                  return new SqlDateTime(sqlDays' sqlTime * SqlDateTime.SQLTicksPerMinute).Value;              }              else              {                  Debug.Assert(length == 8' "invalid length for DateTime");                  return new SqlDateTime(sqlDays' sqlTime).Value;              }
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetTimeSizeFromScale,The following statement contains a magic number: if (scale <= 2)                  return 3;
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetTimeSizeFromScale,The following statement contains a magic number: if (scale <= 2)                  return 3;
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetTimeSizeFromScale,The following statement contains a magic number: if (scale <= 4)                  return 4;
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetTimeSizeFromScale,The following statement contains a magic number: if (scale <= 4)                  return 4;
Magic Number,System.Data.SqlClient,MetaType,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlEnums.cs,GetTimeSizeFromScale,The following statement contains a magic number: return 5;
Magic Number,System.Data.SqlClient,SessionData,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,SessionData,The following statement contains a magic number: _resolvedAliases = new Dictionary<string' Tuple<string' string>>(2);
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,SqlInternalConnectionTds,The following statement contains a magic number: try              {                  var timeout = TimeoutTimer.StartSecondsTimeout(connectionOptions.ConnectTimeout);                    // If transient fault handling is enabled then we can retry the login up to the ConnectRetryCount.                  int connectionEstablishCount = applyTransientFaultHandling ? connectionOptions.ConnectRetryCount + 1 : 1;                  int transientRetryIntervalInMilliSeconds = connectionOptions.ConnectRetryInterval * 1000; // Max value of transientRetryInterval is 60*1000 ms. The max value allowed for ConnectRetryInterval is 60                  for (int i = 0; i < connectionEstablishCount; i++)                  {                      try                      {                          OpenLoginEnlist(timeout' connectionOptions' redirectedUserInstance);                          break;                      }                      catch (SqlException sqlex)                      {                          if (i + 1 == connectionEstablishCount                              || !applyTransientFaultHandling                              || timeout.IsExpired                              || timeout.MillisecondsRemaining < transientRetryIntervalInMilliSeconds                              || !IsTransientError(sqlex))                          {                              throw sqlex;                          }                          else                          {                              Thread.Sleep(transientRetryIntervalInMilliSeconds);                          }                      }                  }              }              finally              {                  ThreadHasParserLockForClose = false;                  _parserLock.Release();              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,Login,The following statement contains a magic number: if (!timeout.IsInfinite)              {                  long t = timeout.MillisecondsRemaining / 1000;                  if ((long)Int32.MaxValue > t)                  {                      timeoutInSeconds = (int)t;                  }              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The following statement contains a magic number: int sleepInterval = 100;
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The following statement contains a magic number: while (true)              {                  if (connectionOptions.MultiSubnetFailover)                  {                      attemptNumber++;                      // Set timeout for this attempt' but don't exceed original timer                                      long nextTimeoutInterval = checked(timeoutUnitInterval * attemptNumber);                      long milliseconds = timeout.MillisecondsRemaining;                      if (nextTimeoutInterval > milliseconds)                      {                          nextTimeoutInterval = milliseconds;                      }                      intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                  }                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    try                  {                      AttemptOneLogin(serverInfo'                                      !connectionOptions.MultiSubnetFailover'    // ignore timeout for SniOpen call unless MSF                                           connectionOptions.MultiSubnetFailover ? intervalTimer : timeout);                        if (connectionOptions.MultiSubnetFailover && null != ServerProvidedFailOverPartner)                      {                          // connection succeeded: trigger exception if server sends failover partner and MultiSubnetFailover is used                          throw SQL.MultiSubnetFailoverWithFailoverPartner(serverProvidedFailoverPartner: true' internalConnection: this);                      }                        if (_routingInfo != null)                      {                          if (routingAttempts > 0)                          {                              throw SQL.ROR_RecursiveRoutingNotSupported(this);                          }                            if (timeout.IsExpired)                          {                              throw SQL.ROR_TimeoutAfterRoutingInfo(this);                          }                            serverInfo = new ServerInfo(ConnectionOptions' _routingInfo' serverInfo.ResolvedServerName);                          _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.RoutingDestination);                          _originalClientConnectionId = _clientConnectionId;                          _routingDestination = serverInfo.UserServerName;                            // restore properties that could be changed by the environment tokens                          _currentPacketSize = ConnectionOptions.PacketSize;                          _currentLanguage = _originalLanguage = ConnectionOptions.CurrentLanguage;                          CurrentDatabase = _originalDatabase = ConnectionOptions.InitialCatalog;                          _currentFailoverPartner = null;                          _instanceName = String.Empty;                            routingAttempts++;                            continue; // repeat the loop' but skip code reserved for failed connections (after the catch)                      }                      else                      {                          break; // leave the while loop -- we've successfully connected                      }                  }                  catch (SqlException sqlex)                  {                      if (null == _parser                              || TdsParserState.Closed != _parser.State                              || IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        // Check sleep interval to make sure we won't exceed the timeout                      //  Do this in the catch block so we can re-throw the current exception                      if (timeout.MillisecondsRemaining <= sleepInterval)                      {                          throw;                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // Switch to failover logic if the server provided a partner                  if (null != ServerProvidedFailOverPartner)                  {                      if (connectionOptions.MultiSubnetFailover)                      {                          // connection failed: do not allow failover to server-provided failover partner if MultiSubnetFailover is set                          throw SQL.MultiSubnetFailoverWithFailoverPartner(serverProvidedFailoverPartner: true' internalConnection: this);                      }                      Debug.Assert(ConnectionOptions.ApplicationIntent != ApplicationIntent.ReadOnly' "FAILOVER+AppIntent=RO: Should already fail (at LOGSHIPNODE in OnEnvChange)");                        _timeoutErrorInternal.ResetAndRestartPhase();                      _timeoutErrorInternal.SetAndBeginPhase(SqlConnectionTimeoutErrorPhase.PreLoginBegin);                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                      _timeoutErrorInternal.SetFailoverScenario(true); // this is a failover scenario                      LoginWithFailover(                                  true'   // start by using failover partner' since we already failed to connect to the primary                                  serverInfo'                                  ServerProvidedFailOverPartner'                              redirectedUserInstance'                                  connectionOptions'                              timeout);                      return; // LoginWithFailover successfully connected and handled entire connection setup                  }                    // Sleep for a bit to prevent clogging the network with requests'                   //  then update sleep interval for next iteration (max 1 second interval)                  Thread.Sleep(sleepInterval);                  sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The following statement contains a magic number: while (true)              {                  if (connectionOptions.MultiSubnetFailover)                  {                      attemptNumber++;                      // Set timeout for this attempt' but don't exceed original timer                                      long nextTimeoutInterval = checked(timeoutUnitInterval * attemptNumber);                      long milliseconds = timeout.MillisecondsRemaining;                      if (nextTimeoutInterval > milliseconds)                      {                          nextTimeoutInterval = milliseconds;                      }                      intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                  }                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    try                  {                      AttemptOneLogin(serverInfo'                                      !connectionOptions.MultiSubnetFailover'    // ignore timeout for SniOpen call unless MSF                                           connectionOptions.MultiSubnetFailover ? intervalTimer : timeout);                        if (connectionOptions.MultiSubnetFailover && null != ServerProvidedFailOverPartner)                      {                          // connection succeeded: trigger exception if server sends failover partner and MultiSubnetFailover is used                          throw SQL.MultiSubnetFailoverWithFailoverPartner(serverProvidedFailoverPartner: true' internalConnection: this);                      }                        if (_routingInfo != null)                      {                          if (routingAttempts > 0)                          {                              throw SQL.ROR_RecursiveRoutingNotSupported(this);                          }                            if (timeout.IsExpired)                          {                              throw SQL.ROR_TimeoutAfterRoutingInfo(this);                          }                            serverInfo = new ServerInfo(ConnectionOptions' _routingInfo' serverInfo.ResolvedServerName);                          _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.RoutingDestination);                          _originalClientConnectionId = _clientConnectionId;                          _routingDestination = serverInfo.UserServerName;                            // restore properties that could be changed by the environment tokens                          _currentPacketSize = ConnectionOptions.PacketSize;                          _currentLanguage = _originalLanguage = ConnectionOptions.CurrentLanguage;                          CurrentDatabase = _originalDatabase = ConnectionOptions.InitialCatalog;                          _currentFailoverPartner = null;                          _instanceName = String.Empty;                            routingAttempts++;                            continue; // repeat the loop' but skip code reserved for failed connections (after the catch)                      }                      else                      {                          break; // leave the while loop -- we've successfully connected                      }                  }                  catch (SqlException sqlex)                  {                      if (null == _parser                              || TdsParserState.Closed != _parser.State                              || IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        // Check sleep interval to make sure we won't exceed the timeout                      //  Do this in the catch block so we can re-throw the current exception                      if (timeout.MillisecondsRemaining <= sleepInterval)                      {                          throw;                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // Switch to failover logic if the server provided a partner                  if (null != ServerProvidedFailOverPartner)                  {                      if (connectionOptions.MultiSubnetFailover)                      {                          // connection failed: do not allow failover to server-provided failover partner if MultiSubnetFailover is set                          throw SQL.MultiSubnetFailoverWithFailoverPartner(serverProvidedFailoverPartner: true' internalConnection: this);                      }                      Debug.Assert(ConnectionOptions.ApplicationIntent != ApplicationIntent.ReadOnly' "FAILOVER+AppIntent=RO: Should already fail (at LOGSHIPNODE in OnEnvChange)");                        _timeoutErrorInternal.ResetAndRestartPhase();                      _timeoutErrorInternal.SetAndBeginPhase(SqlConnectionTimeoutErrorPhase.PreLoginBegin);                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                      _timeoutErrorInternal.SetFailoverScenario(true); // this is a failover scenario                      LoginWithFailover(                                  true'   // start by using failover partner' since we already failed to connect to the primary                                  serverInfo'                                  ServerProvidedFailOverPartner'                              redirectedUserInstance'                                  connectionOptions'                              timeout);                      return; // LoginWithFailover successfully connected and handled entire connection setup                  }                    // Sleep for a bit to prevent clogging the network with requests'                   //  then update sleep interval for next iteration (max 1 second interval)                  Thread.Sleep(sleepInterval);                  sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginNoFailover,The following statement contains a magic number: while (true)              {                  if (connectionOptions.MultiSubnetFailover)                  {                      attemptNumber++;                      // Set timeout for this attempt' but don't exceed original timer                                      long nextTimeoutInterval = checked(timeoutUnitInterval * attemptNumber);                      long milliseconds = timeout.MillisecondsRemaining;                      if (nextTimeoutInterval > milliseconds)                      {                          nextTimeoutInterval = milliseconds;                      }                      intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                  }                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    try                  {                      AttemptOneLogin(serverInfo'                                      !connectionOptions.MultiSubnetFailover'    // ignore timeout for SniOpen call unless MSF                                           connectionOptions.MultiSubnetFailover ? intervalTimer : timeout);                        if (connectionOptions.MultiSubnetFailover && null != ServerProvidedFailOverPartner)                      {                          // connection succeeded: trigger exception if server sends failover partner and MultiSubnetFailover is used                          throw SQL.MultiSubnetFailoverWithFailoverPartner(serverProvidedFailoverPartner: true' internalConnection: this);                      }                        if (_routingInfo != null)                      {                          if (routingAttempts > 0)                          {                              throw SQL.ROR_RecursiveRoutingNotSupported(this);                          }                            if (timeout.IsExpired)                          {                              throw SQL.ROR_TimeoutAfterRoutingInfo(this);                          }                            serverInfo = new ServerInfo(ConnectionOptions' _routingInfo' serverInfo.ResolvedServerName);                          _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.RoutingDestination);                          _originalClientConnectionId = _clientConnectionId;                          _routingDestination = serverInfo.UserServerName;                            // restore properties that could be changed by the environment tokens                          _currentPacketSize = ConnectionOptions.PacketSize;                          _currentLanguage = _originalLanguage = ConnectionOptions.CurrentLanguage;                          CurrentDatabase = _originalDatabase = ConnectionOptions.InitialCatalog;                          _currentFailoverPartner = null;                          _instanceName = String.Empty;                            routingAttempts++;                            continue; // repeat the loop' but skip code reserved for failed connections (after the catch)                      }                      else                      {                          break; // leave the while loop -- we've successfully connected                      }                  }                  catch (SqlException sqlex)                  {                      if (null == _parser                              || TdsParserState.Closed != _parser.State                              || IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        // Check sleep interval to make sure we won't exceed the timeout                      //  Do this in the catch block so we can re-throw the current exception                      if (timeout.MillisecondsRemaining <= sleepInterval)                      {                          throw;                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // Switch to failover logic if the server provided a partner                  if (null != ServerProvidedFailOverPartner)                  {                      if (connectionOptions.MultiSubnetFailover)                      {                          // connection failed: do not allow failover to server-provided failover partner if MultiSubnetFailover is set                          throw SQL.MultiSubnetFailoverWithFailoverPartner(serverProvidedFailoverPartner: true' internalConnection: this);                      }                      Debug.Assert(ConnectionOptions.ApplicationIntent != ApplicationIntent.ReadOnly' "FAILOVER+AppIntent=RO: Should already fail (at LOGSHIPNODE in OnEnvChange)");                        _timeoutErrorInternal.ResetAndRestartPhase();                      _timeoutErrorInternal.SetAndBeginPhase(SqlConnectionTimeoutErrorPhase.PreLoginBegin);                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                      _timeoutErrorInternal.SetFailoverScenario(true); // this is a failover scenario                      LoginWithFailover(                                  true'   // start by using failover partner' since we already failed to connect to the primary                                  serverInfo'                                  ServerProvidedFailOverPartner'                              redirectedUserInstance'                                  connectionOptions'                              timeout);                      return; // LoginWithFailover successfully connected and handled entire connection setup                  }                    // Sleep for a bit to prevent clogging the network with requests'                   //  then update sleep interval for next iteration (max 1 second interval)                  Thread.Sleep(sleepInterval);                  sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The following statement contains a magic number: int sleepInterval = 100;
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The following statement contains a magic number: while (true)              {                  // Set timeout for this attempt' but don't exceed original timer                  long nextTimeoutInterval = checked(timeoutUnitInterval * ((attemptNumber / 2) + 1));                  long milliseconds = timeout.MillisecondsRemaining;                  if (nextTimeoutInterval > milliseconds)                  {                      nextTimeoutInterval = milliseconds;                  }                    TimeoutTimer intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    ServerInfo currentServerInfo;                  if (useFailoverHost)                  {                      // Primary server may give us a different failover partner than the connection string indicates.  Update it                      if (null != ServerProvidedFailOverPartner && failoverServerInfo.ResolvedServerName != ServerProvidedFailOverPartner)                      {                          failoverServerInfo.SetDerivedNames(string.Empty' ServerProvidedFailOverPartner);                      }                      currentServerInfo = failoverServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                  }                  else                  {                      currentServerInfo = primaryServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Principle);                  }                    try                  {                      // Attempt login.  Use timerInterval for attempt timeout unless infinite timeout was requested.                      AttemptOneLogin(                              currentServerInfo'                          false'          // Use timeout in SniOpen                              intervalTimer'                              withFailover: true                              );                        if (_routingInfo != null)                      {                          // We are in login with failover scenation and server sent routing information                          // If it is read-only routing - we did not supply AppIntent=RO (it should be checked before)                          // If it is something else' not known yet (future server) - this client is not designed to support this.                                              // In any case' server should not have sent the routing info.                          throw SQL.ROR_UnexpectedRoutingInfo(this);                      }                        break; // leave the while loop -- we've successfully connected                  }                  catch (SqlException sqlex)                  {                      if (IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        if (IsConnectionDoomed)                      {                          throw;                      }                        if (1 == attemptNumber % 2)                      {                          // Check sleep interval to make sure we won't exceed the original timeout                          //  Do this in the catch block so we can re-throw the current exception                          if (timeout.MillisecondsRemaining <= sleepInterval)                          {                              throw;                          }                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // After trying to connect to both servers fails' sleep for a bit to prevent clogging                   //  the network with requests' then update sleep interval for next iteration (max 1 second interval)                  if (1 == attemptNumber % 2)                  {                      Thread.Sleep(sleepInterval);                      sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;                  }                    // Update attempt number and target host                  attemptNumber++;                  useFailoverHost = !useFailoverHost;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The following statement contains a magic number: while (true)              {                  // Set timeout for this attempt' but don't exceed original timer                  long nextTimeoutInterval = checked(timeoutUnitInterval * ((attemptNumber / 2) + 1));                  long milliseconds = timeout.MillisecondsRemaining;                  if (nextTimeoutInterval > milliseconds)                  {                      nextTimeoutInterval = milliseconds;                  }                    TimeoutTimer intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    ServerInfo currentServerInfo;                  if (useFailoverHost)                  {                      // Primary server may give us a different failover partner than the connection string indicates.  Update it                      if (null != ServerProvidedFailOverPartner && failoverServerInfo.ResolvedServerName != ServerProvidedFailOverPartner)                      {                          failoverServerInfo.SetDerivedNames(string.Empty' ServerProvidedFailOverPartner);                      }                      currentServerInfo = failoverServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                  }                  else                  {                      currentServerInfo = primaryServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Principle);                  }                    try                  {                      // Attempt login.  Use timerInterval for attempt timeout unless infinite timeout was requested.                      AttemptOneLogin(                              currentServerInfo'                          false'          // Use timeout in SniOpen                              intervalTimer'                              withFailover: true                              );                        if (_routingInfo != null)                      {                          // We are in login with failover scenation and server sent routing information                          // If it is read-only routing - we did not supply AppIntent=RO (it should be checked before)                          // If it is something else' not known yet (future server) - this client is not designed to support this.                                              // In any case' server should not have sent the routing info.                          throw SQL.ROR_UnexpectedRoutingInfo(this);                      }                        break; // leave the while loop -- we've successfully connected                  }                  catch (SqlException sqlex)                  {                      if (IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        if (IsConnectionDoomed)                      {                          throw;                      }                        if (1 == attemptNumber % 2)                      {                          // Check sleep interval to make sure we won't exceed the original timeout                          //  Do this in the catch block so we can re-throw the current exception                          if (timeout.MillisecondsRemaining <= sleepInterval)                          {                              throw;                          }                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // After trying to connect to both servers fails' sleep for a bit to prevent clogging                   //  the network with requests' then update sleep interval for next iteration (max 1 second interval)                  if (1 == attemptNumber % 2)                  {                      Thread.Sleep(sleepInterval);                      sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;                  }                    // Update attempt number and target host                  attemptNumber++;                  useFailoverHost = !useFailoverHost;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The following statement contains a magic number: while (true)              {                  // Set timeout for this attempt' but don't exceed original timer                  long nextTimeoutInterval = checked(timeoutUnitInterval * ((attemptNumber / 2) + 1));                  long milliseconds = timeout.MillisecondsRemaining;                  if (nextTimeoutInterval > milliseconds)                  {                      nextTimeoutInterval = milliseconds;                  }                    TimeoutTimer intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    ServerInfo currentServerInfo;                  if (useFailoverHost)                  {                      // Primary server may give us a different failover partner than the connection string indicates.  Update it                      if (null != ServerProvidedFailOverPartner && failoverServerInfo.ResolvedServerName != ServerProvidedFailOverPartner)                      {                          failoverServerInfo.SetDerivedNames(string.Empty' ServerProvidedFailOverPartner);                      }                      currentServerInfo = failoverServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                  }                  else                  {                      currentServerInfo = primaryServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Principle);                  }                    try                  {                      // Attempt login.  Use timerInterval for attempt timeout unless infinite timeout was requested.                      AttemptOneLogin(                              currentServerInfo'                          false'          // Use timeout in SniOpen                              intervalTimer'                              withFailover: true                              );                        if (_routingInfo != null)                      {                          // We are in login with failover scenation and server sent routing information                          // If it is read-only routing - we did not supply AppIntent=RO (it should be checked before)                          // If it is something else' not known yet (future server) - this client is not designed to support this.                                              // In any case' server should not have sent the routing info.                          throw SQL.ROR_UnexpectedRoutingInfo(this);                      }                        break; // leave the while loop -- we've successfully connected                  }                  catch (SqlException sqlex)                  {                      if (IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        if (IsConnectionDoomed)                      {                          throw;                      }                        if (1 == attemptNumber % 2)                      {                          // Check sleep interval to make sure we won't exceed the original timeout                          //  Do this in the catch block so we can re-throw the current exception                          if (timeout.MillisecondsRemaining <= sleepInterval)                          {                              throw;                          }                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // After trying to connect to both servers fails' sleep for a bit to prevent clogging                   //  the network with requests' then update sleep interval for next iteration (max 1 second interval)                  if (1 == attemptNumber % 2)                  {                      Thread.Sleep(sleepInterval);                      sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;                  }                    // Update attempt number and target host                  attemptNumber++;                  useFailoverHost = !useFailoverHost;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The following statement contains a magic number: while (true)              {                  // Set timeout for this attempt' but don't exceed original timer                  long nextTimeoutInterval = checked(timeoutUnitInterval * ((attemptNumber / 2) + 1));                  long milliseconds = timeout.MillisecondsRemaining;                  if (nextTimeoutInterval > milliseconds)                  {                      nextTimeoutInterval = milliseconds;                  }                    TimeoutTimer intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    ServerInfo currentServerInfo;                  if (useFailoverHost)                  {                      // Primary server may give us a different failover partner than the connection string indicates.  Update it                      if (null != ServerProvidedFailOverPartner && failoverServerInfo.ResolvedServerName != ServerProvidedFailOverPartner)                      {                          failoverServerInfo.SetDerivedNames(string.Empty' ServerProvidedFailOverPartner);                      }                      currentServerInfo = failoverServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                  }                  else                  {                      currentServerInfo = primaryServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Principle);                  }                    try                  {                      // Attempt login.  Use timerInterval for attempt timeout unless infinite timeout was requested.                      AttemptOneLogin(                              currentServerInfo'                          false'          // Use timeout in SniOpen                              intervalTimer'                              withFailover: true                              );                        if (_routingInfo != null)                      {                          // We are in login with failover scenation and server sent routing information                          // If it is read-only routing - we did not supply AppIntent=RO (it should be checked before)                          // If it is something else' not known yet (future server) - this client is not designed to support this.                                              // In any case' server should not have sent the routing info.                          throw SQL.ROR_UnexpectedRoutingInfo(this);                      }                        break; // leave the while loop -- we've successfully connected                  }                  catch (SqlException sqlex)                  {                      if (IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        if (IsConnectionDoomed)                      {                          throw;                      }                        if (1 == attemptNumber % 2)                      {                          // Check sleep interval to make sure we won't exceed the original timeout                          //  Do this in the catch block so we can re-throw the current exception                          if (timeout.MillisecondsRemaining <= sleepInterval)                          {                              throw;                          }                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // After trying to connect to both servers fails' sleep for a bit to prevent clogging                   //  the network with requests' then update sleep interval for next iteration (max 1 second interval)                  if (1 == attemptNumber % 2)                  {                      Thread.Sleep(sleepInterval);                      sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;                  }                    // Update attempt number and target host                  attemptNumber++;                  useFailoverHost = !useFailoverHost;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The following statement contains a magic number: while (true)              {                  // Set timeout for this attempt' but don't exceed original timer                  long nextTimeoutInterval = checked(timeoutUnitInterval * ((attemptNumber / 2) + 1));                  long milliseconds = timeout.MillisecondsRemaining;                  if (nextTimeoutInterval > milliseconds)                  {                      nextTimeoutInterval = milliseconds;                  }                    TimeoutTimer intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    ServerInfo currentServerInfo;                  if (useFailoverHost)                  {                      // Primary server may give us a different failover partner than the connection string indicates.  Update it                      if (null != ServerProvidedFailOverPartner && failoverServerInfo.ResolvedServerName != ServerProvidedFailOverPartner)                      {                          failoverServerInfo.SetDerivedNames(string.Empty' ServerProvidedFailOverPartner);                      }                      currentServerInfo = failoverServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                  }                  else                  {                      currentServerInfo = primaryServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Principle);                  }                    try                  {                      // Attempt login.  Use timerInterval for attempt timeout unless infinite timeout was requested.                      AttemptOneLogin(                              currentServerInfo'                          false'          // Use timeout in SniOpen                              intervalTimer'                              withFailover: true                              );                        if (_routingInfo != null)                      {                          // We are in login with failover scenation and server sent routing information                          // If it is read-only routing - we did not supply AppIntent=RO (it should be checked before)                          // If it is something else' not known yet (future server) - this client is not designed to support this.                                              // In any case' server should not have sent the routing info.                          throw SQL.ROR_UnexpectedRoutingInfo(this);                      }                        break; // leave the while loop -- we've successfully connected                  }                  catch (SqlException sqlex)                  {                      if (IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        if (IsConnectionDoomed)                      {                          throw;                      }                        if (1 == attemptNumber % 2)                      {                          // Check sleep interval to make sure we won't exceed the original timeout                          //  Do this in the catch block so we can re-throw the current exception                          if (timeout.MillisecondsRemaining <= sleepInterval)                          {                              throw;                          }                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // After trying to connect to both servers fails' sleep for a bit to prevent clogging                   //  the network with requests' then update sleep interval for next iteration (max 1 second interval)                  if (1 == attemptNumber % 2)                  {                      Thread.Sleep(sleepInterval);                      sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;                  }                    // Update attempt number and target host                  attemptNumber++;                  useFailoverHost = !useFailoverHost;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,LoginWithFailover,The following statement contains a magic number: while (true)              {                  // Set timeout for this attempt' but don't exceed original timer                  long nextTimeoutInterval = checked(timeoutUnitInterval * ((attemptNumber / 2) + 1));                  long milliseconds = timeout.MillisecondsRemaining;                  if (nextTimeoutInterval > milliseconds)                  {                      nextTimeoutInterval = milliseconds;                  }                    TimeoutTimer intervalTimer = TimeoutTimer.StartMillisecondsTimeout(nextTimeoutInterval);                    // Re-allocate parser each time to make sure state is known                  // RFC 50002652 - if parser was created by previous attempt' dispose it to properly close the socket' if created                  if (_parser != null)                      _parser.Disconnect();                    _parser = new TdsParser(ConnectionOptions.MARS' ConnectionOptions.Asynchronous);                  Debug.Assert(SniContext.Undefined == Parser._physicalStateObj.SniContext' String.Format((IFormatProvider)null' "SniContext should be Undefined; actual Value: {0}"' Parser._physicalStateObj.SniContext));                    ServerInfo currentServerInfo;                  if (useFailoverHost)                  {                      // Primary server may give us a different failover partner than the connection string indicates.  Update it                      if (null != ServerProvidedFailOverPartner && failoverServerInfo.ResolvedServerName != ServerProvidedFailOverPartner)                      {                          failoverServerInfo.SetDerivedNames(string.Empty' ServerProvidedFailOverPartner);                      }                      currentServerInfo = failoverServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Failover);                  }                  else                  {                      currentServerInfo = primaryServerInfo;                      _timeoutErrorInternal.SetInternalSourceType(SqlConnectionInternalSourceType.Principle);                  }                    try                  {                      // Attempt login.  Use timerInterval for attempt timeout unless infinite timeout was requested.                      AttemptOneLogin(                              currentServerInfo'                          false'          // Use timeout in SniOpen                              intervalTimer'                              withFailover: true                              );                        if (_routingInfo != null)                      {                          // We are in login with failover scenation and server sent routing information                          // If it is read-only routing - we did not supply AppIntent=RO (it should be checked before)                          // If it is something else' not known yet (future server) - this client is not designed to support this.                                              // In any case' server should not have sent the routing info.                          throw SQL.ROR_UnexpectedRoutingInfo(this);                      }                        break; // leave the while loop -- we've successfully connected                  }                  catch (SqlException sqlex)                  {                      if (IsDoNotRetryConnectError(sqlex)                              || timeout.IsExpired)                      {       // no more time to try again                          throw;  // Caller will call LoginFailure()                      }                        if (IsConnectionDoomed)                      {                          throw;                      }                        if (1 == attemptNumber % 2)                      {                          // Check sleep interval to make sure we won't exceed the original timeout                          //  Do this in the catch block so we can re-throw the current exception                          if (timeout.MillisecondsRemaining <= sleepInterval)                          {                              throw;                          }                      }                  }                    // We only get here when we failed to connect' but are going to re-try                    // After trying to connect to both servers fails' sleep for a bit to prevent clogging                   //  the network with requests' then update sleep interval for next iteration (max 1 second interval)                  if (1 == attemptNumber % 2)                  {                      Thread.Sleep(sleepInterval);                      sleepInterval = (sleepInterval < 500) ? sleepInterval * 2 : 1000;                  }                    // Update attempt number and target host                  attemptNumber++;                  useFailoverHost = !useFailoverHost;              }
Magic Number,System.Data.SqlClient,SqlInternalConnectionTds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlInternalConnectionTds.cs,OnFeatureExtAck,The following statement contains a magic number: switch (featureId)              {                  case TdsEnums.FEATUREEXT_SRECOVERY:                      {                          // Session recovery not requested                          if (!_sessionRecoveryRequested)                          {                              throw SQL.ParsingError();                          }                          _sessionRecoveryAcknowledged = true;    #if DEBUG                          foreach (var s in _currentSessionData._delta)                          {                              Debug.Assert(s == null' "Delta should be null at this point");                          }  #endif                          Debug.Assert(_currentSessionData._unrecoverableStatesCount == 0' "Unrecoverable states count should be 0");                            int i = 0;                          while (i < data.Length)                          {                              byte stateId = data[i]; i++;                              int len;                              byte bLen = data[i]; i++;                              if (bLen == 0xFF)                              {                                  len = BitConverter.ToInt32(data' i); i += 4;                              }                              else                              {                                  len = bLen;                              }                              byte[] stateData = new byte[len];                              Buffer.BlockCopy(data' i' stateData' 0' len); i += len;                              if (_recoverySessionData == null)                              {                                  _currentSessionData._initialState[stateId] = stateData;                              }                              else                              {                                  _currentSessionData._delta[stateId] = new SessionStateRecord { _data = stateData' _dataLength = len' _recoverable = true' _version = 0 };                                  _currentSessionData._deltaDirty = true;                              }                          }                          break;                      }                    case TdsEnums.FEATUREEXT_GLOBALTRANSACTIONS:                      {                          if (data.Length < 1)                          {                              throw SQL.ParsingError();                          }                            IsGlobalTransaction = true;                          if (1 == data[0])                          {                              IsGlobalTransactionsEnabledForServer = true;                          }                          break;                      }                    default:                      {                          // Unknown feature ack                           throw SQL.ParsingError();                      }              }
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int columnSizeIndex = 10;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int isFixedLengthIndex = 9;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int isNullableIndex = 8;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int versionMajorIndex = 2;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int versionMinorIndex = 3;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int versionBuildIndex = 4;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int versionRevisionIndex = 5;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int cultureInfoIndex = 6;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: const int publicKeyIndex = 7;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,addUDTsToDataTypesTable,The following statement contains a magic number: using (IDataReader reader = command.ExecuteReader())              {                    object[] values = new object[11];                  while (reader.Read())                  {                        reader.GetValues(values);                      newRow = dataTypesTable.NewRow();                        newRow[providerDbtype] = SqlDbType.Udt;                        if (values[columnSizeIndex] != DBNull.Value)                      {                          newRow[columnSize] = values[columnSizeIndex];                      }                        if (values[isFixedLengthIndex] != DBNull.Value)                      {                          newRow[isFixedLength] = values[isFixedLengthIndex];                      }                        newRow[isSearchable] = true;                      newRow[isLiteralSupported] = false;                      if (values[isNullableIndex] != DBNull.Value)                      {                          newRow[isNullable] = values[isNullableIndex];                      }                        if ((values[assemblyNameIndex] != DBNull.Value) &&                          (values[assemblyClassIndex] != DBNull.Value) &&                          (values[versionMajorIndex] != DBNull.Value) &&                          (values[versionMinorIndex] != DBNull.Value) &&                          (values[versionBuildIndex] != DBNull.Value) &&                          (values[versionRevisionIndex] != DBNull.Value))                      {                            StringBuilder nameString = new StringBuilder();                          nameString.Append(values[assemblyClassIndex].ToString());                          nameString.Append("' ");                          nameString.Append(values[assemblyNameIndex].ToString());                          nameString.Append("' Version=");                            nameString.Append(values[versionMajorIndex].ToString());                          nameString.Append(".");                          nameString.Append(values[versionMinorIndex].ToString());                          nameString.Append(".");                          nameString.Append(values[versionBuildIndex].ToString());                          nameString.Append(".");                          nameString.Append(values[versionRevisionIndex].ToString());                            if (values[cultureInfoIndex] != DBNull.Value)                          {                              nameString.Append("' Culture=");                              nameString.Append(values[cultureInfoIndex].ToString());                          }                            if (values[publicKeyIndex] != DBNull.Value)                          {                                nameString.Append("' PublicKeyToken=");                                StringBuilder resultString = new StringBuilder();                              Byte[] byteArrayValue = (Byte[])values[publicKeyIndex];                              foreach (byte b in byteArrayValue)                              {                                  resultString.Append(String.Format((IFormatProvider)null' "{0'-2:x2}"' b));                              }                              nameString.Append(resultString.ToString());                          }                            newRow[typeName] = nameString.ToString();                          dataTypesTable.Rows.Add(newRow);                          newRow.AcceptChanges();                      } // if assembly name                    }//end while              }
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,AddTVPsToDataTypesTable,The following statement contains a magic number: const int columnSizeIndex = 2;
Magic Number,System.Data.SqlClient,SqlMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlMetadataFactory.cs,AddTVPsToDataTypesTable,The following statement contains a magic number: using (IDataReader reader = command.ExecuteReader())              {                    object[] values = new object[11];                  while (reader.Read())                  {                        reader.GetValues(values);                      newRow = dataTypesTable.NewRow();                        newRow[providerDbtype] = SqlDbType.Structured;                        if (values[columnSizeIndex] != DBNull.Value)                      {                          newRow[columnSize] = values[columnSizeIndex];                      }                        newRow[isSearchable] = false;                      newRow[isLiteralSupported] = false;                      if (values[isNullableIndex] != DBNull.Value)                      {                          newRow[isNullable] = values[isNullableIndex];                      }                        if (values[typeNameIndex] != DBNull.Value)                      {                          newRow[typeName] = values[typeNameIndex];                          dataTypesTable.Rows.Add(newRow);                          newRow.AcceptChanges();                      } // if type name                  }//end while              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The following statement contains a magic number: if (SqlDbType.Xml == mt.SqlDbType)              {                  typeSpecificNamePart1 = this.XmlSchemaCollectionDatabase;                  typeSpecificNamePart2 = this.XmlSchemaCollectionOwningSchema;                  typeSpecificNamePart3 = this.XmlSchemaCollectionName;              }              else if (SqlDbType.Udt == mt.SqlDbType || (SqlDbType.Structured == mt.SqlDbType && !string.IsNullOrEmpty(this.TypeName)))              {                  // Split the input name. The type name is specified as single 3 part name.                  // NOTE: ParseTypeName throws if format is incorrect                  String[] names;                  if (SqlDbType.Udt == mt.SqlDbType)                  {                      names = ParseTypeName(UdtTypeName' true /* is UdtTypeName */);                  }                  else                  {                      names = ParseTypeName(this.TypeName' false /* not UdtTypeName */);                  }                    if (1 == names.Length)                  {                      typeSpecificNamePart3 = names[0];                  }                  else if (2 == names.Length)                  {                      typeSpecificNamePart2 = names[0];                      typeSpecificNamePart3 = names[1];                  }                  else if (3 == names.Length)                  {                      typeSpecificNamePart1 = names[0];                      typeSpecificNamePart2 = names[1];                      typeSpecificNamePart3 = names[2];                  }                  else                  {                      throw ADP.ArgumentOutOfRange(nameof(names));                  }                    if ((!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length))                  {                      throw ADP.ArgumentOutOfRange(nameof(names));                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The following statement contains a magic number: if (SqlDbType.Xml == mt.SqlDbType)              {                  typeSpecificNamePart1 = this.XmlSchemaCollectionDatabase;                  typeSpecificNamePart2 = this.XmlSchemaCollectionOwningSchema;                  typeSpecificNamePart3 = this.XmlSchemaCollectionName;              }              else if (SqlDbType.Udt == mt.SqlDbType || (SqlDbType.Structured == mt.SqlDbType && !string.IsNullOrEmpty(this.TypeName)))              {                  // Split the input name. The type name is specified as single 3 part name.                  // NOTE: ParseTypeName throws if format is incorrect                  String[] names;                  if (SqlDbType.Udt == mt.SqlDbType)                  {                      names = ParseTypeName(UdtTypeName' true /* is UdtTypeName */);                  }                  else                  {                      names = ParseTypeName(this.TypeName' false /* not UdtTypeName */);                  }                    if (1 == names.Length)                  {                      typeSpecificNamePart3 = names[0];                  }                  else if (2 == names.Length)                  {                      typeSpecificNamePart2 = names[0];                      typeSpecificNamePart3 = names[1];                  }                  else if (3 == names.Length)                  {                      typeSpecificNamePart1 = names[0];                      typeSpecificNamePart2 = names[1];                      typeSpecificNamePart3 = names[2];                  }                  else                  {                      throw ADP.ArgumentOutOfRange(nameof(names));                  }                    if ((!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length))                  {                      throw ADP.ArgumentOutOfRange(nameof(names));                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,MetaDataForSmi,The following statement contains a magic number: if (SqlDbType.Xml == mt.SqlDbType)              {                  typeSpecificNamePart1 = this.XmlSchemaCollectionDatabase;                  typeSpecificNamePart2 = this.XmlSchemaCollectionOwningSchema;                  typeSpecificNamePart3 = this.XmlSchemaCollectionName;              }              else if (SqlDbType.Udt == mt.SqlDbType || (SqlDbType.Structured == mt.SqlDbType && !string.IsNullOrEmpty(this.TypeName)))              {                  // Split the input name. The type name is specified as single 3 part name.                  // NOTE: ParseTypeName throws if format is incorrect                  String[] names;                  if (SqlDbType.Udt == mt.SqlDbType)                  {                      names = ParseTypeName(UdtTypeName' true /* is UdtTypeName */);                  }                  else                  {                      names = ParseTypeName(this.TypeName' false /* not UdtTypeName */);                  }                    if (1 == names.Length)                  {                      typeSpecificNamePart3 = names[0];                  }                  else if (2 == names.Length)                  {                      typeSpecificNamePart2 = names[0];                      typeSpecificNamePart3 = names[1];                  }                  else if (3 == names.Length)                  {                      typeSpecificNamePart1 = names[0];                      typeSpecificNamePart2 = names[1];                      typeSpecificNamePart3 = names[2];                  }                  else                  {                      throw ADP.ArgumentOutOfRange(nameof(names));                  }                    if ((!string.IsNullOrEmpty(typeSpecificNamePart1) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart1.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart2) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart2.Length)                      || (!string.IsNullOrEmpty(typeSpecificNamePart3) && TdsEnums.MAX_SERVERNAME < typeSpecificNamePart3.Length))                  {                      throw ADP.ArgumentOutOfRange(nameof(names));                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualSize,The following statement contains a magic number: if ((_actualSize == -1) || (actualType == Data.SqlDbType.Udt))              {                  _actualSize = 0;                  object val = GetCoercedValue();                  bool isSqlVariant = false;                    if (IsNull && !mt.IsVarTime)                  {                      return 0;                  }                    // if this is a backend SQLVariant type' then infer the TDS type from the SQLVariant type                  if (actualType == SqlDbType.Variant)                  {                      mt = MetaType.GetMetaTypeFromValue(val' streamAllowed: false);                      actualType = MetaType.GetSqlDataType(mt.TDSType' 0 /*no user type*/' 0 /*non-nullable type*/).SqlDbType;                      isSqlVariant = true;                  }                    if (mt.IsFixed)                  {                      _actualSize = mt.FixedLength;                  }                  else                  {                      // @hack: until we have ForceOffset behavior we have the following semantics:                      // @hack: if the user supplies a Size through the Size property or constructor'                      // @hack: we only send a MAX of Size bytes over.  If the actualSize is < Size' then                      // @hack: we send over actualSize                      int coercedSize = 0;                        // get the actual length of the data' in bytes                      switch (actualType)                      {                          case SqlDbType.NChar:                          case SqlDbType.NVarChar:                          case SqlDbType.NText:                          case SqlDbType.Xml:                              {                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                                  _actualSize <<= 1;                              }                              break;                          case SqlDbType.Char:                          case SqlDbType.VarChar:                          case SqlDbType.Text:                              {                                  // for these types' ActualSize is the num of chars' not actual bytes - since non-unicode chars are not always uniform size                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                              }                              break;                          case SqlDbType.Binary:                          case SqlDbType.VarBinary:                          case SqlDbType.Image:                          case SqlDbType.Timestamp:                              coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (BinarySize(val' _coercedValueIsSqlType)) : 0;                              _actualSize = (ShouldSerializeSize() ? Size : 0);                              _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                              if (_actualSize == -1)                                  _actualSize = coercedSize;                              break;                          case SqlDbType.Udt:                              if (!IsNull)                              {                                  coercedSize = SerializationHelperSql9.SizeInBytes(val);                              }                              break;                          case SqlDbType.Structured:                              coercedSize = -1;                              break;                          case SqlDbType.Time:                              _actualSize = (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTime2:                              // Date in number of days (3 bytes) + time                              _actualSize = 3 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTimeOffset:                              // Date in days (3 bytes) + offset in minutes (2 bytes) + time                              _actualSize = 5 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          default:                              Debug.Assert(false' "Unknown variable length type!");                              break;                      }                        // don't even send big values over to the variant                      if (isSqlVariant && (coercedSize > TdsEnums.TYPE_SIZE_LIMIT))                          throw SQL.ParameterInvalidVariant(this.ParameterName);                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualSize,The following statement contains a magic number: if ((_actualSize == -1) || (actualType == Data.SqlDbType.Udt))              {                  _actualSize = 0;                  object val = GetCoercedValue();                  bool isSqlVariant = false;                    if (IsNull && !mt.IsVarTime)                  {                      return 0;                  }                    // if this is a backend SQLVariant type' then infer the TDS type from the SQLVariant type                  if (actualType == SqlDbType.Variant)                  {                      mt = MetaType.GetMetaTypeFromValue(val' streamAllowed: false);                      actualType = MetaType.GetSqlDataType(mt.TDSType' 0 /*no user type*/' 0 /*non-nullable type*/).SqlDbType;                      isSqlVariant = true;                  }                    if (mt.IsFixed)                  {                      _actualSize = mt.FixedLength;                  }                  else                  {                      // @hack: until we have ForceOffset behavior we have the following semantics:                      // @hack: if the user supplies a Size through the Size property or constructor'                      // @hack: we only send a MAX of Size bytes over.  If the actualSize is < Size' then                      // @hack: we send over actualSize                      int coercedSize = 0;                        // get the actual length of the data' in bytes                      switch (actualType)                      {                          case SqlDbType.NChar:                          case SqlDbType.NVarChar:                          case SqlDbType.NText:                          case SqlDbType.Xml:                              {                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                                  _actualSize <<= 1;                              }                              break;                          case SqlDbType.Char:                          case SqlDbType.VarChar:                          case SqlDbType.Text:                              {                                  // for these types' ActualSize is the num of chars' not actual bytes - since non-unicode chars are not always uniform size                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                              }                              break;                          case SqlDbType.Binary:                          case SqlDbType.VarBinary:                          case SqlDbType.Image:                          case SqlDbType.Timestamp:                              coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (BinarySize(val' _coercedValueIsSqlType)) : 0;                              _actualSize = (ShouldSerializeSize() ? Size : 0);                              _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                              if (_actualSize == -1)                                  _actualSize = coercedSize;                              break;                          case SqlDbType.Udt:                              if (!IsNull)                              {                                  coercedSize = SerializationHelperSql9.SizeInBytes(val);                              }                              break;                          case SqlDbType.Structured:                              coercedSize = -1;                              break;                          case SqlDbType.Time:                              _actualSize = (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTime2:                              // Date in number of days (3 bytes) + time                              _actualSize = 3 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTimeOffset:                              // Date in days (3 bytes) + offset in minutes (2 bytes) + time                              _actualSize = 5 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          default:                              Debug.Assert(false' "Unknown variable length type!");                              break;                      }                        // don't even send big values over to the variant                      if (isSqlVariant && (coercedSize > TdsEnums.TYPE_SIZE_LIMIT))                          throw SQL.ParameterInvalidVariant(this.ParameterName);                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualSize,The following statement contains a magic number: if ((_actualSize == -1) || (actualType == Data.SqlDbType.Udt))              {                  _actualSize = 0;                  object val = GetCoercedValue();                  bool isSqlVariant = false;                    if (IsNull && !mt.IsVarTime)                  {                      return 0;                  }                    // if this is a backend SQLVariant type' then infer the TDS type from the SQLVariant type                  if (actualType == SqlDbType.Variant)                  {                      mt = MetaType.GetMetaTypeFromValue(val' streamAllowed: false);                      actualType = MetaType.GetSqlDataType(mt.TDSType' 0 /*no user type*/' 0 /*non-nullable type*/).SqlDbType;                      isSqlVariant = true;                  }                    if (mt.IsFixed)                  {                      _actualSize = mt.FixedLength;                  }                  else                  {                      // @hack: until we have ForceOffset behavior we have the following semantics:                      // @hack: if the user supplies a Size through the Size property or constructor'                      // @hack: we only send a MAX of Size bytes over.  If the actualSize is < Size' then                      // @hack: we send over actualSize                      int coercedSize = 0;                        // get the actual length of the data' in bytes                      switch (actualType)                      {                          case SqlDbType.NChar:                          case SqlDbType.NVarChar:                          case SqlDbType.NText:                          case SqlDbType.Xml:                              {                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                                  _actualSize <<= 1;                              }                              break;                          case SqlDbType.Char:                          case SqlDbType.VarChar:                          case SqlDbType.Text:                              {                                  // for these types' ActualSize is the num of chars' not actual bytes - since non-unicode chars are not always uniform size                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                              }                              break;                          case SqlDbType.Binary:                          case SqlDbType.VarBinary:                          case SqlDbType.Image:                          case SqlDbType.Timestamp:                              coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (BinarySize(val' _coercedValueIsSqlType)) : 0;                              _actualSize = (ShouldSerializeSize() ? Size : 0);                              _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                              if (_actualSize == -1)                                  _actualSize = coercedSize;                              break;                          case SqlDbType.Udt:                              if (!IsNull)                              {                                  coercedSize = SerializationHelperSql9.SizeInBytes(val);                              }                              break;                          case SqlDbType.Structured:                              coercedSize = -1;                              break;                          case SqlDbType.Time:                              _actualSize = (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTime2:                              // Date in number of days (3 bytes) + time                              _actualSize = 3 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTimeOffset:                              // Date in days (3 bytes) + offset in minutes (2 bytes) + time                              _actualSize = 5 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          default:                              Debug.Assert(false' "Unknown variable length type!");                              break;                      }                        // don't even send big values over to the variant                      if (isSqlVariant && (coercedSize > TdsEnums.TYPE_SIZE_LIMIT))                          throw SQL.ParameterInvalidVariant(this.ParameterName);                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualSize,The following statement contains a magic number: if ((_actualSize == -1) || (actualType == Data.SqlDbType.Udt))              {                  _actualSize = 0;                  object val = GetCoercedValue();                  bool isSqlVariant = false;                    if (IsNull && !mt.IsVarTime)                  {                      return 0;                  }                    // if this is a backend SQLVariant type' then infer the TDS type from the SQLVariant type                  if (actualType == SqlDbType.Variant)                  {                      mt = MetaType.GetMetaTypeFromValue(val' streamAllowed: false);                      actualType = MetaType.GetSqlDataType(mt.TDSType' 0 /*no user type*/' 0 /*non-nullable type*/).SqlDbType;                      isSqlVariant = true;                  }                    if (mt.IsFixed)                  {                      _actualSize = mt.FixedLength;                  }                  else                  {                      // @hack: until we have ForceOffset behavior we have the following semantics:                      // @hack: if the user supplies a Size through the Size property or constructor'                      // @hack: we only send a MAX of Size bytes over.  If the actualSize is < Size' then                      // @hack: we send over actualSize                      int coercedSize = 0;                        // get the actual length of the data' in bytes                      switch (actualType)                      {                          case SqlDbType.NChar:                          case SqlDbType.NVarChar:                          case SqlDbType.NText:                          case SqlDbType.Xml:                              {                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                                  _actualSize <<= 1;                              }                              break;                          case SqlDbType.Char:                          case SqlDbType.VarChar:                          case SqlDbType.Text:                              {                                  // for these types' ActualSize is the num of chars' not actual bytes - since non-unicode chars are not always uniform size                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                              }                              break;                          case SqlDbType.Binary:                          case SqlDbType.VarBinary:                          case SqlDbType.Image:                          case SqlDbType.Timestamp:                              coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (BinarySize(val' _coercedValueIsSqlType)) : 0;                              _actualSize = (ShouldSerializeSize() ? Size : 0);                              _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                              if (_actualSize == -1)                                  _actualSize = coercedSize;                              break;                          case SqlDbType.Udt:                              if (!IsNull)                              {                                  coercedSize = SerializationHelperSql9.SizeInBytes(val);                              }                              break;                          case SqlDbType.Structured:                              coercedSize = -1;                              break;                          case SqlDbType.Time:                              _actualSize = (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTime2:                              // Date in number of days (3 bytes) + time                              _actualSize = 3 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTimeOffset:                              // Date in days (3 bytes) + offset in minutes (2 bytes) + time                              _actualSize = 5 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          default:                              Debug.Assert(false' "Unknown variable length type!");                              break;                      }                        // don't even send big values over to the variant                      if (isSqlVariant && (coercedSize > TdsEnums.TYPE_SIZE_LIMIT))                          throw SQL.ParameterInvalidVariant(this.ParameterName);                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,GetActualSize,The following statement contains a magic number: if ((_actualSize == -1) || (actualType == Data.SqlDbType.Udt))              {                  _actualSize = 0;                  object val = GetCoercedValue();                  bool isSqlVariant = false;                    if (IsNull && !mt.IsVarTime)                  {                      return 0;                  }                    // if this is a backend SQLVariant type' then infer the TDS type from the SQLVariant type                  if (actualType == SqlDbType.Variant)                  {                      mt = MetaType.GetMetaTypeFromValue(val' streamAllowed: false);                      actualType = MetaType.GetSqlDataType(mt.TDSType' 0 /*no user type*/' 0 /*non-nullable type*/).SqlDbType;                      isSqlVariant = true;                  }                    if (mt.IsFixed)                  {                      _actualSize = mt.FixedLength;                  }                  else                  {                      // @hack: until we have ForceOffset behavior we have the following semantics:                      // @hack: if the user supplies a Size through the Size property or constructor'                      // @hack: we only send a MAX of Size bytes over.  If the actualSize is < Size' then                      // @hack: we send over actualSize                      int coercedSize = 0;                        // get the actual length of the data' in bytes                      switch (actualType)                      {                          case SqlDbType.NChar:                          case SqlDbType.NVarChar:                          case SqlDbType.NText:                          case SqlDbType.Xml:                              {                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                                  _actualSize <<= 1;                              }                              break;                          case SqlDbType.Char:                          case SqlDbType.VarChar:                          case SqlDbType.Text:                              {                                  // for these types' ActualSize is the num of chars' not actual bytes - since non-unicode chars are not always uniform size                                  coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (StringSize(val' _coercedValueIsSqlType)) : 0;                                  _actualSize = (ShouldSerializeSize() ? Size : 0);                                  _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                                  if (_actualSize == -1)                                      _actualSize = coercedSize;                              }                              break;                          case SqlDbType.Binary:                          case SqlDbType.VarBinary:                          case SqlDbType.Image:                          case SqlDbType.Timestamp:                              coercedSize = ((!_isNull) && (!_coercedValueIsDataFeed)) ? (BinarySize(val' _coercedValueIsSqlType)) : 0;                              _actualSize = (ShouldSerializeSize() ? Size : 0);                              _actualSize = ((ShouldSerializeSize() && (_actualSize <= coercedSize)) ? _actualSize : coercedSize);                              if (_actualSize == -1)                                  _actualSize = coercedSize;                              break;                          case SqlDbType.Udt:                              if (!IsNull)                              {                                  coercedSize = SerializationHelperSql9.SizeInBytes(val);                              }                              break;                          case SqlDbType.Structured:                              coercedSize = -1;                              break;                          case SqlDbType.Time:                              _actualSize = (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTime2:                              // Date in number of days (3 bytes) + time                              _actualSize = 3 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          case SqlDbType.DateTimeOffset:                              // Date in days (3 bytes) + offset in minutes (2 bytes) + time                              _actualSize = 5 + (isSqlVariant ? 5 : MetaType.GetTimeSizeFromScale(GetActualScale()));                              break;                          default:                              Debug.Assert(false' "Unknown variable length type!");                              break;                      }                        // don't even send big values over to the variant                      if (isSqlVariant && (coercedSize > TdsEnums.TYPE_SIZE_LIMIT))                          throw SQL.ParameterInvalidVariant(this.ParameterName);                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ParseTypeName,The following statement contains a magic number: try              {                  string errorMsg = isUdtTypeName ? SR.SQL_UDTTypeName : SR.SQL_TypeName;                  return MultipartIdentifier.ParseMultipartIdentifier(typeName' "[\""' "]\""' '.'' 3' true' errorMsg' true);              }              catch (ArgumentException)              {                  if (isUdtTypeName)                  {                      throw SQL.InvalidUdt3PartNameFormat();                  }                  else                  {                      throw SQL.InvalidParameterTypeNameFormat();                  }              }
Magic Number,System.Data.SqlClient,SqlParameter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ValueScaleCore,The following statement contains a magic number: if (value is Decimal)              {                  return (byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10);              }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: if (p.ShouldSerializeSize())                  {                      flags |= 2;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: if (!string.IsNullOrEmpty(p.SourceColumn))                  {                      flags |= 4;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: if (null != p.Value)                  {                      flags |= 8;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: if ((ParameterDirection.Input != p.Direction) || p.IsNullable                      || p.ShouldSerializePrecision() || p.ShouldSerializeScale()                      || (DataRowVersion.Current != p.SourceVersion)                      )                  {                      flags |= 16; // v1.0 everything                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: if (p.SourceColumnNullMapping || !string.IsNullOrEmpty(p.XmlSchemaCollectionDatabase) ||                      !string.IsNullOrEmpty(p.XmlSchemaCollectionOwningSchema) || !string.IsNullOrEmpty(p.XmlSchemaCollectionName))                  {                      flags |= 32; // v2.0 everything                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlParameterConverter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlParameter.cs,ConvertToInstanceDescriptor,The following statement contains a magic number: switch (flags)                  {                      case 0: // ParameterName                      case 1: // SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType };                          break;                      case 2: // Size                      case 3: // Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size };                          break;                      case 4: // SourceColumn                      case 5: // SourceColumn' SqlDbType                      case 6: // SourceColumn' Size                      case 7: // SourceColumn' Size' SqlDbType                          ctorParams = new Type[] { typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(string) };                          ctorValues = new object[] { p.ParameterName' p.SqlDbType' p.Size' p.SourceColumn };                          break;                      case 8: // Value                          ctorParams = new Type[] { typeof(string)' typeof(object) };                          ctorValues = new object[] { p.ParameterName' p.Value };                          break;                      default:                          if (0 == (32 & flags))                          { // v1.0 everything                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(bool)' typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)'                                                      typeof(object) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.IsNullable' p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion'                                                        p.Value };                          }                          else                          { // v2.0 everything - round trip all browsable properties + precision/scale                              ctorParams = new Type[] {                                                      typeof(string)' typeof(SqlDbType)' typeof(int)' typeof(ParameterDirection)'                                                      typeof(byte)' typeof(byte)'                                                      typeof(string)' typeof(DataRowVersion)' typeof(bool)'                                                      typeof(object)'                                                      typeof(string)' typeof(string)'                                                      typeof(string) };                              ctorValues = new object[] {                                                        p.ParameterName' p.SqlDbType'  p.Size' p.Direction'                                                        p.PrecisionInternal' p.ScaleInternal'                                                        p.SourceColumn' p.SourceVersion' p.SourceColumnNullMapping'                                                        p.Value'                                                        p.XmlSchemaCollectionDatabase' p.XmlSchemaCollectionOwningSchema'                                                        p.XmlSchemaCollectionName};                          }                          break;                  }
Magic Number,System.Data.SqlClient,SqlUnicodeEncoding,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,GetMaxByteCount,The following statement contains a magic number: return charCount * 2;
Magic Number,System.Data.SqlClient,SqlUnicodeDecoder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,GetCharCount,The following statement contains a magic number: return count / 2;
Magic Number,System.Data.SqlClient,SqlUnicodeDecoder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,Convert,The following statement contains a magic number: charsUsed = Math.Min(charCount' byteCount / 2);
Magic Number,System.Data.SqlClient,SqlUnicodeDecoder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,Convert,The following statement contains a magic number: bytesUsed = charsUsed * 2;
Magic Number,System.Data.SqlClient,SqlUnicodeDecoder,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlSequentialTextReader.cs,Convert,The following statement contains a magic number: Buffer.BlockCopy(bytes' byteIndex' chars' charIndex * 2' bytesUsed);
Magic Number,System.Data.SqlClient,SqlStatistics,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStatistics.cs,GetDictionary,The following statement contains a magic number: const int Count = 18;
Magic Number,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,Read,The following statement contains a magic number: if (_bom > 0)              {                  // Read and buffer the first two bytes                  _bufferedData = new byte[2];                  cBufferedData = ReadBytes(_bufferedData' 0' 2);                  // Check to se if we should add the byte order mark                  if ((cBufferedData < 2) || ((_bufferedData[0] == 0xDF) && (_bufferedData[1] == 0xFF)))                  {                      _bom = 0;                  }                  while (count > 0)                  {                      if (_bom > 0)                      {                          buffer[offset] = (byte)_bom;                          _bom >>= 8;                          offset++;                          count--;                          intCount++;                      }                      else                      {                          break;                      }                  }              }
Magic Number,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,Read,The following statement contains a magic number: if (_bom > 0)              {                  // Read and buffer the first two bytes                  _bufferedData = new byte[2];                  cBufferedData = ReadBytes(_bufferedData' 0' 2);                  // Check to se if we should add the byte order mark                  if ((cBufferedData < 2) || ((_bufferedData[0] == 0xDF) && (_bufferedData[1] == 0xFF)))                  {                      _bom = 0;                  }                  while (count > 0)                  {                      if (_bom > 0)                      {                          buffer[offset] = (byte)_bom;                          _bom >>= 8;                          offset++;                          count--;                          intCount++;                      }                      else                      {                          break;                      }                  }              }
Magic Number,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,Read,The following statement contains a magic number: if (_bom > 0)              {                  // Read and buffer the first two bytes                  _bufferedData = new byte[2];                  cBufferedData = ReadBytes(_bufferedData' 0' 2);                  // Check to se if we should add the byte order mark                  if ((cBufferedData < 2) || ((_bufferedData[0] == 0xDF) && (_bufferedData[1] == 0xFF)))                  {                      _bom = 0;                  }                  while (count > 0)                  {                      if (_bom > 0)                      {                          buffer[offset] = (byte)_bom;                          _bom >>= 8;                          offset++;                          count--;                          intCount++;                      }                      else                      {                          break;                      }                  }              }
Magic Number,System.Data.SqlClient,SqlStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,Read,The following statement contains a magic number: if (_bom > 0)              {                  // Read and buffer the first two bytes                  _bufferedData = new byte[2];                  cBufferedData = ReadBytes(_bufferedData' 0' 2);                  // Check to se if we should add the byte order mark                  if ((cBufferedData < 2) || ((_bufferedData[0] == 0xDF) && (_bufferedData[1] == 0xFF)))                  {                      _bom = 0;                  }                  while (count > 0)                  {                      if (_bom > 0)                      {                          buffer[offset] = (byte)_bom;                          _bom >>= 8;                          offset++;                          count--;                          intCount++;                      }                      else                      {                          break;                      }                  }              }
Magic Number,System.Data.SqlClient,SqlStreamingXml,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,WriteXmlElement,The following statement contains a magic number: const int WriteNodeBufferSize = 1024;
Magic Number,System.Data.SqlClient,AsyncHelper,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,WaitForCompletion,The following statement contains a magic number: try              {                  task.Wait(timeout > 0 ? (1000 * timeout) : Timeout.Infinite);              }              catch (AggregateException ae)              {                  if (rethrowExceptions)                  {                      Debug.Assert(ae.InnerExceptions.Count == 1' "There is more than one exception in AggregateException");                      ExceptionDispatchInfo.Capture(ae.InnerException).Throw();                  }              }
Magic Number,System.Data.SqlClient,AsyncHelper,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlUtil.cs,SetTimeoutException,The following statement contains a magic number: if (timeout > 0)              {                  Task.Delay(timeout * 1000' ctoken).ContinueWith((tsk) =>                  {                      if (!tsk.IsCanceled && !completion.Task.IsCompleted)                      {                          completion.TrySetException(exc());                      }                  });              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: int offset = (int)PreLoginOptions.NUMOPT * 5 + 1;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: byte[] payload = new byte[(int)PreLoginOptions.NUMOPT * 5 + TdsEnums.MAX_PRELOGIN_PAYLOAD_LENGTH];
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,SendPreLoginHandshake,The following statement contains a magic number: for (int option = (int)PreLoginOptions.VERSION; option < (int)PreLoginOptions.NUMOPT; option++)              {                  int optionDataSize = 0;                    // Fill in the option                  _physicalStateObj.WriteByte((byte)option);                    // Fill in the offset of the option data                  _physicalStateObj.WriteByte((byte)((offset & 0xff00) >> 8)); // send upper order byte                  _physicalStateObj.WriteByte((byte)(offset & 0x00ff)); // send lower order byte                    switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          Version systemDataVersion = ADP.GetAssemblyVersion();                            // Major and minor                          payload[payloadLength++] = (byte)(systemDataVersion.Major & 0xff);                          payload[payloadLength++] = (byte)(systemDataVersion.Minor & 0xff);                            // Build (Big Endian)                          payload[payloadLength++] = (byte)((systemDataVersion.Build & 0xff00) >> 8);                          payload[payloadLength++] = (byte)(systemDataVersion.Build & 0xff);                            // Sub-build (Little Endian)                          payload[payloadLength++] = (byte)(systemDataVersion.Revision & 0xff);                          payload[payloadLength++] = (byte)((systemDataVersion.Revision & 0xff00) >> 8);                          offset += 6;                          optionDataSize = 6;                          break;                        case (int)PreLoginOptions.ENCRYPT:                          if (_encryptionOption == EncryptionOptions.NOT_SUP)                          {                              // If OS doesn't support encryption' inform server not supported.                              payload[payloadLength] = (byte)EncryptionOptions.NOT_SUP;                          }                          else                          {                              // Else' inform server of user request.                              if (encrypt)                              {                                  payload[payloadLength] = (byte)EncryptionOptions.ON;                                  _encryptionOption = EncryptionOptions.ON;                              }                              else                              {                                  payload[payloadLength] = (byte)EncryptionOptions.OFF;                                  _encryptionOption = EncryptionOptions.OFF;                              }                          }                            payloadLength += 1;                          offset += 1;                          optionDataSize = 1;                          break;                        case (int)PreLoginOptions.INSTANCE:                          int i = 0;                            while (instanceName[i] != 0)                          {                              payload[payloadLength] = instanceName[i];                              payloadLength++;                              i++;                          }                            payload[payloadLength] = 0; // null terminate                          payloadLength++;                          i++;                            offset += i;                          optionDataSize = i;                          break;                        case (int)PreLoginOptions.THREADID:                          Int32 threadID = TdsParserStaticMethods.GetCurrentThreadIdForTdsLoginOnly();                            payload[payloadLength++] = (byte)((0xff000000 & threadID) >> 24);                          payload[payloadLength++] = (byte)((0x00ff0000 & threadID) >> 16);                          payload[payloadLength++] = (byte)((0x0000ff00 & threadID) >> 8);                          payload[payloadLength++] = (byte)(0x000000ff & threadID);                          offset += 4;                          optionDataSize = 4;                          break;                        case (int)PreLoginOptions.MARS:                          payload[payloadLength++] = (byte)(_fMARS ? 1 : 0);                          offset += 1;                          optionDataSize += 1;                          break;                        case (int)PreLoginOptions.TRACEID:                          byte[] connectionIdBytes = _connHandler._clientConnectionId.ToByteArray();                          Debug.Assert(GUID_SIZE == connectionIdBytes.Length);                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          offset += GUID_SIZE;                          optionDataSize = GUID_SIZE;                            ActivityCorrelator.ActivityId actId = ActivityCorrelator.Next();                          connectionIdBytes = actId.Id.ToByteArray();                          Buffer.BlockCopy(connectionIdBytes' 0' payload' payloadLength' GUID_SIZE);                          payloadLength += GUID_SIZE;                          payload[payloadLength++] = (byte)(0x000000ff & actId.Sequence);                          payload[payloadLength++] = (byte)((0x0000ff00 & actId.Sequence) >> 8);                          payload[payloadLength++] = (byte)((0x00ff0000 & actId.Sequence) >> 16);                          payload[payloadLength++] = (byte)((0xff000000 & actId.Sequence) >> 24);                          int actIdSize = GUID_SIZE + sizeof(UInt32);                          offset += actIdSize;                          optionDataSize += actIdSize;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in SendPreLoginHandshake");                          break;                  }                    // Write data length                  _physicalStateObj.WriteByte((byte)((optionDataSize & 0xff00) >> 8));                  _physicalStateObj.WriteByte((byte)(optionDataSize & 0x00ff));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ConsumePreLoginHandshake,The following statement contains a magic number: while (option != (byte)PreLoginOptions.LASTOPT)              {                  switch (option)                  {                      case (int)PreLoginOptions.VERSION:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte majorVersion = payload[payloadOffset];                          byte minorVersion = payload[payloadOffset + 1];                          int level = (payload[payloadOffset + 2] << 8) |                                               payload[payloadOffset + 3];                            isYukonOrLater = majorVersion >= 9;                          if (!isYukonOrLater)                          {                              marsCapable = false;            // If pre-Yukon' MARS not supported.                          }                            break;                        case (int)PreLoginOptions.ENCRYPT:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            EncryptionOptions serverOption = (EncryptionOptions)payload[payloadOffset];                            /* internal enum EncryptionOptions {                              OFF'                              ON'                              NOT_SUP'                              REQ'                              LOGIN                          } */                            switch (_encryptionOption)                          {                              case (EncryptionOptions.ON):                                  if (serverOption == EncryptionOptions.NOT_SUP)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByServer()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                case (EncryptionOptions.OFF):                                  if (serverOption == EncryptionOptions.OFF)                                  {                                      // Only encrypt login.                                      _encryptionOption = EncryptionOptions.LOGIN;                                  }                                  else if (serverOption == EncryptionOptions.REQ)                                  {                                      // Encrypt all.                                      _encryptionOption = EncryptionOptions.ON;                                  }                                    break;                                case (EncryptionOptions.NOT_SUP):                                  if (serverOption == EncryptionOptions.REQ)                                  {                                      _physicalStateObj.AddError(new SqlError(TdsEnums.ENCRYPTION_NOT_SUPPORTED' (byte)0x00' TdsEnums.FATAL_ERROR_CLASS' _server' SQLMessage.EncryptionNotSupportedByClient()' ""' 0));                                      _physicalStateObj.Dispose();                                      ThrowExceptionAndWarning(_physicalStateObj);                                  }                                    break;                                default:                                  Debug.Assert(false' "Invalid client encryption option detected");                                  break;                          }                            if (_encryptionOption == EncryptionOptions.ON ||                              _encryptionOption == EncryptionOptions.LOGIN)                          {                              UInt32 error = 0;                              UInt32 info = ((encrypt && !trustServerCert) ? TdsEnums.SNI_SSL_VALIDATE_CERTIFICATE : 0)                                  | (isYukonOrLater ? TdsEnums.SNI_SSL_USE_SCHANNEL_CACHE : 0);                                if (encrypt && !integratedSecurity)                              {                                  // optimization: in case of SQL Authentication and encryption' set SNI_SSL_IGNORE_CHANNEL_BINDINGS to let SNI                                   // know that it does not need to allocate/retrieve the Channel Bindings from the SSL context.                                  // This applies to Native SNI                                   info |= TdsEnums.SNI_SSL_IGNORE_CHANNEL_BINDINGS;                              }                                error = _physicalStateObj.EnableSsl(ref info);                                if (error != TdsEnums.SNI_SUCCESS)                              {                                  _physicalStateObj.AddError(ProcessSNIError(_physicalStateObj));                                  ThrowExceptionAndWarning(_physicalStateObj);                              }                                WaitForSSLHandShakeToComplete(ref error);                                                            // create a new packet encryption changes the internal packet size                              _physicalStateObj.ClearAllWritePackets();                          }                            break;                        case (int)PreLoginOptions.INSTANCE:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            byte ERROR_INST = 0x1;                          byte instanceResult = payload[payloadOffset];                            if (instanceResult == ERROR_INST)                          {                              // Check if server says ERROR_INST. That either means the cached info                              // we used to connect is not valid or we connected to a named instance                              // listening on default params.                              return PreLoginHandshakeStatus.InstanceFailure;                          }                            break;                        case (int)PreLoginOptions.THREADID:                          // DO NOTHING FOR THREADID                          offset += 4;                          break;                        case (int)PreLoginOptions.MARS:                          payloadOffset = payload[offset++] << 8 | payload[offset++];                          payloadLength = payload[offset++] << 8 | payload[offset++];                            marsCapable = (payload[payloadOffset] == 0 ? false : true);                            Debug.Assert(payload[payloadOffset] == 0 || payload[payloadOffset] == 1' "Value for Mars PreLoginHandshake option not equal to 1 or 0!");                          break;                        case (int)PreLoginOptions.TRACEID:                          // DO NOTHING FOR TRACEID                          offset += 4;                          break;                        default:                          Debug.Assert(false' "UNKNOWN option in ConsumePreLoginHandshake' option:" + option);                            // DO NOTHING FOR THESE UNKNOWN OPTIONS                          offset += 4;                            break;                  }                    if (offset < payload.Length)                  {                      option = payload[offset++];                  }                  else                  {                      break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The following statement contains a magic number: if (details.sniErrorNumber == 0)              {                  // Provider error. The message from provider is preceded with non-localizable info from SNI                  // strip provider info from SNI                  //                  int iColon = errorMessage.IndexOf(':');                  Debug.Assert(0 <= iColon' "':' character missing in sni errorMessage");                  Debug.Assert(errorMessage.Length > iColon + 1 && errorMessage[iColon + 1] == ' '' "Expecting a space after the ':' character");                    // extract the message excluding the colon and trailing cr/lf chars                  if (0 <= iColon)                  {                      int len = errorMessage.Length;                      len -= Environment.NewLine.Length; // exclude newline sequence                      iColon += 2;  // skip over ": " sequence                      len -= iColon;                      /*                          The error message should come back in the following format: "TCP Provider: MESSAGE TEXT"                          If the message is received on a Win9x OS' the error message will not contain MESSAGE TEXT                           If we get an error message with no message text' just return the entire message otherwise                           return just the message text.                      */                      if (len > 0)                      {                          errorMessage = errorMessage.Substring(iColon' len);                      }                  }              }              else              {                    if (TdsParserStateObjectFactory.UseManagedSNI)                  {                      // SNI error. Append additional error message info if available.                      //                      string sniLookupMessage = SQL.GetSNIErrorMessage((int)details.sniErrorNumber);                      errorMessage = (errorMessage != string.Empty) ?                                      (sniLookupMessage + ": " + errorMessage) :                                      sniLookupMessage;                  }                  else                  {                      // SNI error. Replace the entire message.                      //                      errorMessage = SQL.GetSNIErrorMessage((int)details.sniErrorNumber);                        // If its a LocalDB error' then nativeError actually contains a LocalDB-specific error code' not a win32 error code                      if (details.sniErrorNumber == (int)SNINativeMethodWrapper.SniSpecialErrors.LocalDBErrorCode)                      {                          errorMessage += LocalDBAPI.GetLocalDBMessage((int)details.nativeError);                          win32ErrorCode = 0;                      }                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,CheckResetConnection,The following statement contains a magic number: if (_fResetConnection && !stateObj._fResetConnectionSent)              {                  Debug.Assert(stateObj._outputPacketNumber == 1 || stateObj._outputPacketNumber == 2' "In ResetConnection logic unexpectedly!");                  try                  {                      if (_fMARS && !stateObj._fResetEventOwned)                      {                          // If using Async & MARS and we do not own ResetEvent - grab it.  We need to not grab lock here                          // for case where multiple packets are sent to server from one execute.                          stateObj._fResetEventOwned = _resetConnectionEvent.WaitOne(stateObj.GetTimeoutRemaining());                            if (stateObj._fResetEventOwned)                          {                              if (stateObj.TimeoutHasExpired)                              {                                  // We didn't timeout on the WaitOne' but we timed out by the time we decremented stateObj._timeRemaining.                                  stateObj._fResetEventOwned = !_resetConnectionEvent.Set();                                  stateObj.TimeoutTime = 0;                              }                          }                            if (!stateObj._fResetEventOwned)                          {                              // We timed out waiting for ResetEvent.  Throw timeout exception and reset                              // the buffer.  Nothing else to do since we did not actually send anything                              // to the server.                              stateObj.ResetBuffer();                              Debug.Assert(_connHandler != null' "SqlConnectionInternalTds handler can not be null at this point.");                              stateObj.AddError(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' _server' _connHandler.TimeoutErrorInternal.GetErrorMessage()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT));                              Debug.Assert(_connHandler._parserLock.ThreadMayHaveLock()' "Thread is writing without taking the connection lock");                              ThrowExceptionAndWarning(stateObj' callerHasConnectionLock: true);                          }                      }                        if (_fResetConnection)                      {                          // Check again to see if we need to send reset.                            Debug.Assert(!stateObj._fResetConnectionSent' "Unexpected state for sending reset connection");                            if (_fPreserveTransaction)                          {                              // if we are reseting' set bit in header by or'ing with other value                              stateObj._outBuff[1] = (Byte)(stateObj._outBuff[1] | TdsEnums.ST_RESET_CONNECTION_PRESERVE_TRANSACTION);                          }                          else                          {                              // if we are reseting' set bit in header by or'ing with other value                              stateObj._outBuff[1] = (Byte)(stateObj._outBuff[1] | TdsEnums.ST_RESET_CONNECTION);                          }                            if (!_fMARS)                          {                              _fResetConnection = false; // If not MARS' can turn off flag now.                              _fPreserveTransaction = false;                          }                          else                          {                              stateObj._fResetConnectionSent = true; // Otherwise set flag so we don't resend on multiple packet execute.                          }                      }                      else if (_fMARS && stateObj._fResetEventOwned)                      {                          Debug.Assert(!stateObj._fResetConnectionSent' "Unexpected state on WritePacket ResetConnection");                            // Otherwise if Yukon and we grabbed the event' free it.  Another execute grabbed the event and                          // took care of sending the reset.                          stateObj._fResetEventOwned = !_resetConnectionEvent.Set();                          Debug.Assert(!stateObj._fResetEventOwned' "Invalid AutoResetEvent state!");                      }                  }                  catch (Exception)                  {                      if (_fMARS && stateObj._fResetEventOwned)                      {                          // If exception thrown' and we are on Yukon and own the event' release it!                          stateObj._fResetConnectionSent = false;                          stateObj._fResetEventOwned = !_resetConnectionEvent.Set();                          Debug.Assert(!stateObj._fResetEventOwned' "Invalid AutoResetEvent state!");                      }                        throw;                  }              }  #if DEBUG              else              {                  Debug.Assert(!_fResetConnection ||                               (_fResetConnection && stateObj._fResetConnectionSent && stateObj._fResetEventOwned)'                               "Unexpected state on else ResetConnection block in WritePacket");              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteShort,The following statement contains a magic number: if ((stateObj._outBytesUsed + 2) > stateObj._outBuff.Length)              {                  // if all of the short doesn't fit into the buffer                  stateObj.WriteByte((byte)(v & 0xff));                  stateObj.WriteByte((byte)((v >> 8) & 0xff));              }              else              {                  // all of the short fits into the buffer                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBytesUsed += 2;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteShort,The following statement contains a magic number: if ((stateObj._outBytesUsed + 2) > stateObj._outBuff.Length)              {                  // if all of the short doesn't fit into the buffer                  stateObj.WriteByte((byte)(v & 0xff));                  stateObj.WriteByte((byte)((v >> 8) & 0xff));              }              else              {                  // all of the short fits into the buffer                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBytesUsed += 2;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteShort,The following statement contains a magic number: if ((stateObj._outBytesUsed + 2) > stateObj._outBuff.Length)              {                  // if all of the short doesn't fit into the buffer                  stateObj.WriteByte((byte)(v & 0xff));                  stateObj.WriteByte((byte)((v >> 8) & 0xff));              }              else              {                  // all of the short fits into the buffer                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBytesUsed += 2;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteShort,The following statement contains a magic number: if ((stateObj._outBytesUsed + 2) > stateObj._outBuff.Length)              {                  // if all of the short doesn't fit into the buffer                  stateObj.WriteByte((byte)(v & 0xff));                  stateObj.WriteByte((byte)((v >> 8) & 0xff));              }              else              {                  // all of the short fits into the buffer                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBytesUsed += 2;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteInt,The following statement contains a magic number: if ((stateObj._outBytesUsed + 4) > stateObj._outBuff.Length)              {                  // if all of the int doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(int) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the int fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBytesUsed += 4;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + 8) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < sizeof(long) * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  // NOTE: We don't use a loop here for performance                  stateObj._outBuff[stateObj._outBytesUsed] = (byte)(v & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 1] = (byte)((v >> 8) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 2] = (byte)((v >> 16) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 3] = (byte)((v >> 24) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 4] = (byte)((v >> 32) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 5] = (byte)((v >> 40) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 6] = (byte)((v >> 48) & 0xff);                  stateObj._outBuff[stateObj._outBytesUsed + 7] = (byte)((v >> 56) & 0xff);                  stateObj._outBytesUsed += 8;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WritePartialLong,The following statement contains a magic number: Debug.Assert(length <= 8' "Length specified is longer than the size of a long");
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WritePartialLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + length) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < length * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  for (int index = 0; index < length; index++)                  {                      stateObj._outBuff[stateObj._outBytesUsed + index] = (byte)((v >> (index * 8)) & 0xff);                  }                  stateObj._outBytesUsed += length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WritePartialLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + length) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < length * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  for (int index = 0; index < length; index++)                  {                      stateObj._outBuff[stateObj._outBytesUsed + index] = (byte)((v >> (index * 8)) & 0xff);                  }                  stateObj._outBytesUsed += length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WritePartialLong,The following statement contains a magic number: if ((stateObj._outBytesUsed + length) > stateObj._outBuff.Length)              {                  // if all of the long doesn't fit into the buffer                  for (int shiftValue = 0; shiftValue < length * 8; shiftValue += 8)                  {                      stateObj.WriteByte((byte)((v >> shiftValue) & 0xff));                  }              }              else              {                  // all of the long fits into the buffer                  for (int index = 0; index < length; index++)                  {                      stateObj._outBuff[stateObj._outBytesUsed + index] = (byte)((v >> (index * 8)) & 0xff);                  }                  stateObj._outBytesUsed += length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: SqlEnvChange[] envarray = new SqlEnvChange[3];
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessEnvChange,The following statement contains a magic number: while (tokenLength > processedLength)              {                  if (nvalues >= envarray.Length)                  {                      // This is a rare path. Most of the time we will have 1 or 2 envchange data streams.                      SqlEnvChange[] newenvarray = new SqlEnvChange[envarray.Length + 3];                        for (int ii = 0; ii < envarray.Length; ii++)                          newenvarray[ii] = envarray[ii];                        envarray = newenvarray;                  }                    SqlEnvChange env = new SqlEnvChange();                    if (!stateObj.TryReadByte(out env.type))                  {                      return false;                  }                    envarray[nvalues] = env;                  nvalues++;                    switch (env.type)                  {                      case TdsEnums.ENV_DATABASE:                      case TdsEnums.ENV_LANG:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_CHARSET:                          // we copied this behavior directly from luxor - see charset envchange                          // section from sqlctokn.c                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          if (env.newValue == TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_STRING)                          {                              _defaultCodePage = TdsEnums.DEFAULT_ENGLISH_CODE_PAGE_VALUE;                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                          else                          {                              Debug.Assert(env.newValue.Length > TdsEnums.CHARSET_CODE_PAGE_OFFSET' "TdsParser.ProcessEnvChange(): charset value received with length <=10");                                string stringCodePage = env.newValue.Substring(TdsEnums.CHARSET_CODE_PAGE_OFFSET);                                _defaultCodePage = Int32.Parse(stringCodePage' NumberStyles.Integer' CultureInfo.InvariantCulture);                              _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                          }                            break;                        case TdsEnums.ENV_PACKETSIZE:                          // take care of packet size right here                          Debug.Assert(stateObj._syncOverAsync' "Should not attempt pends in a synchronous call");                          if (!TryReadTwoStringFields(env' stateObj))                          {                              // Changing packet size does not support retry' should not pend"                              throw SQL.SynchronousCallMayNotPend();                          }                          // Only set on physical state object - this should only occur on LoginAck prior                          // to MARS initialization!                          Int32 packetSize = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                            if (_physicalStateObj.SetPacketSize(packetSize))                          {                              // If packet size changed' we need to release our SNIPackets since                              // those are tied to packet size of connection.                              _physicalStateObj.ClearAllWritePackets();                                // Update SNI ConsumerInfo value to be resulting packet size                              UInt32 unsignedPacketSize = (UInt32)packetSize;                                UInt32 result = _physicalStateObj.SetConnectionBufferSize(ref unsignedPacketSize);                              Debug.Assert(result == TdsEnums.SNI_SUCCESS' "Unexpected failure state upon calling SNISetInfo");                          }                            break;                        case TdsEnums.ENV_LOCALEID:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          _defaultLCID = Int32.Parse(env.newValue' NumberStyles.Integer' CultureInfo.InvariantCulture);                          break;                        case TdsEnums.ENV_COMPFLAGS:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_COLLATION:                          Debug.Assert(env.newLength == 5 || env.newLength == 0' "Improper length in new collation!");                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          if (env.newLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.newCollation))                              {                                  return false;                              }                                // give the parser the new collation values in case parameters don't specify one                              _defaultCollation = env.newCollation;                              int newCodePage = GetCodePage(env.newCollation' stateObj);                              if (newCodePage != _defaultCodePage)                              {                                  _defaultCodePage = newCodePage;                                  _defaultEncoding = System.Text.Encoding.GetEncoding(_defaultCodePage);                              }                              _defaultLCID = env.newCollation.LCID;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 5 || env.oldLength == 0' "Improper length in old collation!");                          if (env.oldLength == 5)                          {                              if (!TryProcessCollation(stateObj' out env.oldCollation))                              {                                  return false;                              }                          }                            env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_BEGINTRAN:                      case TdsEnums.ENV_COMMITTRAN:                      case TdsEnums.ENV_ROLLBACKTRAN:                      case TdsEnums.ENV_ENLISTDTC:                      case TdsEnums.ENV_DEFECTDTC:                      case TdsEnums.ENV_TRANSACTIONENDED:                          if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.newLength = byteLength;                          Debug.Assert(env.newLength == 0 || env.newLength == 8' "Improper length for new transaction id!");                            if (env.newLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.newLongValue))                              {                                  return false;                              }                              Debug.Assert(env.newLongValue != SqlInternalTransaction.NullTransactionId' "New transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.newLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(env.oldLength == 0 || env.oldLength == 8' "Improper length for old transaction id!");                            if (env.oldLength > 0)                          {                              if (!stateObj.TryReadInt64(out env.oldLongValue))                              {                                  return false;                              }                              Debug.Assert(env.oldLongValue != SqlInternalTransaction.NullTransactionId' "Old transaction id is null?"); // the server guarantees that zero is an invalid transaction id.                          }                          else                          {                              env.oldLongValue = SqlInternalTransaction.NullTransactionId; // the server guarantees that zero is an invalid transaction id.                          }                            // env.length includes 1 byte type token                          env.length = 3 + env.newLength + env.oldLength;                          break;                        case TdsEnums.ENV_LOGSHIPNODE:                          // env.newBinValue is secondary node' env.oldBinValue is witness node                          // comes before LoginAck so we can't assert this                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_PROMOTETRANSACTION:                          if (!stateObj.TryReadInt32(out env.newLength))                          { // new value has 4 byte length                              return false;                          }                          env.newBinValue = new byte[env.newLength];                          if (!stateObj.TryReadByteArray(env.newBinValue' 0' env.newLength))                          { // read new value with 4 byte length                              return false;                          }                            if (!stateObj.TryReadByte(out byteLength))                          {                              return false;                          }                          env.oldLength = byteLength;                          Debug.Assert(0 == env.oldLength' "old length should be zero");                            // env.length includes 1 byte for type token                          env.length = 5 + env.newLength;                          break;                        case TdsEnums.ENV_TRANSACTIONMANAGERADDRESS:                      case TdsEnums.ENV_SPRESETCONNECTIONACK:                          if (!TryReadTwoBinaryFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_USERINSTANCE:                          if (!TryReadTwoStringFields(env' stateObj))                          {                              return false;                          }                          break;                        case TdsEnums.ENV_ROUTING:                          ushort newLength;                          if (!stateObj.TryReadUInt16(out newLength))                          {                              return false;                          }                          env.newLength = newLength;                          byte protocol;                          if (!stateObj.TryReadByte(out protocol))                          {                              return false;                          }                          ushort port;                          if (!stateObj.TryReadUInt16(out port))                          {                              return false;                          }                          ushort serverLen;                          if (!stateObj.TryReadUInt16(out serverLen))                          {                              return false;                          }                          string serverName;                          if (!stateObj.TryReadString(serverLen' out serverName))                          {                              return false;                          }                          env.newRoutingInfo = new RoutingInfo(protocol' port' serverName);                          ushort oldLength;                          if (!stateObj.TryReadUInt16(out oldLength))                          {                              return false;                          }                          if (!stateObj.TrySkipBytes(oldLength))                          {                              return false;                          }                          env.length = env.newLength + oldLength + 5; // 5=2*sizeof(UInt16)+sizeof(byte) [token+newLength+oldLength]                          break;                        default:                          Debug.Assert(false' "Unknown environment change token: " + env.type);                          break;                  }                  processedLength += env.length;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadTwoBinaryFields,The following statement contains a magic number: env.length = 3 + env.newLength + env.oldLength;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadTwoStringFields,The following statement contains a magic number: env.length = 3 + env.newLength * 2 + env.oldLength * 2;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadTwoStringFields,The following statement contains a magic number: env.length = 3 + env.newLength * 2 + env.oldLength * 2;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadTwoStringFields,The following statement contains a magic number: env.length = 3 + env.newLength * 2 + env.oldLength * 2;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessSessionState,The following statement contains a magic number: if (length < 5)              {                  throw SQL.ParsingError();              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessSessionState,The following statement contains a magic number: length -= 5;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessSessionState,The following statement contains a magic number: while (length > 0)              {                  byte stateId;                  if (!stateObj.TryReadByte(out stateId))                  {                      return false;                  }                  int stateLen;                  byte stateLenByte;                  if (!stateObj.TryReadByte(out stateLenByte))                  {                      return false;                  }                  if (stateLenByte < 0xFF)                  {                      stateLen = stateLenByte;                  }                  else                  {                      if (!stateObj.TryReadInt32(out stateLen))                      {                          return false;                      }                  }                  byte[] buffer = null;                  lock (sdata._delta)                  {                      if (sdata._delta[stateId] == null)                      {                          buffer = new byte[stateLen];                          sdata._delta[stateId] = new SessionStateRecord { _version = seqNum' _dataLength = stateLen' _data = buffer' _recoverable = recoverable };                          sdata._deltaDirty = true;                          if (!recoverable)                          {                              checked { sdata._unrecoverableStatesCount++; }                          }                      }                      else                      {                          if (sdata._delta[stateId]._version <= seqNum)                          {                              SessionStateRecord sv = sdata._delta[stateId];                              sv._version = seqNum;                              sv._dataLength = stateLen;                              if (sv._recoverable != recoverable)                              {                                  if (recoverable)                                  {                                      Debug.Assert(sdata._unrecoverableStatesCount > 0' "Unrecoverable states count >0");                                      sdata._unrecoverableStatesCount--;                                  }                                  else                                  {                                      checked { sdata._unrecoverableStatesCount++; }                                  }                                  sv._recoverable = recoverable;                              }                              buffer = sv._data;                              if (buffer.Length < stateLen)                              {                                  buffer = new byte[stateLen];                                  sv._data = buffer;                              }                          }                      }                  }                  if (buffer != null)                  {                      if (!stateObj.TryReadByteArray(buffer' 0' stateLen))                      {                          return false;                      }                  }                  else                  {                      if (!stateObj.TrySkipBytes(stateLen))                          return false;                  }                    if (stateLenByte < 0xFF)                  {                      length -= 2 + stateLen;                  }                  else                  {                      length -= 6 + stateLen;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessSessionState,The following statement contains a magic number: while (length > 0)              {                  byte stateId;                  if (!stateObj.TryReadByte(out stateId))                  {                      return false;                  }                  int stateLen;                  byte stateLenByte;                  if (!stateObj.TryReadByte(out stateLenByte))                  {                      return false;                  }                  if (stateLenByte < 0xFF)                  {                      stateLen = stateLenByte;                  }                  else                  {                      if (!stateObj.TryReadInt32(out stateLen))                      {                          return false;                      }                  }                  byte[] buffer = null;                  lock (sdata._delta)                  {                      if (sdata._delta[stateId] == null)                      {                          buffer = new byte[stateLen];                          sdata._delta[stateId] = new SessionStateRecord { _version = seqNum' _dataLength = stateLen' _data = buffer' _recoverable = recoverable };                          sdata._deltaDirty = true;                          if (!recoverable)                          {                              checked { sdata._unrecoverableStatesCount++; }                          }                      }                      else                      {                          if (sdata._delta[stateId]._version <= seqNum)                          {                              SessionStateRecord sv = sdata._delta[stateId];                              sv._version = seqNum;                              sv._dataLength = stateLen;                              if (sv._recoverable != recoverable)                              {                                  if (recoverable)                                  {                                      Debug.Assert(sdata._unrecoverableStatesCount > 0' "Unrecoverable states count >0");                                      sdata._unrecoverableStatesCount--;                                  }                                  else                                  {                                      checked { sdata._unrecoverableStatesCount++; }                                  }                                  sv._recoverable = recoverable;                              }                              buffer = sv._data;                              if (buffer.Length < stateLen)                              {                                  buffer = new byte[stateLen];                                  sv._data = buffer;                              }                          }                      }                  }                  if (buffer != null)                  {                      if (!stateObj.TryReadByteArray(buffer' 0' stateLen))                      {                          return false;                      }                  }                  else                  {                      if (!stateObj.TrySkipBytes(stateLen))                          return false;                  }                    if (stateLenByte < 0xFF)                  {                      length -= 2 + stateLen;                  }                  else                  {                      length -= 6 + stateLen;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: a.tdsVersion = (UInt32)((((((b[0] << 8) | b[1]) << 8) | b[2]) << 8) | b[3]);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: a.tdsVersion = (UInt32)((((((b[0] << 8) | b[1]) << 8) | b[2]) << 8) | b[3]);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: a.tdsVersion = (UInt32)((((((b[0] << 8) | b[1]) << 8) | b[2]) << 8) | b[3]);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: a.tdsVersion = (UInt32)((((((b[0] << 8) | b[1]) << 8) | b[2]) << 8) | b[3]);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: a.tdsVersion = (UInt32)((((((b[0] << 8) | b[1]) << 8) | b[2]) << 8) | b[3]);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: UInt32 increment = (a.tdsVersion >> 16) & 0xff;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: switch (majorMinor)              {                  case TdsEnums.YUKON_MAJOR << 24 | TdsEnums.YUKON_RTM_MINOR:     // Yukon                      if (increment != TdsEnums.YUKON_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isYukon = true;                      break;                  case TdsEnums.KATMAI_MAJOR << 24 | TdsEnums.KATMAI_MINOR:                      if (increment != TdsEnums.KATMAI_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isKatmai = true;                      break;                  case TdsEnums.DENALI_MAJOR << 24 | TdsEnums.DENALI_MINOR:                      if (increment != TdsEnums.DENALI_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isDenali = true;                      break;                  default:                      throw SQL.InvalidTDSVersion();              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: switch (majorMinor)              {                  case TdsEnums.YUKON_MAJOR << 24 | TdsEnums.YUKON_RTM_MINOR:     // Yukon                      if (increment != TdsEnums.YUKON_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isYukon = true;                      break;                  case TdsEnums.KATMAI_MAJOR << 24 | TdsEnums.KATMAI_MINOR:                      if (increment != TdsEnums.KATMAI_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isKatmai = true;                      break;                  case TdsEnums.DENALI_MAJOR << 24 | TdsEnums.DENALI_MINOR:                      if (increment != TdsEnums.DENALI_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isDenali = true;                      break;                  default:                      throw SQL.InvalidTDSVersion();              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: switch (majorMinor)              {                  case TdsEnums.YUKON_MAJOR << 24 | TdsEnums.YUKON_RTM_MINOR:     // Yukon                      if (increment != TdsEnums.YUKON_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isYukon = true;                      break;                  case TdsEnums.KATMAI_MAJOR << 24 | TdsEnums.KATMAI_MINOR:                      if (increment != TdsEnums.KATMAI_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isKatmai = true;                      break;                  case TdsEnums.DENALI_MAJOR << 24 | TdsEnums.DENALI_MINOR:                      if (increment != TdsEnums.DENALI_INCREMENT) { throw SQL.InvalidTDSVersion(); }                      _isDenali = true;                      break;                  default:                      throw SQL.InvalidTDSVersion();              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessLoginAck,The following statement contains a magic number: a.buildNum = (short)((buildNumHi << 8) + buildNumLo);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessError,The following statement contains a magic number: if (_isYukon)              {                  if (!stateObj.TryReadInt32(out line))                  {                      return false;                  }              }              else              {                  ushort shortLine;                  if (!stateObj.TryReadUInt16(out shortLine))                  {                      return false;                  }                  line = shortLine;                  // If we haven't yet completed processing login token stream yet' we may be talking to a Yukon server                  // In that case we still have to read another 2 bytes                  if (_state == TdsParserState.OpenNotLoggedIn)                  {                      // Login incomplete                      byte b;                      if (!stateObj.TryPeekByte(out b))                      {                          return false;                      }                      if (b == 0)                      {                          // This is an invalid token value                          ushort value;                          if (!stateObj.TryReadUInt16(out value))                          {                              return false;                          }                          line = (line << 16) + value;                      }                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessReturnValue,The following statement contains a magic number: if (tdsType == TdsEnums.SQLXMLTYPE)              {                  tdsLen = TdsEnums.SQL_USHORTVARMAXLEN;              }              else if (IsVarTimeTds(tdsType))                  tdsLen = 0;  // placeholder until we read the scale' just make sure it's not SQL_USHORTVARMAXLEN              else if (tdsType == TdsEnums.SQLDATE)              {                  tdsLen = 3;              }              else              {                  if (!TryGetTokenLength(tdsType' stateObj' out tdsLen))                  {                      return false;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessAltMetaData,The following statement contains a magic number: while (byCols > 0)              {                  if (!stateObj.TrySkipBytes(2))                  { // ignore ColNum ...                      return false;                  }                  byCols--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryCommonProcessMetaData,The following statement contains a magic number: col.updatability = (byte)((flags & TdsEnums.Updatability) >> 2);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryCommonProcessMetaData,The following statement contains a magic number: if (tdsType == TdsEnums.SQLXMLTYPE)                  col.length = TdsEnums.SQL_USHORTVARMAXLEN;  //Use the same length as other plp datatypes              else if (IsVarTimeTds(tdsType))                  col.length = 0;  // placeholder until we read the scale' just make sure it's not SQL_USHORTVARMAXLEN              else if (tdsType == TdsEnums.SQLDATE)              {                  col.length = 3;              }              else              {                  if (!TryGetTokenLength(tdsType' stateObj' out col.length))                  {                      return false;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryCommonProcessMetaData,The following statement contains a magic number: if (col.metaType.IsVarTime)              {                  if (!stateObj.TryReadByte(out col.scale))                  {                      return false;                  }                    Debug.Assert(0 <= col.scale && col.scale <= 7);                    // calculate actual column length here                  switch (col.metaType.SqlDbType)                  {                      case SqlDbType.Time:                          col.length = MetaType.GetTimeSizeFromScale(col.scale);                          break;                      case SqlDbType.DateTime2:                          // Date in number of days (3 bytes) + time                          col.length = 3 + MetaType.GetTimeSizeFromScale(col.scale);                          break;                      case SqlDbType.DateTimeOffset:                          // Date in days (3 bytes) + offset in minutes (2 bytes) + time                          col.length = 5 + MetaType.GetTimeSizeFromScale(col.scale);                          break;                        default:                          Debug.Assert(false' "Unknown VariableTime type!");                          break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryCommonProcessMetaData,The following statement contains a magic number: if (col.metaType.IsVarTime)              {                  if (!stateObj.TryReadByte(out col.scale))                  {                      return false;                  }                    Debug.Assert(0 <= col.scale && col.scale <= 7);                    // calculate actual column length here                  switch (col.metaType.SqlDbType)                  {                      case SqlDbType.Time:                          col.length = MetaType.GetTimeSizeFromScale(col.scale);                          break;                      case SqlDbType.DateTime2:                          // Date in number of days (3 bytes) + time                          col.length = 3 + MetaType.GetTimeSizeFromScale(col.scale);                          break;                      case SqlDbType.DateTimeOffset:                          // Date in days (3 bytes) + offset in minutes (2 bytes) + time                          col.length = 5 + MetaType.GetTimeSizeFromScale(col.scale);                          break;                        default:                          Debug.Assert(false' "Unknown VariableTime type!");                          break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryCommonProcessMetaData,The following statement contains a magic number: if (col.metaType.IsVarTime)              {                  if (!stateObj.TryReadByte(out col.scale))                  {                      return false;                  }                    Debug.Assert(0 <= col.scale && col.scale <= 7);                    // calculate actual column length here                  switch (col.metaType.SqlDbType)                  {                      case SqlDbType.Time:                          col.length = MetaType.GetTimeSizeFromScale(col.scale);                          break;                      case SqlDbType.DateTime2:                          // Date in number of days (3 bytes) + time                          col.length = 3 + MetaType.GetTimeSizeFromScale(col.scale);                          break;                      case SqlDbType.DateTimeOffset:                          // Date in days (3 bytes) + offset in minutes (2 bytes) + time                          col.length = 5 + MetaType.GetTimeSizeFromScale(col.scale);                          break;                        default:                          Debug.Assert(false' "Unknown VariableTime type!");                          break;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 4)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.ServerName = value;                  nParts--;                  length -= (tableLen * 2); // wide bytes              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 4)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.ServerName = value;                  nParts--;                  length -= (tableLen * 2); // wide bytes              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 4)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.ServerName = value;                  nParts--;                  length -= (tableLen * 2); // wide bytes              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 3)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.CatalogName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 3)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.CatalogName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 3)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.CatalogName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 2)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.SchemaName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 2)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.SchemaName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 2)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.SchemaName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 1)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.TableName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryProcessOneTable,The following statement contains a magic number: if (nParts == 1)              {                  if (!stateObj.TryReadUInt16(out tableLen))                  {                      return false;                  }                  length -= 2;                  if (!stateObj.TryReadString(tableLen' out value))                  {                      return false;                  }                  mpt.TableName = value;                  length -= (tableLen * 2); // wide bytes                  nParts--;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLDATE:                      Debug.Assert(length == 3' "invalid length for date type!");                      value.SetToDate(datetimeBuffer);                      break;                    case TdsEnums.SQLTIME:                      Debug.Assert(3 <= length && length <= 5' "invalid length for time type!");                      value.SetToTime(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIME2:                      Debug.Assert(6 <= length && length <= 8' "invalid length for datetime2 type!");                      value.SetToDateTime2(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      Debug.Assert(8 <= length && length <= 10' "invalid length for datetimeoffset type!");                      value.SetToDateTimeOffset(datetimeBuffer' length' scale);                      break;                    default:                      Debug.Assert(false' "ReadSqlDateTime is called with the wrong tdsType");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLDATE:                      Debug.Assert(length == 3' "invalid length for date type!");                      value.SetToDate(datetimeBuffer);                      break;                    case TdsEnums.SQLTIME:                      Debug.Assert(3 <= length && length <= 5' "invalid length for time type!");                      value.SetToTime(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIME2:                      Debug.Assert(6 <= length && length <= 8' "invalid length for datetime2 type!");                      value.SetToDateTime2(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      Debug.Assert(8 <= length && length <= 10' "invalid length for datetimeoffset type!");                      value.SetToDateTimeOffset(datetimeBuffer' length' scale);                      break;                    default:                      Debug.Assert(false' "ReadSqlDateTime is called with the wrong tdsType");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLDATE:                      Debug.Assert(length == 3' "invalid length for date type!");                      value.SetToDate(datetimeBuffer);                      break;                    case TdsEnums.SQLTIME:                      Debug.Assert(3 <= length && length <= 5' "invalid length for time type!");                      value.SetToTime(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIME2:                      Debug.Assert(6 <= length && length <= 8' "invalid length for datetime2 type!");                      value.SetToDateTime2(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      Debug.Assert(8 <= length && length <= 10' "invalid length for datetimeoffset type!");                      value.SetToDateTimeOffset(datetimeBuffer' length' scale);                      break;                    default:                      Debug.Assert(false' "ReadSqlDateTime is called with the wrong tdsType");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLDATE:                      Debug.Assert(length == 3' "invalid length for date type!");                      value.SetToDate(datetimeBuffer);                      break;                    case TdsEnums.SQLTIME:                      Debug.Assert(3 <= length && length <= 5' "invalid length for time type!");                      value.SetToTime(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIME2:                      Debug.Assert(6 <= length && length <= 8' "invalid length for datetime2 type!");                      value.SetToDateTime2(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      Debug.Assert(8 <= length && length <= 10' "invalid length for datetimeoffset type!");                      value.SetToDateTimeOffset(datetimeBuffer' length' scale);                      break;                    default:                      Debug.Assert(false' "ReadSqlDateTime is called with the wrong tdsType");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLDATE:                      Debug.Assert(length == 3' "invalid length for date type!");                      value.SetToDate(datetimeBuffer);                      break;                    case TdsEnums.SQLTIME:                      Debug.Assert(3 <= length && length <= 5' "invalid length for time type!");                      value.SetToTime(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIME2:                      Debug.Assert(6 <= length && length <= 8' "invalid length for datetime2 type!");                      value.SetToDateTime2(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      Debug.Assert(8 <= length && length <= 10' "invalid length for datetimeoffset type!");                      value.SetToDateTimeOffset(datetimeBuffer' length' scale);                      break;                    default:                      Debug.Assert(false' "ReadSqlDateTime is called with the wrong tdsType");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLDATE:                      Debug.Assert(length == 3' "invalid length for date type!");                      value.SetToDate(datetimeBuffer);                      break;                    case TdsEnums.SQLTIME:                      Debug.Assert(3 <= length && length <= 5' "invalid length for time type!");                      value.SetToTime(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIME2:                      Debug.Assert(6 <= length && length <= 8' "invalid length for datetime2 type!");                      value.SetToDateTime2(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      Debug.Assert(8 <= length && length <= 10' "invalid length for datetimeoffset type!");                      value.SetToDateTimeOffset(datetimeBuffer' length' scale);                      break;                    default:                      Debug.Assert(false' "ReadSqlDateTime is called with the wrong tdsType");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlDateTime,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLDATE:                      Debug.Assert(length == 3' "invalid length for date type!");                      value.SetToDate(datetimeBuffer);                      break;                    case TdsEnums.SQLTIME:                      Debug.Assert(3 <= length && length <= 5' "invalid length for time type!");                      value.SetToTime(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIME2:                      Debug.Assert(6 <= length && length <= 8' "invalid length for datetime2 type!");                      value.SetToDateTime2(datetimeBuffer' length' scale);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      Debug.Assert(8 <= length && length <= 10' "invalid length for datetimeoffset type!");                      value.SetToDateTimeOffset(datetimeBuffer' length' scale);                      break;                    default:                      Debug.Assert(false' "ReadSqlDateTime is called with the wrong tdsType");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlValueInternal,The following statement contains a magic number: switch (tdsType)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLBITN:                      Debug.Assert(length == 1' "invalid length for SqlBoolean type!");                      byte byteValue;                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Boolean = (byteValue != 0);                      break;                    case TdsEnums.SQLINTN:                      if (length == 1)                      {                          goto case TdsEnums.SQLINT1;                      }                      else if (length == 2)                      {                          goto case TdsEnums.SQLINT2;                      }                      else if (length == 4)                      {                          goto case TdsEnums.SQLINT4;                      }                      else                      {                          goto case TdsEnums.SQLINT8;                      }                    case TdsEnums.SQLINT1:                      Debug.Assert(length == 1' "invalid length for SqlByte type!");                      if (!stateObj.TryReadByte(out byteValue))                      {                          return false;                      }                      value.Byte = byteValue;                      break;                    case TdsEnums.SQLINT2:                      Debug.Assert(length == 2' "invalid length for SqlInt16 type!");                      short shortValue;                      if (!stateObj.TryReadInt16(out shortValue))                      {                          return false;                      }                      value.Int16 = shortValue;                      break;                    case TdsEnums.SQLINT4:                      Debug.Assert(length == 4' "invalid length for SqlInt32 type!");                      int intValue;                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.Int32 = intValue;                      break;                    case TdsEnums.SQLINT8:                      Debug.Assert(length == 8' "invalid length for SqlInt64 type!");                      long longValue;                      if (!stateObj.TryReadInt64(out longValue))                      {                          return false;                      }                      value.Int64 = longValue;                      break;                    case TdsEnums.SQLFLTN:                      if (length == 4)                      {                          goto case TdsEnums.SQLFLT4;                      }                      else                      {                          goto case TdsEnums.SQLFLT8;                      }                    case TdsEnums.SQLFLT4:                      Debug.Assert(length == 4' "invalid length for SqlSingle type!");                      float singleValue;                      if (!stateObj.TryReadSingle(out singleValue))                      {                          return false;                      }                      value.Single = singleValue;                      break;                    case TdsEnums.SQLFLT8:                      Debug.Assert(length == 8' "invalid length for SqlDouble type!");                      double doubleValue;                      if (!stateObj.TryReadDouble(out doubleValue))                      {                          return false;                      }                      value.Double = doubleValue;                      break;                    case TdsEnums.SQLMONEYN:                      if (length == 4)                      {                          goto case TdsEnums.SQLMONEY4;                      }                      else                      {                          goto case TdsEnums.SQLMONEY;                      }                    case TdsEnums.SQLMONEY:                      {                          int mid;                          uint lo;                            if (!stateObj.TryReadInt32(out mid))                          {                              return false;                          }                          if (!stateObj.TryReadUInt32(out lo))                          {                              return false;                          }                            long l = (((long)mid) << 0x20) + ((long)lo);                            value.SetToMoney(l);                          break;                      }                    case TdsEnums.SQLMONEY4:                      if (!stateObj.TryReadInt32(out intValue))                      {                          return false;                      }                      value.SetToMoney(intValue);                      break;                    case TdsEnums.SQLDATETIMN:                      if (length == 4)                      {                          goto case TdsEnums.SQLDATETIM4;                      }                      else                      {                          goto case TdsEnums.SQLDATETIME;                      }                    case TdsEnums.SQLDATETIM4:                      ushort daypartShort' timepartShort;                      if (!stateObj.TryReadUInt16(out daypartShort))                      {                          return false;                      }                      if (!stateObj.TryReadUInt16(out timepartShort))                      {                          return false;                      }                      value.SetToDateTime(daypartShort' timepartShort * SqlDateTime.SQLTicksPerMinute);                      break;                    case TdsEnums.SQLDATETIME:                      int daypart;                      uint timepart;                      if (!stateObj.TryReadInt32(out daypart))                      {                          return false;                      }                      if (!stateObj.TryReadUInt32(out timepart))                      {                          return false;                      }                      value.SetToDateTime(daypart' (int)timepart);                      break;                    case TdsEnums.SQLUNIQUEID:                      {                          Debug.Assert(length == 16' "invalid length for SqlGuid type!");                            byte[] b = new byte[length];                            if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlGuid = SqlTypeWorkarounds.SqlGuidCtor(b' true);                          break;                      }                    case TdsEnums.SQLBINARY:                  case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          // Note: Better not come here with plp data!!                          Debug.Assert(length <= TdsEnums.MAXSIZE);                          byte[] b = new byte[length];                          if (!stateObj.TryReadByteArray(b' 0' length))                          {                              return false;                          }                          value.SqlBinary = SqlTypeWorkarounds.SqlBinaryCtor(b' true);                            break;                      }                    case TdsEnums.SQLVARIANT:                      if (!TryReadSqlVariant(value' length' stateObj))                      {                          return false;                      }                      break;                    default:                      Debug.Assert(false' "Unknown SqlType!" + tdsType.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlVariant,The following statement contains a magic number: switch (type)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLINT1:                  case TdsEnums.SQLINT2:                  case TdsEnums.SQLINT4:                  case TdsEnums.SQLINT8:                  case TdsEnums.SQLFLT4:                  case TdsEnums.SQLFLT8:                  case TdsEnums.SQLMONEY:                  case TdsEnums.SQLMONEY4:                  case TdsEnums.SQLDATETIME:                  case TdsEnums.SQLDATETIM4:                  case TdsEnums.SQLUNIQUEID:                      if (!TryReadSqlValueInternal(value' type' lenData' stateObj))                      {                          return false;                      }                      break;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN:                      {                          Debug.Assert(cbPropsExpected == 2' "SqlVariant: invalid PropBytes for decimal/numeric type!");                            byte precision;                          if (!stateObj.TryReadByte(out precision))                          {                              return false;                          }                          byte scale;                          if (!stateObj.TryReadByte(out scale))                          {                              return false;                          }                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            if (!TryReadSqlDecimal(value' TdsEnums.MAX_NUMERIC_LEN' precision' scale' stateObj))                          {                              return false;                          }                          break;                      }                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                      //Debug.Assert(TdsEnums.VARNULL == lenData' "SqlVariant: data length for Binary indicates null?");                      Debug.Assert(cbPropsExpected == 2' "SqlVariant: invalid PropBytes for binary type!");                        if (!stateObj.TryReadUInt16(out lenMax))                      {                          return false;                      }                      Debug.Assert(lenMax != TdsEnums.SQL_USHORTVARMAXLEN' "bigvarbinary(max) in a sqlvariant");                        // skip over unknown properties                      if (cbPropsActual > cbPropsExpected)                      {                          if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                          {                              return false;                          }                      }                        goto case TdsEnums.SQLBIT;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                      {                          Debug.Assert(cbPropsExpected == 7' "SqlVariant: invalid PropBytes for character type!");                            SqlCollation collation;                          if (!TryProcessCollation(stateObj' out collation))                          {                              return false;                          }                            if (!stateObj.TryReadUInt16(out lenMax))                          {                              return false;                          }                          Debug.Assert(lenMax != TdsEnums.SQL_USHORTVARMAXLEN' "bigvarchar(max) or nvarchar(max) in a sqlvariant");                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            Encoding encoding = Encoding.GetEncoding(GetCodePage(collation' stateObj));                          if (!TryReadSqlStringValue(value' type' lenData' encoding' false' stateObj))                          {                              return false;                          }                          break;                      }                  case TdsEnums.SQLDATE:                      if (!TryReadSqlDateTime(value' type' lenData' 0' stateObj))                      {                          return false;                      }                      break;                    case TdsEnums.SQLTIME:                  case TdsEnums.SQLDATETIME2:                  case TdsEnums.SQLDATETIMEOFFSET:                      {                          Debug.Assert(cbPropsExpected == 1' "SqlVariant: invalid PropBytes for time/datetime2/datetimeoffset type!");                            byte scale;                          if (!stateObj.TryReadByte(out scale))                          {                              return false;                          }                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            if (!TryReadSqlDateTime(value' type' lenData' scale' stateObj))                          {                              return false;                          }                          break;                      }                    default:                      Debug.Assert(false' "Unknown tds type in SqlVariant!" + type.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlVariant,The following statement contains a magic number: switch (type)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLINT1:                  case TdsEnums.SQLINT2:                  case TdsEnums.SQLINT4:                  case TdsEnums.SQLINT8:                  case TdsEnums.SQLFLT4:                  case TdsEnums.SQLFLT8:                  case TdsEnums.SQLMONEY:                  case TdsEnums.SQLMONEY4:                  case TdsEnums.SQLDATETIME:                  case TdsEnums.SQLDATETIM4:                  case TdsEnums.SQLUNIQUEID:                      if (!TryReadSqlValueInternal(value' type' lenData' stateObj))                      {                          return false;                      }                      break;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN:                      {                          Debug.Assert(cbPropsExpected == 2' "SqlVariant: invalid PropBytes for decimal/numeric type!");                            byte precision;                          if (!stateObj.TryReadByte(out precision))                          {                              return false;                          }                          byte scale;                          if (!stateObj.TryReadByte(out scale))                          {                              return false;                          }                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            if (!TryReadSqlDecimal(value' TdsEnums.MAX_NUMERIC_LEN' precision' scale' stateObj))                          {                              return false;                          }                          break;                      }                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                      //Debug.Assert(TdsEnums.VARNULL == lenData' "SqlVariant: data length for Binary indicates null?");                      Debug.Assert(cbPropsExpected == 2' "SqlVariant: invalid PropBytes for binary type!");                        if (!stateObj.TryReadUInt16(out lenMax))                      {                          return false;                      }                      Debug.Assert(lenMax != TdsEnums.SQL_USHORTVARMAXLEN' "bigvarbinary(max) in a sqlvariant");                        // skip over unknown properties                      if (cbPropsActual > cbPropsExpected)                      {                          if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                          {                              return false;                          }                      }                        goto case TdsEnums.SQLBIT;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                      {                          Debug.Assert(cbPropsExpected == 7' "SqlVariant: invalid PropBytes for character type!");                            SqlCollation collation;                          if (!TryProcessCollation(stateObj' out collation))                          {                              return false;                          }                            if (!stateObj.TryReadUInt16(out lenMax))                          {                              return false;                          }                          Debug.Assert(lenMax != TdsEnums.SQL_USHORTVARMAXLEN' "bigvarchar(max) or nvarchar(max) in a sqlvariant");                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            Encoding encoding = Encoding.GetEncoding(GetCodePage(collation' stateObj));                          if (!TryReadSqlStringValue(value' type' lenData' encoding' false' stateObj))                          {                              return false;                          }                          break;                      }                  case TdsEnums.SQLDATE:                      if (!TryReadSqlDateTime(value' type' lenData' 0' stateObj))                      {                          return false;                      }                      break;                    case TdsEnums.SQLTIME:                  case TdsEnums.SQLDATETIME2:                  case TdsEnums.SQLDATETIMEOFFSET:                      {                          Debug.Assert(cbPropsExpected == 1' "SqlVariant: invalid PropBytes for time/datetime2/datetimeoffset type!");                            byte scale;                          if (!stateObj.TryReadByte(out scale))                          {                              return false;                          }                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            if (!TryReadSqlDateTime(value' type' lenData' scale' stateObj))                          {                              return false;                          }                          break;                      }                    default:                      Debug.Assert(false' "Unknown tds type in SqlVariant!" + type.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadSqlVariant,The following statement contains a magic number: switch (type)              {                  case TdsEnums.SQLBIT:                  case TdsEnums.SQLINT1:                  case TdsEnums.SQLINT2:                  case TdsEnums.SQLINT4:                  case TdsEnums.SQLINT8:                  case TdsEnums.SQLFLT4:                  case TdsEnums.SQLFLT8:                  case TdsEnums.SQLMONEY:                  case TdsEnums.SQLMONEY4:                  case TdsEnums.SQLDATETIME:                  case TdsEnums.SQLDATETIM4:                  case TdsEnums.SQLUNIQUEID:                      if (!TryReadSqlValueInternal(value' type' lenData' stateObj))                      {                          return false;                      }                      break;                    case TdsEnums.SQLDECIMALN:                  case TdsEnums.SQLNUMERICN:                      {                          Debug.Assert(cbPropsExpected == 2' "SqlVariant: invalid PropBytes for decimal/numeric type!");                            byte precision;                          if (!stateObj.TryReadByte(out precision))                          {                              return false;                          }                          byte scale;                          if (!stateObj.TryReadByte(out scale))                          {                              return false;                          }                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            if (!TryReadSqlDecimal(value' TdsEnums.MAX_NUMERIC_LEN' precision' scale' stateObj))                          {                              return false;                          }                          break;                      }                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                      //Debug.Assert(TdsEnums.VARNULL == lenData' "SqlVariant: data length for Binary indicates null?");                      Debug.Assert(cbPropsExpected == 2' "SqlVariant: invalid PropBytes for binary type!");                        if (!stateObj.TryReadUInt16(out lenMax))                      {                          return false;                      }                      Debug.Assert(lenMax != TdsEnums.SQL_USHORTVARMAXLEN' "bigvarbinary(max) in a sqlvariant");                        // skip over unknown properties                      if (cbPropsActual > cbPropsExpected)                      {                          if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                          {                              return false;                          }                      }                        goto case TdsEnums.SQLBIT;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                      {                          Debug.Assert(cbPropsExpected == 7' "SqlVariant: invalid PropBytes for character type!");                            SqlCollation collation;                          if (!TryProcessCollation(stateObj' out collation))                          {                              return false;                          }                            if (!stateObj.TryReadUInt16(out lenMax))                          {                              return false;                          }                          Debug.Assert(lenMax != TdsEnums.SQL_USHORTVARMAXLEN' "bigvarchar(max) or nvarchar(max) in a sqlvariant");                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            Encoding encoding = Encoding.GetEncoding(GetCodePage(collation' stateObj));                          if (!TryReadSqlStringValue(value' type' lenData' encoding' false' stateObj))                          {                              return false;                          }                          break;                      }                  case TdsEnums.SQLDATE:                      if (!TryReadSqlDateTime(value' type' lenData' 0' stateObj))                      {                          return false;                      }                      break;                    case TdsEnums.SQLTIME:                  case TdsEnums.SQLDATETIME2:                  case TdsEnums.SQLDATETIMEOFFSET:                      {                          Debug.Assert(cbPropsExpected == 1' "SqlVariant: invalid PropBytes for time/datetime2/datetimeoffset type!");                            byte scale;                          if (!stateObj.TryReadByte(out scale))                          {                              return false;                          }                            // skip over unknown properties                          if (cbPropsActual > cbPropsExpected)                          {                              if (!stateObj.TrySkipBytes(cbPropsActual - cbPropsExpected))                              {                                  return false;                              }                          }                            if (!TryReadSqlDateTime(value' type' lenData' scale' stateObj))                          {                              return false;                          }                          break;                      }                    default:                      Debug.Assert(false' "Unknown tds type in SqlVariant!" + type.ToString(CultureInfo.InvariantCulture));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantValue,The following statement contains a magic number: if ((TdsEnums.SQLNUMERICN == mt.TDSType) && (8 == length))              {                  // The caller will coerce all SqlTypes to native CLR types' which means SqlMoney will                   // coerce to decimal/SQLNUMERICN (via SqlMoney.Value call).  In the case where the original                   // value was SqlMoney the caller will also pass in the metadata length for the SqlMoney type                   // which is 8 bytes.  To honor the intent of the caller here we coerce this special case                   // input back to SqlMoney from decimal/SQLNUMERICN.                  mt = MetaType.GetMetaTypeFromValue(new SqlMoney((decimal)value));              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantValue,The following statement contains a magic number: switch (mt.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' offset' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((length == b.Length) && (length == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' offset' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          stateObj.WriteByte(mt.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' mt.Scale' length' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' mt.Scale' length' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantValue,The following statement contains a magic number: switch (mt.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' offset' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((length == b.Length) && (length == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' offset' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          stateObj.WriteByte(mt.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' mt.Scale' length' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' mt.Scale' length' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantValue,The following statement contains a magic number: switch (mt.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' offset' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((length == b.Length) && (length == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' offset' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          stateObj.WriteByte(mt.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' mt.Scale' length' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' mt.Scale' length' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantValue,The following statement contains a magic number: switch (mt.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' offset' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((length == b.Length) && (length == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' offset' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          stateObj.WriteByte(mt.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' mt.Scale' length' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      stateObj.WriteByte(mt.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' mt.Scale' length' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDataRowValue,The following statement contains a magic number: switch (metatype.TDSType)              {                  case TdsEnums.SQLFLT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteFloat((float)value' stateObj);                      break;                    case TdsEnums.SQLFLT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteDouble((double)value' stateObj);                      break;                    case TdsEnums.SQLINT8:                      WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteLong((long)value' stateObj);                      break;                    case TdsEnums.SQLINT4:                      WriteSqlVariantHeader(6' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteInt((int)value' stateObj);                      break;                    case TdsEnums.SQLINT2:                      WriteSqlVariantHeader(4' metatype.TDSType' metatype.PropBytes' stateObj);                      WriteShort((short)value' stateObj);                      break;                    case TdsEnums.SQLINT1:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte((byte)value);                      break;                    case TdsEnums.SQLBIT:                      WriteSqlVariantHeader(3' metatype.TDSType' metatype.PropBytes' stateObj);                      if ((bool)value == true)                          stateObj.WriteByte(1);                      else                          stateObj.WriteByte(0);                        break;                    case TdsEnums.SQLBIGVARBINARY:                      {                          byte[] b = (byte[])value;                            length = b.Length;                          WriteSqlVariantHeader(4 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteShort(length' stateObj); // propbytes: varlen                          return stateObj.WriteByteArray(b' length' 0' canAccumulate);                      }                    case TdsEnums.SQLBIGVARCHAR:                      {                          string s = (string)value;                            length = s.Length;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj);                          return WriteEncodingChar(s' _defaultEncoding' stateObj' canAccumulate);                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            length = b.Length;                          Debug.Assert(length == 16' "Invalid length for guid type in com+ object");                          WriteSqlVariantHeader(18' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByteArray(b' length' 0);                          break;                      }                    case TdsEnums.SQLNVARCHAR:                      {                          string s = (string)value;                            length = s.Length * 2;                          WriteSqlVariantHeader(9 + length' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteUnsignedInt(_defaultCollation.info' stateObj); // propbytes: collation.Info                          stateObj.WriteByte(_defaultCollation.sortId); // propbytes: collation.SortId                          WriteShort(length' stateObj); // propbyte: varlen                            // string takes cchar' not cbyte so convert                          length >>= 1;                          return WriteString(s' length' 0' stateObj' canAccumulate);                      }                    case TdsEnums.SQLDATETIME:                      {                          TdsDateTime dt = MetaType.FromDateTime((DateTime)value' 8);                            WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                          break;                      }                    case TdsEnums.SQLMONEY:                      {                          WriteSqlVariantHeader(10' metatype.TDSType' metatype.PropBytes' stateObj);                          WriteCurrency((Decimal)value' 8' stateObj);                          break;                      }                    case TdsEnums.SQLNUMERICN:                      {                          WriteSqlVariantHeader(21' metatype.TDSType' metatype.PropBytes' stateObj);                          stateObj.WriteByte(metatype.Precision); //propbytes: precision                          stateObj.WriteByte((byte)((Decimal.GetBits((Decimal)value)[3] & 0x00ff0000) >> 0x10)); // propbytes: scale                          WriteDecimal((Decimal)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      WriteSqlVariantHeader(8' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteTime((TimeSpan)value' metatype.Scale' 5' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteSqlVariantHeader(13' metatype.TDSType' metatype.PropBytes' stateObj);                      stateObj.WriteByte(metatype.Scale); //propbytes: scale                      WriteDateTimeOffset((DateTimeOffset)value' metatype.Scale' 10' stateObj);                      break;                    default:                      Debug.Assert(false' "unknown tds type for sqlvariant!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDateTime2,The following statement contains a magic number: WriteSqlVariantHeader((int)(dateTime2MetaData.MaxLength + 3)' TdsEnums.SQLDATETIME2' 1 /* one scale prop */' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlVariantDate,The following statement contains a magic number: WriteSqlVariantHeader((int)(dateMetaData.MaxLength + 2)' TdsEnums.SQLDATE' 0 /* one scale prop */' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlMoney,The following statement contains a magic number: bool isNeg = (0 != (bits[3] & unchecked((int)0x80000000)));
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSqlMoney,The following statement contains a magic number: if (length == 4)              {                  Decimal decimalValue = value.Value;                    // validate the value can be represented as a small money                  if (decimalValue < TdsEnums.SQL_SMALL_MONEY_MIN || decimalValue > TdsEnums.SQL_SMALL_MONEY_MAX)                  {                      throw SQL.MoneyOverflow(decimalValue.ToString(CultureInfo.InvariantCulture));                  }                    WriteInt((int)l' stateObj);              }              else              {                  WriteInt((int)(l >> 0x20)' stateObj);                  WriteInt((int)l' stateObj);              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteCurrency,The following statement contains a magic number: bool isNeg = (0 != (bits[3] & unchecked((int)0x80000000)));
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteCurrency,The following statement contains a magic number: if (length == 4)              {                  // validate the value can be represented as a small money                  if (value < TdsEnums.SQL_SMALL_MONEY_MIN || value > TdsEnums.SQL_SMALL_MONEY_MAX)                  {                      throw SQL.MoneyOverflow(value.ToString(CultureInfo.InvariantCulture));                  }                    WriteInt((int)l' stateObj);              }              else              {                  WriteInt((int)(l >> 0x20)' stateObj);                  WriteInt((int)l' stateObj);              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteDate,The following statement contains a magic number: WritePartialLong(days' 3' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteDateTime2,The following statement contains a magic number: WritePartialLong(time' length - 3' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteDateTimeOffset,The following statement contains a magic number: WriteDateTime2(value.UtcDateTime' scale' length - 2' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteDateTimeOffset,The following statement contains a magic number: stateObj.WriteByte((byte)((offset >> 8) & 0xff));
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadDecimalBits,The following statement contains a magic number: if (null == bits)              {                  bits = new int[4];                  stateObj._decimalBits = bits;              }              else              {                  for (i = 0; i < bits.Length; i++)                      bits[i] = 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadDecimalBits,The following statement contains a magic number: Debug.Assert((length > 0) &&                           (length <= TdsEnums.MAX_NUMERIC_LEN - 1) &&                           (length % 4 == 0)' "decimal should have 4' 8' 12' or 16 bytes of data");
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadDecimalBits,The following statement contains a magic number: int decLength = length >> 2;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,AdjustDecimalScale,The following statement contains a magic number: int oldScale = (Decimal.GetBits(value)[3] & 0x00ff0000) >> 0x10;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteDecimal,The following statement contains a magic number: if (0x80000000 == (stateObj._decimalBits[3] & 0x80000000))                  stateObj.WriteByte(0);              else                  stateObj.WriteByte(1);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteDecimal,The following statement contains a magic number: WriteInt(stateObj._decimalBits[2]' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryGetTokenLength,The following statement contains a magic number: switch (token & TdsEnums.SQLLenMask)              {                  case TdsEnums.SQLFixedLen:                      tokenLength = ((0x01 << ((token & 0x0c) >> 2))) & 0xff;                      return true;                  case TdsEnums.SQLZeroLen:                      tokenLength = 0;                      return true;                  case TdsEnums.SQLVarLen:                  case TdsEnums.SQLVarCnt:                      if (0 != (token & 0x80))                      {                          ushort value;                          if (!stateObj.TryReadUInt16(out value))                          {                              tokenLength = 0;                              return false;                          }                          tokenLength = value;                          return true;                      }                      else if (0 == (token & 0x0c))                      {                          if (!stateObj.TryReadInt32(out tokenLength))                          {                              return false;                          }                          return true;                      }                      else                      {                          byte value;                          if (!stateObj.TryReadByte(out value))                          {                              tokenLength = 0;                              return false;                          }                          tokenLength = value;                          return true;                      }                  default:                      Debug.Assert(false' "Unknown token length!");                      tokenLength = 0;                      return true;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,StateValueLength,The following statement contains a magic number: return dataLen < 0xFF ? (dataLen + 1) : (dataLen + 5);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSessionRecoveryFeatureRequest,The following statement contains a magic number: if (reconnectData == null)              {                  if (write)                  {                      WriteInt(0' _physicalStateObj);                  }                  len += 4;              }              else              {                  Debug.Assert(reconnectData._unrecoverableStatesCount == 0' "Unrecoverable state count should be 0");                  int initialLength = 0; // sizeof(DWORD) - length itself                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialDatabase);                  initialLength += 1 + 2 * TdsParserStaticMethods.NullAwareStringLength(reconnectData._initialLanguage);                  initialLength += (reconnectData._initialCollation == null) ? 1 : 6;                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._initialState[i] != null)                      {                          initialLength += 1 /* StateId*/ + StateValueLength(reconnectData._initialState[i].Length);                      }                  }                  int currentLength = 0; // sizeof(DWORD) - length itself                                  currentLength += 1 + 2 * (reconnectData._initialDatabase == reconnectData._database ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._database));                  currentLength += 1 + 2 * (reconnectData._initialLanguage == reconnectData._language ? 0 : TdsParserStaticMethods.NullAwareStringLength(reconnectData._language));                  currentLength += (reconnectData._collation != null && !SqlCollation.AreSame(reconnectData._collation' reconnectData._initialCollation)) ? 6 : 1;                  bool[] writeState = new bool[SessionData._maxNumberOfSessionStates];                  for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                  {                      if (reconnectData._delta[i] != null)                      {                          Debug.Assert(reconnectData._delta[i]._recoverable' "State should be recoverable");                          writeState[i] = true;                          if (reconnectData._initialState[i] != null && reconnectData._initialState[i].Length == reconnectData._delta[i]._dataLength)                          {                              writeState[i] = false;                              for (int j = 0; j < reconnectData._delta[i]._dataLength; j++)                              {                                  if (reconnectData._initialState[i][j] != reconnectData._delta[i]._data[j])                                  {                                      writeState[i] = true;                                      break;                                  }                              }                          }                          if (writeState[i])                          {                              currentLength += 1 /* StateId*/ + StateValueLength(reconnectData._delta[i]._dataLength);                          }                      }                  }                  if (write)                  {                      WriteInt(8 + initialLength + currentLength' _physicalStateObj); // length of data w/o total length (initial + current + 2 * sizeof(DWORD))                      WriteInt(initialLength' _physicalStateObj);                      WriteIdentifier(reconnectData._initialDatabase' _physicalStateObj);                      WriteCollation(reconnectData._initialCollation' _physicalStateObj);                      WriteIdentifier(reconnectData._initialLanguage' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (reconnectData._initialState[i] != null)                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._initialState[i].Length < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._initialState[i].Length);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._initialState[i].Length' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._initialState[i]' reconnectData._initialState[i].Length' 0);                          }                      }                      WriteInt(currentLength' _physicalStateObj);                      WriteIdentifier(reconnectData._database != reconnectData._initialDatabase ? reconnectData._database : null' _physicalStateObj);                      WriteCollation(SqlCollation.AreSame(reconnectData._initialCollation' reconnectData._collation) ? null : reconnectData._collation' _physicalStateObj);                      WriteIdentifier(reconnectData._language != reconnectData._initialLanguage ? reconnectData._language : null' _physicalStateObj);                      for (int i = 0; i < SessionData._maxNumberOfSessionStates; i++)                      {                          if (writeState[i])                          {                              _physicalStateObj.WriteByte((byte)i);                              if (reconnectData._delta[i]._dataLength < 0xFF)                              {                                  _physicalStateObj.WriteByte((byte)reconnectData._delta[i]._dataLength);                              }                              else                              {                                  _physicalStateObj.WriteByte(0xFF);                                  WriteInt(reconnectData._delta[i]._dataLength' _physicalStateObj);                              }                              _physicalStateObj.WriteByteArray(reconnectData._delta[i]._data' reconnectData._delta[i]._dataLength' 0);                          }                      }                  }                  len += initialLength + currentLength + 12 /* length fields (initial' current' total) */;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteGlobalTransactionsFeatureRequest,The following statement contains a magic number: int len = 5;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: checked              {                  length += (rec.hostName.Length + rec.applicationName.Length +                              rec.serverName.Length + clientInterfaceName.Length +                              rec.language.Length + rec.database.Length +                              rec.attachDBFilename.Length) * 2;                  if (useFeatureExt)                  {                      length += 4;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: checked              {                  length += (rec.hostName.Length + rec.applicationName.Length +                              rec.serverName.Length + clientInterfaceName.Length +                              rec.language.Length + rec.database.Length +                              rec.attachDBFilename.Length) * 2;                  if (useFeatureExt)                  {                      length += 4;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: if (!rec.useSSPI)              {                  checked                  {                      length += (userName.Length * 2) + encryptedPasswordLengthInBytes;                  }              }              else              {                  if (rec.useSSPI)                  {                      // now allocate proper length of buffer' and set length                      outSSPIBuff = new byte[s_maxSSPILength];                      outSSPILength = s_maxSSPILength;                        // Call helper function for SSPI data and actual length.                      // Since we don't have SSPI data from the server' send null for the                      // byte[] buffer and 0 for the int length.                      Debug.Assert(SniContext.Snix_Login == _physicalStateObj.SniContext' String.Format((IFormatProvider)null' "Unexpected SniContext. Expecting Snix_Login' actual value is '{0}'"' _physicalStateObj.SniContext));                      _physicalStateObj.SniContext = SniContext.Snix_LoginSspi;                        SSPIData(null' 0' ref outSSPIBuff' ref outSSPILength);                                            if (outSSPILength > Int32.MaxValue)                      {                          throw SQL.InvalidSSPIPacketSize();  // SqlBu 332503                      }                      _physicalStateObj.SniContext = SniContext.Snix_Login;                        checked                      {                          length += (Int32)outSSPILength;                      }                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsLogin,The following statement contains a magic number: try              {                  WriteInt(length' _physicalStateObj);                  if (recoverySessionData == null)                  {                      WriteInt((TdsEnums.DENALI_MAJOR << 24) | (TdsEnums.DENALI_INCREMENT << 16) | TdsEnums.DENALI_MINOR' _physicalStateObj);                  }                  else                  {                      WriteUnsignedInt(recoverySessionData._tdsVersion' _physicalStateObj);                  }                  WriteInt(rec.packetSize' _physicalStateObj);                  WriteInt(TdsEnums.CLIENT_PROG_VER' _physicalStateObj);                  WriteInt(TdsParserStaticMethods.GetCurrentProcessIdForTdsLoginOnly()' _physicalStateObj);                  WriteInt(0' _physicalStateObj); // connectionID is unused                    // Log7Flags (DWORD)                  int log7Flags = 0;                    /*                   Current snapshot from TDS spec with the offsets added:                      0) fByteOrder:1'                // byte order of numeric data types on client                      1) fCharSet:1'                  // character set on client                      2) fFloat:2'                    // Type of floating point on client                      4) fDumpLoad:1'                 // Dump/Load and BCP enable                      5) fUseDb:1'                    // USE notification                      6) fDatabase:1'                 // Initial database fatal flag                      7) fSetLang:1'                  // SET LANGUAGE notification                      8) fLanguage:1'                 // Initial language fatal flag                      9) fODBC:1'                     // Set if client is ODBC driver                     10) fTranBoundary:1'             // Transaction boundary notification                     11) fDelegatedSec:1'             // Security with delegation is available                     12) fUserType:3'                 // Type of user                     15) fIntegratedSecurity:1'       // Set if client is using integrated security                     16) fSQLType:4'                  // Type of SQL sent from client                     20) fOLEDB:1'                    // Set if client is OLEDB driver                     21) fSpare1:3'                   // first bit used for read-only intent' rest unused                     24) fResetPassword:1'            // set if client wants to reset password                     25) fNoNBCAndSparse:1'           // set if client does not support NBC and Sparse column                     26) fUserInstance:1'             // This connection wants to connect to a SQL "user instance"                     27) fUnknownCollationHandling:1' // This connection can handle unknown collation correctly.                     28) fExtension:1                 // Extensions are used                                      32 - total                  */                    // first byte                  log7Flags |= TdsEnums.USE_DB_ON << 5;                  log7Flags |= TdsEnums.INIT_DB_FATAL << 6;                  log7Flags |= TdsEnums.SET_LANG_ON << 7;                    // second byte                  log7Flags |= TdsEnums.INIT_LANG_FATAL << 8;                  log7Flags |= TdsEnums.ODBC_ON << 9;                  if (rec.useReplication)                  {                      log7Flags |= TdsEnums.REPL_ON << 12;                  }                  if (rec.useSSPI)                  {                      log7Flags |= TdsEnums.SSPI_ON << 15;                  }                    // third byte                  if (rec.readOnlyIntent)                  {                      log7Flags |= TdsEnums.READONLY_INTENT_ON << 21; // read-only intent flag is a first bit of fSpare1                  }                    // 4th one                  if (rec.userInstance)                  {                      log7Flags |= 1 << 26;                  }                  if (useFeatureExt)                  {                      log7Flags |= 1 << 28;                  }                    WriteInt(log7Flags' _physicalStateObj);                    WriteInt(0' _physicalStateObj);  // ClientTimeZone is not used                  WriteInt(0' _physicalStateObj);  // LCID is unused by server                    // Start writing offset and length of variable length portions                  int offset = TdsEnums.YUKON_LOG_REC_FIXED_LEN;                    // write offset/length pairs                    // note that you must always set ibHostName since it indicates the beginning of the variable length section of the login record                  WriteShort(offset' _physicalStateObj); // host name offset                  WriteShort(rec.hostName.Length' _physicalStateObj);                  offset += rec.hostName.Length * 2;                    // Only send user/password over if not fSSPI...  If both user/password and SSPI are in login                  // rec' only SSPI is used.  Confirmed same behavior as in luxor.                  if (rec.useSSPI == false)                  {                      WriteShort(offset' _physicalStateObj);  // userName offset                      WriteShort(userName.Length' _physicalStateObj);                      offset += userName.Length * 2;                        // the encrypted password is a byte array - so length computations different than strings                      WriteShort(offset' _physicalStateObj); // password offset                      WriteShort(encryptedPasswordLengthInBytes / 2' _physicalStateObj);                      offset += encryptedPasswordLengthInBytes;                  }                  else                  {                      // case where user/password data is not used' send over zeros                      WriteShort(0' _physicalStateObj);  // userName offset                      WriteShort(0' _physicalStateObj);                      WriteShort(0' _physicalStateObj);  // password offset                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // app name offset                  WriteShort(rec.applicationName.Length' _physicalStateObj);                  offset += rec.applicationName.Length * 2;                    WriteShort(offset' _physicalStateObj); // server name offset                  WriteShort(rec.serverName.Length' _physicalStateObj);                  offset += rec.serverName.Length * 2;                    WriteShort(offset' _physicalStateObj);                  if (useFeatureExt)                  {                      WriteShort(4' _physicalStateObj); // length of ibFeatgureExtLong (which is a DWORD)                      offset += 4;                  }                  else                  {                      WriteShort(0' _physicalStateObj); // unused (was remote password ?)                  }                    WriteShort(offset' _physicalStateObj); // client interface name offset                  WriteShort(clientInterfaceName.Length' _physicalStateObj);                  offset += clientInterfaceName.Length * 2;                    WriteShort(offset' _physicalStateObj); // language name offset                  WriteShort(rec.language.Length' _physicalStateObj);                  offset += rec.language.Length * 2;                    WriteShort(offset' _physicalStateObj); // database name offset                  WriteShort(rec.database.Length' _physicalStateObj);                  offset += rec.database.Length * 2;                    if (null == s_nicAddress)                      s_nicAddress = TdsParserStaticMethods.GetNetworkPhysicalAddressForTdsLoginOnly();                    _physicalStateObj.WriteByteArray(s_nicAddress' s_nicAddress.Length' 0);                    WriteShort(offset' _physicalStateObj); // ibSSPI offset                  if (rec.useSSPI)                  {                      WriteShort((int)outSSPILength' _physicalStateObj);                      offset += (int)outSSPILength;                  }                  else                  {                      WriteShort(0' _physicalStateObj);                  }                    WriteShort(offset' _physicalStateObj); // DB filename offset                  WriteShort(rec.attachDBFilename.Length' _physicalStateObj);                  offset += rec.attachDBFilename.Length * 2;                    WriteShort(offset' _physicalStateObj); // reset password offset                  WriteShort(0' _physicalStateObj);                    WriteInt(0' _physicalStateObj);        // reserved for chSSPI                    // write variable length portion                  WriteString(rec.hostName' _physicalStateObj);                    // if we are using SSPI' do not send over username/password' since we will use SSPI instead                  // same behavior as Luxor                  if (!rec.useSSPI)                  {                      WriteString(userName' _physicalStateObj);                        {                          _physicalStateObj.WriteByteArray(encryptedPassword' encryptedPasswordLengthInBytes' 0);                      }                  }                    WriteString(rec.applicationName' _physicalStateObj);                  WriteString(rec.serverName' _physicalStateObj);                    // write ibFeatureExtLong                  if (useFeatureExt)                  {                      WriteInt(feOffset' _physicalStateObj);                  }                    WriteString(clientInterfaceName' _physicalStateObj);                  WriteString(rec.language' _physicalStateObj);                  WriteString(rec.database' _physicalStateObj);                    // send over SSPI data if we are using SSPI                  if (rec.useSSPI)                      _physicalStateObj.WriteByteArray(outSSPIBuff' (int)outSSPILength' 0);                    WriteString(rec.attachDBFilename' _physicalStateObj);                  if (useFeatureExt)                  {                      if ((requestedFeatures & TdsEnums.FeatureExtension.SessionRecovery) != 0)                      {                          length += WriteSessionRecoveryFeatureRequest(recoverySessionData' true);                      }                      if ((requestedFeatures & TdsEnums.FeatureExtension.GlobalTransactions) != 0)                      {                          WriteGlobalTransactionsFeatureRequest(true);                      }                      _physicalStateObj.WriteByte(0xFF); // terminator                  }              }              catch (Exception e)              {                  if (ADP.IsCatchableExceptionType(e))                  {                      // be sure to wipe out our buffer if we started sending stuff                      _physicalStateObj._outputPacketNumber = 1;  // end of message - reset to 1 - per ramas                      _physicalStateObj.ResetBuffer();                  }                    throw;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The following statement contains a magic number: try              {                  // Temporarily disable async writes                  _asyncWrite = false;                    // This validation step MUST be done after locking the connection to guarantee we don't                   //  accidentally execute after the transaction has completed on a different thread.                  if (!isDelegateControlRequest)                  {                      _connHandler.CheckEnlistedTransactionBinding();                  }                    stateObj._outputMessageType = TdsEnums.MT_TRANS;       // set message type                  stateObj.SetTimeoutSeconds(timeout);                    stateObj.SniContext = SniContext.Snix_Execute;                    const int marsHeaderSize = 18; // 4 + 2 + 8 + 4                  const int totalHeaderLength = 22; // 4 + 4 + 2 + 8 + 4                  Debug.Assert(stateObj._outBytesUsed == stateObj._outputHeaderLen' "Output bytes written before total header length");                  // Write total header length                  WriteInt(totalHeaderLength' stateObj);                  // Write mars header length                  WriteInt(marsHeaderSize' stateObj);                  WriteMarsHeaderData(stateObj' _currentTransaction);                    WriteShort((short)request' stateObj); // write TransactionManager Request type                    bool returnReader = false;                    switch (request)                  {                      case TdsEnums.TransactionManagerRequestType.GetDTCAddress:                          WriteShort(0' stateObj);                            returnReader = true;                          break;                      case TdsEnums.TransactionManagerRequestType.Propagate:                          if (null != buffer)                          {                              WriteShort(buffer.Length' stateObj);                              stateObj.WriteByteArray(buffer' buffer.Length' 0);                          }                          else                          {                              WriteShort(0' stateObj);                          }                          break;                      case TdsEnums.TransactionManagerRequestType.Begin:                          Debug.Assert(null != transaction' "Should have specified an internalTransaction when doing a BeginTransaction request!");                            // Only assign the passed in transaction if it is not equal to the current transaction.                          // And' if it is not equal' the current actually should be null.  Anything else                          // is a unexpected state.  The concern here is mainly for the mixed use of                           // T-SQL and API transactions.                             // Expected states:                          // 1) _pendingTransaction = null' _currentTransaction = null' non null transaction                          // passed in on BeginTransaction API call.                          // 2) _currentTransaction != null' _pendingTransaction = null' non null transaction                          // passed in but equivalent to _currentTransaction.                            // #1 will occur on standard BeginTransactionAPI call.  #2 should only occur if                          // t-sql transaction started followed by a call to SqlConnection.BeginTransaction.                          // Any other state is unknown.                          if (_currentTransaction != transaction)                          {                              Debug.Assert(_currentTransaction == null || true == _fResetConnection' "We should not have a current Tx at this point");                              PendingTransaction = transaction;                          }                            stateObj.WriteByte((byte)isoLevel);                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      case TdsEnums.TransactionManagerRequestType.Promote:                          // No payload - except current transaction in header                          // Promote returns a DTC cookie.  However' the transaction cookie we use for the                          // connection does not change after a promote.                          break;                      case TdsEnums.TransactionManagerRequestType.Commit:                            Debug.Assert(transactionName.Length == 0' "Should not have a transaction name on Commit");                          stateObj.WriteByte((byte)0); // No xact name                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Rollback:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Save:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      default:                          Debug.Assert(false' "Unexpected TransactionManagerRequest");                          break;                  }                    Task writeTask = stateObj.WritePacket(TdsEnums.HARDFLUSH);                  Debug.Assert(writeTask == null' "Writes should not pend when writing sync");                  stateObj._pendingData = true;                  stateObj._messageStatus = 0;                    SqlDataReader dtcReader = null;                  stateObj.SniContext = SniContext.Snix_Read;                  if (returnReader)                  {                      dtcReader = new SqlDataReader(null' CommandBehavior.Default);                      Debug.Assert(this == stateObj.Parser' "different parser");  #if DEBUG                      // Remove the current owner of stateObj - otherwise we will hit asserts                      stateObj.Owner = null;  #endif                      dtcReader.Bind(stateObj);                        // force consumption of metadata                      _SqlMetaDataSet metaData = dtcReader.MetaData;                  }                  else                  {                      Run(RunBehavior.UntilDone' null' null' null' stateObj);                  }                    // If the retained ID is no longer valid (because we are enlisting in null or a new transaction) then it should be cleared                  if (((request == TdsEnums.TransactionManagerRequestType.Begin) || (request == TdsEnums.TransactionManagerRequestType.Propagate)) && ((transaction == null) || (transaction.TransactionId != _retainedTransactionId)))                  {                      _retainedTransactionId = SqlInternalTransaction.NullTransactionId;                  }                    return dtcReader;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                    FailureCleanup(stateObj' e);                    throw;              }              finally              {                  // SQLHotfix 50000518                  // make sure we don't leave temporary fields set when leaving this function                  _pendingTransaction = null;                    _asyncWrite = hadAsyncWrites;                    if (!callerHasConnectionLock)                  {                      _connHandler.ThreadHasParserLockForClose = false;                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The following statement contains a magic number: try              {                  // Temporarily disable async writes                  _asyncWrite = false;                    // This validation step MUST be done after locking the connection to guarantee we don't                   //  accidentally execute after the transaction has completed on a different thread.                  if (!isDelegateControlRequest)                  {                      _connHandler.CheckEnlistedTransactionBinding();                  }                    stateObj._outputMessageType = TdsEnums.MT_TRANS;       // set message type                  stateObj.SetTimeoutSeconds(timeout);                    stateObj.SniContext = SniContext.Snix_Execute;                    const int marsHeaderSize = 18; // 4 + 2 + 8 + 4                  const int totalHeaderLength = 22; // 4 + 4 + 2 + 8 + 4                  Debug.Assert(stateObj._outBytesUsed == stateObj._outputHeaderLen' "Output bytes written before total header length");                  // Write total header length                  WriteInt(totalHeaderLength' stateObj);                  // Write mars header length                  WriteInt(marsHeaderSize' stateObj);                  WriteMarsHeaderData(stateObj' _currentTransaction);                    WriteShort((short)request' stateObj); // write TransactionManager Request type                    bool returnReader = false;                    switch (request)                  {                      case TdsEnums.TransactionManagerRequestType.GetDTCAddress:                          WriteShort(0' stateObj);                            returnReader = true;                          break;                      case TdsEnums.TransactionManagerRequestType.Propagate:                          if (null != buffer)                          {                              WriteShort(buffer.Length' stateObj);                              stateObj.WriteByteArray(buffer' buffer.Length' 0);                          }                          else                          {                              WriteShort(0' stateObj);                          }                          break;                      case TdsEnums.TransactionManagerRequestType.Begin:                          Debug.Assert(null != transaction' "Should have specified an internalTransaction when doing a BeginTransaction request!");                            // Only assign the passed in transaction if it is not equal to the current transaction.                          // And' if it is not equal' the current actually should be null.  Anything else                          // is a unexpected state.  The concern here is mainly for the mixed use of                           // T-SQL and API transactions.                             // Expected states:                          // 1) _pendingTransaction = null' _currentTransaction = null' non null transaction                          // passed in on BeginTransaction API call.                          // 2) _currentTransaction != null' _pendingTransaction = null' non null transaction                          // passed in but equivalent to _currentTransaction.                            // #1 will occur on standard BeginTransactionAPI call.  #2 should only occur if                          // t-sql transaction started followed by a call to SqlConnection.BeginTransaction.                          // Any other state is unknown.                          if (_currentTransaction != transaction)                          {                              Debug.Assert(_currentTransaction == null || true == _fResetConnection' "We should not have a current Tx at this point");                              PendingTransaction = transaction;                          }                            stateObj.WriteByte((byte)isoLevel);                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      case TdsEnums.TransactionManagerRequestType.Promote:                          // No payload - except current transaction in header                          // Promote returns a DTC cookie.  However' the transaction cookie we use for the                          // connection does not change after a promote.                          break;                      case TdsEnums.TransactionManagerRequestType.Commit:                            Debug.Assert(transactionName.Length == 0' "Should not have a transaction name on Commit");                          stateObj.WriteByte((byte)0); // No xact name                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Rollback:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Save:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      default:                          Debug.Assert(false' "Unexpected TransactionManagerRequest");                          break;                  }                    Task writeTask = stateObj.WritePacket(TdsEnums.HARDFLUSH);                  Debug.Assert(writeTask == null' "Writes should not pend when writing sync");                  stateObj._pendingData = true;                  stateObj._messageStatus = 0;                    SqlDataReader dtcReader = null;                  stateObj.SniContext = SniContext.Snix_Read;                  if (returnReader)                  {                      dtcReader = new SqlDataReader(null' CommandBehavior.Default);                      Debug.Assert(this == stateObj.Parser' "different parser");  #if DEBUG                      // Remove the current owner of stateObj - otherwise we will hit asserts                      stateObj.Owner = null;  #endif                      dtcReader.Bind(stateObj);                        // force consumption of metadata                      _SqlMetaDataSet metaData = dtcReader.MetaData;                  }                  else                  {                      Run(RunBehavior.UntilDone' null' null' null' stateObj);                  }                    // If the retained ID is no longer valid (because we are enlisting in null or a new transaction) then it should be cleared                  if (((request == TdsEnums.TransactionManagerRequestType.Begin) || (request == TdsEnums.TransactionManagerRequestType.Propagate)) && ((transaction == null) || (transaction.TransactionId != _retainedTransactionId)))                  {                      _retainedTransactionId = SqlInternalTransaction.NullTransactionId;                  }                    return dtcReader;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                    FailureCleanup(stateObj' e);                    throw;              }              finally              {                  // SQLHotfix 50000518                  // make sure we don't leave temporary fields set when leaving this function                  _pendingTransaction = null;                    _asyncWrite = hadAsyncWrites;                    if (!callerHasConnectionLock)                  {                      _connHandler.ThreadHasParserLockForClose = false;                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The following statement contains a magic number: try              {                  // Temporarily disable async writes                  _asyncWrite = false;                    // This validation step MUST be done after locking the connection to guarantee we don't                   //  accidentally execute after the transaction has completed on a different thread.                  if (!isDelegateControlRequest)                  {                      _connHandler.CheckEnlistedTransactionBinding();                  }                    stateObj._outputMessageType = TdsEnums.MT_TRANS;       // set message type                  stateObj.SetTimeoutSeconds(timeout);                    stateObj.SniContext = SniContext.Snix_Execute;                    const int marsHeaderSize = 18; // 4 + 2 + 8 + 4                  const int totalHeaderLength = 22; // 4 + 4 + 2 + 8 + 4                  Debug.Assert(stateObj._outBytesUsed == stateObj._outputHeaderLen' "Output bytes written before total header length");                  // Write total header length                  WriteInt(totalHeaderLength' stateObj);                  // Write mars header length                  WriteInt(marsHeaderSize' stateObj);                  WriteMarsHeaderData(stateObj' _currentTransaction);                    WriteShort((short)request' stateObj); // write TransactionManager Request type                    bool returnReader = false;                    switch (request)                  {                      case TdsEnums.TransactionManagerRequestType.GetDTCAddress:                          WriteShort(0' stateObj);                            returnReader = true;                          break;                      case TdsEnums.TransactionManagerRequestType.Propagate:                          if (null != buffer)                          {                              WriteShort(buffer.Length' stateObj);                              stateObj.WriteByteArray(buffer' buffer.Length' 0);                          }                          else                          {                              WriteShort(0' stateObj);                          }                          break;                      case TdsEnums.TransactionManagerRequestType.Begin:                          Debug.Assert(null != transaction' "Should have specified an internalTransaction when doing a BeginTransaction request!");                            // Only assign the passed in transaction if it is not equal to the current transaction.                          // And' if it is not equal' the current actually should be null.  Anything else                          // is a unexpected state.  The concern here is mainly for the mixed use of                           // T-SQL and API transactions.                             // Expected states:                          // 1) _pendingTransaction = null' _currentTransaction = null' non null transaction                          // passed in on BeginTransaction API call.                          // 2) _currentTransaction != null' _pendingTransaction = null' non null transaction                          // passed in but equivalent to _currentTransaction.                            // #1 will occur on standard BeginTransactionAPI call.  #2 should only occur if                          // t-sql transaction started followed by a call to SqlConnection.BeginTransaction.                          // Any other state is unknown.                          if (_currentTransaction != transaction)                          {                              Debug.Assert(_currentTransaction == null || true == _fResetConnection' "We should not have a current Tx at this point");                              PendingTransaction = transaction;                          }                            stateObj.WriteByte((byte)isoLevel);                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      case TdsEnums.TransactionManagerRequestType.Promote:                          // No payload - except current transaction in header                          // Promote returns a DTC cookie.  However' the transaction cookie we use for the                          // connection does not change after a promote.                          break;                      case TdsEnums.TransactionManagerRequestType.Commit:                            Debug.Assert(transactionName.Length == 0' "Should not have a transaction name on Commit");                          stateObj.WriteByte((byte)0); // No xact name                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Rollback:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Save:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      default:                          Debug.Assert(false' "Unexpected TransactionManagerRequest");                          break;                  }                    Task writeTask = stateObj.WritePacket(TdsEnums.HARDFLUSH);                  Debug.Assert(writeTask == null' "Writes should not pend when writing sync");                  stateObj._pendingData = true;                  stateObj._messageStatus = 0;                    SqlDataReader dtcReader = null;                  stateObj.SniContext = SniContext.Snix_Read;                  if (returnReader)                  {                      dtcReader = new SqlDataReader(null' CommandBehavior.Default);                      Debug.Assert(this == stateObj.Parser' "different parser");  #if DEBUG                      // Remove the current owner of stateObj - otherwise we will hit asserts                      stateObj.Owner = null;  #endif                      dtcReader.Bind(stateObj);                        // force consumption of metadata                      _SqlMetaDataSet metaData = dtcReader.MetaData;                  }                  else                  {                      Run(RunBehavior.UntilDone' null' null' null' stateObj);                  }                    // If the retained ID is no longer valid (because we are enlisting in null or a new transaction) then it should be cleared                  if (((request == TdsEnums.TransactionManagerRequestType.Begin) || (request == TdsEnums.TransactionManagerRequestType.Propagate)) && ((transaction == null) || (transaction.TransactionId != _retainedTransactionId)))                  {                      _retainedTransactionId = SqlInternalTransaction.NullTransactionId;                  }                    return dtcReader;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                    FailureCleanup(stateObj' e);                    throw;              }              finally              {                  // SQLHotfix 50000518                  // make sure we don't leave temporary fields set when leaving this function                  _pendingTransaction = null;                    _asyncWrite = hadAsyncWrites;                    if (!callerHasConnectionLock)                  {                      _connHandler.ThreadHasParserLockForClose = false;                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The following statement contains a magic number: try              {                  // Temporarily disable async writes                  _asyncWrite = false;                    // This validation step MUST be done after locking the connection to guarantee we don't                   //  accidentally execute after the transaction has completed on a different thread.                  if (!isDelegateControlRequest)                  {                      _connHandler.CheckEnlistedTransactionBinding();                  }                    stateObj._outputMessageType = TdsEnums.MT_TRANS;       // set message type                  stateObj.SetTimeoutSeconds(timeout);                    stateObj.SniContext = SniContext.Snix_Execute;                    const int marsHeaderSize = 18; // 4 + 2 + 8 + 4                  const int totalHeaderLength = 22; // 4 + 4 + 2 + 8 + 4                  Debug.Assert(stateObj._outBytesUsed == stateObj._outputHeaderLen' "Output bytes written before total header length");                  // Write total header length                  WriteInt(totalHeaderLength' stateObj);                  // Write mars header length                  WriteInt(marsHeaderSize' stateObj);                  WriteMarsHeaderData(stateObj' _currentTransaction);                    WriteShort((short)request' stateObj); // write TransactionManager Request type                    bool returnReader = false;                    switch (request)                  {                      case TdsEnums.TransactionManagerRequestType.GetDTCAddress:                          WriteShort(0' stateObj);                            returnReader = true;                          break;                      case TdsEnums.TransactionManagerRequestType.Propagate:                          if (null != buffer)                          {                              WriteShort(buffer.Length' stateObj);                              stateObj.WriteByteArray(buffer' buffer.Length' 0);                          }                          else                          {                              WriteShort(0' stateObj);                          }                          break;                      case TdsEnums.TransactionManagerRequestType.Begin:                          Debug.Assert(null != transaction' "Should have specified an internalTransaction when doing a BeginTransaction request!");                            // Only assign the passed in transaction if it is not equal to the current transaction.                          // And' if it is not equal' the current actually should be null.  Anything else                          // is a unexpected state.  The concern here is mainly for the mixed use of                           // T-SQL and API transactions.                             // Expected states:                          // 1) _pendingTransaction = null' _currentTransaction = null' non null transaction                          // passed in on BeginTransaction API call.                          // 2) _currentTransaction != null' _pendingTransaction = null' non null transaction                          // passed in but equivalent to _currentTransaction.                            // #1 will occur on standard BeginTransactionAPI call.  #2 should only occur if                          // t-sql transaction started followed by a call to SqlConnection.BeginTransaction.                          // Any other state is unknown.                          if (_currentTransaction != transaction)                          {                              Debug.Assert(_currentTransaction == null || true == _fResetConnection' "We should not have a current Tx at this point");                              PendingTransaction = transaction;                          }                            stateObj.WriteByte((byte)isoLevel);                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      case TdsEnums.TransactionManagerRequestType.Promote:                          // No payload - except current transaction in header                          // Promote returns a DTC cookie.  However' the transaction cookie we use for the                          // connection does not change after a promote.                          break;                      case TdsEnums.TransactionManagerRequestType.Commit:                            Debug.Assert(transactionName.Length == 0' "Should not have a transaction name on Commit");                          stateObj.WriteByte((byte)0); // No xact name                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Rollback:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Save:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      default:                          Debug.Assert(false' "Unexpected TransactionManagerRequest");                          break;                  }                    Task writeTask = stateObj.WritePacket(TdsEnums.HARDFLUSH);                  Debug.Assert(writeTask == null' "Writes should not pend when writing sync");                  stateObj._pendingData = true;                  stateObj._messageStatus = 0;                    SqlDataReader dtcReader = null;                  stateObj.SniContext = SniContext.Snix_Read;                  if (returnReader)                  {                      dtcReader = new SqlDataReader(null' CommandBehavior.Default);                      Debug.Assert(this == stateObj.Parser' "different parser");  #if DEBUG                      // Remove the current owner of stateObj - otherwise we will hit asserts                      stateObj.Owner = null;  #endif                      dtcReader.Bind(stateObj);                        // force consumption of metadata                      _SqlMetaDataSet metaData = dtcReader.MetaData;                  }                  else                  {                      Run(RunBehavior.UntilDone' null' null' null' stateObj);                  }                    // If the retained ID is no longer valid (because we are enlisting in null or a new transaction) then it should be cleared                  if (((request == TdsEnums.TransactionManagerRequestType.Begin) || (request == TdsEnums.TransactionManagerRequestType.Propagate)) && ((transaction == null) || (transaction.TransactionId != _retainedTransactionId)))                  {                      _retainedTransactionId = SqlInternalTransaction.NullTransactionId;                  }                    return dtcReader;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                    FailureCleanup(stateObj' e);                    throw;              }              finally              {                  // SQLHotfix 50000518                  // make sure we don't leave temporary fields set when leaving this function                  _pendingTransaction = null;                    _asyncWrite = hadAsyncWrites;                    if (!callerHasConnectionLock)                  {                      _connHandler.ThreadHasParserLockForClose = false;                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteTransactionManagerRequest,The following statement contains a magic number: try              {                  // Temporarily disable async writes                  _asyncWrite = false;                    // This validation step MUST be done after locking the connection to guarantee we don't                   //  accidentally execute after the transaction has completed on a different thread.                  if (!isDelegateControlRequest)                  {                      _connHandler.CheckEnlistedTransactionBinding();                  }                    stateObj._outputMessageType = TdsEnums.MT_TRANS;       // set message type                  stateObj.SetTimeoutSeconds(timeout);                    stateObj.SniContext = SniContext.Snix_Execute;                    const int marsHeaderSize = 18; // 4 + 2 + 8 + 4                  const int totalHeaderLength = 22; // 4 + 4 + 2 + 8 + 4                  Debug.Assert(stateObj._outBytesUsed == stateObj._outputHeaderLen' "Output bytes written before total header length");                  // Write total header length                  WriteInt(totalHeaderLength' stateObj);                  // Write mars header length                  WriteInt(marsHeaderSize' stateObj);                  WriteMarsHeaderData(stateObj' _currentTransaction);                    WriteShort((short)request' stateObj); // write TransactionManager Request type                    bool returnReader = false;                    switch (request)                  {                      case TdsEnums.TransactionManagerRequestType.GetDTCAddress:                          WriteShort(0' stateObj);                            returnReader = true;                          break;                      case TdsEnums.TransactionManagerRequestType.Propagate:                          if (null != buffer)                          {                              WriteShort(buffer.Length' stateObj);                              stateObj.WriteByteArray(buffer' buffer.Length' 0);                          }                          else                          {                              WriteShort(0' stateObj);                          }                          break;                      case TdsEnums.TransactionManagerRequestType.Begin:                          Debug.Assert(null != transaction' "Should have specified an internalTransaction when doing a BeginTransaction request!");                            // Only assign the passed in transaction if it is not equal to the current transaction.                          // And' if it is not equal' the current actually should be null.  Anything else                          // is a unexpected state.  The concern here is mainly for the mixed use of                           // T-SQL and API transactions.                             // Expected states:                          // 1) _pendingTransaction = null' _currentTransaction = null' non null transaction                          // passed in on BeginTransaction API call.                          // 2) _currentTransaction != null' _pendingTransaction = null' non null transaction                          // passed in but equivalent to _currentTransaction.                            // #1 will occur on standard BeginTransactionAPI call.  #2 should only occur if                          // t-sql transaction started followed by a call to SqlConnection.BeginTransaction.                          // Any other state is unknown.                          if (_currentTransaction != transaction)                          {                              Debug.Assert(_currentTransaction == null || true == _fResetConnection' "We should not have a current Tx at this point");                              PendingTransaction = transaction;                          }                            stateObj.WriteByte((byte)isoLevel);                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      case TdsEnums.TransactionManagerRequestType.Promote:                          // No payload - except current transaction in header                          // Promote returns a DTC cookie.  However' the transaction cookie we use for the                          // connection does not change after a promote.                          break;                      case TdsEnums.TransactionManagerRequestType.Commit:                            Debug.Assert(transactionName.Length == 0' "Should not have a transaction name on Commit");                          stateObj.WriteByte((byte)0); // No xact name                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Rollback:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                            stateObj.WriteByte(0);  // No flags                            Debug.Assert(isoLevel == TdsEnums.TransactionManagerIsolationLevel.Unspecified' "Should not have isolation level other than unspecified on Commit!");                          // WriteByte((byte) 0' stateObj); // IsolationLevel                          // WriteByte((byte) 0' stateObj); // No begin xact name                          break;                      case TdsEnums.TransactionManagerRequestType.Save:                            stateObj.WriteByte((byte)(transactionName.Length * 2)); // Write number of bytes (unicode string).                          WriteString(transactionName' stateObj);                          break;                      default:                          Debug.Assert(false' "Unexpected TransactionManagerRequest");                          break;                  }                    Task writeTask = stateObj.WritePacket(TdsEnums.HARDFLUSH);                  Debug.Assert(writeTask == null' "Writes should not pend when writing sync");                  stateObj._pendingData = true;                  stateObj._messageStatus = 0;                    SqlDataReader dtcReader = null;                  stateObj.SniContext = SniContext.Snix_Read;                  if (returnReader)                  {                      dtcReader = new SqlDataReader(null' CommandBehavior.Default);                      Debug.Assert(this == stateObj.Parser' "different parser");  #if DEBUG                      // Remove the current owner of stateObj - otherwise we will hit asserts                      stateObj.Owner = null;  #endif                      dtcReader.Bind(stateObj);                        // force consumption of metadata                      _SqlMetaDataSet metaData = dtcReader.MetaData;                  }                  else                  {                      Run(RunBehavior.UntilDone' null' null' null' stateObj);                  }                    // If the retained ID is no longer valid (because we are enlisting in null or a new transaction) then it should be cleared                  if (((request == TdsEnums.TransactionManagerRequestType.Begin) || (request == TdsEnums.TransactionManagerRequestType.Propagate)) && ((transaction == null) || (transaction.TransactionId != _retainedTransactionId)))                  {                      _retainedTransactionId = SqlInternalTransaction.NullTransactionId;                  }                    return dtcReader;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                    FailureCleanup(stateObj' e);                    throw;              }              finally              {                  // SQLHotfix 50000518                  // make sure we don't leave temporary fields set when leaving this function                  _pendingTransaction = null;                    _asyncWrite = hadAsyncWrites;                    if (!callerHasConnectionLock)                  {                      _connHandler.ThreadHasParserLockForClose = false;                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The following statement contains a magic number: try              {                  _SqlRPC rpcext = null;                  int tempLen;                    // Promote' Commit and Rollback requests for                  // delegated transactions often happen while there is an open result                  // set' so we need to handle them by using a different MARS session'                   // otherwise we'll write on the physical state objects while someone                  // else is using it.  When we don't have MARS enabled' we need to                   // lock the physical state object to synchronize its use at least                  // until we increment the open results count.  Once it's been                   // incremented the delegated transaction requests will fail' so they                  // won't stomp on anything.                      if (firstCall)                  {                      _connHandler._parserLock.Wait(canReleaseFromAnyThread: !sync);                      releaseConnectionLock = true;                  }                  try                  {                      // Ensure that connection is alive                      if ((TdsParserState.Broken == State) || (TdsParserState.Closed == State))                      {                          throw ADP.ClosedConnectionError();                      }                        // This validation step MUST be done after locking the connection to guarantee we don't                       //  accidentally execute after the transaction has completed on a different thread.                      if (firstCall)                      {                          _asyncWrite = !sync;                            _connHandler.CheckEnlistedTransactionBinding();                            stateObj.SetTimeoutSeconds(timeout);                            stateObj.SniContext = SniContext.Snix_Execute;                            if (_isYukon)                          {                              WriteRPCBatchHeaders(stateObj' notificationRequest);                          }                            stateObj._outputMessageType = TdsEnums.MT_RPC;                      }                        for (int ii = startRpc; ii < rpcArray.Length; ii++)                      {                          rpcext = rpcArray[ii];                            if (startParam == 0 || ii > startRpc)                          {                              if (rpcext.ProcID != 0)                              {                                  // Perf optimization for Shiloh and later'                                  Debug.Assert(rpcext.ProcID < 255' "rpcExec:ProcID can't be larger than 255");                                  WriteShort(0xffff' stateObj);                                  WriteShort((short)(rpcext.ProcID)' stateObj);                              }                              else                              {                                  Debug.Assert(!string.IsNullOrEmpty(rpcext.rpcName)' "must have an RPC name");                                  tempLen = rpcext.rpcName.Length;                                  WriteShort(tempLen' stateObj);                                  WriteString(rpcext.rpcName' tempLen' 0' stateObj);                              }                                // Options                              WriteShort((short)rpcext.options' stateObj);                          }                            // Stream out parameters                          SqlParameter[] parameters = rpcext.parameters;                            for (int i = (ii == startRpc) ? startParam : 0; i < parameters.Length; i++)                          {                              // parameters can be unnamed                              SqlParameter param = parameters[i];                              // Since we are reusing the parameters array' we cannot rely on length to indicate no of parameters.                              if (param == null)                                  break;      // End of parameters for this execute                                // Validate parameters are not variable length without size and with null value.                              param.Validate(i' isCommandProc);                                // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)                              MetaType mt = param.InternalMetaType;                                if (mt.IsNewKatmaiType)                              {                                  WriteSmiParameter(param' i' 0 != (rpcext.paramoptions[i] & TdsEnums.RPC_PARAM_DEFAULT)' stateObj);                                  continue;                              }                                if ((!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported))                              {                                  throw ADP.VersionDoesNotSupportDataType(mt.TypeName);                              }                              object value = null;                              bool isNull = true;                              bool isSqlVal = false;                              bool isDataFeed = false;                              // if we have an output param' set the value to null so we do not send it across to the server                              if (param.Direction == ParameterDirection.Output)                              {                                  isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing.                                  param.Value = null;                                  param.ParameterIsSqlType = isSqlVal;                              }                              else                              {                                  value = param.GetCoercedValue();                                  isNull = param.IsNull;                                  if (!isNull)                                  {                                      isSqlVal = param.CoercedValueIsSqlType;                                      isDataFeed = param.CoercedValueIsDataFeed;                                  }                              }                                WriteParameterName(param.ParameterNameFixed' stateObj);                                // Write parameter status                              stateObj.WriteByte(rpcext.paramoptions[i]);                                // MaxLen field is only written out for non-fixed length data types                              // use the greater of the two sizes for maxLen                              int actualSize;                              int size = mt.IsSizeInCharacters ? param.GetParameterSize() * 2 : param.GetParameterSize();                                // for UDTs' we calculate the length later when we get the bytes. This is a really expensive operation                              if (mt.TDSType != TdsEnums.SQLUDT)                                  // getting the actualSize is expensive' cache here and use below                                  actualSize = param.GetActualSize();                              else                                  actualSize = 0; //get this later                                byte precision = 0;                              byte scale = 0;                                // scale and precision are only relevant for numeric and decimal types                              // adjust the actual value scale and precision to match the user specified                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  precision = param.GetActualPrecision();                                  scale = param.GetActualScale();                                    if (precision > TdsEnums.MAX_NUMERIC_PRECISION)                                  {                                      throw SQL.PrecisionValueOutOfRange(precision);                                  }                                    // Make sure the value matches the scale the user enters                                  if (!isNull)                                  {                                      if (isSqlVal)                                      {                                          value = AdjustSqlDecimalScale((SqlDecimal)value' scale);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < ((SqlDecimal)value).Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((SqlDecimal)value);                                              }                                          }                                      }                                      else                                      {                                          value = AdjustDecimalScale((decimal)value' scale);                                            SqlDecimal sqlValue = new SqlDecimal((decimal)value);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < sqlValue.Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((decimal)value);                                              }                                          }                                      }                                  }                              }                                // fixup the types by using the NullableType property of the MetaType class                              //                              // following rules should be followed based on feedback from the M-SQL team                              // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)                              // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)                              // 3) DECIMALN should always be sent as NUMERICN                              //                              stateObj.WriteByte(mt.NullableType);                                // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns                              if (mt.TDSType == TdsEnums.SQLVARIANT)                              {                                  // devnote: Do we ever hit this codepath? Yes' when a null value is being written out via a sql variant                                  // param.GetActualSize is not used                                  WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj);                                  continue;                              }                                int codePageByteSize = 0;                              int maxsize = 0;                                if (mt.IsAnsiType)                              {                                  // Avoid the following code block if ANSI but unfilled LazyMat blob                                  if ((!isNull) && (!isDataFeed))                                  {                                      string s;                                        if (isSqlVal)                                      {                                          if (value is SqlString)                                          {                                              s = ((SqlString)value).Value;                                          }                                          else                                          {                                              Debug.Assert(value is SqlChars' "Unknown value for Ansi datatype");                                              s = new String(((SqlChars)value).Value);                                          }                                      }                                      else                                      {                                          s = (string)value;                                      }                                        codePageByteSize = GetEncodingCharLength(s' actualSize' param.Offset' _defaultEncoding);                                  }                                    if (mt.IsPlp)                                  {                                      WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else                                  {                                      maxsize = (size > codePageByteSize) ? size : codePageByteSize;                                      if (maxsize == 0)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                              else                              {                                  // If type timestamp - treat as fixed type and always send over timestamp length' which is 8.                                  // For fixed types' we either send null or fixed length for type length.  We want to match that                                  // behavior for timestamps.  However' in the case of null' we still must send 8 because if we                                  // send null we will not receive a output val.  You can send null for fixed types and still                                  // receive a output value' but not for variable types.  So' always send 8 for timestamp because                                  // while the user sees it as a fixed type' we are actually representing it as a bigbinary which                                  // is variable.                                  if (mt.SqlDbType == SqlDbType.Timestamp)                                  {                                      WriteParameterVarLen(mt' TdsEnums.TEXT_TIME_STAMP_LEN' false' stateObj);                                  }                                  else if (mt.SqlDbType == SqlDbType.Udt)                                  {                                      byte[] udtVal = null;                                      Format format = Format.Native;                                        Debug.Assert(_isYukon' "Invalid DataType UDT for non-Yukon or later server!");                                        if (!isNull)                                      {                                          udtVal = _connHandler.Connection.GetBytes(value' out format' out maxsize);                                            Debug.Assert(null != udtVal' "GetBytes returned null instance. Make sure that it always returns non-null value");                                          size = udtVal.Length;                                            //it may be legitimate' but we dont support it yet                                          if (size < 0 || (size >= ushort.MaxValue && maxsize != -1))                                              throw new IndexOutOfRangeException();                                      }                                        //if this is NULL value' write special null value                                      byte[] lenBytes = BitConverter.GetBytes((long)size);                                        if (string.IsNullOrEmpty(param.UdtTypeName))                                          throw SQL.MustSetUdtTypeNameForUdtParams();                                        // Split the input name. TypeName is returned as single 3 part name during DeriveParameters.                                      // NOTE: ParseUdtTypeName throws if format is incorrect                                      string[] names = SqlParameter.ParseTypeName(param.UdtTypeName' true /* is UdtTypeName */);                                      if (!string.IsNullOrEmpty(names[0]) && TdsEnums.MAX_SERVERNAME < names[0].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (!string.IsNullOrEmpty(names[1]) && TdsEnums.MAX_SERVERNAME < names[names.Length - 2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (TdsEnums.MAX_SERVERNAME < names[2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                        WriteUDTMetaData(value' names[0]' names[1]' names[2]' stateObj);                                        if (!isNull)                                      {                                          WriteUnsignedLong((ulong)udtVal.Length' stateObj); // PLP length                                          if (udtVal.Length > 0)                                          { // Only write chunk length if its value is greater than 0                                              WriteInt(udtVal.Length' stateObj); // Chunk length                                              stateObj.WriteByteArray(udtVal' udtVal.Length' 0); // Value                                          }                                          WriteInt(0' stateObj); // Terminator                                      }                                      else                                      {                                          WriteUnsignedLong(TdsEnums.SQL_PLP_NULL' stateObj); // PLP Null.                                      }                                      continue; // End of UDT - continue to next parameter.                                  }                                  else if (mt.IsPlp)                                  {                                      if (mt.SqlDbType != SqlDbType.Xml)                                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else if ((!mt.IsVarTime) && (mt.SqlDbType != SqlDbType.Date))                                  {   // Time' Date' DateTime2' DateTimeoffset do not have the size written out                                      maxsize = (size > actualSize) ? size : actualSize;                                      if (maxsize == 0 && _isYukon)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types (SQL9 - 682322)                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                                // scale and precision are only relevant for numeric and decimal types                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  if (0 == precision)                                  {                                      stateObj.WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);                                  }                                  else                                  {                                      stateObj.WriteByte(precision);                                  }                                    stateObj.WriteByte(scale);                              }                              else if (mt.IsVarTime)                              {                                  stateObj.WriteByte(param.GetActualScale());                              }                                // write out collation or xml metadata                                if (_isYukon && (mt.SqlDbType == SqlDbType.Xml))                              {                                  if (((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty)))                                  {                                      stateObj.WriteByte(1);  //Schema present flag                                        if ((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionDatabase).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionDatabase' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);       // No dbname                                      }                                        if ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionOwningSchema).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionOwningSchema' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);      // no xml schema name                                      }                                        if ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionName).Length;                                          WriteShort((short)(tempLen)' stateObj);                                          WriteString(param.XmlSchemaCollectionName' tempLen' 0' stateObj);                                      }                                      else                                      {                                          WriteShort(0' stateObj);       // No xml schema collection name                                      }                                  }                                  else                                  {                                      stateObj.WriteByte(0);       // No schema                                  }                              }                              else if (mt.IsCharType)                              {                                  // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter                                  SqlCollation outCollation = (param.Collation != null) ? param.Collation : _defaultCollation;                                  Debug.Assert(_defaultCollation != null' "_defaultCollation is null!");                                    WriteUnsignedInt(outCollation.info' stateObj);                                  stateObj.WriteByte(outCollation.sortId);                              }                                if (0 == codePageByteSize)                                  WriteParameterVarLen(mt' actualSize' isNull' stateObj' isDataFeed);                              else                                  WriteParameterVarLen(mt' codePageByteSize' isNull' stateObj' isDataFeed);                                Task writeParamTask = null;                              // write the value now                              if (!isNull)                              {                                  if (isSqlVal)                                  {                                      writeParamTask = WriteSqlValue(value' mt' actualSize' codePageByteSize' param.Offset' stateObj);                                  }                                  else                                  {                                      // for codePageEncoded types' WriteValue simply expects the number of characters                                      // For plp types' we also need the encoded byte size                                      writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed);                                  }                              }                                if (!sync)                              {                                  if (writeParamTask == null)                                  {                                      writeParamTask = stateObj.WaitForAccumulatedWrites();                                  }                                    if (writeParamTask != null)                                  {                                      Task task = null;                                      if (completion == null)                                      {                                          completion = new TaskCompletionSource<object>();                                          task = completion.Task;                                      }                                        AsyncHelper.ContinueTask(writeParamTask' completion'                                          () => TdsExecuteRPC(rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion'                                                                startRpc: ii' startParam: i + 1)'                                          connectionToDoom: _connHandler'                                          onFailure: exc => TdsExecuteRPC_OnFailure(exc' stateObj));                                        // Take care of releasing the locks                                      if (releaseConnectionLock)                                      {                                          task.ContinueWith(_ =>                                          {                                              _connHandler._parserLock.Release();                                          }' TaskScheduler.Default);                                          releaseConnectionLock = false;                                      }                                        return task;                                  }                              }  #if DEBUG                              else                              {                                  Debug.Assert(writeParamTask == null' "Should not have a task when executing sync");                              }  #endif                          } // parameter for loop                            // If this is not the last RPC we are sending' add the batch flag                          if (ii < (rpcArray.Length - 1))                          {                              if (_isYukon)                              {                                  stateObj.WriteByte(TdsEnums.YUKON_RPCBATCHFLAG);                              }                              else                              {                                  stateObj.WriteByte(TdsEnums.SHILOH_RPCBATCHFLAG);                              }                          }                      } // rpc for loop                        Task execFlushTask = stateObj.ExecuteFlush();                      Debug.Assert(!sync || execFlushTask == null' "Should not get a task when executing sync");                      if (execFlushTask != null)                      {                          Task task = null;                            if (completion == null)                          {                              completion = new TaskCompletionSource<object>();                              task = completion.Task;                          }                            bool taskReleaseConnectionLock = releaseConnectionLock;                          execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default);                            // ExecuteFlushTaskCallback will take care of the locks for us                          releaseConnectionLock = false;                            return task;                      }                  }                  catch (Exception e)                  {                      if (!ADP.IsCatchableExceptionType(e))                      {                          throw;                      }                        FailureCleanup(stateObj' e);                        throw;                  }                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetResult(null);                  }                  return null;              }              catch (Exception e)              {                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetException(e);                      return null;                  }                  else                  {                      throw;                  }              }              finally              {                  Debug.Assert(firstCall || !releaseConnectionLock' "Shouldn't be releasing locks synchronously after the first call");                  if (releaseConnectionLock)                  {                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The following statement contains a magic number: try              {                  _SqlRPC rpcext = null;                  int tempLen;                    // Promote' Commit and Rollback requests for                  // delegated transactions often happen while there is an open result                  // set' so we need to handle them by using a different MARS session'                   // otherwise we'll write on the physical state objects while someone                  // else is using it.  When we don't have MARS enabled' we need to                   // lock the physical state object to synchronize its use at least                  // until we increment the open results count.  Once it's been                   // incremented the delegated transaction requests will fail' so they                  // won't stomp on anything.                      if (firstCall)                  {                      _connHandler._parserLock.Wait(canReleaseFromAnyThread: !sync);                      releaseConnectionLock = true;                  }                  try                  {                      // Ensure that connection is alive                      if ((TdsParserState.Broken == State) || (TdsParserState.Closed == State))                      {                          throw ADP.ClosedConnectionError();                      }                        // This validation step MUST be done after locking the connection to guarantee we don't                       //  accidentally execute after the transaction has completed on a different thread.                      if (firstCall)                      {                          _asyncWrite = !sync;                            _connHandler.CheckEnlistedTransactionBinding();                            stateObj.SetTimeoutSeconds(timeout);                            stateObj.SniContext = SniContext.Snix_Execute;                            if (_isYukon)                          {                              WriteRPCBatchHeaders(stateObj' notificationRequest);                          }                            stateObj._outputMessageType = TdsEnums.MT_RPC;                      }                        for (int ii = startRpc; ii < rpcArray.Length; ii++)                      {                          rpcext = rpcArray[ii];                            if (startParam == 0 || ii > startRpc)                          {                              if (rpcext.ProcID != 0)                              {                                  // Perf optimization for Shiloh and later'                                  Debug.Assert(rpcext.ProcID < 255' "rpcExec:ProcID can't be larger than 255");                                  WriteShort(0xffff' stateObj);                                  WriteShort((short)(rpcext.ProcID)' stateObj);                              }                              else                              {                                  Debug.Assert(!string.IsNullOrEmpty(rpcext.rpcName)' "must have an RPC name");                                  tempLen = rpcext.rpcName.Length;                                  WriteShort(tempLen' stateObj);                                  WriteString(rpcext.rpcName' tempLen' 0' stateObj);                              }                                // Options                              WriteShort((short)rpcext.options' stateObj);                          }                            // Stream out parameters                          SqlParameter[] parameters = rpcext.parameters;                            for (int i = (ii == startRpc) ? startParam : 0; i < parameters.Length; i++)                          {                              // parameters can be unnamed                              SqlParameter param = parameters[i];                              // Since we are reusing the parameters array' we cannot rely on length to indicate no of parameters.                              if (param == null)                                  break;      // End of parameters for this execute                                // Validate parameters are not variable length without size and with null value.                              param.Validate(i' isCommandProc);                                // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)                              MetaType mt = param.InternalMetaType;                                if (mt.IsNewKatmaiType)                              {                                  WriteSmiParameter(param' i' 0 != (rpcext.paramoptions[i] & TdsEnums.RPC_PARAM_DEFAULT)' stateObj);                                  continue;                              }                                if ((!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported))                              {                                  throw ADP.VersionDoesNotSupportDataType(mt.TypeName);                              }                              object value = null;                              bool isNull = true;                              bool isSqlVal = false;                              bool isDataFeed = false;                              // if we have an output param' set the value to null so we do not send it across to the server                              if (param.Direction == ParameterDirection.Output)                              {                                  isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing.                                  param.Value = null;                                  param.ParameterIsSqlType = isSqlVal;                              }                              else                              {                                  value = param.GetCoercedValue();                                  isNull = param.IsNull;                                  if (!isNull)                                  {                                      isSqlVal = param.CoercedValueIsSqlType;                                      isDataFeed = param.CoercedValueIsDataFeed;                                  }                              }                                WriteParameterName(param.ParameterNameFixed' stateObj);                                // Write parameter status                              stateObj.WriteByte(rpcext.paramoptions[i]);                                // MaxLen field is only written out for non-fixed length data types                              // use the greater of the two sizes for maxLen                              int actualSize;                              int size = mt.IsSizeInCharacters ? param.GetParameterSize() * 2 : param.GetParameterSize();                                // for UDTs' we calculate the length later when we get the bytes. This is a really expensive operation                              if (mt.TDSType != TdsEnums.SQLUDT)                                  // getting the actualSize is expensive' cache here and use below                                  actualSize = param.GetActualSize();                              else                                  actualSize = 0; //get this later                                byte precision = 0;                              byte scale = 0;                                // scale and precision are only relevant for numeric and decimal types                              // adjust the actual value scale and precision to match the user specified                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  precision = param.GetActualPrecision();                                  scale = param.GetActualScale();                                    if (precision > TdsEnums.MAX_NUMERIC_PRECISION)                                  {                                      throw SQL.PrecisionValueOutOfRange(precision);                                  }                                    // Make sure the value matches the scale the user enters                                  if (!isNull)                                  {                                      if (isSqlVal)                                      {                                          value = AdjustSqlDecimalScale((SqlDecimal)value' scale);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < ((SqlDecimal)value).Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((SqlDecimal)value);                                              }                                          }                                      }                                      else                                      {                                          value = AdjustDecimalScale((decimal)value' scale);                                            SqlDecimal sqlValue = new SqlDecimal((decimal)value);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < sqlValue.Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((decimal)value);                                              }                                          }                                      }                                  }                              }                                // fixup the types by using the NullableType property of the MetaType class                              //                              // following rules should be followed based on feedback from the M-SQL team                              // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)                              // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)                              // 3) DECIMALN should always be sent as NUMERICN                              //                              stateObj.WriteByte(mt.NullableType);                                // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns                              if (mt.TDSType == TdsEnums.SQLVARIANT)                              {                                  // devnote: Do we ever hit this codepath? Yes' when a null value is being written out via a sql variant                                  // param.GetActualSize is not used                                  WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj);                                  continue;                              }                                int codePageByteSize = 0;                              int maxsize = 0;                                if (mt.IsAnsiType)                              {                                  // Avoid the following code block if ANSI but unfilled LazyMat blob                                  if ((!isNull) && (!isDataFeed))                                  {                                      string s;                                        if (isSqlVal)                                      {                                          if (value is SqlString)                                          {                                              s = ((SqlString)value).Value;                                          }                                          else                                          {                                              Debug.Assert(value is SqlChars' "Unknown value for Ansi datatype");                                              s = new String(((SqlChars)value).Value);                                          }                                      }                                      else                                      {                                          s = (string)value;                                      }                                        codePageByteSize = GetEncodingCharLength(s' actualSize' param.Offset' _defaultEncoding);                                  }                                    if (mt.IsPlp)                                  {                                      WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else                                  {                                      maxsize = (size > codePageByteSize) ? size : codePageByteSize;                                      if (maxsize == 0)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                              else                              {                                  // If type timestamp - treat as fixed type and always send over timestamp length' which is 8.                                  // For fixed types' we either send null or fixed length for type length.  We want to match that                                  // behavior for timestamps.  However' in the case of null' we still must send 8 because if we                                  // send null we will not receive a output val.  You can send null for fixed types and still                                  // receive a output value' but not for variable types.  So' always send 8 for timestamp because                                  // while the user sees it as a fixed type' we are actually representing it as a bigbinary which                                  // is variable.                                  if (mt.SqlDbType == SqlDbType.Timestamp)                                  {                                      WriteParameterVarLen(mt' TdsEnums.TEXT_TIME_STAMP_LEN' false' stateObj);                                  }                                  else if (mt.SqlDbType == SqlDbType.Udt)                                  {                                      byte[] udtVal = null;                                      Format format = Format.Native;                                        Debug.Assert(_isYukon' "Invalid DataType UDT for non-Yukon or later server!");                                        if (!isNull)                                      {                                          udtVal = _connHandler.Connection.GetBytes(value' out format' out maxsize);                                            Debug.Assert(null != udtVal' "GetBytes returned null instance. Make sure that it always returns non-null value");                                          size = udtVal.Length;                                            //it may be legitimate' but we dont support it yet                                          if (size < 0 || (size >= ushort.MaxValue && maxsize != -1))                                              throw new IndexOutOfRangeException();                                      }                                        //if this is NULL value' write special null value                                      byte[] lenBytes = BitConverter.GetBytes((long)size);                                        if (string.IsNullOrEmpty(param.UdtTypeName))                                          throw SQL.MustSetUdtTypeNameForUdtParams();                                        // Split the input name. TypeName is returned as single 3 part name during DeriveParameters.                                      // NOTE: ParseUdtTypeName throws if format is incorrect                                      string[] names = SqlParameter.ParseTypeName(param.UdtTypeName' true /* is UdtTypeName */);                                      if (!string.IsNullOrEmpty(names[0]) && TdsEnums.MAX_SERVERNAME < names[0].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (!string.IsNullOrEmpty(names[1]) && TdsEnums.MAX_SERVERNAME < names[names.Length - 2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (TdsEnums.MAX_SERVERNAME < names[2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                        WriteUDTMetaData(value' names[0]' names[1]' names[2]' stateObj);                                        if (!isNull)                                      {                                          WriteUnsignedLong((ulong)udtVal.Length' stateObj); // PLP length                                          if (udtVal.Length > 0)                                          { // Only write chunk length if its value is greater than 0                                              WriteInt(udtVal.Length' stateObj); // Chunk length                                              stateObj.WriteByteArray(udtVal' udtVal.Length' 0); // Value                                          }                                          WriteInt(0' stateObj); // Terminator                                      }                                      else                                      {                                          WriteUnsignedLong(TdsEnums.SQL_PLP_NULL' stateObj); // PLP Null.                                      }                                      continue; // End of UDT - continue to next parameter.                                  }                                  else if (mt.IsPlp)                                  {                                      if (mt.SqlDbType != SqlDbType.Xml)                                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else if ((!mt.IsVarTime) && (mt.SqlDbType != SqlDbType.Date))                                  {   // Time' Date' DateTime2' DateTimeoffset do not have the size written out                                      maxsize = (size > actualSize) ? size : actualSize;                                      if (maxsize == 0 && _isYukon)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types (SQL9 - 682322)                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                                // scale and precision are only relevant for numeric and decimal types                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  if (0 == precision)                                  {                                      stateObj.WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);                                  }                                  else                                  {                                      stateObj.WriteByte(precision);                                  }                                    stateObj.WriteByte(scale);                              }                              else if (mt.IsVarTime)                              {                                  stateObj.WriteByte(param.GetActualScale());                              }                                // write out collation or xml metadata                                if (_isYukon && (mt.SqlDbType == SqlDbType.Xml))                              {                                  if (((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty)))                                  {                                      stateObj.WriteByte(1);  //Schema present flag                                        if ((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionDatabase).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionDatabase' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);       // No dbname                                      }                                        if ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionOwningSchema).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionOwningSchema' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);      // no xml schema name                                      }                                        if ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionName).Length;                                          WriteShort((short)(tempLen)' stateObj);                                          WriteString(param.XmlSchemaCollectionName' tempLen' 0' stateObj);                                      }                                      else                                      {                                          WriteShort(0' stateObj);       // No xml schema collection name                                      }                                  }                                  else                                  {                                      stateObj.WriteByte(0);       // No schema                                  }                              }                              else if (mt.IsCharType)                              {                                  // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter                                  SqlCollation outCollation = (param.Collation != null) ? param.Collation : _defaultCollation;                                  Debug.Assert(_defaultCollation != null' "_defaultCollation is null!");                                    WriteUnsignedInt(outCollation.info' stateObj);                                  stateObj.WriteByte(outCollation.sortId);                              }                                if (0 == codePageByteSize)                                  WriteParameterVarLen(mt' actualSize' isNull' stateObj' isDataFeed);                              else                                  WriteParameterVarLen(mt' codePageByteSize' isNull' stateObj' isDataFeed);                                Task writeParamTask = null;                              // write the value now                              if (!isNull)                              {                                  if (isSqlVal)                                  {                                      writeParamTask = WriteSqlValue(value' mt' actualSize' codePageByteSize' param.Offset' stateObj);                                  }                                  else                                  {                                      // for codePageEncoded types' WriteValue simply expects the number of characters                                      // For plp types' we also need the encoded byte size                                      writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed);                                  }                              }                                if (!sync)                              {                                  if (writeParamTask == null)                                  {                                      writeParamTask = stateObj.WaitForAccumulatedWrites();                                  }                                    if (writeParamTask != null)                                  {                                      Task task = null;                                      if (completion == null)                                      {                                          completion = new TaskCompletionSource<object>();                                          task = completion.Task;                                      }                                        AsyncHelper.ContinueTask(writeParamTask' completion'                                          () => TdsExecuteRPC(rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion'                                                                startRpc: ii' startParam: i + 1)'                                          connectionToDoom: _connHandler'                                          onFailure: exc => TdsExecuteRPC_OnFailure(exc' stateObj));                                        // Take care of releasing the locks                                      if (releaseConnectionLock)                                      {                                          task.ContinueWith(_ =>                                          {                                              _connHandler._parserLock.Release();                                          }' TaskScheduler.Default);                                          releaseConnectionLock = false;                                      }                                        return task;                                  }                              }  #if DEBUG                              else                              {                                  Debug.Assert(writeParamTask == null' "Should not have a task when executing sync");                              }  #endif                          } // parameter for loop                            // If this is not the last RPC we are sending' add the batch flag                          if (ii < (rpcArray.Length - 1))                          {                              if (_isYukon)                              {                                  stateObj.WriteByte(TdsEnums.YUKON_RPCBATCHFLAG);                              }                              else                              {                                  stateObj.WriteByte(TdsEnums.SHILOH_RPCBATCHFLAG);                              }                          }                      } // rpc for loop                        Task execFlushTask = stateObj.ExecuteFlush();                      Debug.Assert(!sync || execFlushTask == null' "Should not get a task when executing sync");                      if (execFlushTask != null)                      {                          Task task = null;                            if (completion == null)                          {                              completion = new TaskCompletionSource<object>();                              task = completion.Task;                          }                            bool taskReleaseConnectionLock = releaseConnectionLock;                          execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default);                            // ExecuteFlushTaskCallback will take care of the locks for us                          releaseConnectionLock = false;                            return task;                      }                  }                  catch (Exception e)                  {                      if (!ADP.IsCatchableExceptionType(e))                      {                          throw;                      }                        FailureCleanup(stateObj' e);                        throw;                  }                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetResult(null);                  }                  return null;              }              catch (Exception e)              {                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetException(e);                      return null;                  }                  else                  {                      throw;                  }              }              finally              {                  Debug.Assert(firstCall || !releaseConnectionLock' "Shouldn't be releasing locks synchronously after the first call");                  if (releaseConnectionLock)                  {                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The following statement contains a magic number: try              {                  _SqlRPC rpcext = null;                  int tempLen;                    // Promote' Commit and Rollback requests for                  // delegated transactions often happen while there is an open result                  // set' so we need to handle them by using a different MARS session'                   // otherwise we'll write on the physical state objects while someone                  // else is using it.  When we don't have MARS enabled' we need to                   // lock the physical state object to synchronize its use at least                  // until we increment the open results count.  Once it's been                   // incremented the delegated transaction requests will fail' so they                  // won't stomp on anything.                      if (firstCall)                  {                      _connHandler._parserLock.Wait(canReleaseFromAnyThread: !sync);                      releaseConnectionLock = true;                  }                  try                  {                      // Ensure that connection is alive                      if ((TdsParserState.Broken == State) || (TdsParserState.Closed == State))                      {                          throw ADP.ClosedConnectionError();                      }                        // This validation step MUST be done after locking the connection to guarantee we don't                       //  accidentally execute after the transaction has completed on a different thread.                      if (firstCall)                      {                          _asyncWrite = !sync;                            _connHandler.CheckEnlistedTransactionBinding();                            stateObj.SetTimeoutSeconds(timeout);                            stateObj.SniContext = SniContext.Snix_Execute;                            if (_isYukon)                          {                              WriteRPCBatchHeaders(stateObj' notificationRequest);                          }                            stateObj._outputMessageType = TdsEnums.MT_RPC;                      }                        for (int ii = startRpc; ii < rpcArray.Length; ii++)                      {                          rpcext = rpcArray[ii];                            if (startParam == 0 || ii > startRpc)                          {                              if (rpcext.ProcID != 0)                              {                                  // Perf optimization for Shiloh and later'                                  Debug.Assert(rpcext.ProcID < 255' "rpcExec:ProcID can't be larger than 255");                                  WriteShort(0xffff' stateObj);                                  WriteShort((short)(rpcext.ProcID)' stateObj);                              }                              else                              {                                  Debug.Assert(!string.IsNullOrEmpty(rpcext.rpcName)' "must have an RPC name");                                  tempLen = rpcext.rpcName.Length;                                  WriteShort(tempLen' stateObj);                                  WriteString(rpcext.rpcName' tempLen' 0' stateObj);                              }                                // Options                              WriteShort((short)rpcext.options' stateObj);                          }                            // Stream out parameters                          SqlParameter[] parameters = rpcext.parameters;                            for (int i = (ii == startRpc) ? startParam : 0; i < parameters.Length; i++)                          {                              // parameters can be unnamed                              SqlParameter param = parameters[i];                              // Since we are reusing the parameters array' we cannot rely on length to indicate no of parameters.                              if (param == null)                                  break;      // End of parameters for this execute                                // Validate parameters are not variable length without size and with null value.                              param.Validate(i' isCommandProc);                                // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)                              MetaType mt = param.InternalMetaType;                                if (mt.IsNewKatmaiType)                              {                                  WriteSmiParameter(param' i' 0 != (rpcext.paramoptions[i] & TdsEnums.RPC_PARAM_DEFAULT)' stateObj);                                  continue;                              }                                if ((!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported))                              {                                  throw ADP.VersionDoesNotSupportDataType(mt.TypeName);                              }                              object value = null;                              bool isNull = true;                              bool isSqlVal = false;                              bool isDataFeed = false;                              // if we have an output param' set the value to null so we do not send it across to the server                              if (param.Direction == ParameterDirection.Output)                              {                                  isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing.                                  param.Value = null;                                  param.ParameterIsSqlType = isSqlVal;                              }                              else                              {                                  value = param.GetCoercedValue();                                  isNull = param.IsNull;                                  if (!isNull)                                  {                                      isSqlVal = param.CoercedValueIsSqlType;                                      isDataFeed = param.CoercedValueIsDataFeed;                                  }                              }                                WriteParameterName(param.ParameterNameFixed' stateObj);                                // Write parameter status                              stateObj.WriteByte(rpcext.paramoptions[i]);                                // MaxLen field is only written out for non-fixed length data types                              // use the greater of the two sizes for maxLen                              int actualSize;                              int size = mt.IsSizeInCharacters ? param.GetParameterSize() * 2 : param.GetParameterSize();                                // for UDTs' we calculate the length later when we get the bytes. This is a really expensive operation                              if (mt.TDSType != TdsEnums.SQLUDT)                                  // getting the actualSize is expensive' cache here and use below                                  actualSize = param.GetActualSize();                              else                                  actualSize = 0; //get this later                                byte precision = 0;                              byte scale = 0;                                // scale and precision are only relevant for numeric and decimal types                              // adjust the actual value scale and precision to match the user specified                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  precision = param.GetActualPrecision();                                  scale = param.GetActualScale();                                    if (precision > TdsEnums.MAX_NUMERIC_PRECISION)                                  {                                      throw SQL.PrecisionValueOutOfRange(precision);                                  }                                    // Make sure the value matches the scale the user enters                                  if (!isNull)                                  {                                      if (isSqlVal)                                      {                                          value = AdjustSqlDecimalScale((SqlDecimal)value' scale);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < ((SqlDecimal)value).Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((SqlDecimal)value);                                              }                                          }                                      }                                      else                                      {                                          value = AdjustDecimalScale((decimal)value' scale);                                            SqlDecimal sqlValue = new SqlDecimal((decimal)value);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < sqlValue.Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((decimal)value);                                              }                                          }                                      }                                  }                              }                                // fixup the types by using the NullableType property of the MetaType class                              //                              // following rules should be followed based on feedback from the M-SQL team                              // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)                              // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)                              // 3) DECIMALN should always be sent as NUMERICN                              //                              stateObj.WriteByte(mt.NullableType);                                // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns                              if (mt.TDSType == TdsEnums.SQLVARIANT)                              {                                  // devnote: Do we ever hit this codepath? Yes' when a null value is being written out via a sql variant                                  // param.GetActualSize is not used                                  WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj);                                  continue;                              }                                int codePageByteSize = 0;                              int maxsize = 0;                                if (mt.IsAnsiType)                              {                                  // Avoid the following code block if ANSI but unfilled LazyMat blob                                  if ((!isNull) && (!isDataFeed))                                  {                                      string s;                                        if (isSqlVal)                                      {                                          if (value is SqlString)                                          {                                              s = ((SqlString)value).Value;                                          }                                          else                                          {                                              Debug.Assert(value is SqlChars' "Unknown value for Ansi datatype");                                              s = new String(((SqlChars)value).Value);                                          }                                      }                                      else                                      {                                          s = (string)value;                                      }                                        codePageByteSize = GetEncodingCharLength(s' actualSize' param.Offset' _defaultEncoding);                                  }                                    if (mt.IsPlp)                                  {                                      WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else                                  {                                      maxsize = (size > codePageByteSize) ? size : codePageByteSize;                                      if (maxsize == 0)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                              else                              {                                  // If type timestamp - treat as fixed type and always send over timestamp length' which is 8.                                  // For fixed types' we either send null or fixed length for type length.  We want to match that                                  // behavior for timestamps.  However' in the case of null' we still must send 8 because if we                                  // send null we will not receive a output val.  You can send null for fixed types and still                                  // receive a output value' but not for variable types.  So' always send 8 for timestamp because                                  // while the user sees it as a fixed type' we are actually representing it as a bigbinary which                                  // is variable.                                  if (mt.SqlDbType == SqlDbType.Timestamp)                                  {                                      WriteParameterVarLen(mt' TdsEnums.TEXT_TIME_STAMP_LEN' false' stateObj);                                  }                                  else if (mt.SqlDbType == SqlDbType.Udt)                                  {                                      byte[] udtVal = null;                                      Format format = Format.Native;                                        Debug.Assert(_isYukon' "Invalid DataType UDT for non-Yukon or later server!");                                        if (!isNull)                                      {                                          udtVal = _connHandler.Connection.GetBytes(value' out format' out maxsize);                                            Debug.Assert(null != udtVal' "GetBytes returned null instance. Make sure that it always returns non-null value");                                          size = udtVal.Length;                                            //it may be legitimate' but we dont support it yet                                          if (size < 0 || (size >= ushort.MaxValue && maxsize != -1))                                              throw new IndexOutOfRangeException();                                      }                                        //if this is NULL value' write special null value                                      byte[] lenBytes = BitConverter.GetBytes((long)size);                                        if (string.IsNullOrEmpty(param.UdtTypeName))                                          throw SQL.MustSetUdtTypeNameForUdtParams();                                        // Split the input name. TypeName is returned as single 3 part name during DeriveParameters.                                      // NOTE: ParseUdtTypeName throws if format is incorrect                                      string[] names = SqlParameter.ParseTypeName(param.UdtTypeName' true /* is UdtTypeName */);                                      if (!string.IsNullOrEmpty(names[0]) && TdsEnums.MAX_SERVERNAME < names[0].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (!string.IsNullOrEmpty(names[1]) && TdsEnums.MAX_SERVERNAME < names[names.Length - 2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (TdsEnums.MAX_SERVERNAME < names[2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                        WriteUDTMetaData(value' names[0]' names[1]' names[2]' stateObj);                                        if (!isNull)                                      {                                          WriteUnsignedLong((ulong)udtVal.Length' stateObj); // PLP length                                          if (udtVal.Length > 0)                                          { // Only write chunk length if its value is greater than 0                                              WriteInt(udtVal.Length' stateObj); // Chunk length                                              stateObj.WriteByteArray(udtVal' udtVal.Length' 0); // Value                                          }                                          WriteInt(0' stateObj); // Terminator                                      }                                      else                                      {                                          WriteUnsignedLong(TdsEnums.SQL_PLP_NULL' stateObj); // PLP Null.                                      }                                      continue; // End of UDT - continue to next parameter.                                  }                                  else if (mt.IsPlp)                                  {                                      if (mt.SqlDbType != SqlDbType.Xml)                                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else if ((!mt.IsVarTime) && (mt.SqlDbType != SqlDbType.Date))                                  {   // Time' Date' DateTime2' DateTimeoffset do not have the size written out                                      maxsize = (size > actualSize) ? size : actualSize;                                      if (maxsize == 0 && _isYukon)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types (SQL9 - 682322)                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                                // scale and precision are only relevant for numeric and decimal types                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  if (0 == precision)                                  {                                      stateObj.WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);                                  }                                  else                                  {                                      stateObj.WriteByte(precision);                                  }                                    stateObj.WriteByte(scale);                              }                              else if (mt.IsVarTime)                              {                                  stateObj.WriteByte(param.GetActualScale());                              }                                // write out collation or xml metadata                                if (_isYukon && (mt.SqlDbType == SqlDbType.Xml))                              {                                  if (((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty)))                                  {                                      stateObj.WriteByte(1);  //Schema present flag                                        if ((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionDatabase).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionDatabase' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);       // No dbname                                      }                                        if ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionOwningSchema).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionOwningSchema' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);      // no xml schema name                                      }                                        if ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionName).Length;                                          WriteShort((short)(tempLen)' stateObj);                                          WriteString(param.XmlSchemaCollectionName' tempLen' 0' stateObj);                                      }                                      else                                      {                                          WriteShort(0' stateObj);       // No xml schema collection name                                      }                                  }                                  else                                  {                                      stateObj.WriteByte(0);       // No schema                                  }                              }                              else if (mt.IsCharType)                              {                                  // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter                                  SqlCollation outCollation = (param.Collation != null) ? param.Collation : _defaultCollation;                                  Debug.Assert(_defaultCollation != null' "_defaultCollation is null!");                                    WriteUnsignedInt(outCollation.info' stateObj);                                  stateObj.WriteByte(outCollation.sortId);                              }                                if (0 == codePageByteSize)                                  WriteParameterVarLen(mt' actualSize' isNull' stateObj' isDataFeed);                              else                                  WriteParameterVarLen(mt' codePageByteSize' isNull' stateObj' isDataFeed);                                Task writeParamTask = null;                              // write the value now                              if (!isNull)                              {                                  if (isSqlVal)                                  {                                      writeParamTask = WriteSqlValue(value' mt' actualSize' codePageByteSize' param.Offset' stateObj);                                  }                                  else                                  {                                      // for codePageEncoded types' WriteValue simply expects the number of characters                                      // For plp types' we also need the encoded byte size                                      writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed);                                  }                              }                                if (!sync)                              {                                  if (writeParamTask == null)                                  {                                      writeParamTask = stateObj.WaitForAccumulatedWrites();                                  }                                    if (writeParamTask != null)                                  {                                      Task task = null;                                      if (completion == null)                                      {                                          completion = new TaskCompletionSource<object>();                                          task = completion.Task;                                      }                                        AsyncHelper.ContinueTask(writeParamTask' completion'                                          () => TdsExecuteRPC(rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion'                                                                startRpc: ii' startParam: i + 1)'                                          connectionToDoom: _connHandler'                                          onFailure: exc => TdsExecuteRPC_OnFailure(exc' stateObj));                                        // Take care of releasing the locks                                      if (releaseConnectionLock)                                      {                                          task.ContinueWith(_ =>                                          {                                              _connHandler._parserLock.Release();                                          }' TaskScheduler.Default);                                          releaseConnectionLock = false;                                      }                                        return task;                                  }                              }  #if DEBUG                              else                              {                                  Debug.Assert(writeParamTask == null' "Should not have a task when executing sync");                              }  #endif                          } // parameter for loop                            // If this is not the last RPC we are sending' add the batch flag                          if (ii < (rpcArray.Length - 1))                          {                              if (_isYukon)                              {                                  stateObj.WriteByte(TdsEnums.YUKON_RPCBATCHFLAG);                              }                              else                              {                                  stateObj.WriteByte(TdsEnums.SHILOH_RPCBATCHFLAG);                              }                          }                      } // rpc for loop                        Task execFlushTask = stateObj.ExecuteFlush();                      Debug.Assert(!sync || execFlushTask == null' "Should not get a task when executing sync");                      if (execFlushTask != null)                      {                          Task task = null;                            if (completion == null)                          {                              completion = new TaskCompletionSource<object>();                              task = completion.Task;                          }                            bool taskReleaseConnectionLock = releaseConnectionLock;                          execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default);                            // ExecuteFlushTaskCallback will take care of the locks for us                          releaseConnectionLock = false;                            return task;                      }                  }                  catch (Exception e)                  {                      if (!ADP.IsCatchableExceptionType(e))                      {                          throw;                      }                        FailureCleanup(stateObj' e);                        throw;                  }                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetResult(null);                  }                  return null;              }              catch (Exception e)              {                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetException(e);                      return null;                  }                  else                  {                      throw;                  }              }              finally              {                  Debug.Assert(firstCall || !releaseConnectionLock' "Shouldn't be releasing locks synchronously after the first call");                  if (releaseConnectionLock)                  {                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The following statement contains a magic number: try              {                  _SqlRPC rpcext = null;                  int tempLen;                    // Promote' Commit and Rollback requests for                  // delegated transactions often happen while there is an open result                  // set' so we need to handle them by using a different MARS session'                   // otherwise we'll write on the physical state objects while someone                  // else is using it.  When we don't have MARS enabled' we need to                   // lock the physical state object to synchronize its use at least                  // until we increment the open results count.  Once it's been                   // incremented the delegated transaction requests will fail' so they                  // won't stomp on anything.                      if (firstCall)                  {                      _connHandler._parserLock.Wait(canReleaseFromAnyThread: !sync);                      releaseConnectionLock = true;                  }                  try                  {                      // Ensure that connection is alive                      if ((TdsParserState.Broken == State) || (TdsParserState.Closed == State))                      {                          throw ADP.ClosedConnectionError();                      }                        // This validation step MUST be done after locking the connection to guarantee we don't                       //  accidentally execute after the transaction has completed on a different thread.                      if (firstCall)                      {                          _asyncWrite = !sync;                            _connHandler.CheckEnlistedTransactionBinding();                            stateObj.SetTimeoutSeconds(timeout);                            stateObj.SniContext = SniContext.Snix_Execute;                            if (_isYukon)                          {                              WriteRPCBatchHeaders(stateObj' notificationRequest);                          }                            stateObj._outputMessageType = TdsEnums.MT_RPC;                      }                        for (int ii = startRpc; ii < rpcArray.Length; ii++)                      {                          rpcext = rpcArray[ii];                            if (startParam == 0 || ii > startRpc)                          {                              if (rpcext.ProcID != 0)                              {                                  // Perf optimization for Shiloh and later'                                  Debug.Assert(rpcext.ProcID < 255' "rpcExec:ProcID can't be larger than 255");                                  WriteShort(0xffff' stateObj);                                  WriteShort((short)(rpcext.ProcID)' stateObj);                              }                              else                              {                                  Debug.Assert(!string.IsNullOrEmpty(rpcext.rpcName)' "must have an RPC name");                                  tempLen = rpcext.rpcName.Length;                                  WriteShort(tempLen' stateObj);                                  WriteString(rpcext.rpcName' tempLen' 0' stateObj);                              }                                // Options                              WriteShort((short)rpcext.options' stateObj);                          }                            // Stream out parameters                          SqlParameter[] parameters = rpcext.parameters;                            for (int i = (ii == startRpc) ? startParam : 0; i < parameters.Length; i++)                          {                              // parameters can be unnamed                              SqlParameter param = parameters[i];                              // Since we are reusing the parameters array' we cannot rely on length to indicate no of parameters.                              if (param == null)                                  break;      // End of parameters for this execute                                // Validate parameters are not variable length without size and with null value.                              param.Validate(i' isCommandProc);                                // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)                              MetaType mt = param.InternalMetaType;                                if (mt.IsNewKatmaiType)                              {                                  WriteSmiParameter(param' i' 0 != (rpcext.paramoptions[i] & TdsEnums.RPC_PARAM_DEFAULT)' stateObj);                                  continue;                              }                                if ((!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported))                              {                                  throw ADP.VersionDoesNotSupportDataType(mt.TypeName);                              }                              object value = null;                              bool isNull = true;                              bool isSqlVal = false;                              bool isDataFeed = false;                              // if we have an output param' set the value to null so we do not send it across to the server                              if (param.Direction == ParameterDirection.Output)                              {                                  isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing.                                  param.Value = null;                                  param.ParameterIsSqlType = isSqlVal;                              }                              else                              {                                  value = param.GetCoercedValue();                                  isNull = param.IsNull;                                  if (!isNull)                                  {                                      isSqlVal = param.CoercedValueIsSqlType;                                      isDataFeed = param.CoercedValueIsDataFeed;                                  }                              }                                WriteParameterName(param.ParameterNameFixed' stateObj);                                // Write parameter status                              stateObj.WriteByte(rpcext.paramoptions[i]);                                // MaxLen field is only written out for non-fixed length data types                              // use the greater of the two sizes for maxLen                              int actualSize;                              int size = mt.IsSizeInCharacters ? param.GetParameterSize() * 2 : param.GetParameterSize();                                // for UDTs' we calculate the length later when we get the bytes. This is a really expensive operation                              if (mt.TDSType != TdsEnums.SQLUDT)                                  // getting the actualSize is expensive' cache here and use below                                  actualSize = param.GetActualSize();                              else                                  actualSize = 0; //get this later                                byte precision = 0;                              byte scale = 0;                                // scale and precision are only relevant for numeric and decimal types                              // adjust the actual value scale and precision to match the user specified                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  precision = param.GetActualPrecision();                                  scale = param.GetActualScale();                                    if (precision > TdsEnums.MAX_NUMERIC_PRECISION)                                  {                                      throw SQL.PrecisionValueOutOfRange(precision);                                  }                                    // Make sure the value matches the scale the user enters                                  if (!isNull)                                  {                                      if (isSqlVal)                                      {                                          value = AdjustSqlDecimalScale((SqlDecimal)value' scale);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < ((SqlDecimal)value).Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((SqlDecimal)value);                                              }                                          }                                      }                                      else                                      {                                          value = AdjustDecimalScale((decimal)value' scale);                                            SqlDecimal sqlValue = new SqlDecimal((decimal)value);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < sqlValue.Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((decimal)value);                                              }                                          }                                      }                                  }                              }                                // fixup the types by using the NullableType property of the MetaType class                              //                              // following rules should be followed based on feedback from the M-SQL team                              // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)                              // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)                              // 3) DECIMALN should always be sent as NUMERICN                              //                              stateObj.WriteByte(mt.NullableType);                                // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns                              if (mt.TDSType == TdsEnums.SQLVARIANT)                              {                                  // devnote: Do we ever hit this codepath? Yes' when a null value is being written out via a sql variant                                  // param.GetActualSize is not used                                  WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj);                                  continue;                              }                                int codePageByteSize = 0;                              int maxsize = 0;                                if (mt.IsAnsiType)                              {                                  // Avoid the following code block if ANSI but unfilled LazyMat blob                                  if ((!isNull) && (!isDataFeed))                                  {                                      string s;                                        if (isSqlVal)                                      {                                          if (value is SqlString)                                          {                                              s = ((SqlString)value).Value;                                          }                                          else                                          {                                              Debug.Assert(value is SqlChars' "Unknown value for Ansi datatype");                                              s = new String(((SqlChars)value).Value);                                          }                                      }                                      else                                      {                                          s = (string)value;                                      }                                        codePageByteSize = GetEncodingCharLength(s' actualSize' param.Offset' _defaultEncoding);                                  }                                    if (mt.IsPlp)                                  {                                      WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else                                  {                                      maxsize = (size > codePageByteSize) ? size : codePageByteSize;                                      if (maxsize == 0)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                              else                              {                                  // If type timestamp - treat as fixed type and always send over timestamp length' which is 8.                                  // For fixed types' we either send null or fixed length for type length.  We want to match that                                  // behavior for timestamps.  However' in the case of null' we still must send 8 because if we                                  // send null we will not receive a output val.  You can send null for fixed types and still                                  // receive a output value' but not for variable types.  So' always send 8 for timestamp because                                  // while the user sees it as a fixed type' we are actually representing it as a bigbinary which                                  // is variable.                                  if (mt.SqlDbType == SqlDbType.Timestamp)                                  {                                      WriteParameterVarLen(mt' TdsEnums.TEXT_TIME_STAMP_LEN' false' stateObj);                                  }                                  else if (mt.SqlDbType == SqlDbType.Udt)                                  {                                      byte[] udtVal = null;                                      Format format = Format.Native;                                        Debug.Assert(_isYukon' "Invalid DataType UDT for non-Yukon or later server!");                                        if (!isNull)                                      {                                          udtVal = _connHandler.Connection.GetBytes(value' out format' out maxsize);                                            Debug.Assert(null != udtVal' "GetBytes returned null instance. Make sure that it always returns non-null value");                                          size = udtVal.Length;                                            //it may be legitimate' but we dont support it yet                                          if (size < 0 || (size >= ushort.MaxValue && maxsize != -1))                                              throw new IndexOutOfRangeException();                                      }                                        //if this is NULL value' write special null value                                      byte[] lenBytes = BitConverter.GetBytes((long)size);                                        if (string.IsNullOrEmpty(param.UdtTypeName))                                          throw SQL.MustSetUdtTypeNameForUdtParams();                                        // Split the input name. TypeName is returned as single 3 part name during DeriveParameters.                                      // NOTE: ParseUdtTypeName throws if format is incorrect                                      string[] names = SqlParameter.ParseTypeName(param.UdtTypeName' true /* is UdtTypeName */);                                      if (!string.IsNullOrEmpty(names[0]) && TdsEnums.MAX_SERVERNAME < names[0].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (!string.IsNullOrEmpty(names[1]) && TdsEnums.MAX_SERVERNAME < names[names.Length - 2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (TdsEnums.MAX_SERVERNAME < names[2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                        WriteUDTMetaData(value' names[0]' names[1]' names[2]' stateObj);                                        if (!isNull)                                      {                                          WriteUnsignedLong((ulong)udtVal.Length' stateObj); // PLP length                                          if (udtVal.Length > 0)                                          { // Only write chunk length if its value is greater than 0                                              WriteInt(udtVal.Length' stateObj); // Chunk length                                              stateObj.WriteByteArray(udtVal' udtVal.Length' 0); // Value                                          }                                          WriteInt(0' stateObj); // Terminator                                      }                                      else                                      {                                          WriteUnsignedLong(TdsEnums.SQL_PLP_NULL' stateObj); // PLP Null.                                      }                                      continue; // End of UDT - continue to next parameter.                                  }                                  else if (mt.IsPlp)                                  {                                      if (mt.SqlDbType != SqlDbType.Xml)                                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else if ((!mt.IsVarTime) && (mt.SqlDbType != SqlDbType.Date))                                  {   // Time' Date' DateTime2' DateTimeoffset do not have the size written out                                      maxsize = (size > actualSize) ? size : actualSize;                                      if (maxsize == 0 && _isYukon)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types (SQL9 - 682322)                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                                // scale and precision are only relevant for numeric and decimal types                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  if (0 == precision)                                  {                                      stateObj.WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);                                  }                                  else                                  {                                      stateObj.WriteByte(precision);                                  }                                    stateObj.WriteByte(scale);                              }                              else if (mt.IsVarTime)                              {                                  stateObj.WriteByte(param.GetActualScale());                              }                                // write out collation or xml metadata                                if (_isYukon && (mt.SqlDbType == SqlDbType.Xml))                              {                                  if (((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty)))                                  {                                      stateObj.WriteByte(1);  //Schema present flag                                        if ((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionDatabase).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionDatabase' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);       // No dbname                                      }                                        if ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionOwningSchema).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionOwningSchema' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);      // no xml schema name                                      }                                        if ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionName).Length;                                          WriteShort((short)(tempLen)' stateObj);                                          WriteString(param.XmlSchemaCollectionName' tempLen' 0' stateObj);                                      }                                      else                                      {                                          WriteShort(0' stateObj);       // No xml schema collection name                                      }                                  }                                  else                                  {                                      stateObj.WriteByte(0);       // No schema                                  }                              }                              else if (mt.IsCharType)                              {                                  // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter                                  SqlCollation outCollation = (param.Collation != null) ? param.Collation : _defaultCollation;                                  Debug.Assert(_defaultCollation != null' "_defaultCollation is null!");                                    WriteUnsignedInt(outCollation.info' stateObj);                                  stateObj.WriteByte(outCollation.sortId);                              }                                if (0 == codePageByteSize)                                  WriteParameterVarLen(mt' actualSize' isNull' stateObj' isDataFeed);                              else                                  WriteParameterVarLen(mt' codePageByteSize' isNull' stateObj' isDataFeed);                                Task writeParamTask = null;                              // write the value now                              if (!isNull)                              {                                  if (isSqlVal)                                  {                                      writeParamTask = WriteSqlValue(value' mt' actualSize' codePageByteSize' param.Offset' stateObj);                                  }                                  else                                  {                                      // for codePageEncoded types' WriteValue simply expects the number of characters                                      // For plp types' we also need the encoded byte size                                      writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed);                                  }                              }                                if (!sync)                              {                                  if (writeParamTask == null)                                  {                                      writeParamTask = stateObj.WaitForAccumulatedWrites();                                  }                                    if (writeParamTask != null)                                  {                                      Task task = null;                                      if (completion == null)                                      {                                          completion = new TaskCompletionSource<object>();                                          task = completion.Task;                                      }                                        AsyncHelper.ContinueTask(writeParamTask' completion'                                          () => TdsExecuteRPC(rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion'                                                                startRpc: ii' startParam: i + 1)'                                          connectionToDoom: _connHandler'                                          onFailure: exc => TdsExecuteRPC_OnFailure(exc' stateObj));                                        // Take care of releasing the locks                                      if (releaseConnectionLock)                                      {                                          task.ContinueWith(_ =>                                          {                                              _connHandler._parserLock.Release();                                          }' TaskScheduler.Default);                                          releaseConnectionLock = false;                                      }                                        return task;                                  }                              }  #if DEBUG                              else                              {                                  Debug.Assert(writeParamTask == null' "Should not have a task when executing sync");                              }  #endif                          } // parameter for loop                            // If this is not the last RPC we are sending' add the batch flag                          if (ii < (rpcArray.Length - 1))                          {                              if (_isYukon)                              {                                  stateObj.WriteByte(TdsEnums.YUKON_RPCBATCHFLAG);                              }                              else                              {                                  stateObj.WriteByte(TdsEnums.SHILOH_RPCBATCHFLAG);                              }                          }                      } // rpc for loop                        Task execFlushTask = stateObj.ExecuteFlush();                      Debug.Assert(!sync || execFlushTask == null' "Should not get a task when executing sync");                      if (execFlushTask != null)                      {                          Task task = null;                            if (completion == null)                          {                              completion = new TaskCompletionSource<object>();                              task = completion.Task;                          }                            bool taskReleaseConnectionLock = releaseConnectionLock;                          execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default);                            // ExecuteFlushTaskCallback will take care of the locks for us                          releaseConnectionLock = false;                            return task;                      }                  }                  catch (Exception e)                  {                      if (!ADP.IsCatchableExceptionType(e))                      {                          throw;                      }                        FailureCleanup(stateObj' e);                        throw;                  }                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetResult(null);                  }                  return null;              }              catch (Exception e)              {                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetException(e);                      return null;                  }                  else                  {                      throw;                  }              }              finally              {                  Debug.Assert(firstCall || !releaseConnectionLock' "Shouldn't be releasing locks synchronously after the first call");                  if (releaseConnectionLock)                  {                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The following statement contains a magic number: try              {                  _SqlRPC rpcext = null;                  int tempLen;                    // Promote' Commit and Rollback requests for                  // delegated transactions often happen while there is an open result                  // set' so we need to handle them by using a different MARS session'                   // otherwise we'll write on the physical state objects while someone                  // else is using it.  When we don't have MARS enabled' we need to                   // lock the physical state object to synchronize its use at least                  // until we increment the open results count.  Once it's been                   // incremented the delegated transaction requests will fail' so they                  // won't stomp on anything.                      if (firstCall)                  {                      _connHandler._parserLock.Wait(canReleaseFromAnyThread: !sync);                      releaseConnectionLock = true;                  }                  try                  {                      // Ensure that connection is alive                      if ((TdsParserState.Broken == State) || (TdsParserState.Closed == State))                      {                          throw ADP.ClosedConnectionError();                      }                        // This validation step MUST be done after locking the connection to guarantee we don't                       //  accidentally execute after the transaction has completed on a different thread.                      if (firstCall)                      {                          _asyncWrite = !sync;                            _connHandler.CheckEnlistedTransactionBinding();                            stateObj.SetTimeoutSeconds(timeout);                            stateObj.SniContext = SniContext.Snix_Execute;                            if (_isYukon)                          {                              WriteRPCBatchHeaders(stateObj' notificationRequest);                          }                            stateObj._outputMessageType = TdsEnums.MT_RPC;                      }                        for (int ii = startRpc; ii < rpcArray.Length; ii++)                      {                          rpcext = rpcArray[ii];                            if (startParam == 0 || ii > startRpc)                          {                              if (rpcext.ProcID != 0)                              {                                  // Perf optimization for Shiloh and later'                                  Debug.Assert(rpcext.ProcID < 255' "rpcExec:ProcID can't be larger than 255");                                  WriteShort(0xffff' stateObj);                                  WriteShort((short)(rpcext.ProcID)' stateObj);                              }                              else                              {                                  Debug.Assert(!string.IsNullOrEmpty(rpcext.rpcName)' "must have an RPC name");                                  tempLen = rpcext.rpcName.Length;                                  WriteShort(tempLen' stateObj);                                  WriteString(rpcext.rpcName' tempLen' 0' stateObj);                              }                                // Options                              WriteShort((short)rpcext.options' stateObj);                          }                            // Stream out parameters                          SqlParameter[] parameters = rpcext.parameters;                            for (int i = (ii == startRpc) ? startParam : 0; i < parameters.Length; i++)                          {                              // parameters can be unnamed                              SqlParameter param = parameters[i];                              // Since we are reusing the parameters array' we cannot rely on length to indicate no of parameters.                              if (param == null)                                  break;      // End of parameters for this execute                                // Validate parameters are not variable length without size and with null value.                              param.Validate(i' isCommandProc);                                // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)                              MetaType mt = param.InternalMetaType;                                if (mt.IsNewKatmaiType)                              {                                  WriteSmiParameter(param' i' 0 != (rpcext.paramoptions[i] & TdsEnums.RPC_PARAM_DEFAULT)' stateObj);                                  continue;                              }                                if ((!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported))                              {                                  throw ADP.VersionDoesNotSupportDataType(mt.TypeName);                              }                              object value = null;                              bool isNull = true;                              bool isSqlVal = false;                              bool isDataFeed = false;                              // if we have an output param' set the value to null so we do not send it across to the server                              if (param.Direction == ParameterDirection.Output)                              {                                  isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing.                                  param.Value = null;                                  param.ParameterIsSqlType = isSqlVal;                              }                              else                              {                                  value = param.GetCoercedValue();                                  isNull = param.IsNull;                                  if (!isNull)                                  {                                      isSqlVal = param.CoercedValueIsSqlType;                                      isDataFeed = param.CoercedValueIsDataFeed;                                  }                              }                                WriteParameterName(param.ParameterNameFixed' stateObj);                                // Write parameter status                              stateObj.WriteByte(rpcext.paramoptions[i]);                                // MaxLen field is only written out for non-fixed length data types                              // use the greater of the two sizes for maxLen                              int actualSize;                              int size = mt.IsSizeInCharacters ? param.GetParameterSize() * 2 : param.GetParameterSize();                                // for UDTs' we calculate the length later when we get the bytes. This is a really expensive operation                              if (mt.TDSType != TdsEnums.SQLUDT)                                  // getting the actualSize is expensive' cache here and use below                                  actualSize = param.GetActualSize();                              else                                  actualSize = 0; //get this later                                byte precision = 0;                              byte scale = 0;                                // scale and precision are only relevant for numeric and decimal types                              // adjust the actual value scale and precision to match the user specified                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  precision = param.GetActualPrecision();                                  scale = param.GetActualScale();                                    if (precision > TdsEnums.MAX_NUMERIC_PRECISION)                                  {                                      throw SQL.PrecisionValueOutOfRange(precision);                                  }                                    // Make sure the value matches the scale the user enters                                  if (!isNull)                                  {                                      if (isSqlVal)                                      {                                          value = AdjustSqlDecimalScale((SqlDecimal)value' scale);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < ((SqlDecimal)value).Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((SqlDecimal)value);                                              }                                          }                                      }                                      else                                      {                                          value = AdjustDecimalScale((decimal)value' scale);                                            SqlDecimal sqlValue = new SqlDecimal((decimal)value);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < sqlValue.Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((decimal)value);                                              }                                          }                                      }                                  }                              }                                // fixup the types by using the NullableType property of the MetaType class                              //                              // following rules should be followed based on feedback from the M-SQL team                              // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)                              // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)                              // 3) DECIMALN should always be sent as NUMERICN                              //                              stateObj.WriteByte(mt.NullableType);                                // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns                              if (mt.TDSType == TdsEnums.SQLVARIANT)                              {                                  // devnote: Do we ever hit this codepath? Yes' when a null value is being written out via a sql variant                                  // param.GetActualSize is not used                                  WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj);                                  continue;                              }                                int codePageByteSize = 0;                              int maxsize = 0;                                if (mt.IsAnsiType)                              {                                  // Avoid the following code block if ANSI but unfilled LazyMat blob                                  if ((!isNull) && (!isDataFeed))                                  {                                      string s;                                        if (isSqlVal)                                      {                                          if (value is SqlString)                                          {                                              s = ((SqlString)value).Value;                                          }                                          else                                          {                                              Debug.Assert(value is SqlChars' "Unknown value for Ansi datatype");                                              s = new String(((SqlChars)value).Value);                                          }                                      }                                      else                                      {                                          s = (string)value;                                      }                                        codePageByteSize = GetEncodingCharLength(s' actualSize' param.Offset' _defaultEncoding);                                  }                                    if (mt.IsPlp)                                  {                                      WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else                                  {                                      maxsize = (size > codePageByteSize) ? size : codePageByteSize;                                      if (maxsize == 0)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                              else                              {                                  // If type timestamp - treat as fixed type and always send over timestamp length' which is 8.                                  // For fixed types' we either send null or fixed length for type length.  We want to match that                                  // behavior for timestamps.  However' in the case of null' we still must send 8 because if we                                  // send null we will not receive a output val.  You can send null for fixed types and still                                  // receive a output value' but not for variable types.  So' always send 8 for timestamp because                                  // while the user sees it as a fixed type' we are actually representing it as a bigbinary which                                  // is variable.                                  if (mt.SqlDbType == SqlDbType.Timestamp)                                  {                                      WriteParameterVarLen(mt' TdsEnums.TEXT_TIME_STAMP_LEN' false' stateObj);                                  }                                  else if (mt.SqlDbType == SqlDbType.Udt)                                  {                                      byte[] udtVal = null;                                      Format format = Format.Native;                                        Debug.Assert(_isYukon' "Invalid DataType UDT for non-Yukon or later server!");                                        if (!isNull)                                      {                                          udtVal = _connHandler.Connection.GetBytes(value' out format' out maxsize);                                            Debug.Assert(null != udtVal' "GetBytes returned null instance. Make sure that it always returns non-null value");                                          size = udtVal.Length;                                            //it may be legitimate' but we dont support it yet                                          if (size < 0 || (size >= ushort.MaxValue && maxsize != -1))                                              throw new IndexOutOfRangeException();                                      }                                        //if this is NULL value' write special null value                                      byte[] lenBytes = BitConverter.GetBytes((long)size);                                        if (string.IsNullOrEmpty(param.UdtTypeName))                                          throw SQL.MustSetUdtTypeNameForUdtParams();                                        // Split the input name. TypeName is returned as single 3 part name during DeriveParameters.                                      // NOTE: ParseUdtTypeName throws if format is incorrect                                      string[] names = SqlParameter.ParseTypeName(param.UdtTypeName' true /* is UdtTypeName */);                                      if (!string.IsNullOrEmpty(names[0]) && TdsEnums.MAX_SERVERNAME < names[0].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (!string.IsNullOrEmpty(names[1]) && TdsEnums.MAX_SERVERNAME < names[names.Length - 2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (TdsEnums.MAX_SERVERNAME < names[2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                        WriteUDTMetaData(value' names[0]' names[1]' names[2]' stateObj);                                        if (!isNull)                                      {                                          WriteUnsignedLong((ulong)udtVal.Length' stateObj); // PLP length                                          if (udtVal.Length > 0)                                          { // Only write chunk length if its value is greater than 0                                              WriteInt(udtVal.Length' stateObj); // Chunk length                                              stateObj.WriteByteArray(udtVal' udtVal.Length' 0); // Value                                          }                                          WriteInt(0' stateObj); // Terminator                                      }                                      else                                      {                                          WriteUnsignedLong(TdsEnums.SQL_PLP_NULL' stateObj); // PLP Null.                                      }                                      continue; // End of UDT - continue to next parameter.                                  }                                  else if (mt.IsPlp)                                  {                                      if (mt.SqlDbType != SqlDbType.Xml)                                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else if ((!mt.IsVarTime) && (mt.SqlDbType != SqlDbType.Date))                                  {   // Time' Date' DateTime2' DateTimeoffset do not have the size written out                                      maxsize = (size > actualSize) ? size : actualSize;                                      if (maxsize == 0 && _isYukon)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types (SQL9 - 682322)                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                                // scale and precision are only relevant for numeric and decimal types                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  if (0 == precision)                                  {                                      stateObj.WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);                                  }                                  else                                  {                                      stateObj.WriteByte(precision);                                  }                                    stateObj.WriteByte(scale);                              }                              else if (mt.IsVarTime)                              {                                  stateObj.WriteByte(param.GetActualScale());                              }                                // write out collation or xml metadata                                if (_isYukon && (mt.SqlDbType == SqlDbType.Xml))                              {                                  if (((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty)))                                  {                                      stateObj.WriteByte(1);  //Schema present flag                                        if ((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionDatabase).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionDatabase' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);       // No dbname                                      }                                        if ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionOwningSchema).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionOwningSchema' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);      // no xml schema name                                      }                                        if ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionName).Length;                                          WriteShort((short)(tempLen)' stateObj);                                          WriteString(param.XmlSchemaCollectionName' tempLen' 0' stateObj);                                      }                                      else                                      {                                          WriteShort(0' stateObj);       // No xml schema collection name                                      }                                  }                                  else                                  {                                      stateObj.WriteByte(0);       // No schema                                  }                              }                              else if (mt.IsCharType)                              {                                  // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter                                  SqlCollation outCollation = (param.Collation != null) ? param.Collation : _defaultCollation;                                  Debug.Assert(_defaultCollation != null' "_defaultCollation is null!");                                    WriteUnsignedInt(outCollation.info' stateObj);                                  stateObj.WriteByte(outCollation.sortId);                              }                                if (0 == codePageByteSize)                                  WriteParameterVarLen(mt' actualSize' isNull' stateObj' isDataFeed);                              else                                  WriteParameterVarLen(mt' codePageByteSize' isNull' stateObj' isDataFeed);                                Task writeParamTask = null;                              // write the value now                              if (!isNull)                              {                                  if (isSqlVal)                                  {                                      writeParamTask = WriteSqlValue(value' mt' actualSize' codePageByteSize' param.Offset' stateObj);                                  }                                  else                                  {                                      // for codePageEncoded types' WriteValue simply expects the number of characters                                      // For plp types' we also need the encoded byte size                                      writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed);                                  }                              }                                if (!sync)                              {                                  if (writeParamTask == null)                                  {                                      writeParamTask = stateObj.WaitForAccumulatedWrites();                                  }                                    if (writeParamTask != null)                                  {                                      Task task = null;                                      if (completion == null)                                      {                                          completion = new TaskCompletionSource<object>();                                          task = completion.Task;                                      }                                        AsyncHelper.ContinueTask(writeParamTask' completion'                                          () => TdsExecuteRPC(rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion'                                                                startRpc: ii' startParam: i + 1)'                                          connectionToDoom: _connHandler'                                          onFailure: exc => TdsExecuteRPC_OnFailure(exc' stateObj));                                        // Take care of releasing the locks                                      if (releaseConnectionLock)                                      {                                          task.ContinueWith(_ =>                                          {                                              _connHandler._parserLock.Release();                                          }' TaskScheduler.Default);                                          releaseConnectionLock = false;                                      }                                        return task;                                  }                              }  #if DEBUG                              else                              {                                  Debug.Assert(writeParamTask == null' "Should not have a task when executing sync");                              }  #endif                          } // parameter for loop                            // If this is not the last RPC we are sending' add the batch flag                          if (ii < (rpcArray.Length - 1))                          {                              if (_isYukon)                              {                                  stateObj.WriteByte(TdsEnums.YUKON_RPCBATCHFLAG);                              }                              else                              {                                  stateObj.WriteByte(TdsEnums.SHILOH_RPCBATCHFLAG);                              }                          }                      } // rpc for loop                        Task execFlushTask = stateObj.ExecuteFlush();                      Debug.Assert(!sync || execFlushTask == null' "Should not get a task when executing sync");                      if (execFlushTask != null)                      {                          Task task = null;                            if (completion == null)                          {                              completion = new TaskCompletionSource<object>();                              task = completion.Task;                          }                            bool taskReleaseConnectionLock = releaseConnectionLock;                          execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default);                            // ExecuteFlushTaskCallback will take care of the locks for us                          releaseConnectionLock = false;                            return task;                      }                  }                  catch (Exception e)                  {                      if (!ADP.IsCatchableExceptionType(e))                      {                          throw;                      }                        FailureCleanup(stateObj' e);                        throw;                  }                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetResult(null);                  }                  return null;              }              catch (Exception e)              {                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetException(e);                      return null;                  }                  else                  {                      throw;                  }              }              finally              {                  Debug.Assert(firstCall || !releaseConnectionLock' "Shouldn't be releasing locks synchronously after the first call");                  if (releaseConnectionLock)                  {                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The following statement contains a magic number: try              {                  _SqlRPC rpcext = null;                  int tempLen;                    // Promote' Commit and Rollback requests for                  // delegated transactions often happen while there is an open result                  // set' so we need to handle them by using a different MARS session'                   // otherwise we'll write on the physical state objects while someone                  // else is using it.  When we don't have MARS enabled' we need to                   // lock the physical state object to synchronize its use at least                  // until we increment the open results count.  Once it's been                   // incremented the delegated transaction requests will fail' so they                  // won't stomp on anything.                      if (firstCall)                  {                      _connHandler._parserLock.Wait(canReleaseFromAnyThread: !sync);                      releaseConnectionLock = true;                  }                  try                  {                      // Ensure that connection is alive                      if ((TdsParserState.Broken == State) || (TdsParserState.Closed == State))                      {                          throw ADP.ClosedConnectionError();                      }                        // This validation step MUST be done after locking the connection to guarantee we don't                       //  accidentally execute after the transaction has completed on a different thread.                      if (firstCall)                      {                          _asyncWrite = !sync;                            _connHandler.CheckEnlistedTransactionBinding();                            stateObj.SetTimeoutSeconds(timeout);                            stateObj.SniContext = SniContext.Snix_Execute;                            if (_isYukon)                          {                              WriteRPCBatchHeaders(stateObj' notificationRequest);                          }                            stateObj._outputMessageType = TdsEnums.MT_RPC;                      }                        for (int ii = startRpc; ii < rpcArray.Length; ii++)                      {                          rpcext = rpcArray[ii];                            if (startParam == 0 || ii > startRpc)                          {                              if (rpcext.ProcID != 0)                              {                                  // Perf optimization for Shiloh and later'                                  Debug.Assert(rpcext.ProcID < 255' "rpcExec:ProcID can't be larger than 255");                                  WriteShort(0xffff' stateObj);                                  WriteShort((short)(rpcext.ProcID)' stateObj);                              }                              else                              {                                  Debug.Assert(!string.IsNullOrEmpty(rpcext.rpcName)' "must have an RPC name");                                  tempLen = rpcext.rpcName.Length;                                  WriteShort(tempLen' stateObj);                                  WriteString(rpcext.rpcName' tempLen' 0' stateObj);                              }                                // Options                              WriteShort((short)rpcext.options' stateObj);                          }                            // Stream out parameters                          SqlParameter[] parameters = rpcext.parameters;                            for (int i = (ii == startRpc) ? startParam : 0; i < parameters.Length; i++)                          {                              // parameters can be unnamed                              SqlParameter param = parameters[i];                              // Since we are reusing the parameters array' we cannot rely on length to indicate no of parameters.                              if (param == null)                                  break;      // End of parameters for this execute                                // Validate parameters are not variable length without size and with null value.                              param.Validate(i' isCommandProc);                                // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)                              MetaType mt = param.InternalMetaType;                                if (mt.IsNewKatmaiType)                              {                                  WriteSmiParameter(param' i' 0 != (rpcext.paramoptions[i] & TdsEnums.RPC_PARAM_DEFAULT)' stateObj);                                  continue;                              }                                if ((!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported))                              {                                  throw ADP.VersionDoesNotSupportDataType(mt.TypeName);                              }                              object value = null;                              bool isNull = true;                              bool isSqlVal = false;                              bool isDataFeed = false;                              // if we have an output param' set the value to null so we do not send it across to the server                              if (param.Direction == ParameterDirection.Output)                              {                                  isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing.                                  param.Value = null;                                  param.ParameterIsSqlType = isSqlVal;                              }                              else                              {                                  value = param.GetCoercedValue();                                  isNull = param.IsNull;                                  if (!isNull)                                  {                                      isSqlVal = param.CoercedValueIsSqlType;                                      isDataFeed = param.CoercedValueIsDataFeed;                                  }                              }                                WriteParameterName(param.ParameterNameFixed' stateObj);                                // Write parameter status                              stateObj.WriteByte(rpcext.paramoptions[i]);                                // MaxLen field is only written out for non-fixed length data types                              // use the greater of the two sizes for maxLen                              int actualSize;                              int size = mt.IsSizeInCharacters ? param.GetParameterSize() * 2 : param.GetParameterSize();                                // for UDTs' we calculate the length later when we get the bytes. This is a really expensive operation                              if (mt.TDSType != TdsEnums.SQLUDT)                                  // getting the actualSize is expensive' cache here and use below                                  actualSize = param.GetActualSize();                              else                                  actualSize = 0; //get this later                                byte precision = 0;                              byte scale = 0;                                // scale and precision are only relevant for numeric and decimal types                              // adjust the actual value scale and precision to match the user specified                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  precision = param.GetActualPrecision();                                  scale = param.GetActualScale();                                    if (precision > TdsEnums.MAX_NUMERIC_PRECISION)                                  {                                      throw SQL.PrecisionValueOutOfRange(precision);                                  }                                    // Make sure the value matches the scale the user enters                                  if (!isNull)                                  {                                      if (isSqlVal)                                      {                                          value = AdjustSqlDecimalScale((SqlDecimal)value' scale);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < ((SqlDecimal)value).Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((SqlDecimal)value);                                              }                                          }                                      }                                      else                                      {                                          value = AdjustDecimalScale((decimal)value' scale);                                            SqlDecimal sqlValue = new SqlDecimal((decimal)value);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < sqlValue.Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((decimal)value);                                              }                                          }                                      }                                  }                              }                                // fixup the types by using the NullableType property of the MetaType class                              //                              // following rules should be followed based on feedback from the M-SQL team                              // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)                              // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)                              // 3) DECIMALN should always be sent as NUMERICN                              //                              stateObj.WriteByte(mt.NullableType);                                // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns                              if (mt.TDSType == TdsEnums.SQLVARIANT)                              {                                  // devnote: Do we ever hit this codepath? Yes' when a null value is being written out via a sql variant                                  // param.GetActualSize is not used                                  WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj);                                  continue;                              }                                int codePageByteSize = 0;                              int maxsize = 0;                                if (mt.IsAnsiType)                              {                                  // Avoid the following code block if ANSI but unfilled LazyMat blob                                  if ((!isNull) && (!isDataFeed))                                  {                                      string s;                                        if (isSqlVal)                                      {                                          if (value is SqlString)                                          {                                              s = ((SqlString)value).Value;                                          }                                          else                                          {                                              Debug.Assert(value is SqlChars' "Unknown value for Ansi datatype");                                              s = new String(((SqlChars)value).Value);                                          }                                      }                                      else                                      {                                          s = (string)value;                                      }                                        codePageByteSize = GetEncodingCharLength(s' actualSize' param.Offset' _defaultEncoding);                                  }                                    if (mt.IsPlp)                                  {                                      WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else                                  {                                      maxsize = (size > codePageByteSize) ? size : codePageByteSize;                                      if (maxsize == 0)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                              else                              {                                  // If type timestamp - treat as fixed type and always send over timestamp length' which is 8.                                  // For fixed types' we either send null or fixed length for type length.  We want to match that                                  // behavior for timestamps.  However' in the case of null' we still must send 8 because if we                                  // send null we will not receive a output val.  You can send null for fixed types and still                                  // receive a output value' but not for variable types.  So' always send 8 for timestamp because                                  // while the user sees it as a fixed type' we are actually representing it as a bigbinary which                                  // is variable.                                  if (mt.SqlDbType == SqlDbType.Timestamp)                                  {                                      WriteParameterVarLen(mt' TdsEnums.TEXT_TIME_STAMP_LEN' false' stateObj);                                  }                                  else if (mt.SqlDbType == SqlDbType.Udt)                                  {                                      byte[] udtVal = null;                                      Format format = Format.Native;                                        Debug.Assert(_isYukon' "Invalid DataType UDT for non-Yukon or later server!");                                        if (!isNull)                                      {                                          udtVal = _connHandler.Connection.GetBytes(value' out format' out maxsize);                                            Debug.Assert(null != udtVal' "GetBytes returned null instance. Make sure that it always returns non-null value");                                          size = udtVal.Length;                                            //it may be legitimate' but we dont support it yet                                          if (size < 0 || (size >= ushort.MaxValue && maxsize != -1))                                              throw new IndexOutOfRangeException();                                      }                                        //if this is NULL value' write special null value                                      byte[] lenBytes = BitConverter.GetBytes((long)size);                                        if (string.IsNullOrEmpty(param.UdtTypeName))                                          throw SQL.MustSetUdtTypeNameForUdtParams();                                        // Split the input name. TypeName is returned as single 3 part name during DeriveParameters.                                      // NOTE: ParseUdtTypeName throws if format is incorrect                                      string[] names = SqlParameter.ParseTypeName(param.UdtTypeName' true /* is UdtTypeName */);                                      if (!string.IsNullOrEmpty(names[0]) && TdsEnums.MAX_SERVERNAME < names[0].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (!string.IsNullOrEmpty(names[1]) && TdsEnums.MAX_SERVERNAME < names[names.Length - 2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (TdsEnums.MAX_SERVERNAME < names[2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                        WriteUDTMetaData(value' names[0]' names[1]' names[2]' stateObj);                                        if (!isNull)                                      {                                          WriteUnsignedLong((ulong)udtVal.Length' stateObj); // PLP length                                          if (udtVal.Length > 0)                                          { // Only write chunk length if its value is greater than 0                                              WriteInt(udtVal.Length' stateObj); // Chunk length                                              stateObj.WriteByteArray(udtVal' udtVal.Length' 0); // Value                                          }                                          WriteInt(0' stateObj); // Terminator                                      }                                      else                                      {                                          WriteUnsignedLong(TdsEnums.SQL_PLP_NULL' stateObj); // PLP Null.                                      }                                      continue; // End of UDT - continue to next parameter.                                  }                                  else if (mt.IsPlp)                                  {                                      if (mt.SqlDbType != SqlDbType.Xml)                                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else if ((!mt.IsVarTime) && (mt.SqlDbType != SqlDbType.Date))                                  {   // Time' Date' DateTime2' DateTimeoffset do not have the size written out                                      maxsize = (size > actualSize) ? size : actualSize;                                      if (maxsize == 0 && _isYukon)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types (SQL9 - 682322)                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                                // scale and precision are only relevant for numeric and decimal types                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  if (0 == precision)                                  {                                      stateObj.WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);                                  }                                  else                                  {                                      stateObj.WriteByte(precision);                                  }                                    stateObj.WriteByte(scale);                              }                              else if (mt.IsVarTime)                              {                                  stateObj.WriteByte(param.GetActualScale());                              }                                // write out collation or xml metadata                                if (_isYukon && (mt.SqlDbType == SqlDbType.Xml))                              {                                  if (((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty)))                                  {                                      stateObj.WriteByte(1);  //Schema present flag                                        if ((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionDatabase).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionDatabase' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);       // No dbname                                      }                                        if ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionOwningSchema).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionOwningSchema' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);      // no xml schema name                                      }                                        if ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionName).Length;                                          WriteShort((short)(tempLen)' stateObj);                                          WriteString(param.XmlSchemaCollectionName' tempLen' 0' stateObj);                                      }                                      else                                      {                                          WriteShort(0' stateObj);       // No xml schema collection name                                      }                                  }                                  else                                  {                                      stateObj.WriteByte(0);       // No schema                                  }                              }                              else if (mt.IsCharType)                              {                                  // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter                                  SqlCollation outCollation = (param.Collation != null) ? param.Collation : _defaultCollation;                                  Debug.Assert(_defaultCollation != null' "_defaultCollation is null!");                                    WriteUnsignedInt(outCollation.info' stateObj);                                  stateObj.WriteByte(outCollation.sortId);                              }                                if (0 == codePageByteSize)                                  WriteParameterVarLen(mt' actualSize' isNull' stateObj' isDataFeed);                              else                                  WriteParameterVarLen(mt' codePageByteSize' isNull' stateObj' isDataFeed);                                Task writeParamTask = null;                              // write the value now                              if (!isNull)                              {                                  if (isSqlVal)                                  {                                      writeParamTask = WriteSqlValue(value' mt' actualSize' codePageByteSize' param.Offset' stateObj);                                  }                                  else                                  {                                      // for codePageEncoded types' WriteValue simply expects the number of characters                                      // For plp types' we also need the encoded byte size                                      writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed);                                  }                              }                                if (!sync)                              {                                  if (writeParamTask == null)                                  {                                      writeParamTask = stateObj.WaitForAccumulatedWrites();                                  }                                    if (writeParamTask != null)                                  {                                      Task task = null;                                      if (completion == null)                                      {                                          completion = new TaskCompletionSource<object>();                                          task = completion.Task;                                      }                                        AsyncHelper.ContinueTask(writeParamTask' completion'                                          () => TdsExecuteRPC(rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion'                                                                startRpc: ii' startParam: i + 1)'                                          connectionToDoom: _connHandler'                                          onFailure: exc => TdsExecuteRPC_OnFailure(exc' stateObj));                                        // Take care of releasing the locks                                      if (releaseConnectionLock)                                      {                                          task.ContinueWith(_ =>                                          {                                              _connHandler._parserLock.Release();                                          }' TaskScheduler.Default);                                          releaseConnectionLock = false;                                      }                                        return task;                                  }                              }  #if DEBUG                              else                              {                                  Debug.Assert(writeParamTask == null' "Should not have a task when executing sync");                              }  #endif                          } // parameter for loop                            // If this is not the last RPC we are sending' add the batch flag                          if (ii < (rpcArray.Length - 1))                          {                              if (_isYukon)                              {                                  stateObj.WriteByte(TdsEnums.YUKON_RPCBATCHFLAG);                              }                              else                              {                                  stateObj.WriteByte(TdsEnums.SHILOH_RPCBATCHFLAG);                              }                          }                      } // rpc for loop                        Task execFlushTask = stateObj.ExecuteFlush();                      Debug.Assert(!sync || execFlushTask == null' "Should not get a task when executing sync");                      if (execFlushTask != null)                      {                          Task task = null;                            if (completion == null)                          {                              completion = new TaskCompletionSource<object>();                              task = completion.Task;                          }                            bool taskReleaseConnectionLock = releaseConnectionLock;                          execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default);                            // ExecuteFlushTaskCallback will take care of the locks for us                          releaseConnectionLock = false;                            return task;                      }                  }                  catch (Exception e)                  {                      if (!ADP.IsCatchableExceptionType(e))                      {                          throw;                      }                        FailureCleanup(stateObj' e);                        throw;                  }                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetResult(null);                  }                  return null;              }              catch (Exception e)              {                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetException(e);                      return null;                  }                  else                  {                      throw;                  }              }              finally              {                  Debug.Assert(firstCall || !releaseConnectionLock' "Shouldn't be releasing locks synchronously after the first call");                  if (releaseConnectionLock)                  {                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TdsExecuteRPC,The following statement contains a magic number: try              {                  _SqlRPC rpcext = null;                  int tempLen;                    // Promote' Commit and Rollback requests for                  // delegated transactions often happen while there is an open result                  // set' so we need to handle them by using a different MARS session'                   // otherwise we'll write on the physical state objects while someone                  // else is using it.  When we don't have MARS enabled' we need to                   // lock the physical state object to synchronize its use at least                  // until we increment the open results count.  Once it's been                   // incremented the delegated transaction requests will fail' so they                  // won't stomp on anything.                      if (firstCall)                  {                      _connHandler._parserLock.Wait(canReleaseFromAnyThread: !sync);                      releaseConnectionLock = true;                  }                  try                  {                      // Ensure that connection is alive                      if ((TdsParserState.Broken == State) || (TdsParserState.Closed == State))                      {                          throw ADP.ClosedConnectionError();                      }                        // This validation step MUST be done after locking the connection to guarantee we don't                       //  accidentally execute after the transaction has completed on a different thread.                      if (firstCall)                      {                          _asyncWrite = !sync;                            _connHandler.CheckEnlistedTransactionBinding();                            stateObj.SetTimeoutSeconds(timeout);                            stateObj.SniContext = SniContext.Snix_Execute;                            if (_isYukon)                          {                              WriteRPCBatchHeaders(stateObj' notificationRequest);                          }                            stateObj._outputMessageType = TdsEnums.MT_RPC;                      }                        for (int ii = startRpc; ii < rpcArray.Length; ii++)                      {                          rpcext = rpcArray[ii];                            if (startParam == 0 || ii > startRpc)                          {                              if (rpcext.ProcID != 0)                              {                                  // Perf optimization for Shiloh and later'                                  Debug.Assert(rpcext.ProcID < 255' "rpcExec:ProcID can't be larger than 255");                                  WriteShort(0xffff' stateObj);                                  WriteShort((short)(rpcext.ProcID)' stateObj);                              }                              else                              {                                  Debug.Assert(!string.IsNullOrEmpty(rpcext.rpcName)' "must have an RPC name");                                  tempLen = rpcext.rpcName.Length;                                  WriteShort(tempLen' stateObj);                                  WriteString(rpcext.rpcName' tempLen' 0' stateObj);                              }                                // Options                              WriteShort((short)rpcext.options' stateObj);                          }                            // Stream out parameters                          SqlParameter[] parameters = rpcext.parameters;                            for (int i = (ii == startRpc) ? startParam : 0; i < parameters.Length; i++)                          {                              // parameters can be unnamed                              SqlParameter param = parameters[i];                              // Since we are reusing the parameters array' we cannot rely on length to indicate no of parameters.                              if (param == null)                                  break;      // End of parameters for this execute                                // Validate parameters are not variable length without size and with null value.                              param.Validate(i' isCommandProc);                                // type (parameter record stores the MetaType class which is a helper that encapsulates all the type information we need here)                              MetaType mt = param.InternalMetaType;                                if (mt.IsNewKatmaiType)                              {                                  WriteSmiParameter(param' i' 0 != (rpcext.paramoptions[i] & TdsEnums.RPC_PARAM_DEFAULT)' stateObj);                                  continue;                              }                                if ((!_isYukon && !mt.Is80Supported) ||                                  (!_isKatmai && !mt.Is90Supported))                              {                                  throw ADP.VersionDoesNotSupportDataType(mt.TypeName);                              }                              object value = null;                              bool isNull = true;                              bool isSqlVal = false;                              bool isDataFeed = false;                              // if we have an output param' set the value to null so we do not send it across to the server                              if (param.Direction == ParameterDirection.Output)                              {                                  isSqlVal = param.ParameterIsSqlType;  // We have to forward the TYPE info' we need to know what type we are returning.  Once we null the parameter we will no longer be able to distinguish what type were seeing.                                  param.Value = null;                                  param.ParameterIsSqlType = isSqlVal;                              }                              else                              {                                  value = param.GetCoercedValue();                                  isNull = param.IsNull;                                  if (!isNull)                                  {                                      isSqlVal = param.CoercedValueIsSqlType;                                      isDataFeed = param.CoercedValueIsDataFeed;                                  }                              }                                WriteParameterName(param.ParameterNameFixed' stateObj);                                // Write parameter status                              stateObj.WriteByte(rpcext.paramoptions[i]);                                // MaxLen field is only written out for non-fixed length data types                              // use the greater of the two sizes for maxLen                              int actualSize;                              int size = mt.IsSizeInCharacters ? param.GetParameterSize() * 2 : param.GetParameterSize();                                // for UDTs' we calculate the length later when we get the bytes. This is a really expensive operation                              if (mt.TDSType != TdsEnums.SQLUDT)                                  // getting the actualSize is expensive' cache here and use below                                  actualSize = param.GetActualSize();                              else                                  actualSize = 0; //get this later                                byte precision = 0;                              byte scale = 0;                                // scale and precision are only relevant for numeric and decimal types                              // adjust the actual value scale and precision to match the user specified                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  precision = param.GetActualPrecision();                                  scale = param.GetActualScale();                                    if (precision > TdsEnums.MAX_NUMERIC_PRECISION)                                  {                                      throw SQL.PrecisionValueOutOfRange(precision);                                  }                                    // Make sure the value matches the scale the user enters                                  if (!isNull)                                  {                                      if (isSqlVal)                                      {                                          value = AdjustSqlDecimalScale((SqlDecimal)value' scale);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < ((SqlDecimal)value).Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((SqlDecimal)value);                                              }                                          }                                      }                                      else                                      {                                          value = AdjustDecimalScale((decimal)value' scale);                                            SqlDecimal sqlValue = new SqlDecimal((decimal)value);                                            // If Precision is specified' verify value precision vs param precision                                          if (precision != 0)                                          {                                              if (precision < sqlValue.Precision)                                              {                                                  throw ADP.ParameterValueOutOfRange((decimal)value);                                              }                                          }                                      }                                  }                              }                                // fixup the types by using the NullableType property of the MetaType class                              //                              // following rules should be followed based on feedback from the M-SQL team                              // 1) always use the BIG* types (ex: instead of SQLCHAR use SQLBIGCHAR)                              // 2) always use nullable types (ex: instead of SQLINT use SQLINTN)                              // 3) DECIMALN should always be sent as NUMERICN                              //                              stateObj.WriteByte(mt.NullableType);                                // handle variants here: the SQLVariant writing routine will write the maxlen and actual len columns                              if (mt.TDSType == TdsEnums.SQLVARIANT)                              {                                  // devnote: Do we ever hit this codepath? Yes' when a null value is being written out via a sql variant                                  // param.GetActualSize is not used                                  WriteSqlVariantValue(isSqlVal ? MetaType.GetComValueFromSqlVariant(value) : value' param.GetActualSize()' param.Offset' stateObj);                                  continue;                              }                                int codePageByteSize = 0;                              int maxsize = 0;                                if (mt.IsAnsiType)                              {                                  // Avoid the following code block if ANSI but unfilled LazyMat blob                                  if ((!isNull) && (!isDataFeed))                                  {                                      string s;                                        if (isSqlVal)                                      {                                          if (value is SqlString)                                          {                                              s = ((SqlString)value).Value;                                          }                                          else                                          {                                              Debug.Assert(value is SqlChars' "Unknown value for Ansi datatype");                                              s = new String(((SqlChars)value).Value);                                          }                                      }                                      else                                      {                                          s = (string)value;                                      }                                        codePageByteSize = GetEncodingCharLength(s' actualSize' param.Offset' _defaultEncoding);                                  }                                    if (mt.IsPlp)                                  {                                      WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else                                  {                                      maxsize = (size > codePageByteSize) ? size : codePageByteSize;                                      if (maxsize == 0)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                              else                              {                                  // If type timestamp - treat as fixed type and always send over timestamp length' which is 8.                                  // For fixed types' we either send null or fixed length for type length.  We want to match that                                  // behavior for timestamps.  However' in the case of null' we still must send 8 because if we                                  // send null we will not receive a output val.  You can send null for fixed types and still                                  // receive a output value' but not for variable types.  So' always send 8 for timestamp because                                  // while the user sees it as a fixed type' we are actually representing it as a bigbinary which                                  // is variable.                                  if (mt.SqlDbType == SqlDbType.Timestamp)                                  {                                      WriteParameterVarLen(mt' TdsEnums.TEXT_TIME_STAMP_LEN' false' stateObj);                                  }                                  else if (mt.SqlDbType == SqlDbType.Udt)                                  {                                      byte[] udtVal = null;                                      Format format = Format.Native;                                        Debug.Assert(_isYukon' "Invalid DataType UDT for non-Yukon or later server!");                                        if (!isNull)                                      {                                          udtVal = _connHandler.Connection.GetBytes(value' out format' out maxsize);                                            Debug.Assert(null != udtVal' "GetBytes returned null instance. Make sure that it always returns non-null value");                                          size = udtVal.Length;                                            //it may be legitimate' but we dont support it yet                                          if (size < 0 || (size >= ushort.MaxValue && maxsize != -1))                                              throw new IndexOutOfRangeException();                                      }                                        //if this is NULL value' write special null value                                      byte[] lenBytes = BitConverter.GetBytes((long)size);                                        if (string.IsNullOrEmpty(param.UdtTypeName))                                          throw SQL.MustSetUdtTypeNameForUdtParams();                                        // Split the input name. TypeName is returned as single 3 part name during DeriveParameters.                                      // NOTE: ParseUdtTypeName throws if format is incorrect                                      string[] names = SqlParameter.ParseTypeName(param.UdtTypeName' true /* is UdtTypeName */);                                      if (!string.IsNullOrEmpty(names[0]) && TdsEnums.MAX_SERVERNAME < names[0].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (!string.IsNullOrEmpty(names[1]) && TdsEnums.MAX_SERVERNAME < names[names.Length - 2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                      if (TdsEnums.MAX_SERVERNAME < names[2].Length)                                      {                                          throw ADP.ArgumentOutOfRange(nameof(names));                                      }                                        WriteUDTMetaData(value' names[0]' names[1]' names[2]' stateObj);                                        if (!isNull)                                      {                                          WriteUnsignedLong((ulong)udtVal.Length' stateObj); // PLP length                                          if (udtVal.Length > 0)                                          { // Only write chunk length if its value is greater than 0                                              WriteInt(udtVal.Length' stateObj); // Chunk length                                              stateObj.WriteByteArray(udtVal' udtVal.Length' 0); // Value                                          }                                          WriteInt(0' stateObj); // Terminator                                      }                                      else                                      {                                          WriteUnsignedLong(TdsEnums.SQL_PLP_NULL' stateObj); // PLP Null.                                      }                                      continue; // End of UDT - continue to next parameter.                                  }                                  else if (mt.IsPlp)                                  {                                      if (mt.SqlDbType != SqlDbType.Xml)                                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                                  }                                  else if ((!mt.IsVarTime) && (mt.SqlDbType != SqlDbType.Date))                                  {   // Time' Date' DateTime2' DateTimeoffset do not have the size written out                                      maxsize = (size > actualSize) ? size : actualSize;                                      if (maxsize == 0 && _isYukon)                                      {                                          // Yukon doesn't like 0 as MaxSize. Change it to 2 for unicode types (SQL9 - 682322)                                          if (mt.IsNCharType)                                              maxsize = 2;                                          else                                              maxsize = 1;                                      }                                        WriteParameterVarLen(mt' maxsize' false /*IsNull*/' stateObj);                                  }                              }                                // scale and precision are only relevant for numeric and decimal types                              if (mt.SqlDbType == SqlDbType.Decimal)                              {                                  if (0 == precision)                                  {                                      stateObj.WriteByte(TdsEnums.DEFAULT_NUMERIC_PRECISION);                                  }                                  else                                  {                                      stateObj.WriteByte(precision);                                  }                                    stateObj.WriteByte(scale);                              }                              else if (mt.IsVarTime)                              {                                  stateObj.WriteByte(param.GetActualScale());                              }                                // write out collation or xml metadata                                if (_isYukon && (mt.SqlDbType == SqlDbType.Xml))                              {                                  if (((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty)) ||                                      ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty)))                                  {                                      stateObj.WriteByte(1);  //Schema present flag                                        if ((param.XmlSchemaCollectionDatabase != null) && (param.XmlSchemaCollectionDatabase != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionDatabase).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionDatabase' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);       // No dbname                                      }                                        if ((param.XmlSchemaCollectionOwningSchema != null) && (param.XmlSchemaCollectionOwningSchema != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionOwningSchema).Length;                                          stateObj.WriteByte((byte)(tempLen));                                          WriteString(param.XmlSchemaCollectionOwningSchema' tempLen' 0' stateObj);                                      }                                      else                                      {                                          stateObj.WriteByte(0);      // no xml schema name                                      }                                        if ((param.XmlSchemaCollectionName != null) && (param.XmlSchemaCollectionName != ADP.StrEmpty))                                      {                                          tempLen = (param.XmlSchemaCollectionName).Length;                                          WriteShort((short)(tempLen)' stateObj);                                          WriteString(param.XmlSchemaCollectionName' tempLen' 0' stateObj);                                      }                                      else                                      {                                          WriteShort(0' stateObj);       // No xml schema collection name                                      }                                  }                                  else                                  {                                      stateObj.WriteByte(0);       // No schema                                  }                              }                              else if (mt.IsCharType)                              {                                  // if it is not supplied' simply write out our default collation' otherwise' write out the one attached to the parameter                                  SqlCollation outCollation = (param.Collation != null) ? param.Collation : _defaultCollation;                                  Debug.Assert(_defaultCollation != null' "_defaultCollation is null!");                                    WriteUnsignedInt(outCollation.info' stateObj);                                  stateObj.WriteByte(outCollation.sortId);                              }                                if (0 == codePageByteSize)                                  WriteParameterVarLen(mt' actualSize' isNull' stateObj' isDataFeed);                              else                                  WriteParameterVarLen(mt' codePageByteSize' isNull' stateObj' isDataFeed);                                Task writeParamTask = null;                              // write the value now                              if (!isNull)                              {                                  if (isSqlVal)                                  {                                      writeParamTask = WriteSqlValue(value' mt' actualSize' codePageByteSize' param.Offset' stateObj);                                  }                                  else                                  {                                      // for codePageEncoded types' WriteValue simply expects the number of characters                                      // For plp types' we also need the encoded byte size                                      writeParamTask = WriteValue(value' mt' param.GetActualScale()' actualSize' codePageByteSize' param.Offset' stateObj' param.Size' isDataFeed);                                  }                              }                                if (!sync)                              {                                  if (writeParamTask == null)                                  {                                      writeParamTask = stateObj.WaitForAccumulatedWrites();                                  }                                    if (writeParamTask != null)                                  {                                      Task task = null;                                      if (completion == null)                                      {                                          completion = new TaskCompletionSource<object>();                                          task = completion.Task;                                      }                                        AsyncHelper.ContinueTask(writeParamTask' completion'                                          () => TdsExecuteRPC(rpcArray' timeout' inSchema' notificationRequest' stateObj' isCommandProc' sync' completion'                                                                startRpc: ii' startParam: i + 1)'                                          connectionToDoom: _connHandler'                                          onFailure: exc => TdsExecuteRPC_OnFailure(exc' stateObj));                                        // Take care of releasing the locks                                      if (releaseConnectionLock)                                      {                                          task.ContinueWith(_ =>                                          {                                              _connHandler._parserLock.Release();                                          }' TaskScheduler.Default);                                          releaseConnectionLock = false;                                      }                                        return task;                                  }                              }  #if DEBUG                              else                              {                                  Debug.Assert(writeParamTask == null' "Should not have a task when executing sync");                              }  #endif                          } // parameter for loop                            // If this is not the last RPC we are sending' add the batch flag                          if (ii < (rpcArray.Length - 1))                          {                              if (_isYukon)                              {                                  stateObj.WriteByte(TdsEnums.YUKON_RPCBATCHFLAG);                              }                              else                              {                                  stateObj.WriteByte(TdsEnums.SHILOH_RPCBATCHFLAG);                              }                          }                      } // rpc for loop                        Task execFlushTask = stateObj.ExecuteFlush();                      Debug.Assert(!sync || execFlushTask == null' "Should not get a task when executing sync");                      if (execFlushTask != null)                      {                          Task task = null;                            if (completion == null)                          {                              completion = new TaskCompletionSource<object>();                              task = completion.Task;                          }                            bool taskReleaseConnectionLock = releaseConnectionLock;                          execFlushTask.ContinueWith(tsk => ExecuteFlushTaskCallback(tsk' stateObj' completion' taskReleaseConnectionLock)' TaskScheduler.Default);                            // ExecuteFlushTaskCallback will take care of the locks for us                          releaseConnectionLock = false;                            return task;                      }                  }                  catch (Exception e)                  {                      if (!ADP.IsCatchableExceptionType(e))                      {                          throw;                      }                        FailureCleanup(stateObj' e);                        throw;                  }                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetResult(null);                  }                  return null;              }              catch (Exception e)              {                  FinalizeExecuteRPC(stateObj);                  if (completion != null)                  {                      completion.SetException(e);                      return null;                  }                  else                  {                      throw;                  }              }              finally              {                  Debug.Assert(firstCall || !releaseConnectionLock' "Shouldn't be releasing locks synchronously after the first call");                  if (releaseConnectionLock)                  {                      _connHandler._parserLock.Release();                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSmiTypeInfo,The following statement contains a magic number: switch (metaData.SqlDbType)              {                  case SqlDbType.BigInt:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Binary:                      stateObj.WriteByte(TdsEnums.SQLBIGBINARY);                      WriteUnsignedShort(checked((ushort)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.Bit:                      stateObj.WriteByte(TdsEnums.SQLBITN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Char:                      stateObj.WriteByte(TdsEnums.SQLBIGCHAR);                      WriteUnsignedShort(checked((ushort)(metaData.MaxLength))' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.DateTime:                      stateObj.WriteByte(TdsEnums.SQLDATETIMN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Decimal:                      stateObj.WriteByte(TdsEnums.SQLNUMERICN);                      stateObj.WriteByte(checked((byte)MetaType.MetaDecimal.FixedLength));   // SmiMetaData's length and actual wire format's length are different                      stateObj.WriteByte(0 == metaData.Precision ? (byte)1 : metaData.Precision);                      stateObj.WriteByte(metaData.Scale);                      break;                  case SqlDbType.Float:                      stateObj.WriteByte(TdsEnums.SQLFLTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Image:                      stateObj.WriteByte(TdsEnums.SQLBIGVARBINARY);                      WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      break;                  case SqlDbType.Int:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Money:                      stateObj.WriteByte(TdsEnums.SQLMONEYN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.NChar:                      stateObj.WriteByte(TdsEnums.SQLNCHAR);                      WriteUnsignedShort(checked((ushort)(metaData.MaxLength * 2))' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.NText:                      stateObj.WriteByte(TdsEnums.SQLNVARCHAR);                      WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.NVarChar:                      stateObj.WriteByte(TdsEnums.SQLNVARCHAR);                      if (MSS.SmiMetaData.UnlimitedMaxLengthIndicator == metaData.MaxLength)                      {                          WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      }                      else                      {                          WriteUnsignedShort(checked((ushort)(metaData.MaxLength * 2))' stateObj);                      }                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.Real:                      stateObj.WriteByte(TdsEnums.SQLFLTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.UniqueIdentifier:                      stateObj.WriteByte(TdsEnums.SQLUNIQUEID);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.SmallDateTime:                      stateObj.WriteByte(TdsEnums.SQLDATETIMN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.SmallInt:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.SmallMoney:                      stateObj.WriteByte(TdsEnums.SQLMONEYN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Text:                      stateObj.WriteByte(TdsEnums.SQLBIGVARCHAR);                      WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.Timestamp:                      stateObj.WriteByte(TdsEnums.SQLBIGBINARY);                      WriteShort(checked((int)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.TinyInt:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.VarBinary:                      stateObj.WriteByte(TdsEnums.SQLBIGVARBINARY);                      WriteUnsignedShort(unchecked((ushort)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.VarChar:                      stateObj.WriteByte(TdsEnums.SQLBIGVARCHAR);                      WriteUnsignedShort(unchecked((ushort)metaData.MaxLength)' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.Variant:                      stateObj.WriteByte(TdsEnums.SQLVARIANT);                      WriteInt(checked((int)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.Xml:                      stateObj.WriteByte(TdsEnums.SQLXMLTYPE);                      // Is there a schema                      if (string.IsNullOrEmpty(metaData.TypeSpecificNamePart1) && string.IsNullOrEmpty(metaData.TypeSpecificNamePart2) &&                              string.IsNullOrEmpty(metaData.TypeSpecificNamePart3))                      {                          stateObj.WriteByte(0);  // schema not present                      }                      else                      {                          stateObj.WriteByte(1); // schema present                          WriteIdentifier(metaData.TypeSpecificNamePart1' stateObj);                          WriteIdentifier(metaData.TypeSpecificNamePart2' stateObj);                          WriteIdentifierWithShortLength(metaData.TypeSpecificNamePart3' stateObj);                      }                      break;                  case SqlDbType.Udt:                      stateObj.WriteByte(TdsEnums.SQLUDT);                      WriteIdentifier(metaData.TypeSpecificNamePart1' stateObj);                      WriteIdentifier(metaData.TypeSpecificNamePart2' stateObj);                      WriteIdentifier(metaData.TypeSpecificNamePart3' stateObj);                      break;                  case SqlDbType.Structured:                      if (metaData.IsMultiValued)                      {                          WriteTvpTypeInfo(metaData' stateObj);                      }                      else                      {                          Debug.Assert(false' "SUDTs not yet supported.");                      }                      break;                  case SqlDbType.Date:                      stateObj.WriteByte(TdsEnums.SQLDATE);                      break;                  case SqlDbType.Time:                      stateObj.WriteByte(TdsEnums.SQLTIME);                      stateObj.WriteByte(metaData.Scale);                      break;                  case SqlDbType.DateTime2:                      stateObj.WriteByte(TdsEnums.SQLDATETIME2);                      stateObj.WriteByte(metaData.Scale);                      break;                  case SqlDbType.DateTimeOffset:                      stateObj.WriteByte(TdsEnums.SQLDATETIMEOFFSET);                      stateObj.WriteByte(metaData.Scale);                      break;                  default:                      Debug.Assert(false' "Unknown SqlDbType should have been caught earlier!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteSmiTypeInfo,The following statement contains a magic number: switch (metaData.SqlDbType)              {                  case SqlDbType.BigInt:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Binary:                      stateObj.WriteByte(TdsEnums.SQLBIGBINARY);                      WriteUnsignedShort(checked((ushort)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.Bit:                      stateObj.WriteByte(TdsEnums.SQLBITN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Char:                      stateObj.WriteByte(TdsEnums.SQLBIGCHAR);                      WriteUnsignedShort(checked((ushort)(metaData.MaxLength))' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.DateTime:                      stateObj.WriteByte(TdsEnums.SQLDATETIMN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Decimal:                      stateObj.WriteByte(TdsEnums.SQLNUMERICN);                      stateObj.WriteByte(checked((byte)MetaType.MetaDecimal.FixedLength));   // SmiMetaData's length and actual wire format's length are different                      stateObj.WriteByte(0 == metaData.Precision ? (byte)1 : metaData.Precision);                      stateObj.WriteByte(metaData.Scale);                      break;                  case SqlDbType.Float:                      stateObj.WriteByte(TdsEnums.SQLFLTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Image:                      stateObj.WriteByte(TdsEnums.SQLBIGVARBINARY);                      WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      break;                  case SqlDbType.Int:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Money:                      stateObj.WriteByte(TdsEnums.SQLMONEYN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.NChar:                      stateObj.WriteByte(TdsEnums.SQLNCHAR);                      WriteUnsignedShort(checked((ushort)(metaData.MaxLength * 2))' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.NText:                      stateObj.WriteByte(TdsEnums.SQLNVARCHAR);                      WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.NVarChar:                      stateObj.WriteByte(TdsEnums.SQLNVARCHAR);                      if (MSS.SmiMetaData.UnlimitedMaxLengthIndicator == metaData.MaxLength)                      {                          WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      }                      else                      {                          WriteUnsignedShort(checked((ushort)(metaData.MaxLength * 2))' stateObj);                      }                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.Real:                      stateObj.WriteByte(TdsEnums.SQLFLTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.UniqueIdentifier:                      stateObj.WriteByte(TdsEnums.SQLUNIQUEID);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.SmallDateTime:                      stateObj.WriteByte(TdsEnums.SQLDATETIMN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.SmallInt:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.SmallMoney:                      stateObj.WriteByte(TdsEnums.SQLMONEYN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.Text:                      stateObj.WriteByte(TdsEnums.SQLBIGVARCHAR);                      WriteUnsignedShort(unchecked((ushort)MSS.SmiMetaData.UnlimitedMaxLengthIndicator)' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.Timestamp:                      stateObj.WriteByte(TdsEnums.SQLBIGBINARY);                      WriteShort(checked((int)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.TinyInt:                      stateObj.WriteByte(TdsEnums.SQLINTN);                      stateObj.WriteByte(checked((byte)metaData.MaxLength));                      break;                  case SqlDbType.VarBinary:                      stateObj.WriteByte(TdsEnums.SQLBIGVARBINARY);                      WriteUnsignedShort(unchecked((ushort)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.VarChar:                      stateObj.WriteByte(TdsEnums.SQLBIGVARCHAR);                      WriteUnsignedShort(unchecked((ushort)metaData.MaxLength)' stateObj);                      WriteUnsignedInt(_defaultCollation.info' stateObj);                      stateObj.WriteByte(_defaultCollation.sortId);                      break;                  case SqlDbType.Variant:                      stateObj.WriteByte(TdsEnums.SQLVARIANT);                      WriteInt(checked((int)metaData.MaxLength)' stateObj);                      break;                  case SqlDbType.Xml:                      stateObj.WriteByte(TdsEnums.SQLXMLTYPE);                      // Is there a schema                      if (string.IsNullOrEmpty(metaData.TypeSpecificNamePart1) && string.IsNullOrEmpty(metaData.TypeSpecificNamePart2) &&                              string.IsNullOrEmpty(metaData.TypeSpecificNamePart3))                      {                          stateObj.WriteByte(0);  // schema not present                      }                      else                      {                          stateObj.WriteByte(1); // schema present                          WriteIdentifier(metaData.TypeSpecificNamePart1' stateObj);                          WriteIdentifier(metaData.TypeSpecificNamePart2' stateObj);                          WriteIdentifierWithShortLength(metaData.TypeSpecificNamePart3' stateObj);                      }                      break;                  case SqlDbType.Udt:                      stateObj.WriteByte(TdsEnums.SQLUDT);                      WriteIdentifier(metaData.TypeSpecificNamePart1' stateObj);                      WriteIdentifier(metaData.TypeSpecificNamePart2' stateObj);                      WriteIdentifier(metaData.TypeSpecificNamePart3' stateObj);                      break;                  case SqlDbType.Structured:                      if (metaData.IsMultiValued)                      {                          WriteTvpTypeInfo(metaData' stateObj);                      }                      else                      {                          Debug.Assert(false' "SUDTs not yet supported.");                      }                      break;                  case SqlDbType.Date:                      stateObj.WriteByte(TdsEnums.SQLDATE);                      break;                  case SqlDbType.Time:                      stateObj.WriteByte(TdsEnums.SQLTIME);                      stateObj.WriteByte(metaData.Scale);                      break;                  case SqlDbType.DateTime2:                      stateObj.WriteByte(TdsEnums.SQLDATETIME2);                      stateObj.WriteByte(metaData.Scale);                      break;                  case SqlDbType.DateTimeOffset:                      stateObj.WriteByte(TdsEnums.SQLDATETIMEOFFSET);                      stateObj.WriteByte(metaData.Scale);                      break;                  default:                      Debug.Assert(false' "Unknown SqlDbType should have been caught earlier!");                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyMetaData,The following statement contains a magic number: for (int i = 0; i < metadataCollection.Length; i++)              {                  if (metadataCollection[i] != null)                  {                      _SqlMetaData md = metadataCollection[i];                        // read user type - 4 bytes Yukon' 2 backwards                      WriteInt(0x0' stateObj);                        ushort flags;                        flags = (ushort)(md.updatability << 2);                      flags |= (ushort)(md.isNullable ? (ushort)TdsEnums.Nullable : (ushort)0);                      flags |= (ushort)(md.isIdentity ? (ushort)TdsEnums.Identity : (ushort)0);                        WriteShort(flags' stateObj);      // write the flags                          switch (md.type)                      {                          case SqlDbType.Decimal:                              stateObj.WriteByte(md.tdsType);                              WriteTokenLength(md.tdsType' md.length' stateObj);                              stateObj.WriteByte(md.precision);                              stateObj.WriteByte(md.scale);                              break;                          case SqlDbType.Xml:                              stateObj.WriteByteArray(s_xmlMetadataSubstituteSequence' s_xmlMetadataSubstituteSequence.Length' 0);                              break;                          case SqlDbType.Udt:                              stateObj.WriteByte(TdsEnums.SQLBIGVARBINARY);                              WriteTokenLength(TdsEnums.SQLBIGVARBINARY' md.length' stateObj);                              break;                          case SqlDbType.Date:                              stateObj.WriteByte(md.tdsType);                              break;                          case SqlDbType.Time:                          case SqlDbType.DateTime2:                          case SqlDbType.DateTimeOffset:                              stateObj.WriteByte(md.tdsType);                              stateObj.WriteByte(md.scale);                              break;                          default:                              stateObj.WriteByte(md.tdsType);                              WriteTokenLength(md.tdsType' md.length' stateObj);                              if (md.metaType.IsCharType)                              {                                  WriteUnsignedInt(md.collation.info' stateObj);                                  stateObj.WriteByte(md.collation.sortId);                              }                              break;                      }                        if (md.metaType.IsLong && !md.metaType.IsPlp)                      {                          WriteShort(md.tableName.Length' stateObj);                          WriteString(md.tableName' stateObj);                      }                        stateObj.WriteByte((byte)md.column.Length);                      WriteString(md.column' stateObj);                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The following statement contains a magic number: try              {                  if (metadata.encoding != null)                  {                      _defaultEncoding = metadata.encoding;                  }                  if (metadata.collation != null)                  {                      _defaultCollation = metadata.collation;                      _defaultLCID = _defaultCollation.LCID;                  }                  _defaultCodePage = metadata.codePage;                    MetaType metatype = metadata.metaType;                  int ccb = 0;                  int ccbStringBytes = 0;                    if (isNull)                  {                      // For UDT' remember we treat as binary even though it is a PLP                      if (metatype.IsPlp && (metatype.NullableType != TdsEnums.SQLUDT || metatype.IsLong))                      {                          WriteLong(unchecked((long)TdsEnums.SQL_PLP_NULL)' stateObj);                      }                      else if (!metatype.IsFixed && !metatype.IsLong && !metatype.IsVarTime)                      {                          WriteShort(TdsEnums.VARNULL' stateObj);                      }                      else                      {                          stateObj.WriteByte(TdsEnums.FIXEDNULL);                      }                      return resultTask;                  }                    if (!isDataFeed)                  {                      switch (metatype.NullableType)                      {                          case TdsEnums.SQLBIGBINARY:                          case TdsEnums.SQLBIGVARBINARY:                          case TdsEnums.SQLIMAGE:                          case TdsEnums.SQLUDT:                              ccb = (isSqlType) ? ((SqlBinary)value).Length : ((byte[])value).Length;                              break;                          case TdsEnums.SQLUNIQUEID:                              ccb = GUID_SIZE;   // that's a constant for guid                              break;                          case TdsEnums.SQLBIGCHAR:                          case TdsEnums.SQLBIGVARCHAR:                          case TdsEnums.SQLTEXT:                              if (null == _defaultEncoding)                              {                                  ThrowUnsupportedCollationEncountered(null); // stateObject only when reading                              }                                string stringValue = null;                              if (isSqlType)                              {                                  stringValue = ((SqlString)value).Value;                              }                              else                              {                                  stringValue = (string)value;                              }                                ccb = stringValue.Length;                              ccbStringBytes = _defaultEncoding.GetByteCount(stringValue);                              break;                          case TdsEnums.SQLNCHAR:                          case TdsEnums.SQLNVARCHAR:                          case TdsEnums.SQLNTEXT:                              ccb = ((isSqlType) ? ((SqlString)value).Value.Length : ((string)value).Length) * 2;                              break;                          case TdsEnums.SQLXMLTYPE:                              // Value here could be string or XmlReader                              if (value is XmlReader)                              {                                  value = MetaType.GetStringFromXml((XmlReader)value);                              }                              ccb = ((isSqlType) ? ((SqlString)value).Value.Length : ((string)value).Length) * 2;                              break;                            default:                              ccb = metadata.length;                              break;                      }                  }                  else                  {                      Debug.Assert(metatype.IsLong &&                          ((metatype.SqlDbType == SqlDbType.VarBinary && value is StreamDataFeed) ||                           ((metatype.SqlDbType == SqlDbType.VarChar || metatype.SqlDbType == SqlDbType.NVarChar) && value is TextDataFeed) ||                           (metatype.SqlDbType == SqlDbType.Xml && value is XmlDataFeed))'                     "Stream data feed should only be assigned to VarBinary(max)' Text data feed should only be assigned to [N]VarChar(max)' Xml data feed should only be assigned to XML(max)");                  }                      // Expected the text length in data stream for bulk copy of text' ntext' or image data.                  //                  if (metatype.IsLong)                  {                      switch (metatype.SqlDbType)                      {                          case SqlDbType.Text:                          case SqlDbType.NText:                          case SqlDbType.Image:                              stateObj.WriteByteArray(s_longDataHeader' s_longDataHeader.Length' 0);                              WriteTokenLength(metadata.tdsType' ccbStringBytes == 0 ? ccb : ccbStringBytes' stateObj);                              break;                            case SqlDbType.VarChar:                          case SqlDbType.NVarChar:                          case SqlDbType.VarBinary:                          case SqlDbType.Xml:                          case SqlDbType.Udt:                              // plp data                              WriteUnsignedLong(TdsEnums.SQL_PLP_UNKNOWNLEN' stateObj);                              break;                      }                  }                  else                  {                      WriteTokenLength(metadata.tdsType' ccbStringBytes == 0 ? ccb : ccbStringBytes' stateObj);                  }                    if (isSqlType)                  {                      internalWriteTask = WriteSqlValue(value' metatype' ccb' ccbStringBytes' 0' stateObj);                  }                  else if (metatype.SqlDbType != SqlDbType.Udt || metatype.IsLong)                  {                      internalWriteTask = WriteValue(value' metatype' metadata.scale' ccb' ccbStringBytes' 0' stateObj' metadata.length' isDataFeed);                      if ((internalWriteTask == null) && (_asyncWrite))                      {                          internalWriteTask = stateObj.WaitForAccumulatedWrites();                      }                      Debug.Assert(_asyncWrite || stateObj.WaitForAccumulatedWrites() == null' "Should not have accumulated writes when writing sync");                  }                  else                  {                      WriteShort(ccb' stateObj);                      internalWriteTask = stateObj.WriteByteArray((byte[])value' ccb' 0);                  }    #if DEBUG                  //In DEBUG mode' when SetAlwaysTaskOnWrite is true' we create a task. Allows us to verify async execution paths.                  if (_asyncWrite && internalWriteTask == null && SqlBulkCopy.SetAlwaysTaskOnWrite == true)                  {                      internalWriteTask = Task.FromResult<object>(null);                  }  #endif                  if (internalWriteTask != null)                  { //i.e. the write was async.                      resultTask = WriteBulkCopyValueSetupContinuation(internalWriteTask' saveEncoding' saveCollation' saveCodePage' saveLCID);                  }              }              finally              {                  if (internalWriteTask == null)                  {                      _defaultEncoding = saveEncoding;                      _defaultCollation = saveCollation;                      _defaultCodePage = saveCodePage;                      _defaultLCID = saveLCID;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The following statement contains a magic number: try              {                  if (metadata.encoding != null)                  {                      _defaultEncoding = metadata.encoding;                  }                  if (metadata.collation != null)                  {                      _defaultCollation = metadata.collation;                      _defaultLCID = _defaultCollation.LCID;                  }                  _defaultCodePage = metadata.codePage;                    MetaType metatype = metadata.metaType;                  int ccb = 0;                  int ccbStringBytes = 0;                    if (isNull)                  {                      // For UDT' remember we treat as binary even though it is a PLP                      if (metatype.IsPlp && (metatype.NullableType != TdsEnums.SQLUDT || metatype.IsLong))                      {                          WriteLong(unchecked((long)TdsEnums.SQL_PLP_NULL)' stateObj);                      }                      else if (!metatype.IsFixed && !metatype.IsLong && !metatype.IsVarTime)                      {                          WriteShort(TdsEnums.VARNULL' stateObj);                      }                      else                      {                          stateObj.WriteByte(TdsEnums.FIXEDNULL);                      }                      return resultTask;                  }                    if (!isDataFeed)                  {                      switch (metatype.NullableType)                      {                          case TdsEnums.SQLBIGBINARY:                          case TdsEnums.SQLBIGVARBINARY:                          case TdsEnums.SQLIMAGE:                          case TdsEnums.SQLUDT:                              ccb = (isSqlType) ? ((SqlBinary)value).Length : ((byte[])value).Length;                              break;                          case TdsEnums.SQLUNIQUEID:                              ccb = GUID_SIZE;   // that's a constant for guid                              break;                          case TdsEnums.SQLBIGCHAR:                          case TdsEnums.SQLBIGVARCHAR:                          case TdsEnums.SQLTEXT:                              if (null == _defaultEncoding)                              {                                  ThrowUnsupportedCollationEncountered(null); // stateObject only when reading                              }                                string stringValue = null;                              if (isSqlType)                              {                                  stringValue = ((SqlString)value).Value;                              }                              else                              {                                  stringValue = (string)value;                              }                                ccb = stringValue.Length;                              ccbStringBytes = _defaultEncoding.GetByteCount(stringValue);                              break;                          case TdsEnums.SQLNCHAR:                          case TdsEnums.SQLNVARCHAR:                          case TdsEnums.SQLNTEXT:                              ccb = ((isSqlType) ? ((SqlString)value).Value.Length : ((string)value).Length) * 2;                              break;                          case TdsEnums.SQLXMLTYPE:                              // Value here could be string or XmlReader                              if (value is XmlReader)                              {                                  value = MetaType.GetStringFromXml((XmlReader)value);                              }                              ccb = ((isSqlType) ? ((SqlString)value).Value.Length : ((string)value).Length) * 2;                              break;                            default:                              ccb = metadata.length;                              break;                      }                  }                  else                  {                      Debug.Assert(metatype.IsLong &&                          ((metatype.SqlDbType == SqlDbType.VarBinary && value is StreamDataFeed) ||                           ((metatype.SqlDbType == SqlDbType.VarChar || metatype.SqlDbType == SqlDbType.NVarChar) && value is TextDataFeed) ||                           (metatype.SqlDbType == SqlDbType.Xml && value is XmlDataFeed))'                     "Stream data feed should only be assigned to VarBinary(max)' Text data feed should only be assigned to [N]VarChar(max)' Xml data feed should only be assigned to XML(max)");                  }                      // Expected the text length in data stream for bulk copy of text' ntext' or image data.                  //                  if (metatype.IsLong)                  {                      switch (metatype.SqlDbType)                      {                          case SqlDbType.Text:                          case SqlDbType.NText:                          case SqlDbType.Image:                              stateObj.WriteByteArray(s_longDataHeader' s_longDataHeader.Length' 0);                              WriteTokenLength(metadata.tdsType' ccbStringBytes == 0 ? ccb : ccbStringBytes' stateObj);                              break;                            case SqlDbType.VarChar:                          case SqlDbType.NVarChar:                          case SqlDbType.VarBinary:                          case SqlDbType.Xml:                          case SqlDbType.Udt:                              // plp data                              WriteUnsignedLong(TdsEnums.SQL_PLP_UNKNOWNLEN' stateObj);                              break;                      }                  }                  else                  {                      WriteTokenLength(metadata.tdsType' ccbStringBytes == 0 ? ccb : ccbStringBytes' stateObj);                  }                    if (isSqlType)                  {                      internalWriteTask = WriteSqlValue(value' metatype' ccb' ccbStringBytes' 0' stateObj);                  }                  else if (metatype.SqlDbType != SqlDbType.Udt || metatype.IsLong)                  {                      internalWriteTask = WriteValue(value' metatype' metadata.scale' ccb' ccbStringBytes' 0' stateObj' metadata.length' isDataFeed);                      if ((internalWriteTask == null) && (_asyncWrite))                      {                          internalWriteTask = stateObj.WaitForAccumulatedWrites();                      }                      Debug.Assert(_asyncWrite || stateObj.WaitForAccumulatedWrites() == null' "Should not have accumulated writes when writing sync");                  }                  else                  {                      WriteShort(ccb' stateObj);                      internalWriteTask = stateObj.WriteByteArray((byte[])value' ccb' 0);                  }    #if DEBUG                  //In DEBUG mode' when SetAlwaysTaskOnWrite is true' we create a task. Allows us to verify async execution paths.                  if (_asyncWrite && internalWriteTask == null && SqlBulkCopy.SetAlwaysTaskOnWrite == true)                  {                      internalWriteTask = Task.FromResult<object>(null);                  }  #endif                  if (internalWriteTask != null)                  { //i.e. the write was async.                      resultTask = WriteBulkCopyValueSetupContinuation(internalWriteTask' saveEncoding' saveCollation' saveCodePage' saveLCID);                  }              }              finally              {                  if (internalWriteTask == null)                  {                      _defaultEncoding = saveEncoding;                      _defaultCollation = saveCollation;                      _defaultCodePage = saveCodePage;                      _defaultLCID = saveLCID;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetNotificationHeaderSize,The following statement contains a magic number: if (null != notificationRequest)              {                  string callbackId = notificationRequest.UserData;                  string service = notificationRequest.Options;                  int timeout = notificationRequest.Timeout;                    if (null == callbackId)                  {                      throw ADP.ArgumentNull(nameof(callbackId));                  }                  else if (ushort.MaxValue < callbackId.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(callbackId));                  }                    if (null == service)                  {                      throw ADP.ArgumentNull(nameof(service));                  }                  else if (ushort.MaxValue < service.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(service));                  }                    if (-1 > timeout)                  {                      throw ADP.ArgumentOutOfRange(nameof(timeout));                  }                    // Header Length (uint) (included in size) (already written to output buffer)                  // Header Type (ushort)                  // NotifyID Length (ushort)                  // NotifyID UnicodeStream (unicode text)                  // SSBDeployment Length (ushort)                  // SSBDeployment UnicodeStream (unicode text)                  // Timeout (uint) -- optional                  // Don't send timeout value if it is 0                    int headerLength = 4 + 2 + 2 + (callbackId.Length * 2) + 2 + (service.Length * 2);                  if (timeout > 0)                      headerLength += 4;                  return headerLength;              }              else              {                  return 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetNotificationHeaderSize,The following statement contains a magic number: if (null != notificationRequest)              {                  string callbackId = notificationRequest.UserData;                  string service = notificationRequest.Options;                  int timeout = notificationRequest.Timeout;                    if (null == callbackId)                  {                      throw ADP.ArgumentNull(nameof(callbackId));                  }                  else if (ushort.MaxValue < callbackId.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(callbackId));                  }                    if (null == service)                  {                      throw ADP.ArgumentNull(nameof(service));                  }                  else if (ushort.MaxValue < service.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(service));                  }                    if (-1 > timeout)                  {                      throw ADP.ArgumentOutOfRange(nameof(timeout));                  }                    // Header Length (uint) (included in size) (already written to output buffer)                  // Header Type (ushort)                  // NotifyID Length (ushort)                  // NotifyID UnicodeStream (unicode text)                  // SSBDeployment Length (ushort)                  // SSBDeployment UnicodeStream (unicode text)                  // Timeout (uint) -- optional                  // Don't send timeout value if it is 0                    int headerLength = 4 + 2 + 2 + (callbackId.Length * 2) + 2 + (service.Length * 2);                  if (timeout > 0)                      headerLength += 4;                  return headerLength;              }              else              {                  return 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetNotificationHeaderSize,The following statement contains a magic number: if (null != notificationRequest)              {                  string callbackId = notificationRequest.UserData;                  string service = notificationRequest.Options;                  int timeout = notificationRequest.Timeout;                    if (null == callbackId)                  {                      throw ADP.ArgumentNull(nameof(callbackId));                  }                  else if (ushort.MaxValue < callbackId.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(callbackId));                  }                    if (null == service)                  {                      throw ADP.ArgumentNull(nameof(service));                  }                  else if (ushort.MaxValue < service.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(service));                  }                    if (-1 > timeout)                  {                      throw ADP.ArgumentOutOfRange(nameof(timeout));                  }                    // Header Length (uint) (included in size) (already written to output buffer)                  // Header Type (ushort)                  // NotifyID Length (ushort)                  // NotifyID UnicodeStream (unicode text)                  // SSBDeployment Length (ushort)                  // SSBDeployment UnicodeStream (unicode text)                  // Timeout (uint) -- optional                  // Don't send timeout value if it is 0                    int headerLength = 4 + 2 + 2 + (callbackId.Length * 2) + 2 + (service.Length * 2);                  if (timeout > 0)                      headerLength += 4;                  return headerLength;              }              else              {                  return 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetNotificationHeaderSize,The following statement contains a magic number: if (null != notificationRequest)              {                  string callbackId = notificationRequest.UserData;                  string service = notificationRequest.Options;                  int timeout = notificationRequest.Timeout;                    if (null == callbackId)                  {                      throw ADP.ArgumentNull(nameof(callbackId));                  }                  else if (ushort.MaxValue < callbackId.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(callbackId));                  }                    if (null == service)                  {                      throw ADP.ArgumentNull(nameof(service));                  }                  else if (ushort.MaxValue < service.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(service));                  }                    if (-1 > timeout)                  {                      throw ADP.ArgumentOutOfRange(nameof(timeout));                  }                    // Header Length (uint) (included in size) (already written to output buffer)                  // Header Type (ushort)                  // NotifyID Length (ushort)                  // NotifyID UnicodeStream (unicode text)                  // SSBDeployment Length (ushort)                  // SSBDeployment UnicodeStream (unicode text)                  // Timeout (uint) -- optional                  // Don't send timeout value if it is 0                    int headerLength = 4 + 2 + 2 + (callbackId.Length * 2) + 2 + (service.Length * 2);                  if (timeout > 0)                      headerLength += 4;                  return headerLength;              }              else              {                  return 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetNotificationHeaderSize,The following statement contains a magic number: if (null != notificationRequest)              {                  string callbackId = notificationRequest.UserData;                  string service = notificationRequest.Options;                  int timeout = notificationRequest.Timeout;                    if (null == callbackId)                  {                      throw ADP.ArgumentNull(nameof(callbackId));                  }                  else if (ushort.MaxValue < callbackId.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(callbackId));                  }                    if (null == service)                  {                      throw ADP.ArgumentNull(nameof(service));                  }                  else if (ushort.MaxValue < service.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(service));                  }                    if (-1 > timeout)                  {                      throw ADP.ArgumentOutOfRange(nameof(timeout));                  }                    // Header Length (uint) (included in size) (already written to output buffer)                  // Header Type (ushort)                  // NotifyID Length (ushort)                  // NotifyID UnicodeStream (unicode text)                  // SSBDeployment Length (ushort)                  // SSBDeployment UnicodeStream (unicode text)                  // Timeout (uint) -- optional                  // Don't send timeout value if it is 0                    int headerLength = 4 + 2 + 2 + (callbackId.Length * 2) + 2 + (service.Length * 2);                  if (timeout > 0)                      headerLength += 4;                  return headerLength;              }              else              {                  return 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetNotificationHeaderSize,The following statement contains a magic number: if (null != notificationRequest)              {                  string callbackId = notificationRequest.UserData;                  string service = notificationRequest.Options;                  int timeout = notificationRequest.Timeout;                    if (null == callbackId)                  {                      throw ADP.ArgumentNull(nameof(callbackId));                  }                  else if (ushort.MaxValue < callbackId.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(callbackId));                  }                    if (null == service)                  {                      throw ADP.ArgumentNull(nameof(service));                  }                  else if (ushort.MaxValue < service.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(service));                  }                    if (-1 > timeout)                  {                      throw ADP.ArgumentOutOfRange(nameof(timeout));                  }                    // Header Length (uint) (included in size) (already written to output buffer)                  // Header Type (ushort)                  // NotifyID Length (ushort)                  // NotifyID UnicodeStream (unicode text)                  // SSBDeployment Length (ushort)                  // SSBDeployment UnicodeStream (unicode text)                  // Timeout (uint) -- optional                  // Don't send timeout value if it is 0                    int headerLength = 4 + 2 + 2 + (callbackId.Length * 2) + 2 + (service.Length * 2);                  if (timeout > 0)                      headerLength += 4;                  return headerLength;              }              else              {                  return 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,GetNotificationHeaderSize,The following statement contains a magic number: if (null != notificationRequest)              {                  string callbackId = notificationRequest.UserData;                  string service = notificationRequest.Options;                  int timeout = notificationRequest.Timeout;                    if (null == callbackId)                  {                      throw ADP.ArgumentNull(nameof(callbackId));                  }                  else if (ushort.MaxValue < callbackId.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(callbackId));                  }                    if (null == service)                  {                      throw ADP.ArgumentNull(nameof(service));                  }                  else if (ushort.MaxValue < service.Length)                  {                      throw ADP.ArgumentOutOfRange(nameof(service));                  }                    if (-1 > timeout)                  {                      throw ADP.ArgumentOutOfRange(nameof(timeout));                  }                    // Header Length (uint) (included in size) (already written to output buffer)                  // Header Type (ushort)                  // NotifyID Length (ushort)                  // NotifyID UnicodeStream (unicode text)                  // SSBDeployment Length (ushort)                  // SSBDeployment UnicodeStream (unicode text)                  // Timeout (uint) -- optional                  // Don't send timeout value if it is 0                    int headerLength = 4 + 2 + 2 + (callbackId.Length * 2) + 2 + (service.Length * 2);                  if (timeout > 0)                      headerLength += 4;                  return headerLength;              }              else              {                  return 0;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteQueryNotificationHeaderData,The following statement contains a magic number: WriteShort(callbackId.Length * 2' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteQueryNotificationHeaderData,The following statement contains a magic number: WriteShort(service.Length * 2' stateObj);
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteRPCBatchHeaders,The following statement contains a magic number: const int marsHeaderSize = 18;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteRPCBatchHeaders,The following statement contains a magic number: int totalHeaderLength = 4 + marsHeaderSize + notificationHeaderSize;
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: {                  if (TdsEnums.SQLUDT == token)                  {                      tokenLength = 8;                  }                  else if (token == TdsEnums.SQLXMLTYPE)                  {                      tokenLength = 8;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: {                  if (TdsEnums.SQLUDT == token)                  {                      tokenLength = 8;                  }                  else if (token == TdsEnums.SQLXMLTYPE)                  {                      tokenLength = 8;                  }              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: if (tokenLength == 0)              {                  switch (token & TdsEnums.SQLLenMask)                  {                      case TdsEnums.SQLFixedLen:                          Debug.Assert(length == 0x01 << ((token & 0x0c) >> 2)' "length does not match encoded length in token");                          tokenLength = 0;                          break;                        case TdsEnums.SQLZeroLen:                          tokenLength = 0;                          break;                        case TdsEnums.SQLVarLen:                      case TdsEnums.SQLVarCnt:                          if (0 != (token & 0x80))                              tokenLength = 2;                          else if (0 == (token & 0x0c))                              tokenLength = 4;                          else                              tokenLength = 1;                            break;                        default:                          Debug.Assert(false' "Unknown token length!");                          break;                  }                    switch (tokenLength)                  {                      case 1:                          stateObj.WriteByte((byte)length);                          break;                        case 2:                          WriteShort(length' stateObj);                          break;                        case 4:                          WriteInt(length' stateObj);                          break;                        case 8:                          // In the metadata case we write 0xffff for partial length prefixed types.                          //  For actual data length preceding data' WriteDataLength should be used.                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                          break;                  } // end switch              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: if (tokenLength == 0)              {                  switch (token & TdsEnums.SQLLenMask)                  {                      case TdsEnums.SQLFixedLen:                          Debug.Assert(length == 0x01 << ((token & 0x0c) >> 2)' "length does not match encoded length in token");                          tokenLength = 0;                          break;                        case TdsEnums.SQLZeroLen:                          tokenLength = 0;                          break;                        case TdsEnums.SQLVarLen:                      case TdsEnums.SQLVarCnt:                          if (0 != (token & 0x80))                              tokenLength = 2;                          else if (0 == (token & 0x0c))                              tokenLength = 4;                          else                              tokenLength = 1;                            break;                        default:                          Debug.Assert(false' "Unknown token length!");                          break;                  }                    switch (tokenLength)                  {                      case 1:                          stateObj.WriteByte((byte)length);                          break;                        case 2:                          WriteShort(length' stateObj);                          break;                        case 4:                          WriteInt(length' stateObj);                          break;                        case 8:                          // In the metadata case we write 0xffff for partial length prefixed types.                          //  For actual data length preceding data' WriteDataLength should be used.                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                          break;                  } // end switch              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: if (tokenLength == 0)              {                  switch (token & TdsEnums.SQLLenMask)                  {                      case TdsEnums.SQLFixedLen:                          Debug.Assert(length == 0x01 << ((token & 0x0c) >> 2)' "length does not match encoded length in token");                          tokenLength = 0;                          break;                        case TdsEnums.SQLZeroLen:                          tokenLength = 0;                          break;                        case TdsEnums.SQLVarLen:                      case TdsEnums.SQLVarCnt:                          if (0 != (token & 0x80))                              tokenLength = 2;                          else if (0 == (token & 0x0c))                              tokenLength = 4;                          else                              tokenLength = 1;                            break;                        default:                          Debug.Assert(false' "Unknown token length!");                          break;                  }                    switch (tokenLength)                  {                      case 1:                          stateObj.WriteByte((byte)length);                          break;                        case 2:                          WriteShort(length' stateObj);                          break;                        case 4:                          WriteInt(length' stateObj);                          break;                        case 8:                          // In the metadata case we write 0xffff for partial length prefixed types.                          //  For actual data length preceding data' WriteDataLength should be used.                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                          break;                  } // end switch              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: if (tokenLength == 0)              {                  switch (token & TdsEnums.SQLLenMask)                  {                      case TdsEnums.SQLFixedLen:                          Debug.Assert(length == 0x01 << ((token & 0x0c) >> 2)' "length does not match encoded length in token");                          tokenLength = 0;                          break;                        case TdsEnums.SQLZeroLen:                          tokenLength = 0;                          break;                        case TdsEnums.SQLVarLen:                      case TdsEnums.SQLVarCnt:                          if (0 != (token & 0x80))                              tokenLength = 2;                          else if (0 == (token & 0x0c))                              tokenLength = 4;                          else                              tokenLength = 1;                            break;                        default:                          Debug.Assert(false' "Unknown token length!");                          break;                  }                    switch (tokenLength)                  {                      case 1:                          stateObj.WriteByte((byte)length);                          break;                        case 2:                          WriteShort(length' stateObj);                          break;                        case 4:                          WriteInt(length' stateObj);                          break;                        case 8:                          // In the metadata case we write 0xffff for partial length prefixed types.                          //  For actual data length preceding data' WriteDataLength should be used.                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                          break;                  } // end switch              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: if (tokenLength == 0)              {                  switch (token & TdsEnums.SQLLenMask)                  {                      case TdsEnums.SQLFixedLen:                          Debug.Assert(length == 0x01 << ((token & 0x0c) >> 2)' "length does not match encoded length in token");                          tokenLength = 0;                          break;                        case TdsEnums.SQLZeroLen:                          tokenLength = 0;                          break;                        case TdsEnums.SQLVarLen:                      case TdsEnums.SQLVarCnt:                          if (0 != (token & 0x80))                              tokenLength = 2;                          else if (0 == (token & 0x0c))                              tokenLength = 4;                          else                              tokenLength = 1;                            break;                        default:                          Debug.Assert(false' "Unknown token length!");                          break;                  }                    switch (tokenLength)                  {                      case 1:                          stateObj.WriteByte((byte)length);                          break;                        case 2:                          WriteShort(length' stateObj);                          break;                        case 4:                          WriteInt(length' stateObj);                          break;                        case 8:                          // In the metadata case we write 0xffff for partial length prefixed types.                          //  For actual data length preceding data' WriteDataLength should be used.                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                          break;                  } // end switch              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following statement contains a magic number: if (tokenLength == 0)              {                  switch (token & TdsEnums.SQLLenMask)                  {                      case TdsEnums.SQLFixedLen:                          Debug.Assert(length == 0x01 << ((token & 0x0c) >> 2)' "length does not match encoded length in token");                          tokenLength = 0;                          break;                        case TdsEnums.SQLZeroLen:                          tokenLength = 0;                          break;                        case TdsEnums.SQLVarLen:                      case TdsEnums.SQLVarCnt:                          if (0 != (token & 0x80))                              tokenLength = 2;                          else if (0 == (token & 0x0c))                              tokenLength = 4;                          else                              tokenLength = 1;                            break;                        default:                          Debug.Assert(false' "Unknown token length!");                          break;                  }                    switch (tokenLength)                  {                      case 1:                          stateObj.WriteByte((byte)length);                          break;                        case 2:                          WriteShort(length' stateObj);                          break;                        case 4:                          WriteInt(length' stateObj);                          break;                        case 8:                          // In the metadata case we write 0xffff for partial length prefixed types.                          //  For actual data length preceding data' WriteDataLength should be used.                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                          break;                  } // end switch              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedSqlValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat(((SqlSingle)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble(((SqlDouble)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                      {                          if (type.IsPlp)                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                            if (value is SqlBinary)                          {                              return stateObj.WriteByteArray(((SqlBinary)value).Value' actualLength' offset' canAccumulate: false);                          }                          else                          {                              Debug.Assert(value is SqlBytes);                              return stateObj.WriteByteArray(((SqlBytes)value).Value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          byte[] b = ((SqlGuid)value).ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if (((SqlBoolean)value).Value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte(((SqlByte)value).Value);                      else                          if (type.FixedLength == 2)                          WriteShort(((SqlInt16)value).Value' stateObj);                      else                              if (type.FixedLength == 4)                          WriteInt(((SqlInt32)value).Value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong(((SqlInt64)value).Value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      if (type.IsPlp)                      {                          WriteInt(codePageByteSize' stateObj);               // chunk length                      }                      if (value is SqlChars)                      {                          String sch = new String(((SqlChars)value).Value);                            return WriteEncodingChar(sch' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteEncodingChar(((SqlString)value).Value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                      }                      case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                        if (type.IsPlp)                      {                          if (IsBOMNeeded(type' value))                          {                              WriteInt(actualLength + 2' stateObj);               // chunk length                              WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                          }                          else                          {                              WriteInt(actualLength' stateObj);               // chunk length                          }                      }                        // convert to cchars instead of cbytes                      // Xml type is already converted to string through GetCoercedValue                      if (actualLength != 0)                          actualLength >>= 1;                        if (value is SqlChars)                      {                          return WriteCharArray(((SqlChars)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                      else                      {                          Debug.Assert(value is SqlString);                          return WriteString(((SqlString)value).Value' actualLength' offset' stateObj' canAccumulate: false);                      }                    case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteSqlDecimal((SqlDecimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      SqlDateTime dt = (SqlDateTime)value;                        if (type.FixedLength == 4)                      {                          if (0 > dt.DayTicks || dt.DayTicks > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(dt.ToString());                            WriteShort(dt.DayTicks' stateObj);                          WriteShort(dt.TimeTicks / SqlDateTime.SQLTicksPerMinute' stateObj);                      }                      else                      {                          WriteInt(dt.DayTicks' stateObj);                          WriteInt(dt.TimeTicks' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteSqlMoney((SqlMoney)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLUDT:                      Debug.Fail("Called WriteSqlValue on UDT param.Should have already been handled");                      throw SQL.UDTUnexpectedResult(value.GetType().AssemblyQualifiedName);                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteUnterminatedValue,The following statement contains a magic number: switch (type.NullableType)              {                  case TdsEnums.SQLFLTN:                      if (type.FixedLength == 4)                          WriteFloat((Single)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "Invalid length for SqlDouble type!");                          WriteDouble((Double)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGBINARY:                  case TdsEnums.SQLBIGVARBINARY:                  case TdsEnums.SQLIMAGE:                  case TdsEnums.SQLUDT:                      {                          // An array should be in the object                          Debug.Assert(isDataFeed || value is byte[]' "Value should be an array of bytes");                          Debug.Assert(!isDataFeed || value is StreamDataFeed' "Value should be a stream");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              return NullIfCompletedWriteTask(WriteStreamFeed((StreamDataFeed)value' stateObj' paramSize));                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(actualLength' stateObj);               // chunk length                                                      }                              return stateObj.WriteByteArray((byte[])value' actualLength' offset' canAccumulate: false);                          }                      }                    case TdsEnums.SQLUNIQUEID:                      {                          System.Guid guid = (System.Guid)value;                          byte[] b = guid.ToByteArray();                            Debug.Assert((actualLength == b.Length) && (actualLength == 16)' "Invalid length for guid type in com+ object");                          stateObj.WriteByteArray(b' actualLength' 0);                          break;                      }                    case TdsEnums.SQLBITN:                      {                          Debug.Assert(type.FixedLength == 1' "Invalid length for SqlBoolean type");                          if ((bool)value == true)                              stateObj.WriteByte(1);                          else                              stateObj.WriteByte(0);                            break;                      }                    case TdsEnums.SQLINTN:                      if (type.FixedLength == 1)                          stateObj.WriteByte((byte)value);                      else if (type.FixedLength == 2)                          WriteShort((short)value' stateObj);                      else if (type.FixedLength == 4)                          WriteInt((int)value' stateObj);                      else                      {                          Debug.Assert(type.FixedLength == 8' "invalid length for SqlIntN type:  " + type.FixedLength.ToString(CultureInfo.InvariantCulture));                          WriteLong((long)value' stateObj);                      }                        break;                    case TdsEnums.SQLBIGCHAR:                  case TdsEnums.SQLBIGVARCHAR:                  case TdsEnums.SQLTEXT:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' needBom: true' encoding: _defaultEncoding' size: paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' _defaultEncoding' false' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  WriteInt(encodingByteSize' stateObj);               // chunk length                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  return WriteEncodingChar((string)value' actualLength' offset' _defaultEncoding' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNCHAR:                  case TdsEnums.SQLNVARCHAR:                  case TdsEnums.SQLNTEXT:                  case TdsEnums.SQLXMLTYPE:                      {                          Debug.Assert(!isDataFeed || (value is TextDataFeed || value is XmlDataFeed)' "Value must be a TextReader or XmlReader");                          Debug.Assert(isDataFeed || (value is string || value is byte[])' "Value is a byte array or string");                            if (isDataFeed)                          {                              Debug.Assert(type.IsPlp' "Stream assigned to non-PLP was not converted!");                              TextDataFeed tdf = value as TextDataFeed;                              if (tdf == null)                              {                                  return NullIfCompletedWriteTask(WriteXmlFeed((XmlDataFeed)value' stateObj' IsBOMNeeded(type' value)' Encoding.Unicode' paramSize));                              }                              else                              {                                  return NullIfCompletedWriteTask(WriteTextFeed(tdf' null' IsBOMNeeded(type' value)' stateObj' paramSize));                              }                          }                          else                          {                              if (type.IsPlp)                              {                                  if (IsBOMNeeded(type' value))                                  {                                      WriteInt(actualLength + 2' stateObj);               // chunk length                                      WriteShort(TdsEnums.XMLUNICODEBOM' stateObj);                                  }                                  else                                  {                                      WriteInt(actualLength' stateObj);               // chunk length                                  }                              }                              if (value is byte[])                              { // If LazyMat non-filled blob' send cookie rather than value                                  return stateObj.WriteByteArray((byte[])value' actualLength' 0' canAccumulate: false);                              }                              else                              {                                  // convert to cchars instead of cbytes                                  actualLength >>= 1;                                  return WriteString((string)value' actualLength' offset' stateObj' canAccumulate: false);                              }                          }                      }                  case TdsEnums.SQLNUMERICN:                      Debug.Assert(type.FixedLength <= 17' "Decimal length cannot be greater than 17 bytes");                      WriteDecimal((Decimal)value' stateObj);                      break;                    case TdsEnums.SQLDATETIMN:                      Debug.Assert(type.FixedLength <= 0xff' "Invalid Fixed Length");                        TdsDateTime dt = MetaType.FromDateTime((DateTime)value' (byte)type.FixedLength);                        if (type.FixedLength == 4)                      {                          if (0 > dt.days || dt.days > ushort.MaxValue)                              throw SQL.SmallDateTimeOverflow(MetaType.ToDateTime(dt.days' dt.time' 4).ToString(CultureInfo.InvariantCulture));                            WriteShort(dt.days' stateObj);                          WriteShort(dt.time' stateObj);                      }                      else                      {                          WriteInt(dt.days' stateObj);                          WriteInt(dt.time' stateObj);                      }                        break;                    case TdsEnums.SQLMONEYN:                      {                          WriteCurrency((Decimal)value' type.FixedLength' stateObj);                          break;                      }                    case TdsEnums.SQLDATE:                      {                          WriteDate((DateTime)value' stateObj);                          break;                      }                    case TdsEnums.SQLTIME:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteTime((TimeSpan)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIME2:                      if (scale > TdsEnums.DEFAULT_VARTIME_SCALE)                      {                          throw SQL.TimeScaleValueOutOfRange(scale);                      }                      WriteDateTime2((DateTime)value' scale' actualLength' stateObj);                      break;                    case TdsEnums.SQLDATETIMEOFFSET:                      WriteDateTimeOffset((DateTimeOffset)value' scale' actualLength' stateObj);                      break;                    default:                      Debug.Assert(false' "Unknown TdsType!" + type.NullableType.ToString("x2"' (IFormatProvider)null));                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeChars,The following statement contains a magic number: while (charsLeft > 0)              {                  charsRead = (int)Math.Min((stateObj._longlenleft + 1) >> 1' (ulong)charsLeft);                  if ((buff == null) || (buff.Length < (offst + charsRead)))                  {                      // Grow the array                      newbuf = new char[offst + charsRead];                      if (buff != null)                      {                          Buffer.BlockCopy(buff' 0' newbuf' 0' offst * 2);                      }                      buff = newbuf;                  }                  if (charsRead > 0)                  {                      if (!TryReadPlpUnicodeCharsChunk(buff' offst' charsRead' stateObj' out charsRead))                      {                          return false;                      }                      charsLeft -= charsRead;                      offst += charsRead;                      totalCharsRead += charsRead;                  }                  // Special case single byte left                  if (stateObj._longlenleft == 1 && (charsLeft > 0))                  {                      byte b1;                      if (!stateObj.TryReadByte(out b1))                      {                          return false;                      }                      stateObj._longlenleft--;                      ulong ignored;                      if (!stateObj.TryReadPlpLength(false' out ignored))                      {                          return false;                      }                      Debug.Assert((stateObj._longlenleft != 0)' "ReadPlpUnicodeChars: Odd byte left at the end!");                      byte b2;                      if (!stateObj.TryReadByte(out b2))                      {                          return false;                      }                      stateObj._longlenleft--;                      // Put it at the end of the array. At this point we know we have an extra byte.                      buff[offst] = (char)(((b2 & 0xff) << 8) + (b1 & 0xff));                      offst = checked((int)offst + 1);                      charsRead++;                      charsLeft--;                      totalCharsRead++;                  }                  if (stateObj._longlenleft == 0)                  { // Read the next chunk or cleanup state if hit the end                      ulong ignored;                      if (!stateObj.TryReadPlpLength(false' out ignored))                      {                          return false;                      }                  }                    if (stateObj._longlenleft == 0)   // Data read complete                      break;              }
Magic Number,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryReadPlpUnicodeChars,The following statement contains a magic number: while (charsLeft > 0)              {                  charsRead = (int)Math.Min((stateObj._longlenleft + 1) >> 1' (ulong)charsLeft);                  if ((buff == null) || (buff.Length < (offst + charsRead)))                  {                      // Grow the array                      newbuf = new char[offst + charsRead];                      if (buff != null)                      {                          Buffer.BlockCopy(buff' 0' newbuf' 0' offst * 2);                      }                      buff = newbuf;                  }                  if (charsRead > 0)                  {                      if (!TryReadPlpUnicodeCharsChunk(buff' offst' charsRead' stateObj' out charsRead))                      {                          return false;                      }                      charsLeft -= charsRead;                      offst += charsRead;                      totalCharsRead += charsRead;                  }                  // Special case single byte left                  if (stateObj._longlenleft == 1 && (charsLeft > 0))                  {                      byte b1;                      if (!stateObj.TryReadByte(out b1))                      {                          return false;                      }                      stateObj._longlenleft--;                      ulong ignored;                      if (!stateObj.TryReadPlpLength(false' out ignored))                      {                          return false;                      }                      Debug.Assert((stateObj._longlenleft != 0)' "ReadPlpUnicodeChars: Odd byte left at the end!");                      byte b2;                      if (!stateObj.TryReadByte(out b2))                      {                          return false;                      }                      stateObj._longlenleft--;                      // Put it at the end of the array. At this point we know we have an extra byte.                      buff[offst] = (char)(((b2 & 0xff) << 8) + (b1 & 0xff));                      offst = checked((int)offst + 1);                      charsRead++;                      charsLeft--;                      totalCharsRead++;                  }                  if (stateObj._longlenleft == 0)                  { // Read the next chunk or cleanup state if hit the end                      ulong ignored;                      if (!stateObj.TryReadPlpLength(false' out ignored))                      {                          return false;                      }                  }                    if (stateObj._longlenleft == 0)   // Data read complete                      break;              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,SqlCollation,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,FirstSupportedCollationVersion,The following statement contains a magic number: switch (lcid)              {                  case 1044: return 2; // Norwegian_100_BIN                  case 1047: return 2; // Romansh_100_BIN                  case 1056: return 2; // Urdu_100_BIN                  case 1065: return 2; // Persian_100_BIN                  case 1068: return 2; // Azeri_Latin_100_BIN                  case 1070: return 2; // Upper_Sorbian_100_BIN                  case 1071: return 1; // Macedonian_FYROM_90_BIN                  case 1081: return 1; // Indic_General_90_BIN                  case 1082: return 2; // Maltese_100_BIN                  case 1083: return 2; // Sami_Norway_100_BIN                  case 1087: return 1; // Kazakh_90_BIN                  case 1090: return 2; // Turkmen_100_BIN                  case 1091: return 1; // Uzbek_Latin_90_BIN                  case 1092: return 1; // Tatar_90_BIN                  case 1093: return 2; // Bengali_100_BIN                  case 1101: return 2; // Assamese_100_BIN                  case 1105: return 2; // Tibetan_100_BIN                  case 1106: return 2; // Welsh_100_BIN                  case 1107: return 2; // Khmer_100_BIN                  case 1108: return 2; // Lao_100_BIN                  case 1114: return 1; // Syriac_90_BIN                  case 1121: return 2; // Nepali_100_BIN                  case 1122: return 2; // Frisian_100_BIN                  case 1123: return 2; // Pashto_100_BIN                  case 1125: return 1; // Divehi_90_BIN                  case 1133: return 2; // Bashkir_100_BIN                  case 1146: return 2; // Mapudungan_100_BIN                  case 1148: return 2; // Mohawk_100_BIN                  case 1150: return 2; // Breton_100_BIN                  case 1152: return 2; // Uighur_100_BIN                  case 1153: return 2; // Maori_100_BIN                  case 1155: return 2; // Corsican_100_BIN                  case 1157: return 2; // Yakut_100_BIN                  case 1164: return 2; // Dari_100_BIN                  case 2074: return 2; // Serbian_Latin_100_BIN                  case 2092: return 2; // Azeri_Cyrillic_100_BIN                  case 2107: return 2; // Sami_Sweden_Finland_100_BIN                  case 2143: return 2; // Tamazight_100_BIN                  case 3076: return 1; // Chinese_Hong_Kong_Stroke_90_BIN                  case 3098: return 2; // Serbian_Cyrillic_100_BIN                  case 5124: return 2; // Chinese_Traditional_Pinyin_100_BIN                  case 5146: return 2; // Bosnian_Latin_100_BIN                  case 8218: return 2; // Bosnian_Cyrillic_100_BIN                    default: return 0;   // other LCIDs have collation with version 0              }
Magic Number,System.Data.SqlClient,MultiPartTableName,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,MultiPartTableName,The following statement contains a magic number: _schemaName = parts[2];
Magic Number,System.Data.SqlClient,MultiPartTableName,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,MultiPartTableName,The following statement contains a magic number: _tableName = parts[3];
Magic Number,System.Data.SqlClient,MultiPartTableName,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,ParseMultipartName,The following statement contains a magic number: if (null != _multipartName)              {                  string[] parts = MultipartIdentifier.ParseMultipartIdentifier(_multipartName' "[\""' "]\""' SR.SQL_TDSParserTableName' false);                  _serverName = parts[0];                  _catalogName = parts[1];                  _schemaName = parts[2];                  _tableName = parts[3];                  _multipartName = null;              }
Magic Number,System.Data.SqlClient,MultiPartTableName,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserHelperClasses.cs,ParseMultipartName,The following statement contains a magic number: if (null != _multipartName)              {                  string[] parts = MultipartIdentifier.ParseMultipartIdentifier(_multipartName' "[\""' "]\""' SR.SQL_TDSParserTableName' false);                  _serverName = parts[0];                  _catalogName = parts[1];                  _schemaName = parts[2];                  _tableName = parts[3];                  _multipartName = null;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,IsRowTokenReady,The following statement contains a magic number: if (bytesRemaining > 0)              {                  if (_inBuff[_inBytesUsed] == TdsEnums.SQLROW)                  {                      // At a row token' so we're ready                      return true;                  }                  else if (_inBuff[_inBytesUsed] == TdsEnums.SQLNBCROW)                  {                      // NBC row token' ensure that we have enough data for the bitmap                      // SQLNBCROW + Null Bitmap (copied from NullBitmap.TryInitialize)                      int bytesToRead = 1 + (_cleanupMetaData.Length + 7) / 8;                      return (bytesToRead <= bytesRemaining);                  }              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,IsRowTokenReady,The following statement contains a magic number: if (bytesRemaining > 0)              {                  if (_inBuff[_inBytesUsed] == TdsEnums.SQLROW)                  {                      // At a row token' so we're ready                      return true;                  }                  else if (_inBuff[_inBytesUsed] == TdsEnums.SQLNBCROW)                  {                      // NBC row token' ensure that we have enough data for the bitmap                      // SQLNBCROW + Null Bitmap (copied from NullBitmap.TryInitialize)                      int bytesToRead = 1 + (_cleanupMetaData.Length + 7) / 8;                      return (bytesToRead <= bytesRemaining);                  }              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,DecrementPendingCallbacks,The following statement contains a magic number: Debug.Assert((remaining == -1 && SessionHandle == null) || (0 <= remaining && remaining < 3)' string.Format("_pendingCallbacks values is invalid after decrementing: {0}"' remaining));
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,IncrementPendingCallbacks,The following statement contains a magic number: Debug.Assert(0 < remaining && remaining <= 3' string.Format("_pendingCallbacks values is invalid after incrementing: {0}"' remaining));
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryProcessHeader,The following statement contains a magic number: if ((_partialHeaderBytesRead > 0) || (_inBytesUsed + _inputHeaderLen > _inBytesRead))              {                  // VSTS 219884: when some kind of MITM (man-in-the-middle) tool splits the network packets' the message header can be split over                   // several network packets.                  // Note: cannot use ReadByteArray here since it uses _inBytesPacket which is not set yet.                  do                  {                      int copy = Math.Min(_inBytesRead - _inBytesUsed' _inputHeaderLen - _partialHeaderBytesRead);                      Debug.Assert(copy > 0' "ReadNetworkPacket read empty buffer");                        Buffer.BlockCopy(_inBuff' _inBytesUsed' _partialHeaderBuffer' _partialHeaderBytesRead' copy);                      _partialHeaderBytesRead += copy;                      _inBytesUsed += copy;                        Debug.Assert(_partialHeaderBytesRead <= _inputHeaderLen' "Read more bytes for header than required");                      if (_partialHeaderBytesRead == _inputHeaderLen)                      {                          // All read                          _partialHeaderBytesRead = 0;                          _inBytesPacket = ((int)_partialHeaderBuffer[TdsEnums.HEADER_LEN_FIELD_OFFSET] << 8 |                                    (int)_partialHeaderBuffer[TdsEnums.HEADER_LEN_FIELD_OFFSET + 1]) - _inputHeaderLen;                            _messageStatus = _partialHeaderBuffer[1];                      }                      else                      {                          Debug.Assert(_inBytesUsed == _inBytesRead' "Did not use all data while reading partial header");                            // Require more data                          if (_parser.State == TdsParserState.Broken || _parser.State == TdsParserState.Closed)                          {                              // NOTE: ReadNetworkPacket does nothing if the parser state is closed or broken                              // to avoid infinite loop' we raise an exception                              ThrowExceptionAndWarning();                              return true;                          }                            if (!TryReadNetworkPacket())                          {                              return false;                          }                            if (_internalTimeout)                          {                              ThrowExceptionAndWarning();                              return true;                          }                      }                  } while (_partialHeaderBytesRead != 0); // This is reset to 0 once we have read everything that we need                    AssertValidState();              }              else              {                  // normal header processing...                  _messageStatus = _inBuff[_inBytesUsed + 1];                  _inBytesPacket = ((int)_inBuff[_inBytesUsed + TdsEnums.HEADER_LEN_FIELD_OFFSET] << 8 |                                                (int)_inBuff[_inBytesUsed + TdsEnums.HEADER_LEN_FIELD_OFFSET + 1]) - _inputHeaderLen;                  _inBytesUsed += _inputHeaderLen;                    AssertValidState();              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryProcessHeader,The following statement contains a magic number: if ((_partialHeaderBytesRead > 0) || (_inBytesUsed + _inputHeaderLen > _inBytesRead))              {                  // VSTS 219884: when some kind of MITM (man-in-the-middle) tool splits the network packets' the message header can be split over                   // several network packets.                  // Note: cannot use ReadByteArray here since it uses _inBytesPacket which is not set yet.                  do                  {                      int copy = Math.Min(_inBytesRead - _inBytesUsed' _inputHeaderLen - _partialHeaderBytesRead);                      Debug.Assert(copy > 0' "ReadNetworkPacket read empty buffer");                        Buffer.BlockCopy(_inBuff' _inBytesUsed' _partialHeaderBuffer' _partialHeaderBytesRead' copy);                      _partialHeaderBytesRead += copy;                      _inBytesUsed += copy;                        Debug.Assert(_partialHeaderBytesRead <= _inputHeaderLen' "Read more bytes for header than required");                      if (_partialHeaderBytesRead == _inputHeaderLen)                      {                          // All read                          _partialHeaderBytesRead = 0;                          _inBytesPacket = ((int)_partialHeaderBuffer[TdsEnums.HEADER_LEN_FIELD_OFFSET] << 8 |                                    (int)_partialHeaderBuffer[TdsEnums.HEADER_LEN_FIELD_OFFSET + 1]) - _inputHeaderLen;                            _messageStatus = _partialHeaderBuffer[1];                      }                      else                      {                          Debug.Assert(_inBytesUsed == _inBytesRead' "Did not use all data while reading partial header");                            // Require more data                          if (_parser.State == TdsParserState.Broken || _parser.State == TdsParserState.Closed)                          {                              // NOTE: ReadNetworkPacket does nothing if the parser state is closed or broken                              // to avoid infinite loop' we raise an exception                              ThrowExceptionAndWarning();                              return true;                          }                            if (!TryReadNetworkPacket())                          {                              return false;                          }                            if (_internalTimeout)                          {                              ThrowExceptionAndWarning();                              return true;                          }                      }                  } while (_partialHeaderBytesRead != 0); // This is reset to 0 once we have read everything that we need                    AssertValidState();              }              else              {                  // normal header processing...                  _messageStatus = _inBuff[_inBytesUsed + 1];                  _inBytesPacket = ((int)_inBuff[_inBytesUsed + TdsEnums.HEADER_LEN_FIELD_OFFSET] << 8 |                                                (int)_inBuff[_inBytesUsed + TdsEnums.HEADER_LEN_FIELD_OFFSET + 1]) - _inputHeaderLen;                  _inBytesUsed += _inputHeaderLen;                    AssertValidState();              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadChar,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the char isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = '\0';                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire char is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadChar,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the char isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = '\0';                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire char is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadChar,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the char isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = '\0';                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire char is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadChar,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the char isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = '\0';                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire char is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadChar,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the char isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = '\0';                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire char is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadChar,The following statement contains a magic number: value = (char)((buffer[offset + 1] << 8) + buffer[offset]);
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the int16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(short);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire int16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the int16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(short);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire int16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the int16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(short);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire int16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the int16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(short);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire int16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the int16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(short);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire int16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt16,The following statement contains a magic number: value = (short)((buffer[offset + 1] << 8) + buffer[offset]);
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt32,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = 0;                      return false;                  }                    AssertValidState();                  value = BitConverter.ToInt32(_bTmp' 0);                  return true;              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt32,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = 0;                      return false;                  }                    AssertValidState();                  value = BitConverter.ToInt32(_bTmp' 0);                  return true;              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt32,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = 0;                      return false;                  }                    AssertValidState();                  value = BitConverter.ToInt32(_bTmp' 0);                  return true;              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt32,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = 0;                      return false;                  }                    AssertValidState();                  value = BitConverter.ToInt32(_bTmp' 0);                  return true;              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt32,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = 0;                      return false;                  }                    AssertValidState();                  value = BitConverter.ToInt32(_bTmp' 0);                  return true;              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt64,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8)))              {                  // If the long isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 8 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 8' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 8' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToInt64(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire long is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt64(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt64,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8)))              {                  // If the long isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 8 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 8' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 8' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToInt64(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire long is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt64(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt64,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8)))              {                  // If the long isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 8 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 8' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 8' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToInt64(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire long is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt64(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt64,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8)))              {                  // If the long isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 8 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 8' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 8' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToInt64(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire long is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt64(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt64,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8)))              {                  // If the long isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 8 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 8' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 8' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToInt64(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire long is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt64(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt64,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8)))              {                  // If the long isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 8 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 8' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 8' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToInt64(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire long is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt64(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadInt64,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8)))              {                  // If the long isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 8 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 8' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 8' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToInt64(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire long is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToInt64(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the uint16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(ushort);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire uint16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the uint16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(ushort);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire uint16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the uint16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(ushort);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire uint16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the uint16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(ushort);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire uint16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt16,The following statement contains a magic number: if (((_inBytesUsed + 2) > _inBytesRead) || (_inBytesPacket < 2))              {                  // If the uint16 isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 2))                  {                      value = default(ushort);                      return false;                  }                    buffer = _bTmp;                  offset = 0;              }              else              {                  // The entire uint16 is in the packet and in the buffer' so just return it                  // and take care of the counters.                    buffer = _inBuff;                  offset = _inBytesUsed;                    _inBytesUsed += 2;                  _inBytesPacket -= 2;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt16,The following statement contains a magic number: value = (ushort)((buffer[offset + 1] << 8) + buffer[offset]);
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt32,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4)))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 4 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 4' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 4' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToUInt32(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToUInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt32,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4)))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 4 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 4' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 4' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToUInt32(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToUInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt32,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4)))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 4 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 4' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 4' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToUInt32(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToUInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt32,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4)))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 4 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 4' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 4' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToUInt32(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToUInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt32,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4)))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 4 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 4' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 4' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToUInt32(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToUInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt32,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4)))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 4 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 4' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 4' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToUInt32(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToUInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadUInt32,The following statement contains a magic number: if ((_bTmpRead > 0) || (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4)))              {                  // If the int isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    int bytesRead = 0;                  if (!TryReadByteArray(_bTmp' _bTmpRead' 4 - _bTmpRead' out bytesRead))                  {                      Debug.Assert(_bTmpRead + bytesRead <= 4' "Read more data than required");                      _bTmpRead += bytesRead;                      value = 0;                      return false;                  }                  else                  {                      Debug.Assert(_bTmpRead + bytesRead == 4' "TryReadByteArray returned true without reading all data required");                      _bTmpRead = 0;                      AssertValidState();                      value = BitConverter.ToUInt32(_bTmp' 0);                      return true;                  }              }              else              {                  // The entire int is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToUInt32(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadSingle,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the float isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = default(float);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToSingle(_bTmp' 0);                  return true;              }              else              {                  // The entire float is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToSingle(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadSingle,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the float isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = default(float);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToSingle(_bTmp' 0);                  return true;              }              else              {                  // The entire float is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToSingle(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadSingle,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the float isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = default(float);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToSingle(_bTmp' 0);                  return true;              }              else              {                  // The entire float is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToSingle(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadSingle,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the float isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = default(float);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToSingle(_bTmp' 0);                  return true;              }              else              {                  // The entire float is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToSingle(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadSingle,The following statement contains a magic number: if (((_inBytesUsed + 4) > _inBytesRead) || (_inBytesPacket < 4))              {                  // If the float isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 4))                  {                      value = default(float);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToSingle(_bTmp' 0);                  return true;              }              else              {                  // The entire float is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToSingle(_inBuff' _inBytesUsed);                    _inBytesUsed += 4;                  _inBytesPacket -= 4;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadDouble,The following statement contains a magic number: if (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8))              {                  // If the double isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 8))                  {                      value = default(double);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToDouble(_bTmp' 0);                  return true;              }              else              {                  // The entire double is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToDouble(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadDouble,The following statement contains a magic number: if (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8))              {                  // If the double isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 8))                  {                      value = default(double);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToDouble(_bTmp' 0);                  return true;              }              else              {                  // The entire double is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToDouble(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadDouble,The following statement contains a magic number: if (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8))              {                  // If the double isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 8))                  {                      value = default(double);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToDouble(_bTmp' 0);                  return true;              }              else              {                  // The entire double is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToDouble(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadDouble,The following statement contains a magic number: if (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8))              {                  // If the double isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 8))                  {                      value = default(double);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToDouble(_bTmp' 0);                  return true;              }              else              {                  // The entire double is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToDouble(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryReadDouble,The following statement contains a magic number: if (((_inBytesUsed + 8) > _inBytesRead) || (_inBytesPacket < 8))              {                  // If the double isn't fully in the buffer' or if it isn't fully in the packet'                  // then use ReadByteArray since the logic is there to take care of that.                    if (!TryReadByteArray(_bTmp' 0' 8))                  {                      value = default(double);                      return false;                  }                    AssertValidState();                  value = BitConverter.ToDouble(_bTmp' 0);                  return true;              }              else              {                  // The entire double is in the packet and in the buffer' so just return it                  // and take care of the counters.                    value = BitConverter.ToDouble(_inBuff' _inBytesUsed);                    _inBytesUsed += 8;                  _inBytesPacket -= 8;                    AssertValidState();                  return true;              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,OnTimeout,The following statement contains a magic number: if (!_internalTimeout)              {                  _internalTimeout = true;                  // lock protects against Close and Cancel                  lock (this)                  {                      if (!_attentionSent)                      {                          AddError(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' _parser.Server' _parser.Connection.TimeoutErrorInternal.GetErrorMessage()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT));                            // Grab a reference to the _networkPacketTaskSource in case it becomes null while we are trying to use it                          TaskCompletionSource<object> source = _networkPacketTaskSource;                            if (_parser.Connection.IsInPool)                          {                              // We should never timeout if the connection is currently in the pool: the safest thing to do here is to doom the connection to avoid corruption                              Debug.Assert(_parser.Connection.IsConnectionDoomed' "Timeout occurred while the connection is in the pool");                              _parser.State = TdsParserState.Broken;                              _parser.Connection.BreakConnection();                              if (source != null)                              {                                  source.TrySetCanceled();                              }                          }                          else if (_parser.State == TdsParserState.OpenLoggedIn)                          {                              try                              {                                  SendAttention(mustTakeWriteLock: true);                              }                              catch (Exception e)                              {                                  if (!ADP.IsCatchableExceptionType(e))                                  {                                      throw;                                  }                                  // if unable to send attention' cancel the _networkPacketTaskSource to                                  // request the parser be broken.  SNIWritePacket errors will already                                  // be in the _errors collection.                                  if (source != null)                                  {                                      source.TrySetCanceled();                                  }                              }                          }                            // If we still haven't received a packet then we don't want to actually close the connection                          // from another thread' so complete the pending operation as cancelled' informing them to break it                          if (source != null)                          {                              Task.Delay(AttentionTimeoutSeconds * 1000).ContinueWith(_ =>                              {                                  // Only break the connection if the read didn't finish                                  if (!source.Task.IsCompleted)                                  {                                      int pendingCallback = IncrementPendingCallbacks();                                      try                                      {                                          // If pendingCallback is at 3' then ReadAsyncCallback hasn't been called yet                                          // So it is safe for us to break the connection and cancel the Task (since we are not sure that ReadAsyncCallback will ever be called)                                          if ((pendingCallback == 3) && (!source.Task.IsCompleted))                                          {                                              Debug.Assert(source == _networkPacketTaskSource' "_networkPacketTaskSource which is being timed is not the current task source");                                                // Try to throw the timeout exception and store it in the task                                              bool exceptionStored = false;                                              try                                              {                                                  CheckThrowSNIException();                                              }                                              catch (Exception ex)                                              {                                                  if (source.TrySetException(ex))                                                  {                                                      exceptionStored = true;                                                  }                                              }                                                // Ensure that the connection is no longer usable                                               // This is needed since the timeout error added above is non-fatal (and so throwing it won't break the connection)                                              _parser.State = TdsParserState.Broken;                                              _parser.Connection.BreakConnection();                                                // If we didn't get an exception (something else observed it?) then ensure that the task is cancelled                                              if (!exceptionStored)                                              {                                                  source.TrySetCanceled();                                              }                                          }                                      }                                      finally                                      {                                          DecrementPendingCallbacks(release: false);                                      }                                  }                              });                          }                      }                  }              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,OnTimeout,The following statement contains a magic number: if (!_internalTimeout)              {                  _internalTimeout = true;                  // lock protects against Close and Cancel                  lock (this)                  {                      if (!_attentionSent)                      {                          AddError(new SqlError(TdsEnums.TIMEOUT_EXPIRED' (byte)0x00' TdsEnums.MIN_ERROR_CLASS' _parser.Server' _parser.Connection.TimeoutErrorInternal.GetErrorMessage()' ""' 0' TdsEnums.SNI_WAIT_TIMEOUT));                            // Grab a reference to the _networkPacketTaskSource in case it becomes null while we are trying to use it                          TaskCompletionSource<object> source = _networkPacketTaskSource;                            if (_parser.Connection.IsInPool)                          {                              // We should never timeout if the connection is currently in the pool: the safest thing to do here is to doom the connection to avoid corruption                              Debug.Assert(_parser.Connection.IsConnectionDoomed' "Timeout occurred while the connection is in the pool");                              _parser.State = TdsParserState.Broken;                              _parser.Connection.BreakConnection();                              if (source != null)                              {                                  source.TrySetCanceled();                              }                          }                          else if (_parser.State == TdsParserState.OpenLoggedIn)                          {                              try                              {                                  SendAttention(mustTakeWriteLock: true);                              }                              catch (Exception e)                              {                                  if (!ADP.IsCatchableExceptionType(e))                                  {                                      throw;                                  }                                  // if unable to send attention' cancel the _networkPacketTaskSource to                                  // request the parser be broken.  SNIWritePacket errors will already                                  // be in the _errors collection.                                  if (source != null)                                  {                                      source.TrySetCanceled();                                  }                              }                          }                            // If we still haven't received a packet then we don't want to actually close the connection                          // from another thread' so complete the pending operation as cancelled' informing them to break it                          if (source != null)                          {                              Task.Delay(AttentionTimeoutSeconds * 1000).ContinueWith(_ =>                              {                                  // Only break the connection if the read didn't finish                                  if (!source.Task.IsCompleted)                                  {                                      int pendingCallback = IncrementPendingCallbacks();                                      try                                      {                                          // If pendingCallback is at 3' then ReadAsyncCallback hasn't been called yet                                          // So it is safe for us to break the connection and cancel the Task (since we are not sure that ReadAsyncCallback will ever be called)                                          if ((pendingCallback == 3) && (!source.Task.IsCompleted))                                          {                                              Debug.Assert(source == _networkPacketTaskSource' "_networkPacketTaskSource which is being timed is not the current task source");                                                // Try to throw the timeout exception and store it in the task                                              bool exceptionStored = false;                                              try                                              {                                                  CheckThrowSNIException();                                              }                                              catch (Exception ex)                                              {                                                  if (source.TrySetException(ex))                                                  {                                                      exceptionStored = true;                                                  }                                              }                                                // Ensure that the connection is no longer usable                                               // This is needed since the timeout error added above is non-fatal (and so throwing it won't break the connection)                                              _parser.State = TdsParserState.Broken;                                              _parser.Connection.BreakConnection();                                                // If we didn't get an exception (something else observed it?) then ensure that the task is cancelled                                              if (!exceptionStored)                                              {                                                  source.TrySetCanceled();                                              }                                          }                                      }                                      finally                                      {                                          DecrementPendingCallbacks(release: false);                                      }                                  }                              });                          }                      }                  }              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,ReadAsyncCallback,The following statement contains a magic number: try              {                  Debug.Assert(CheckPacket(packet' source) && source != null' "AsyncResult null on callback");                    if (_parser.MARSOn)                  { // Only take reset lock on MARS and Async.                      CheckSetResetConnectionState(error' CallbackType.Read);                  }                    ChangeNetworkPacketTimeout(Timeout.Infinite' Timeout.Infinite);                    ProcessSniPacket(packet' error);              }              catch (Exception e)              {                  processFinallyBlock = ADP.IsCatchableExceptionType(e);                  throw;              }              finally              {                  // pendingCallbacks may be 2 after decrementing' this indicates that a fatal timeout is occurring' and therefore we shouldn't complete the task                  int pendingCallbacks = DecrementPendingCallbacks(false); // may dispose of GC handle.                  if ((processFinallyBlock) && (source != null) && (pendingCallbacks < 2))                  {                      if (error == 0)                      {                          if (_executionContext != null)                          {                              ExecutionContext.Run(_executionContext' (state) => source.TrySetResult(null)' null);                          }                          else                          {                              source.TrySetResult(null);                          }                      }                      else                      {                          if (_executionContext != null)                          {                              ExecutionContext.Run(_executionContext' (state) => ReadAsyncCallbackCaptureException(source)' null);                          }                          else                          {                              ReadAsyncCallbackCaptureException(source);                          }                      }                  }                    AssertValidState();              }
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The following statement contains a magic number: _outBuff[2] = (byte)(_outBytesUsed >> 8);
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The following statement contains a magic number: _outBuff[2] = (byte)(_outBytesUsed >> 8);
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The following statement contains a magic number: _outBuff[3] = (byte)(_outBytesUsed & 0xff);
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The following statement contains a magic number: _outBuff[4] = 0;
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The following statement contains a magic number: _outBuff[5] = 0;
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The following statement contains a magic number: _outBuff[6] = packetNumber;
Magic Number,System.Data.SqlClient,TdsParserStateObject,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,WritePacket,The following statement contains a magic number: _outBuff[7] = 0;
Magic Number,System.Data.SqlClient,NullBitmap,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryInitialize,The following statement contains a magic number: int bitmapArrayLength = (columnsCount + 7) / 8;
Magic Number,System.Data.SqlClient,NullBitmap,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,TryInitialize,The following statement contains a magic number: int bitmapArrayLength = (columnsCount + 7) / 8;
Magic Number,System.Data.SqlClient,NullBitmap,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStateObject.cs,IsGuaranteedNull,The following statement contains a magic number: byte testByte = _nullBitmap[columnOrdinal >> 3];
Magic Number,System.Data.SqlClient,TdsParserStaticMethods,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStaticMethods.cs,ObfuscatePassword,The following statement contains a magic number: for (int i = 0; i < password.Length; i++)              {                  s = (int)password[i];                  bLo = (byte)(s & 0xff);                  bHi = (byte)((s >> 8) & 0xff);                  bObfuscated[i << 1] = (Byte)((((bLo & 0x0f) << 4) | (bLo >> 4)) ^ 0xa5);                  bObfuscated[(i << 1) + 1] = (Byte)((((bHi & 0x0f) << 4) | (bHi >> 4)) ^ 0xa5);              }
Magic Number,System.Data.SqlClient,TdsParserStaticMethods,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStaticMethods.cs,ObfuscatePassword,The following statement contains a magic number: for (int i = 0; i < password.Length; i++)              {                  s = (int)password[i];                  bLo = (byte)(s & 0xff);                  bHi = (byte)((s >> 8) & 0xff);                  bObfuscated[i << 1] = (Byte)((((bLo & 0x0f) << 4) | (bLo >> 4)) ^ 0xa5);                  bObfuscated[(i << 1) + 1] = (Byte)((((bHi & 0x0f) << 4) | (bHi >> 4)) ^ 0xa5);              }
Magic Number,System.Data.SqlClient,TdsParserStaticMethods,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStaticMethods.cs,ObfuscatePassword,The following statement contains a magic number: for (int i = 0; i < password.Length; i++)              {                  s = (int)password[i];                  bLo = (byte)(s & 0xff);                  bHi = (byte)((s >> 8) & 0xff);                  bObfuscated[i << 1] = (Byte)((((bLo & 0x0f) << 4) | (bLo >> 4)) ^ 0xa5);                  bObfuscated[(i << 1) + 1] = (Byte)((((bHi & 0x0f) << 4) | (bHi >> 4)) ^ 0xa5);              }
Magic Number,System.Data.SqlClient,TdsParserStaticMethods,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStaticMethods.cs,ObfuscatePassword,The following statement contains a magic number: for (int i = 0; i < password.Length; i++)              {                  s = (int)password[i];                  bLo = (byte)(s & 0xff);                  bHi = (byte)((s >> 8) & 0xff);                  bObfuscated[i << 1] = (Byte)((((bLo & 0x0f) << 4) | (bLo >> 4)) ^ 0xa5);                  bObfuscated[(i << 1) + 1] = (Byte)((((bHi & 0x0f) << 4) | (bHi >> 4)) ^ 0xa5);              }
Magic Number,System.Data.SqlClient,TdsParserStaticMethods,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParserStaticMethods.cs,ObfuscatePassword,The following statement contains a magic number: for (int i = 0; i < password.Length; i++)              {                  s = (int)password[i];                  bLo = (byte)(s & 0xff);                  bHi = (byte)((s >> 8) & 0xff);                  bObfuscated[i << 1] = (Byte)((((bLo & 0x0f) << 4) | (bLo >> 4)) ^ 0xa5);                  bObfuscated[(i << 1) + 1] = (Byte)((((bHi & 0x0f) << 4) | (bHi >> 4)) ^ 0xa5);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetBoolean,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(3' TdsEnums.SQLBIT' 0' _stateObj);              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetByte,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(3' TdsEnums.SQLINT1' 0' _stateObj);              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetBytesNoOffsetHandling,The following statement contains a magic number: if (_isPlp)              {                  if (!_plpUnknownSent)                  {                      _stateObj.Parser.WriteUnsignedLong(TdsEnums.SQL_PLP_UNKNOWNLEN' _stateObj);                      _plpUnknownSent = true;                  }                    // Write chunk length & chunk                  _stateObj.Parser.WriteInt(length' _stateObj);                  _stateObj.WriteByteArray(buffer' length' bufferOffset);              }              else              {                  // Non-plp data must be sent in one chunk for now.  #if DEBUG                  Debug.Assert(0 == _currentOffset' "SetBytes doesn't yet support chunking for non-plp data: " + _currentOffset);    #endif                  Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType' _metaData.IsMultiValued).IsLong'                      "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);                    if (SqlDbType.Variant == _metaData.SqlDbType)                  {                      _stateObj.Parser.WriteSqlVariantHeader(4 + length' TdsEnums.SQLBIGVARBINARY' 2' _stateObj);                  }                  _stateObj.Parser.WriteShort(length' _stateObj);                  _stateObj.WriteByteArray(buffer' length' bufferOffset);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetBytesNoOffsetHandling,The following statement contains a magic number: if (_isPlp)              {                  if (!_plpUnknownSent)                  {                      _stateObj.Parser.WriteUnsignedLong(TdsEnums.SQL_PLP_UNKNOWNLEN' _stateObj);                      _plpUnknownSent = true;                  }                    // Write chunk length & chunk                  _stateObj.Parser.WriteInt(length' _stateObj);                  _stateObj.WriteByteArray(buffer' length' bufferOffset);              }              else              {                  // Non-plp data must be sent in one chunk for now.  #if DEBUG                  Debug.Assert(0 == _currentOffset' "SetBytes doesn't yet support chunking for non-plp data: " + _currentOffset);    #endif                  Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType' _metaData.IsMultiValued).IsLong'                      "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);                    if (SqlDbType.Variant == _metaData.SqlDbType)                  {                      _stateObj.Parser.WriteSqlVariantHeader(4 + length' TdsEnums.SQLBIGVARBINARY' 2' _stateObj);                  }                  _stateObj.Parser.WriteShort(length' _stateObj);                  _stateObj.WriteByteArray(buffer' length' bufferOffset);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetBytesLength,The following statement contains a magic number: if (0 == length)              {                  if (_isPlp)                  {                      Debug.Assert(!_plpUnknownSent' "A plpUnknown has already been sent before setting length to zero.");                        _stateObj.Parser.WriteLong(0' _stateObj);                      _plpUnknownSent = true;                  }                  else                  {                      Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType' _metaData.IsMultiValued).IsLong'                          "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);                        if (SqlDbType.Variant == _metaData.SqlDbType)                      {                          _stateObj.Parser.WriteSqlVariantHeader(4' TdsEnums.SQLBIGVARBINARY' 2' _stateObj);                      }                      _stateObj.Parser.WriteShort(0' _stateObj);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetBytesLength,The following statement contains a magic number: if (0 == length)              {                  if (_isPlp)                  {                      Debug.Assert(!_plpUnknownSent' "A plpUnknown has already been sent before setting length to zero.");                        _stateObj.Parser.WriteLong(0' _stateObj);                      _plpUnknownSent = true;                  }                  else                  {                      Debug.Assert(!MetaType.GetMetaTypeFromSqlDbType(_metaData.SqlDbType' _metaData.IsMultiValued).IsLong'                          "We're assuming long length types are sent as PLP. SqlDbType = " + _metaData.SqlDbType);                        if (SqlDbType.Variant == _metaData.SqlDbType)                      {                          _stateObj.Parser.WriteSqlVariantHeader(4' TdsEnums.SQLBIGVARBINARY' 2' _stateObj);                      }                      _stateObj.Parser.WriteShort(0' _stateObj);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetString,The following statement contains a magic number: if (MetaDataUtilsSmi.IsAnsiType(_metaData.SqlDbType))              {                  byte[] bytes;                  // Optimize for common case of writing entire string                  if (offset == 0 && value.Length <= length)                  {                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                  }                  else                  {                      char[] chars = value.ToCharArray(offset' length);                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(chars);                  }                  SetBytes(0' bytes' 0' bytes.Length);                  SetBytesLength(bytes.Length);              }              else if (SqlDbType.Variant == _metaData.SqlDbType)              {                  Debug.Assert(null != _variantType && SqlDbType.NVarChar == _variantType.SqlDbType' "Invalid variant type");                    SqlCollation collation = new SqlCollation();                  collation.LCID = checked((int)_variantType.LocaleId);                  collation.SqlCompareOptions = _variantType.CompareOptions;                    if (length * ADP.CharSize > TdsEnums.TYPE_SIZE_LIMIT)                  { // send as varchar for length greater than 4000                      byte[] bytes;                      // Optimize for common case of writing entire string                      if (offset == 0 && value.Length <= length)                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                      }                      else                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value.ToCharArray(offset' length));                      }                      _stateObj.Parser.WriteSqlVariantHeader(9 + bytes.Length' TdsEnums.SQLBIGVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(bytes.Length' _stateObj); // propbyte: varlen                      _stateObj.WriteByteArray(bytes' bytes.Length' 0);                  }                  else                  {                      _stateObj.Parser.WriteSqlVariantHeader(9 + length * ADP.CharSize' TdsEnums.SQLNVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj); // propbyte: varlen                      _stateObj.Parser.WriteString(value' length' offset' _stateObj);                  }                  _variantType = null;              }              else if (_isPlp)              {                  // Send the string as a complete PLP chunk.                  _stateObj.Parser.WriteLong(length * ADP.CharSize' _stateObj);  // PLP total length                  _stateObj.Parser.WriteInt(length * ADP.CharSize' _stateObj);   // Chunk length                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);  // Data                  if (length != 0)                  {                      _stateObj.Parser.WriteInt(TdsEnums.SQL_PLP_CHUNK_TERMINATOR' _stateObj); // Terminator                  }              }              else              {                  _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj);                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetString,The following statement contains a magic number: if (MetaDataUtilsSmi.IsAnsiType(_metaData.SqlDbType))              {                  byte[] bytes;                  // Optimize for common case of writing entire string                  if (offset == 0 && value.Length <= length)                  {                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                  }                  else                  {                      char[] chars = value.ToCharArray(offset' length);                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(chars);                  }                  SetBytes(0' bytes' 0' bytes.Length);                  SetBytesLength(bytes.Length);              }              else if (SqlDbType.Variant == _metaData.SqlDbType)              {                  Debug.Assert(null != _variantType && SqlDbType.NVarChar == _variantType.SqlDbType' "Invalid variant type");                    SqlCollation collation = new SqlCollation();                  collation.LCID = checked((int)_variantType.LocaleId);                  collation.SqlCompareOptions = _variantType.CompareOptions;                    if (length * ADP.CharSize > TdsEnums.TYPE_SIZE_LIMIT)                  { // send as varchar for length greater than 4000                      byte[] bytes;                      // Optimize for common case of writing entire string                      if (offset == 0 && value.Length <= length)                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                      }                      else                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value.ToCharArray(offset' length));                      }                      _stateObj.Parser.WriteSqlVariantHeader(9 + bytes.Length' TdsEnums.SQLBIGVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(bytes.Length' _stateObj); // propbyte: varlen                      _stateObj.WriteByteArray(bytes' bytes.Length' 0);                  }                  else                  {                      _stateObj.Parser.WriteSqlVariantHeader(9 + length * ADP.CharSize' TdsEnums.SQLNVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj); // propbyte: varlen                      _stateObj.Parser.WriteString(value' length' offset' _stateObj);                  }                  _variantType = null;              }              else if (_isPlp)              {                  // Send the string as a complete PLP chunk.                  _stateObj.Parser.WriteLong(length * ADP.CharSize' _stateObj);  // PLP total length                  _stateObj.Parser.WriteInt(length * ADP.CharSize' _stateObj);   // Chunk length                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);  // Data                  if (length != 0)                  {                      _stateObj.Parser.WriteInt(TdsEnums.SQL_PLP_CHUNK_TERMINATOR' _stateObj); // Terminator                  }              }              else              {                  _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj);                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetString,The following statement contains a magic number: if (MetaDataUtilsSmi.IsAnsiType(_metaData.SqlDbType))              {                  byte[] bytes;                  // Optimize for common case of writing entire string                  if (offset == 0 && value.Length <= length)                  {                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                  }                  else                  {                      char[] chars = value.ToCharArray(offset' length);                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(chars);                  }                  SetBytes(0' bytes' 0' bytes.Length);                  SetBytesLength(bytes.Length);              }              else if (SqlDbType.Variant == _metaData.SqlDbType)              {                  Debug.Assert(null != _variantType && SqlDbType.NVarChar == _variantType.SqlDbType' "Invalid variant type");                    SqlCollation collation = new SqlCollation();                  collation.LCID = checked((int)_variantType.LocaleId);                  collation.SqlCompareOptions = _variantType.CompareOptions;                    if (length * ADP.CharSize > TdsEnums.TYPE_SIZE_LIMIT)                  { // send as varchar for length greater than 4000                      byte[] bytes;                      // Optimize for common case of writing entire string                      if (offset == 0 && value.Length <= length)                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                      }                      else                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value.ToCharArray(offset' length));                      }                      _stateObj.Parser.WriteSqlVariantHeader(9 + bytes.Length' TdsEnums.SQLBIGVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(bytes.Length' _stateObj); // propbyte: varlen                      _stateObj.WriteByteArray(bytes' bytes.Length' 0);                  }                  else                  {                      _stateObj.Parser.WriteSqlVariantHeader(9 + length * ADP.CharSize' TdsEnums.SQLNVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj); // propbyte: varlen                      _stateObj.Parser.WriteString(value' length' offset' _stateObj);                  }                  _variantType = null;              }              else if (_isPlp)              {                  // Send the string as a complete PLP chunk.                  _stateObj.Parser.WriteLong(length * ADP.CharSize' _stateObj);  // PLP total length                  _stateObj.Parser.WriteInt(length * ADP.CharSize' _stateObj);   // Chunk length                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);  // Data                  if (length != 0)                  {                      _stateObj.Parser.WriteInt(TdsEnums.SQL_PLP_CHUNK_TERMINATOR' _stateObj); // Terminator                  }              }              else              {                  _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj);                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetString,The following statement contains a magic number: if (MetaDataUtilsSmi.IsAnsiType(_metaData.SqlDbType))              {                  byte[] bytes;                  // Optimize for common case of writing entire string                  if (offset == 0 && value.Length <= length)                  {                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                  }                  else                  {                      char[] chars = value.ToCharArray(offset' length);                      bytes = _stateObj.Parser._defaultEncoding.GetBytes(chars);                  }                  SetBytes(0' bytes' 0' bytes.Length);                  SetBytesLength(bytes.Length);              }              else if (SqlDbType.Variant == _metaData.SqlDbType)              {                  Debug.Assert(null != _variantType && SqlDbType.NVarChar == _variantType.SqlDbType' "Invalid variant type");                    SqlCollation collation = new SqlCollation();                  collation.LCID = checked((int)_variantType.LocaleId);                  collation.SqlCompareOptions = _variantType.CompareOptions;                    if (length * ADP.CharSize > TdsEnums.TYPE_SIZE_LIMIT)                  { // send as varchar for length greater than 4000                      byte[] bytes;                      // Optimize for common case of writing entire string                      if (offset == 0 && value.Length <= length)                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value);                      }                      else                      {                          bytes = _stateObj.Parser._defaultEncoding.GetBytes(value.ToCharArray(offset' length));                      }                      _stateObj.Parser.WriteSqlVariantHeader(9 + bytes.Length' TdsEnums.SQLBIGVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(bytes.Length' _stateObj); // propbyte: varlen                      _stateObj.WriteByteArray(bytes' bytes.Length' 0);                  }                  else                  {                      _stateObj.Parser.WriteSqlVariantHeader(9 + length * ADP.CharSize' TdsEnums.SQLNVARCHAR' 7' _stateObj);                      _stateObj.Parser.WriteUnsignedInt(collation.info' _stateObj); // propbytes: collation.Info                      _stateObj.WriteByte(collation.sortId); // propbytes: collation.SortId                      _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj); // propbyte: varlen                      _stateObj.Parser.WriteString(value' length' offset' _stateObj);                  }                  _variantType = null;              }              else if (_isPlp)              {                  // Send the string as a complete PLP chunk.                  _stateObj.Parser.WriteLong(length * ADP.CharSize' _stateObj);  // PLP total length                  _stateObj.Parser.WriteInt(length * ADP.CharSize' _stateObj);   // Chunk length                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);  // Data                  if (length != 0)                  {                      _stateObj.Parser.WriteInt(TdsEnums.SQL_PLP_CHUNK_TERMINATOR' _stateObj); // Terminator                  }              }              else              {                  _stateObj.Parser.WriteShort(length * ADP.CharSize' _stateObj);                  _stateObj.Parser.WriteString(value' length' offset' _stateObj);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetInt16,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(4' TdsEnums.SQLINT2' 0' _stateObj);              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetInt32,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(6' TdsEnums.SQLINT4' 0' _stateObj);              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetInt64,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  if (null == _variantType)                  {                      _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLINT8' 0' _stateObj);                      _stateObj.Parser.WriteLong(value' _stateObj);                  }                  else                  {                      Debug.Assert(SqlDbType.Money == _variantType.SqlDbType' "Invalid variant type");                        _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLMONEY' 0' _stateObj);                      _stateObj.Parser.WriteInt((int)(value >> 0x20)' _stateObj);                      _stateObj.Parser.WriteInt((int)value' _stateObj);                      _variantType = null;                  }              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);                  if (SqlDbType.SmallMoney == _metaData.SqlDbType)                  {                      _stateObj.Parser.WriteInt((int)value' _stateObj);                  }                  else if (SqlDbType.Money == _metaData.SqlDbType)                  {                      _stateObj.Parser.WriteInt((int)(value >> 0x20)' _stateObj);                      _stateObj.Parser.WriteInt((int)value' _stateObj);                  }                  else                  {                      _stateObj.Parser.WriteLong(value' _stateObj);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetInt64,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  if (null == _variantType)                  {                      _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLINT8' 0' _stateObj);                      _stateObj.Parser.WriteLong(value' _stateObj);                  }                  else                  {                      Debug.Assert(SqlDbType.Money == _variantType.SqlDbType' "Invalid variant type");                        _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLMONEY' 0' _stateObj);                      _stateObj.Parser.WriteInt((int)(value >> 0x20)' _stateObj);                      _stateObj.Parser.WriteInt((int)value' _stateObj);                      _variantType = null;                  }              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);                  if (SqlDbType.SmallMoney == _metaData.SqlDbType)                  {                      _stateObj.Parser.WriteInt((int)value' _stateObj);                  }                  else if (SqlDbType.Money == _metaData.SqlDbType)                  {                      _stateObj.Parser.WriteInt((int)(value >> 0x20)' _stateObj);                      _stateObj.Parser.WriteInt((int)value' _stateObj);                  }                  else                  {                      _stateObj.Parser.WriteLong(value' _stateObj);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetSingle,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(6' TdsEnums.SQLFLT4' 0' _stateObj);              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDouble,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLFLT8' 0' _stateObj);              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetSqlDecimal,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(21' TdsEnums.SQLNUMERICN' 2' _stateObj);                  _stateObj.WriteByte(value.Precision); // propbytes: precision                  _stateObj.WriteByte(value.Scale); // propbytes: scale                  _stateObj.Parser.WriteSqlDecimal(value' _stateObj);              }              else              {                  _stateObj.WriteByte(checked((byte)MetaType.MetaDecimal.FixedLength)); // SmiMetaData's length and actual wire format's length are different                  _stateObj.Parser.WriteSqlDecimal(SqlDecimal.ConvertToPrecScale(value' _metaData.Precision' _metaData.Scale)' _stateObj);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetSqlDecimal,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(21' TdsEnums.SQLNUMERICN' 2' _stateObj);                  _stateObj.WriteByte(value.Precision); // propbytes: precision                  _stateObj.WriteByte(value.Scale); // propbytes: scale                  _stateObj.Parser.WriteSqlDecimal(value' _stateObj);              }              else              {                  _stateObj.WriteByte(checked((byte)MetaType.MetaDecimal.FixedLength)); // SmiMetaData's length and actual wire format's length are different                  _stateObj.Parser.WriteSqlDecimal(SqlDecimal.ConvertToPrecScale(value' _metaData.Precision' _metaData.Scale)' _stateObj);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTime,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.DateTime2))                  {                      _stateObj.Parser.WriteSqlVariantDateTime2(value' _stateObj);                  }                  else if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.Date))                  {                      _stateObj.Parser.WriteSqlVariantDate(value' _stateObj);                  }                  else                  {                      TdsDateTime dt = MetaType.FromDateTime(value' 8);                      _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLDATETIME' 0' _stateObj);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                    // Clean the variant metadata to prevent sharing it with next row.                   // As a reminder' SetVariantType raises an assert if _variantType is not clean                  _variantType = null;              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);                  if (SqlDbType.SmallDateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      Debug.Assert(0 <= dt.days && dt.days <= UInt16.MaxValue' "Invalid DateTime '" + value + "' for SmallDateTime");                        _stateObj.Parser.WriteShort(dt.days' _stateObj);                      _stateObj.Parser.WriteShort(dt.time' _stateObj);                  }                  else if (SqlDbType.DateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                  else                  { // date and datetime2                      int days = value.Subtract(DateTime.MinValue).Days;                      if (SqlDbType.DateTime2 == _metaData.SqlDbType)                      {                          Int64 time = value.TimeOfDay.Ticks / TdsEnums.TICKS_FROM_SCALE[_metaData.Scale];                          _stateObj.WriteByteArray(BitConverter.GetBytes(time)' (int)_metaData.MaxLength - 3' 0);                      }                      _stateObj.WriteByteArray(BitConverter.GetBytes(days)' 3' 0);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTime,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.DateTime2))                  {                      _stateObj.Parser.WriteSqlVariantDateTime2(value' _stateObj);                  }                  else if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.Date))                  {                      _stateObj.Parser.WriteSqlVariantDate(value' _stateObj);                  }                  else                  {                      TdsDateTime dt = MetaType.FromDateTime(value' 8);                      _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLDATETIME' 0' _stateObj);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                    // Clean the variant metadata to prevent sharing it with next row.                   // As a reminder' SetVariantType raises an assert if _variantType is not clean                  _variantType = null;              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);                  if (SqlDbType.SmallDateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      Debug.Assert(0 <= dt.days && dt.days <= UInt16.MaxValue' "Invalid DateTime '" + value + "' for SmallDateTime");                        _stateObj.Parser.WriteShort(dt.days' _stateObj);                      _stateObj.Parser.WriteShort(dt.time' _stateObj);                  }                  else if (SqlDbType.DateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                  else                  { // date and datetime2                      int days = value.Subtract(DateTime.MinValue).Days;                      if (SqlDbType.DateTime2 == _metaData.SqlDbType)                      {                          Int64 time = value.TimeOfDay.Ticks / TdsEnums.TICKS_FROM_SCALE[_metaData.Scale];                          _stateObj.WriteByteArray(BitConverter.GetBytes(time)' (int)_metaData.MaxLength - 3' 0);                      }                      _stateObj.WriteByteArray(BitConverter.GetBytes(days)' 3' 0);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTime,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.DateTime2))                  {                      _stateObj.Parser.WriteSqlVariantDateTime2(value' _stateObj);                  }                  else if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.Date))                  {                      _stateObj.Parser.WriteSqlVariantDate(value' _stateObj);                  }                  else                  {                      TdsDateTime dt = MetaType.FromDateTime(value' 8);                      _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLDATETIME' 0' _stateObj);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                    // Clean the variant metadata to prevent sharing it with next row.                   // As a reminder' SetVariantType raises an assert if _variantType is not clean                  _variantType = null;              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);                  if (SqlDbType.SmallDateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      Debug.Assert(0 <= dt.days && dt.days <= UInt16.MaxValue' "Invalid DateTime '" + value + "' for SmallDateTime");                        _stateObj.Parser.WriteShort(dt.days' _stateObj);                      _stateObj.Parser.WriteShort(dt.time' _stateObj);                  }                  else if (SqlDbType.DateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                  else                  { // date and datetime2                      int days = value.Subtract(DateTime.MinValue).Days;                      if (SqlDbType.DateTime2 == _metaData.SqlDbType)                      {                          Int64 time = value.TimeOfDay.Ticks / TdsEnums.TICKS_FROM_SCALE[_metaData.Scale];                          _stateObj.WriteByteArray(BitConverter.GetBytes(time)' (int)_metaData.MaxLength - 3' 0);                      }                      _stateObj.WriteByteArray(BitConverter.GetBytes(days)' 3' 0);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTime,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.DateTime2))                  {                      _stateObj.Parser.WriteSqlVariantDateTime2(value' _stateObj);                  }                  else if ((_variantType != null) && (_variantType.SqlDbType == SqlDbType.Date))                  {                      _stateObj.Parser.WriteSqlVariantDate(value' _stateObj);                  }                  else                  {                      TdsDateTime dt = MetaType.FromDateTime(value' 8);                      _stateObj.Parser.WriteSqlVariantHeader(10' TdsEnums.SQLDATETIME' 0' _stateObj);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                    // Clean the variant metadata to prevent sharing it with next row.                   // As a reminder' SetVariantType raises an assert if _variantType is not clean                  _variantType = null;              }              else              {                  _stateObj.WriteByte((byte)_metaData.MaxLength);                  if (SqlDbType.SmallDateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      Debug.Assert(0 <= dt.days && dt.days <= UInt16.MaxValue' "Invalid DateTime '" + value + "' for SmallDateTime");                        _stateObj.Parser.WriteShort(dt.days' _stateObj);                      _stateObj.Parser.WriteShort(dt.time' _stateObj);                  }                  else if (SqlDbType.DateTime == _metaData.SqlDbType)                  {                      TdsDateTime dt = MetaType.FromDateTime(value' (byte)_metaData.MaxLength);                      _stateObj.Parser.WriteInt(dt.days' _stateObj);                      _stateObj.Parser.WriteInt(dt.time' _stateObj);                  }                  else                  { // date and datetime2                      int days = value.Subtract(DateTime.MinValue).Days;                      if (SqlDbType.DateTime2 == _metaData.SqlDbType)                      {                          Int64 time = value.TimeOfDay.Ticks / TdsEnums.TICKS_FROM_SCALE[_metaData.Scale];                          _stateObj.WriteByteArray(BitConverter.GetBytes(time)' (int)_metaData.MaxLength - 3' 0);                      }                      _stateObj.WriteByteArray(BitConverter.GetBytes(days)' 3' 0);                  }              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetGuid,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  _stateObj.Parser.WriteSqlVariantHeader(18' TdsEnums.SQLUNIQUEID' 0' _stateObj);              }              else              {                  Debug.Assert(_metaData.MaxLength == bytes.Length' "Unexpected uniqueid metadata length: " + _metaData.MaxLength);                    _stateObj.WriteByte((byte)_metaData.MaxLength);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetTimeSpan,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  scale = SmiMetaData.DefaultTime.Scale;                  length = (byte)SmiMetaData.DefaultTime.MaxLength;                  _stateObj.Parser.WriteSqlVariantHeader(8' TdsEnums.SQLTIME' 1' _stateObj);                  _stateObj.WriteByte(scale); //propbytes: scale              }              else              {                  scale = _metaData.Scale;                  length = (byte)_metaData.MaxLength;                  _stateObj.WriteByte(length);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTimeOffset,The following statement contains a magic number: if (SqlDbType.Variant == _metaData.SqlDbType)              {                  // VSTFDevDiv #885208 - DateTimeOffset throws ArgumentException for when passing DateTimeOffset value to a sql_variant TVP                   //                      using a SqlDataRecord or SqlDataReader                  MSS.SmiMetaData dateTimeOffsetMetaData = MSS.SmiMetaData.DefaultDateTimeOffset;                  scale = MetaType.MetaDateTimeOffset.Scale;                  length = (byte)dateTimeOffsetMetaData.MaxLength;                  _stateObj.Parser.WriteSqlVariantHeader(13' TdsEnums.SQLDATETIMEOFFSET' 1' _stateObj);                  _stateObj.WriteByte(scale); //propbytes: scale              }              else              {                  scale = _metaData.Scale;                  length = (byte)_metaData.MaxLength;                  _stateObj.WriteByte(length);              }
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTimeOffset,The following statement contains a magic number: _stateObj.WriteByteArray(BitConverter.GetBytes(time)' length - 5' 0);
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTimeOffset,The following statement contains a magic number: _stateObj.WriteByteArray(BitConverter.GetBytes(days)' 3' 0);
Magic Number,System.Data.SqlClient,TdsValueSetter,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsValueSetter.cs,SetDateTimeOffset,The following statement contains a magic number: _stateObj.WriteByte((byte)((offset >> 8) & 0xff));
Magic Number,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,The following statement contains a magic number: const int KeyIndex = 1' ValueIndex = 2;
Magic Number,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,The following statement contains a magic number: if (null != connectionString)              {                  Match match = parser.Match(connectionString);                  if (!match.Success || (match.Length != connectionString.Length))                  {                      throw ADP.ConnectionStringSyntax(match.Length);                  }                  int indexValue = 0;                  CaptureCollection keyvalues = match.Groups[ValueIndex].Captures;                  foreach (Capture keypair in match.Groups[KeyIndex].Captures)                  {                      string keyname = (firstKey ? keypair.Value : keypair.Value.Replace("=="' "=")).ToLower(CultureInfo.InvariantCulture);                      string keyvalue = keyvalues[indexValue++].Value;                      if (0 < keyvalue.Length)                      {                          if (!firstKey)                          {                              switch (keyvalue[0])                              {                                  case '\"':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\"\""' "\"");                                      break;                                  case '\'':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\'\'"' "\'");                                      break;                                  default:                                      break;                              }                          }                      }                      else                      {                          keyvalue = null;                      }                      DebugTraceKeyValuePair(keyname' keyvalue' synonyms);                      string synonym;                      string realkeyname = null != synonyms ?                          (synonyms.TryGetValue(keyname' out synonym) ? synonym : null) : keyname;                         if (!IsKeyNameValid(realkeyname))                      {                          throw ADP.KeywordNotSupported(keyname);                      }                      if (!firstKey || !parsetable.ContainsKey(realkeyname))                      {                          parsetable[realkeyname] = keyvalue; // last key-value pair wins (or first)                      }                  }              }
Magic Number,System.Data.Common,DbConnectionOptions,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionOptions.cs,SplitConnectionString,The following statement contains a magic number: if (null != connectionString)              {                  Match match = parser.Match(connectionString);                  if (!match.Success || (match.Length != connectionString.Length))                  {                      throw ADP.ConnectionStringSyntax(match.Length);                  }                  int indexValue = 0;                  CaptureCollection keyvalues = match.Groups[ValueIndex].Captures;                  foreach (Capture keypair in match.Groups[KeyIndex].Captures)                  {                      string keyname = (firstKey ? keypair.Value : keypair.Value.Replace("=="' "=")).ToLower(CultureInfo.InvariantCulture);                      string keyvalue = keyvalues[indexValue++].Value;                      if (0 < keyvalue.Length)                      {                          if (!firstKey)                          {                              switch (keyvalue[0])                              {                                  case '\"':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\"\""' "\"");                                      break;                                  case '\'':                                      keyvalue = keyvalue.Substring(1' keyvalue.Length - 2).Replace("\'\'"' "\'");                                      break;                                  default:                                      break;                              }                          }                      }                      else                      {                          keyvalue = null;                      }                      DebugTraceKeyValuePair(keyname' keyvalue' synonyms);                      string synonym;                      string realkeyname = null != synonyms ?                          (synonyms.TryGetValue(keyname' out synonym) ? synonym : null) : keyname;                         if (!IsKeyNameValid(realkeyname))                      {                          throw ADP.KeywordNotSupported(keyname);                      }                      if (!firstKey || !parsetable.ContainsKey(realkeyname))                      {                          parsetable[realkeyname] = keyvalue; // last key-value pair wins (or first)                      }                  }              }
Magic Number,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,TryConvertToApplicationIntent,The following statement contains a magic number: Debug.Assert(Enum.GetNames(typeof(ApplicationIntent)).Length == 2' "ApplicationIntent enum has changed' update needed");
Magic Number,System.Data.Common,DbConnectionStringBuilderUtil,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\Common\DbConnectionStringCommon.cs,IsValidApplicationIntentValue,The following statement contains a magic number: Debug.Assert(Enum.GetNames(typeof(ApplicationIntent)).Length == 2' "ApplicationIntent enum has changed' update needed");
Magic Number,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,TryGetConnection,The following statement contains a magic number: int retriesLeft = 10;
Magic Number,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,TryGetConnection,The following statement contains a magic number: do              {                  poolGroup = GetConnectionPoolGroup(owningConnection);                  // Doing this on the callers thread is important because it looks up the WindowsIdentity from the thread.                  connectionPool = GetConnectionPool(owningConnection' poolGroup);                  if (null == connectionPool)                  {                      // If GetConnectionPool returns null' we can be certain that                      // this connection should not be pooled via DbConnectionPool                      // or have a disabled pool entry.                      poolGroup = GetConnectionPoolGroup(owningConnection); // previous entry have been disabled                        if (retry != null)                      {                          Task<DbConnectionInternal> newTask;                          CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();                          lock (s_pendingOpenNonPooled)                          {                              // look for an available task slot (completed or empty)                              int idx;                              for (idx = 0; idx < s_pendingOpenNonPooled.Length; idx++)                              {                                  Task task = s_pendingOpenNonPooled[idx];                                  if (task == null)                                  {                                      s_pendingOpenNonPooled[idx] = GetCompletedTask();                                      break;                                  }                                  else if (task.IsCompleted)                                  {                                      break;                                  }                              }                                // if didn't find one' pick the next one in round-robin fashion                              if (idx == s_pendingOpenNonPooled.Length)                              {                                  idx = (int)(s_pendingOpenNonPooledNext % s_pendingOpenNonPooled.Length);                                  unchecked                                  {                                      s_pendingOpenNonPooledNext++;                                  }                              }                                // now that we have an antecedent task' schedule our work when it is completed.                              // If it is a new slot or a completed task' this continuation will start right away.                              newTask = s_pendingOpenNonPooled[idx].ContinueWith((_) =>                              {                                  Transactions.Transaction originalTransaction = ADP.GetCurrentTransaction();                                  try                                  {                                      ADP.SetCurrentTransaction(retry.Task.AsyncState as Transactions.Transaction);                                      var newConnection = CreateNonPooledConnection(owningConnection' poolGroup' userOptions);                                      if ((oldConnection != null) && (oldConnection.State == ConnectionState.Open))                                      {                                          oldConnection.PrepareForReplaceConnection();                                          oldConnection.Dispose();                                      }                                      return newConnection;                                  }                                  finally                                  {                                      ADP.SetCurrentTransaction(originalTransaction);                                  }                              }' cancellationTokenSource.Token' TaskContinuationOptions.LongRunning' TaskScheduler.Default);                                // Place this new task in the slot so any future work will be queued behind it                              s_pendingOpenNonPooled[idx] = newTask;                          }                            // Set up the timeout (if needed)                          if (owningConnection.ConnectionTimeout > 0)                          {                              int connectionTimeoutMilliseconds = owningConnection.ConnectionTimeout * 1000;                              cancellationTokenSource.CancelAfter(connectionTimeoutMilliseconds);                          }                            // once the task is done' propagate the final results to the original caller                          newTask.ContinueWith((task) =>                          {                              cancellationTokenSource.Dispose();                              if (task.IsCanceled)                              {                                  retry.TrySetException(ADP.ExceptionWithStackTrace(ADP.NonPooledOpenTimeout()));                              }                              else if (task.IsFaulted)                              {                                  retry.TrySetException(task.Exception.InnerException);                              }                              else                              {                                  if (!retry.TrySetResult(task.Result))                                  {                                      // The outer TaskCompletionSource was already completed                                      // Which means that we don't know if someone has messed with the outer connection in the middle of creation                                      // So the best thing to do now is to destroy the newly created connection                                      task.Result.DoomThisConnection();                                      task.Result.Dispose();                                  }                              }                          }' TaskScheduler.Default);                            return false;                      }                        connection = CreateNonPooledConnection(owningConnection' poolGroup' userOptions);                  }                  else                  {                      if (((SqlClient.SqlConnection)owningConnection).ForceNewConnection)                      {                          Debug.Assert(!(oldConnection is DbConnectionClosed)' "Force new connection' but there is no old connection");                          connection = connectionPool.ReplaceConnection(owningConnection' userOptions' oldConnection);                      }                      else                      {                          if (!connectionPool.TryGetConnection(owningConnection' retry' userOptions' out connection))                          {                              return false;                          }                      }                        if (connection == null)                      {                          // connection creation failed on semaphore waiting or if max pool reached                          if (connectionPool.IsRunning)                          {                              // If GetConnection failed while the pool is running' the pool timeout occurred.                              throw ADP.PooledOpenTimeout();                          }                          else                          {                              // We've hit the race condition' where the pool was shut down after we got it from the group.                              // Yield time slice to allow shut down activities to complete and a new' running pool to be instantiated                              //  before retrying.                              Threading.Thread.Sleep(timeBetweenRetriesMilliseconds);                              timeBetweenRetriesMilliseconds *= 2; // double the wait time for next iteration                          }                      }                  }              } while (connection == null && retriesLeft-- > 0);
Magic Number,System.Data.ProviderBase,DbConnectionFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionFactory.cs,TryGetConnection,The following statement contains a magic number: do              {                  poolGroup = GetConnectionPoolGroup(owningConnection);                  // Doing this on the callers thread is important because it looks up the WindowsIdentity from the thread.                  connectionPool = GetConnectionPool(owningConnection' poolGroup);                  if (null == connectionPool)                  {                      // If GetConnectionPool returns null' we can be certain that                      // this connection should not be pooled via DbConnectionPool                      // or have a disabled pool entry.                      poolGroup = GetConnectionPoolGroup(owningConnection); // previous entry have been disabled                        if (retry != null)                      {                          Task<DbConnectionInternal> newTask;                          CancellationTokenSource cancellationTokenSource = new CancellationTokenSource();                          lock (s_pendingOpenNonPooled)                          {                              // look for an available task slot (completed or empty)                              int idx;                              for (idx = 0; idx < s_pendingOpenNonPooled.Length; idx++)                              {                                  Task task = s_pendingOpenNonPooled[idx];                                  if (task == null)                                  {                                      s_pendingOpenNonPooled[idx] = GetCompletedTask();                                      break;                                  }                                  else if (task.IsCompleted)                                  {                                      break;                                  }                              }                                // if didn't find one' pick the next one in round-robin fashion                              if (idx == s_pendingOpenNonPooled.Length)                              {                                  idx = (int)(s_pendingOpenNonPooledNext % s_pendingOpenNonPooled.Length);                                  unchecked                                  {                                      s_pendingOpenNonPooledNext++;                                  }                              }                                // now that we have an antecedent task' schedule our work when it is completed.                              // If it is a new slot or a completed task' this continuation will start right away.                              newTask = s_pendingOpenNonPooled[idx].ContinueWith((_) =>                              {                                  Transactions.Transaction originalTransaction = ADP.GetCurrentTransaction();                                  try                                  {                                      ADP.SetCurrentTransaction(retry.Task.AsyncState as Transactions.Transaction);                                      var newConnection = CreateNonPooledConnection(owningConnection' poolGroup' userOptions);                                      if ((oldConnection != null) && (oldConnection.State == ConnectionState.Open))                                      {                                          oldConnection.PrepareForReplaceConnection();                                          oldConnection.Dispose();                                      }                                      return newConnection;                                  }                                  finally                                  {                                      ADP.SetCurrentTransaction(originalTransaction);                                  }                              }' cancellationTokenSource.Token' TaskContinuationOptions.LongRunning' TaskScheduler.Default);                                // Place this new task in the slot so any future work will be queued behind it                              s_pendingOpenNonPooled[idx] = newTask;                          }                            // Set up the timeout (if needed)                          if (owningConnection.ConnectionTimeout > 0)                          {                              int connectionTimeoutMilliseconds = owningConnection.ConnectionTimeout * 1000;                              cancellationTokenSource.CancelAfter(connectionTimeoutMilliseconds);                          }                            // once the task is done' propagate the final results to the original caller                          newTask.ContinueWith((task) =>                          {                              cancellationTokenSource.Dispose();                              if (task.IsCanceled)                              {                                  retry.TrySetException(ADP.ExceptionWithStackTrace(ADP.NonPooledOpenTimeout()));                              }                              else if (task.IsFaulted)                              {                                  retry.TrySetException(task.Exception.InnerException);                              }                              else                              {                                  if (!retry.TrySetResult(task.Result))                                  {                                      // The outer TaskCompletionSource was already completed                                      // Which means that we don't know if someone has messed with the outer connection in the middle of creation                                      // So the best thing to do now is to destroy the newly created connection                                      task.Result.DoomThisConnection();                                      task.Result.Dispose();                                  }                              }                          }' TaskScheduler.Default);                            return false;                      }                        connection = CreateNonPooledConnection(owningConnection' poolGroup' userOptions);                  }                  else                  {                      if (((SqlClient.SqlConnection)owningConnection).ForceNewConnection)                      {                          Debug.Assert(!(oldConnection is DbConnectionClosed)' "Force new connection' but there is no old connection");                          connection = connectionPool.ReplaceConnection(owningConnection' userOptions' oldConnection);                      }                      else                      {                          if (!connectionPool.TryGetConnection(owningConnection' retry' userOptions' out connection))                          {                              return false;                          }                      }                        if (connection == null)                      {                          // connection creation failed on semaphore waiting or if max pool reached                          if (connectionPool.IsRunning)                          {                              // If GetConnection failed while the pool is running' the pool timeout occurred.                              throw ADP.PooledOpenTimeout();                          }                          else                          {                              // We've hit the race condition' where the pool was shut down after we got it from the group.                              // Yield time slice to allow shut down activities to complete and a new' running pool to be instantiated                              //  before retrying.                              Threading.Thread.Sleep(timeBetweenRetriesMilliseconds);                              timeBetweenRetriesMilliseconds *= 2; // double the wait time for next iteration                          }                      }                  }              } while (connection == null && retriesLeft-- > 0);
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,DbConnectionPool,The following statement contains a magic number: lock (s_random)              { // Random.Next is not thread-safe                  _cleanupWait = s_random.Next(12' 24) * 10 * 1000; // 2-4 minutes in 10 sec intervals              }
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,DbConnectionPool,The following statement contains a magic number: lock (s_random)              { // Random.Next is not thread-safe                  _cleanupWait = s_random.Next(12' 24) * 10 * 1000; // 2-4 minutes in 10 sec intervals              }
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,DbConnectionPool,The following statement contains a magic number: lock (s_random)              { // Random.Next is not thread-safe                  _cleanupWait = s_random.Next(12' 24) * 10 * 1000; // 2-4 minutes in 10 sec intervals              }
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,DbConnectionPool,The following statement contains a magic number: lock (s_random)              { // Random.Next is not thread-safe                  _cleanupWait = s_random.Next(12' 24) * 10 * 1000; // 2-4 minutes in 10 sec intervals              }
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,CreateObject,The following statement contains a magic number: try              {                  newObj = _connectionFactory.CreatePooledConnection(this' owningObject' _connectionPoolGroup.ConnectionOptions' _connectionPoolGroup.PoolKey' userOptions);                  if (null == newObj)                  {                      throw ADP.InternalError(ADP.InternalErrorCode.CreateObjectReturnedNull);    // CreateObject succeeded' but null object                  }                  if (!newObj.CanBePooled)                  {                      throw ADP.InternalError(ADP.InternalErrorCode.NewObjectCannotBePooled);        // CreateObject succeeded' but non-poolable object                  }                  newObj.PrePush(null);                    lock (_objectList)                  {                      if ((oldConnection != null) && (oldConnection.Pool == this))                      {                          _objectList.Remove(oldConnection);                      }                      _objectList.Add(newObj);                      _totalObjects = _objectList.Count;                  }                    // If the old connection belonged to another pool' we need to remove it from that                  if (oldConnection != null)                  {                      var oldConnectionPool = oldConnection.Pool;                      if (oldConnectionPool != null && oldConnectionPool != this)                      {                          Debug.Assert(oldConnectionPool._state == State.ShuttingDown' "Old connections pool should be shutting down");                          lock (oldConnectionPool._objectList)                          {                              oldConnectionPool._objectList.Remove(oldConnection);                              oldConnectionPool._totalObjects = oldConnectionPool._objectList.Count;                          }                      }                  }                    // Reset the error wait:                  _errorWait = ERROR_WAIT_DEFAULT;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                  newObj = null; // set to null' so we do not return bad new object                  // Failed to create instance                  _resError = e;                    // Make sure the timer starts even if ThreadAbort occurs after setting the ErrorEvent.                    // timer allocation has to be done out of CER block                  Timer t = new Timer(new TimerCallback(this.ErrorCallback)' null' Timeout.Infinite' Timeout.Infinite);                  bool timerIsNotDisposed;                  try { }                  finally                  {                      _waitHandles.ErrorEvent.Set();                      _errorOccurred = true;                        // Enable the timer.                      // Note that the timer is created to allow periodic invocation. If ThreadAbort occurs in the middle of ErrorCallback'                      // the timer will restart. Otherwise' the timer callback (ErrorCallback) destroys the timer after resetting the error to avoid second callback.                      _errorTimer = t;                      timerIsNotDisposed = t.Change(_errorWait' _errorWait);                  }                    Debug.Assert(timerIsNotDisposed' "ErrorCallback timer has been disposed");                    if (30000 < _errorWait)                  {                      _errorWait = 60000;                  }                  else                  {                      _errorWait *= 2;                  }                  throw;              }
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,CreateObject,The following statement contains a magic number: try              {                  newObj = _connectionFactory.CreatePooledConnection(this' owningObject' _connectionPoolGroup.ConnectionOptions' _connectionPoolGroup.PoolKey' userOptions);                  if (null == newObj)                  {                      throw ADP.InternalError(ADP.InternalErrorCode.CreateObjectReturnedNull);    // CreateObject succeeded' but null object                  }                  if (!newObj.CanBePooled)                  {                      throw ADP.InternalError(ADP.InternalErrorCode.NewObjectCannotBePooled);        // CreateObject succeeded' but non-poolable object                  }                  newObj.PrePush(null);                    lock (_objectList)                  {                      if ((oldConnection != null) && (oldConnection.Pool == this))                      {                          _objectList.Remove(oldConnection);                      }                      _objectList.Add(newObj);                      _totalObjects = _objectList.Count;                  }                    // If the old connection belonged to another pool' we need to remove it from that                  if (oldConnection != null)                  {                      var oldConnectionPool = oldConnection.Pool;                      if (oldConnectionPool != null && oldConnectionPool != this)                      {                          Debug.Assert(oldConnectionPool._state == State.ShuttingDown' "Old connections pool should be shutting down");                          lock (oldConnectionPool._objectList)                          {                              oldConnectionPool._objectList.Remove(oldConnection);                              oldConnectionPool._totalObjects = oldConnectionPool._objectList.Count;                          }                      }                  }                    // Reset the error wait:                  _errorWait = ERROR_WAIT_DEFAULT;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                  newObj = null; // set to null' so we do not return bad new object                  // Failed to create instance                  _resError = e;                    // Make sure the timer starts even if ThreadAbort occurs after setting the ErrorEvent.                    // timer allocation has to be done out of CER block                  Timer t = new Timer(new TimerCallback(this.ErrorCallback)' null' Timeout.Infinite' Timeout.Infinite);                  bool timerIsNotDisposed;                  try { }                  finally                  {                      _waitHandles.ErrorEvent.Set();                      _errorOccurred = true;                        // Enable the timer.                      // Note that the timer is created to allow periodic invocation. If ThreadAbort occurs in the middle of ErrorCallback'                      // the timer will restart. Otherwise' the timer callback (ErrorCallback) destroys the timer after resetting the error to avoid second callback.                      _errorTimer = t;                      timerIsNotDisposed = t.Change(_errorWait' _errorWait);                  }                    Debug.Assert(timerIsNotDisposed' "ErrorCallback timer has been disposed");                    if (30000 < _errorWait)                  {                      _errorWait = 60000;                  }                  else                  {                      _errorWait *= 2;                  }                  throw;              }
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,CreateObject,The following statement contains a magic number: try              {                  newObj = _connectionFactory.CreatePooledConnection(this' owningObject' _connectionPoolGroup.ConnectionOptions' _connectionPoolGroup.PoolKey' userOptions);                  if (null == newObj)                  {                      throw ADP.InternalError(ADP.InternalErrorCode.CreateObjectReturnedNull);    // CreateObject succeeded' but null object                  }                  if (!newObj.CanBePooled)                  {                      throw ADP.InternalError(ADP.InternalErrorCode.NewObjectCannotBePooled);        // CreateObject succeeded' but non-poolable object                  }                  newObj.PrePush(null);                    lock (_objectList)                  {                      if ((oldConnection != null) && (oldConnection.Pool == this))                      {                          _objectList.Remove(oldConnection);                      }                      _objectList.Add(newObj);                      _totalObjects = _objectList.Count;                  }                    // If the old connection belonged to another pool' we need to remove it from that                  if (oldConnection != null)                  {                      var oldConnectionPool = oldConnection.Pool;                      if (oldConnectionPool != null && oldConnectionPool != this)                      {                          Debug.Assert(oldConnectionPool._state == State.ShuttingDown' "Old connections pool should be shutting down");                          lock (oldConnectionPool._objectList)                          {                              oldConnectionPool._objectList.Remove(oldConnection);                              oldConnectionPool._totalObjects = oldConnectionPool._objectList.Count;                          }                      }                  }                    // Reset the error wait:                  _errorWait = ERROR_WAIT_DEFAULT;              }              catch (Exception e)              {                  if (!ADP.IsCatchableExceptionType(e))                  {                      throw;                  }                  newObj = null; // set to null' so we do not return bad new object                  // Failed to create instance                  _resError = e;                    // Make sure the timer starts even if ThreadAbort occurs after setting the ErrorEvent.                    // timer allocation has to be done out of CER block                  Timer t = new Timer(new TimerCallback(this.ErrorCallback)' null' Timeout.Infinite' Timeout.Infinite);                  bool timerIsNotDisposed;                  try { }                  finally                  {                      _waitHandles.ErrorEvent.Set();                      _errorOccurred = true;                        // Enable the timer.                      // Note that the timer is created to allow periodic invocation. If ThreadAbort occurs in the middle of ErrorCallback'                      // the timer will restart. Otherwise' the timer callback (ErrorCallback) destroys the timer after resetting the error to avoid second callback.                      _errorTimer = t;                      timerIsNotDisposed = t.Change(_errorWait' _errorWait);                  }                    Debug.Assert(timerIsNotDisposed' "ErrorCallback timer has been disposed");                    if (30000 < _errorWait)                  {                      _errorWait = 60000;                  }                  else                  {                      _errorWait *= 2;                  }                  throw;              }
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,TryGetConnection,The following statement contains a magic number: var pendingGetConnection =                  new PendingGetConnection(                      CreationTimeout == 0 ? Timeout.Infinite : ADP.TimerCurrent() + ADP.TimerFromSeconds(CreationTimeout / 1000)'                      owningObject'                      retry'                      userOptions);
Magic Number,System.Data.ProviderBase,DbConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,TryGetConnection,The following statement contains a magic number: if (null == obj)              {                  Interlocked.Increment(ref _waitCount);                    do                  {                      int waitResult = BOGUS_HANDLE;                      try                      {                          try                          {                          }                          finally                          {                              waitResult = WaitHandle.WaitAny(_waitHandles.GetHandles(allowCreate)' unchecked((int)waitForMultipleObjectsTimeout));                          }                            // From the WaitAny docs: "If more than one object became signaled during                          // the call' this is the array index of the signaled object with the                          // smallest index value of all the signaled objects."  This is important                          // so that the free object signal will be returned before a creation                          // signal.                            switch (waitResult)                          {                              case WaitHandle.WaitTimeout:                                  Interlocked.Decrement(ref _waitCount);                                  connection = null;                                  return false;                                case ERROR_HANDLE:                                  // Throw the error that PoolCreateRequest stashed.                                  Interlocked.Decrement(ref _waitCount);                                  throw TryCloneCachedException();                                case CREATION_HANDLE:                                  try                                  {                                      obj = UserCreateRequest(owningObject' userOptions);                                  }                                  catch                                  {                                      if (null == obj)                                      {                                          Interlocked.Decrement(ref _waitCount);                                      }                                      throw;                                  }                                  finally                                  {                                      // Ensure that we release this waiter' regardless                                      // of any exceptions that may be thrown.                                      if (null != obj)                                      {                                          Interlocked.Decrement(ref _waitCount);                                      }                                  }                                    if (null == obj)                                  {                                      // If we were not able to create an object' check to see if                                      // we reached MaxPoolSize.  If so' we will no longer wait on                                      // the CreationHandle' but instead wait for a free object or                                      // the timeout.                                      if (Count >= MaxPoolSize && 0 != MaxPoolSize)                                      {                                          if (!ReclaimEmancipatedObjects())                                          {                                              // modify handle array not to wait on creation mutex anymore                                              Debug.Assert(2 == CREATION_HANDLE' "creation handle changed value");                                              allowCreate = false;                                          }                                      }                                  }                                  break;                                case SEMAPHORE_HANDLE:                                  //                                  //    guaranteed available inventory                                  //                                  Interlocked.Decrement(ref _waitCount);                                  obj = GetFromGeneralPool();                                    if ((obj != null) && (!obj.IsConnectionAlive()))                                  {                                      DestroyObject(obj);                                      obj = null;     // Setting to null in case creating a new object fails                                        if (onlyOneCheckConnection)                                      {                                          if (_waitHandles.CreationSemaphore.WaitOne(unchecked((int)waitForMultipleObjectsTimeout)))                                          {                                              try                                              {                                                  obj = UserCreateRequest(owningObject' userOptions);                                              }                                              finally                                              {                                                  _waitHandles.CreationSemaphore.Release(1);                                              }                                          }                                          else                                          {                                              // Timeout waiting for creation semaphore - return null                                              connection = null;                                              return false;                                          }                                      }                                  }                                  break;                              default:                                  Interlocked.Decrement(ref _waitCount);                                  throw ADP.InternalError(ADP.InternalErrorCode.UnexpectedWaitAnyResult);                          }                      }                      finally                      {                          if (CREATION_HANDLE == waitResult)                          {                              _waitHandles.CreationSemaphore.Release(1);                          }                      }                  } while (null == obj);              }
Magic Number,System.Data.ProviderBase,TransactedConnectionPool,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbConnectionPool.cs,PutTransactedObject,The following statement contains a magic number: if (!txnFound)                  {                      // create the transacted pool' making sure to clone the associated transaction                      //   for use as a key in our internal dictionary of transactions and connections                      Transaction transactionClone = null;                      TransactedConnectionList newConnections = null;                        try                      {                          transactionClone = transaction.Clone();                          newConnections = new TransactedConnectionList(2' transactionClone); // start with only two connections in the list; most times we won't need that many.                            lock (_transactedCxns)                          {                              // NOTE: in the interim between the locks on the transacted pool (this) during                               //   execution of this method' another thread (threadB) may have attempted to                               //   add a different connection to the transacted pool under the same                               //   transaction. As a result' threadB may have completed creating the                              //   transacted pool while threadA was processing the above instructions.                              if (txnFound = _transactedCxns.TryGetValue(transaction' out connections))                              {                                  Debug.Assert(connections != null);                                    // synchronize multi-threaded access with GetTransactedObject                                  lock (connections)                                  {                                      Debug.Assert(0 > connections.IndexOf(transactedObject)' "adding to pool a second time?");                                      connections.Add(transactedObject);                                  }                              }                              else                              {                                  // add the connection/transacted object to the list                                  newConnections.Add(transactedObject);                                    _transactedCxns.Add(transactionClone' newConnections);                                  transactionClone = null; // we've used it -- don't throw it or the TransactedConnectionList that references it away.                                                              }                          }                      }                      finally                      {                          if (null != transactionClone)                          {                              if (newConnections != null)                              {                                  // another thread created the transaction pool and thus the new                                   //   TransactedConnectionList was not used' so dispose of it and                                  //   the transaction clone that it incorporates.                                  newConnections.Dispose();                              }                              else                              {                                  // memory allocation for newConnections failed...clean up unused transactionClone                                  transactionClone.Dispose();                              }                          }                      }                  }
Magic Number,System.Data.ProviderBase,DbMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbMetaDataFactory.cs,ExecuteCommand,The following statement contains a magic number: command.CommandTimeout = Math.Max(command.CommandTimeout' 180);
Magic Number,System.Data.ProviderBase,DbMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbMetaDataFactory.cs,GetSchema,The following statement contains a magic number: if (ADP.IsEmptyArray(restrictions) == false)              {                    for (int i = 0; i < restrictions.Length; i++)                  {                      if ((restrictions[i] != null) && (restrictions[i].Length > 4096))                      {                          // use a non-specific error because no new beta 2 error messages are allowed                          // TODO: will add a more descriptive error in RTM                          throw ADP.NotSupported();                      }                  }              }
Magic Number,System.Data.ProviderBase,DbMetaDataFactory,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbMetaDataFactory.cs,GetSchema,The following statement contains a magic number: switch (populationMechanism)              {                    case _dataTable:                      if (exactCollectionName == DbMetaDataCollectionNames.MetaDataCollections)                      {                          hiddenColumns = new string[2];                          hiddenColumns[0] = _populationMechanism;                          hiddenColumns[1] = _populationString;                      }                      else                      {                          hiddenColumns = null;                      }                      // none of the datatable collections support restrictions                      if (ADP.IsEmptyArray(restrictions) == false)                      {                          throw ADP.TooManyRestrictions(exactCollectionName);                      }                          requestedSchema = CloneAndFilterCollection(exactCollectionName' hiddenColumns);                        // TODO: Consider an alternate method that doesn't involve special casing -- perhaps _prepareCollection                        // for the data source infomation table we need to fix up the version columns at run time                      // since the version is determined at run time                      if (exactCollectionName == DbMetaDataCollectionNames.DataSourceInformation)                      {                          FixUpVersion(requestedSchema);                      }                      break;                    case _sqlCommand:                      requestedSchema = ExecuteCommand(requestedCollectionRow' restrictions' connection);                      break;                    case _prepareCollection:                      requestedSchema = PrepareCollection(exactCollectionName' restrictions' connection);                      break;                    default:                      throw ADP.UndefinedPopulationMechanism(populationMechanism);              }
Magic Number,System.Data.ProviderBase,DbReferenceCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbReferenceCollection.cs,AddItem,The following statement contains a magic number: lock (_itemLock)              {                  // Try to find a free spot                  for (int i = 0; i <= _lastItemIndex; ++i)                  {                      if (_items[i].Tag == 0)                      {                          _items[i].NewTarget(tag' value);                          Debug.Assert(_items[i].HasTarget' "missing expected target");                          itemAdded = true;                          break;                      }                  }                    // No free spots' can we just add on to the end?                  if ((!itemAdded) && (_lastItemIndex + 1 < _items.Length))                  {                      _lastItemIndex++;                      _items[_lastItemIndex].NewTarget(tag' value);                      itemAdded = true;                  }                    // If no free spots and no space at the end' try to find a dead item                  if (!itemAdded)                  {                      for (int i = 0; i <= _lastItemIndex; ++i)                      {                          if (!_items[i].HasTarget)                          {                              _items[i].NewTarget(tag' value);                              Debug.Assert(_items[i].HasTarget' "missing expected target");                              itemAdded = true;                              break;                          }                      }                  }                    // If nothing was free' then resize and add to the end                  if (!itemAdded)                  {                      Array.Resize<CollectionEntry>(ref _items' _items.Length * 2);                      _lastItemIndex++;                      _items[_lastItemIndex].NewTarget(tag' value);                  }                    _optimisticCount++;              }
Magic Number,System.Data.ProviderBase,DbReferenceCollection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\ProviderBase\DbReferenceCollection.cs,Notify,The following statement contains a magic number: try              {                  TryEnterItemLock(ref lockObtained);                  if (lockObtained)                  {                      try                      {                          _isNotifying = true;                            // Loop through each live item and notify it                          if (_optimisticCount > 0)                          {                              for (int index = 0; index <= _lastItemIndex; ++index)                              {                                  object value = _items[index].Target; // checks tag & gets target                                  if (null != value)                                  {                                      NotifyItem(message' _items[index].Tag' value);                                      _items[index].RemoveTarget();                                  }                                  Debug.Assert(!_items[index].HasTarget' "Unexpected target after notifying");                              }                              _optimisticCount = 0;                          }                            // Shrink collection (if needed)                          if (_items.Length > 100)                          {                              _lastItemIndex = 0;                              _items = new CollectionEntry[DefaultCollectionSize];                          }                      }                      finally                      {                          _isNotifying = false;                      }                  }              }              finally              {                  ExitItemLockIfNeeded(lockObtained);              }
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: const double SQLTicksPerMillisecond = 0.3;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: const int SQLTicksPerSecond = 300;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: const int SQLTicksPerMinute = SQLTicksPerSecond * 60;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: const int SQLTicksPerHour = SQLTicksPerMinute * 60;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: const int SQLTicksPerDay = SQLTicksPerHour * 24;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: const int MinDay = -53690;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: const int MaxDay = 2958463;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: long baseDateTicks = new DateTime(1900' 1' 1).Ticks;
Magic Number,System.Data.SqlTypes,SqlTypeWorkarounds,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlTypes\SqlTypeWorkarounds.cs,SqlDateTimeToDateTime,The following statement contains a magic number: long timeticks = ((long)(timepart / SQLTicksPerMillisecond + 0.5)) * TimeSpan.TicksPerMillisecond;
Magic Number,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,HandleReceiveComplete,The following statement contains a magic number: while (true)              {                  lock (this)                  {                      if (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                      {                          currentHeader = null;                          currentPacket = null;                          currentSession = null;                            while (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                          {                              int bytesTaken = packet.TakeData(_headerBytes' _currentHeaderByteCount' SNISMUXHeader.HEADER_LENGTH - _currentHeaderByteCount);                              _currentHeaderByteCount += bytesTaken;                                if (bytesTaken == 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                            _currentHeader = new SNISMUXHeader()                          {                              SMID = _headerBytes[0]'                              flags = _headerBytes[1]'                              sessionId = BitConverter.ToUInt16(_headerBytes' 2)'                              length = BitConverter.ToUInt32(_headerBytes' 4) - SNISMUXHeader.HEADER_LENGTH'                              sequenceNumber = BitConverter.ToUInt32(_headerBytes' 8)'                              highwater = BitConverter.ToUInt32(_headerBytes' 12)                          };                            _dataBytesLeft = (int)_currentHeader.length;                          _currentPacket = new SNIPacket(null);                          _currentPacket.Allocate((int)_currentHeader.length);                      }                        currentHeader = _currentHeader;                      currentPacket = _currentPacket;                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                      {                          if (_dataBytesLeft > 0)                          {                              int length = packet.TakeData(_currentPacket' _dataBytesLeft);                              _dataBytesLeft -= length;                                if (_dataBytesLeft > 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                      }                        _currentHeaderByteCount = 0;                        if (!_sessions.ContainsKey(_currentHeader.sessionId))                      {                          SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.SMUX_PROV' 0' SNICommon.InvalidParameterError' string.Empty);                          HandleReceiveError(packet);                          _lowerHandle.Dispose();                          _lowerHandle = null;                          return;                      }                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_FIN)                      {                          _sessions.Remove(_currentHeader.sessionId);                      }                      else                      {                          currentSession = _sessions[_currentHeader.sessionId];                      }                  }                    if (currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                  {                      currentSession.HandleReceiveComplete(currentPacket' currentHeader);                  }                    if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_ACK)                  {                      try                      {                          currentSession.HandleAck(currentHeader.highwater);                      }                      catch (Exception e)                      {                          SNICommon.ReportSNIError(SNIProviders.SMUX_PROV' SNICommon.InternalExceptionError' e);                      }                  }                    lock (this)                  {                      if (packet.DataLeft == 0)                      {                          sniErrorCode = ReceiveAsync(ref packet);                            if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                          {                              return;                          }                            HandleReceiveError(packet);                          return;                      }                  }              }
Magic Number,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,HandleReceiveComplete,The following statement contains a magic number: while (true)              {                  lock (this)                  {                      if (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                      {                          currentHeader = null;                          currentPacket = null;                          currentSession = null;                            while (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                          {                              int bytesTaken = packet.TakeData(_headerBytes' _currentHeaderByteCount' SNISMUXHeader.HEADER_LENGTH - _currentHeaderByteCount);                              _currentHeaderByteCount += bytesTaken;                                if (bytesTaken == 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                            _currentHeader = new SNISMUXHeader()                          {                              SMID = _headerBytes[0]'                              flags = _headerBytes[1]'                              sessionId = BitConverter.ToUInt16(_headerBytes' 2)'                              length = BitConverter.ToUInt32(_headerBytes' 4) - SNISMUXHeader.HEADER_LENGTH'                              sequenceNumber = BitConverter.ToUInt32(_headerBytes' 8)'                              highwater = BitConverter.ToUInt32(_headerBytes' 12)                          };                            _dataBytesLeft = (int)_currentHeader.length;                          _currentPacket = new SNIPacket(null);                          _currentPacket.Allocate((int)_currentHeader.length);                      }                        currentHeader = _currentHeader;                      currentPacket = _currentPacket;                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                      {                          if (_dataBytesLeft > 0)                          {                              int length = packet.TakeData(_currentPacket' _dataBytesLeft);                              _dataBytesLeft -= length;                                if (_dataBytesLeft > 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                      }                        _currentHeaderByteCount = 0;                        if (!_sessions.ContainsKey(_currentHeader.sessionId))                      {                          SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.SMUX_PROV' 0' SNICommon.InvalidParameterError' string.Empty);                          HandleReceiveError(packet);                          _lowerHandle.Dispose();                          _lowerHandle = null;                          return;                      }                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_FIN)                      {                          _sessions.Remove(_currentHeader.sessionId);                      }                      else                      {                          currentSession = _sessions[_currentHeader.sessionId];                      }                  }                    if (currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                  {                      currentSession.HandleReceiveComplete(currentPacket' currentHeader);                  }                    if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_ACK)                  {                      try                      {                          currentSession.HandleAck(currentHeader.highwater);                      }                      catch (Exception e)                      {                          SNICommon.ReportSNIError(SNIProviders.SMUX_PROV' SNICommon.InternalExceptionError' e);                      }                  }                    lock (this)                  {                      if (packet.DataLeft == 0)                      {                          sniErrorCode = ReceiveAsync(ref packet);                            if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                          {                              return;                          }                            HandleReceiveError(packet);                          return;                      }                  }              }
Magic Number,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,HandleReceiveComplete,The following statement contains a magic number: while (true)              {                  lock (this)                  {                      if (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                      {                          currentHeader = null;                          currentPacket = null;                          currentSession = null;                            while (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                          {                              int bytesTaken = packet.TakeData(_headerBytes' _currentHeaderByteCount' SNISMUXHeader.HEADER_LENGTH - _currentHeaderByteCount);                              _currentHeaderByteCount += bytesTaken;                                if (bytesTaken == 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                            _currentHeader = new SNISMUXHeader()                          {                              SMID = _headerBytes[0]'                              flags = _headerBytes[1]'                              sessionId = BitConverter.ToUInt16(_headerBytes' 2)'                              length = BitConverter.ToUInt32(_headerBytes' 4) - SNISMUXHeader.HEADER_LENGTH'                              sequenceNumber = BitConverter.ToUInt32(_headerBytes' 8)'                              highwater = BitConverter.ToUInt32(_headerBytes' 12)                          };                            _dataBytesLeft = (int)_currentHeader.length;                          _currentPacket = new SNIPacket(null);                          _currentPacket.Allocate((int)_currentHeader.length);                      }                        currentHeader = _currentHeader;                      currentPacket = _currentPacket;                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                      {                          if (_dataBytesLeft > 0)                          {                              int length = packet.TakeData(_currentPacket' _dataBytesLeft);                              _dataBytesLeft -= length;                                if (_dataBytesLeft > 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                      }                        _currentHeaderByteCount = 0;                        if (!_sessions.ContainsKey(_currentHeader.sessionId))                      {                          SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.SMUX_PROV' 0' SNICommon.InvalidParameterError' string.Empty);                          HandleReceiveError(packet);                          _lowerHandle.Dispose();                          _lowerHandle = null;                          return;                      }                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_FIN)                      {                          _sessions.Remove(_currentHeader.sessionId);                      }                      else                      {                          currentSession = _sessions[_currentHeader.sessionId];                      }                  }                    if (currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                  {                      currentSession.HandleReceiveComplete(currentPacket' currentHeader);                  }                    if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_ACK)                  {                      try                      {                          currentSession.HandleAck(currentHeader.highwater);                      }                      catch (Exception e)                      {                          SNICommon.ReportSNIError(SNIProviders.SMUX_PROV' SNICommon.InternalExceptionError' e);                      }                  }                    lock (this)                  {                      if (packet.DataLeft == 0)                      {                          sniErrorCode = ReceiveAsync(ref packet);                            if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                          {                              return;                          }                            HandleReceiveError(packet);                          return;                      }                  }              }
Magic Number,System.Data.SqlClient.SNI,SNIMarsConnection,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsConnection.cs,HandleReceiveComplete,The following statement contains a magic number: while (true)              {                  lock (this)                  {                      if (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                      {                          currentHeader = null;                          currentPacket = null;                          currentSession = null;                            while (_currentHeaderByteCount != SNISMUXHeader.HEADER_LENGTH)                          {                              int bytesTaken = packet.TakeData(_headerBytes' _currentHeaderByteCount' SNISMUXHeader.HEADER_LENGTH - _currentHeaderByteCount);                              _currentHeaderByteCount += bytesTaken;                                if (bytesTaken == 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                            _currentHeader = new SNISMUXHeader()                          {                              SMID = _headerBytes[0]'                              flags = _headerBytes[1]'                              sessionId = BitConverter.ToUInt16(_headerBytes' 2)'                              length = BitConverter.ToUInt32(_headerBytes' 4) - SNISMUXHeader.HEADER_LENGTH'                              sequenceNumber = BitConverter.ToUInt32(_headerBytes' 8)'                              highwater = BitConverter.ToUInt32(_headerBytes' 12)                          };                            _dataBytesLeft = (int)_currentHeader.length;                          _currentPacket = new SNIPacket(null);                          _currentPacket.Allocate((int)_currentHeader.length);                      }                        currentHeader = _currentHeader;                      currentPacket = _currentPacket;                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                      {                          if (_dataBytesLeft > 0)                          {                              int length = packet.TakeData(_currentPacket' _dataBytesLeft);                              _dataBytesLeft -= length;                                if (_dataBytesLeft > 0)                              {                                  sniErrorCode = ReceiveAsync(ref packet);                                    if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                                  {                                      return;                                  }                                    HandleReceiveError(packet);                                  return;                              }                          }                      }                        _currentHeaderByteCount = 0;                        if (!_sessions.ContainsKey(_currentHeader.sessionId))                      {                          SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.SMUX_PROV' 0' SNICommon.InvalidParameterError' string.Empty);                          HandleReceiveError(packet);                          _lowerHandle.Dispose();                          _lowerHandle = null;                          return;                      }                        if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_FIN)                      {                          _sessions.Remove(_currentHeader.sessionId);                      }                      else                      {                          currentSession = _sessions[_currentHeader.sessionId];                      }                  }                    if (currentHeader.flags == (byte)SNISMUXFlags.SMUX_DATA)                  {                      currentSession.HandleReceiveComplete(currentPacket' currentHeader);                  }                    if (_currentHeader.flags == (byte)SNISMUXFlags.SMUX_ACK)                  {                      try                      {                          currentSession.HandleAck(currentHeader.highwater);                      }                      catch (Exception e)                      {                          SNICommon.ReportSNIError(SNIProviders.SMUX_PROV' SNICommon.InternalExceptionError' e);                      }                  }                    lock (this)                  {                      if (packet.DataLeft == 0)                      {                          sniErrorCode = ReceiveAsync(ref packet);                            if (sniErrorCode == TdsEnums.SNI_SUCCESS_IO_PENDING)                          {                              return;                          }                            HandleReceiveError(packet);                          return;                      }                  }              }
Magic Number,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXHeaderBytes,The following statement contains a magic number: _currentHeader.SMID = 83;
Magic Number,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXHeaderBytes,The following statement contains a magic number: BitConverter.GetBytes(_currentHeader.sessionId).CopyTo(headerBytes' 2);
Magic Number,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXHeaderBytes,The following statement contains a magic number: BitConverter.GetBytes(_currentHeader.length).CopyTo(headerBytes' 4);
Magic Number,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXHeaderBytes,The following statement contains a magic number: BitConverter.GetBytes(_currentHeader.sequenceNumber).CopyTo(headerBytes' 8);
Magic Number,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXHeaderBytes,The following statement contains a magic number: BitConverter.GetBytes(_currentHeader.highwater).CopyTo(headerBytes' 12);
Magic Number,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXEncapsulatedPacket,The following statement contains a magic number: smuxPacket.Allocate(16 + packet.Length);
Magic Number,System.Data.SqlClient.SNI,SNIMarsHandle,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIMarsHandle.cs,GetSMUXEncapsulatedPacket,The following statement contains a magic number: smuxPacket.AppendData(headerBytes' 16);
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,GetLocalDBInstance,The following statement contains a magic number: if (tokensByBackSlash.Length == 2 && LocalDbHost.Equals(tokensByBackSlash[0].TrimStart()))              {                  if (!string.IsNullOrWhiteSpace(tokensByBackSlash[1]))                  {                      instanceName = tokensByBackSlash[1].Trim();                  }                  else                  {                      SNILoadHandle.SingletonInstance.LastError = new SNIError(SNIProviders.INVALID_PROV' 0' SNICommon.LocalDBNoInstanceName' string.Empty);                      error = true;                      return null;                  }              }
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferConnectionDetails,The following statement contains a magic number: if (commaIndex > -1)              {                  string parameter = backSlashIndex > -1                          ? ((commaIndex > backSlashIndex) ? tokensByCommaAndSlash[2].Trim() : tokensByCommaAndSlash[1].Trim())                          : tokensByCommaAndSlash[1].Trim();                    // Bad Data Source like "server' "                  if (string.IsNullOrEmpty(parameter))                  {                      ReportSNIError(SNIProviders.INVALID_PROV);                      return false;                  }                    // For Tcp and Only Tcp are parameters allowed.                  if (ConnectionProtocol == DataSource.Protocol.None)                  {                      ConnectionProtocol = DataSource.Protocol.TCP;                  }                  else if (ConnectionProtocol != DataSource.Protocol.TCP)                  {                      // Parameter has been specified for non-TCP protocol. This is not allowed.                      ReportSNIError(SNIProviders.INVALID_PROV);                      return false;                  }                    int port;                  if (!int.TryParse(parameter' out port))                  {                      ReportSNIError(SNIProviders.TCP_PROV);                      return false;                  }                    // If the user explicitly specified a invalid port in the connection string.                  if (port < 1)                  {                      ReportSNIError(SNIProviders.TCP_PROV);                      return false;                  }                    Port = port;              }              // Instance Name Handling. Only if we found a '\' and we did not find a port in the Data Source              else if (backSlashIndex > -1)              {                  // This means that there will not be any part separated by comma.                   InstanceName = tokensByCommaAndSlash[1].Trim();                    if (string.IsNullOrWhiteSpace(InstanceName))                  {                      ReportSNIError(SNIProviders.INVALID_PROV);                      return false;                  }                    if (DefaultSqlServerInstanceName.Equals(InstanceName))                  {                      ReportSNIError(SNIProviders.INVALID_PROV);                      return false;                  }                    IsSsrpRequired = true;              }
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferNamedPipesInformation,The following statement contains a magic number: if (_dataSourceAfterTrimmingProtocol.StartsWith(PipeBeginning) || ConnectionProtocol == Protocol.NP)              {                  // If the data source is "np:servername"                  if (!_dataSourceAfterTrimmingProtocol.Contains(BackSlashSeparator))                  {                      PipeHostName = ServerName = _dataSourceAfterTrimmingProtocol;                      InferLocalServerName();                      PipeName = SNINpHandle.DefaultPipePath;                      return true;                  }                    try                  {                      string[] tokensByBackSlash = _dataSourceAfterTrimmingProtocol.Split(BackSlashSeparator);                        // The datasource is of the format \\host\pipe\sql\query [0]\[1]\[2]\[3]\[4]\[5]                      // It would at least have 6 parts.                       // Another valid Sql named pipe for an named instance is \\.\pipe\MSSQL$MYINSTANCE\sql\query                      if (tokensByBackSlash.Length < 6)                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        string host = tokensByBackSlash[2];                        if (string.IsNullOrEmpty(host))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        //Check if the "pipe" keyword is the first part of path                      if (!PipeToken.Equals(tokensByBackSlash[3]))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        if (tokensByBackSlash[4].StartsWith(NamedPipeInstanceNameHeader))                      {                          InstanceName = tokensByBackSlash[4].Substring(NamedPipeInstanceNameHeader.Length);                      }                        StringBuilder pipeNameBuilder = new StringBuilder();                        for (int i = 4; i < tokensByBackSlash.Length - 1; i++)                      {                          pipeNameBuilder.Append(tokensByBackSlash[i]);                          pipeNameBuilder.Append(Path.DirectorySeparatorChar);                      }                      // Append the last part without a "/"                      pipeNameBuilder.Append(tokensByBackSlash[tokensByBackSlash.Length - 1]);                      PipeName = pipeNameBuilder.ToString();                        if (string.IsNullOrWhiteSpace(InstanceName) && !DefaultPipeName.Equals(PipeName))                      {                          InstanceName = PipeToken + PipeName;                      }                        ServerName = IsLocalHost(host) ? Environment.MachineName : host;                      // Pipe hostname is the hostname after leading \\ which should be passed down as is to open Named Pipe.                      // For Named Pipes the ServerName makes sense for SPN creation only.                      PipeHostName = host;                  }                  catch (UriFormatException)                  {                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                    // DataSource is something like "\\pipename"                  if (ConnectionProtocol == DataSource.Protocol.None)                  {                      ConnectionProtocol = DataSource.Protocol.NP;                  }                  else if (ConnectionProtocol != DataSource.Protocol.NP)                  {                      // In case the path began with a "\\" and protocol was not Named Pipes                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                  return true;              }
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferNamedPipesInformation,The following statement contains a magic number: if (_dataSourceAfterTrimmingProtocol.StartsWith(PipeBeginning) || ConnectionProtocol == Protocol.NP)              {                  // If the data source is "np:servername"                  if (!_dataSourceAfterTrimmingProtocol.Contains(BackSlashSeparator))                  {                      PipeHostName = ServerName = _dataSourceAfterTrimmingProtocol;                      InferLocalServerName();                      PipeName = SNINpHandle.DefaultPipePath;                      return true;                  }                    try                  {                      string[] tokensByBackSlash = _dataSourceAfterTrimmingProtocol.Split(BackSlashSeparator);                        // The datasource is of the format \\host\pipe\sql\query [0]\[1]\[2]\[3]\[4]\[5]                      // It would at least have 6 parts.                       // Another valid Sql named pipe for an named instance is \\.\pipe\MSSQL$MYINSTANCE\sql\query                      if (tokensByBackSlash.Length < 6)                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        string host = tokensByBackSlash[2];                        if (string.IsNullOrEmpty(host))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        //Check if the "pipe" keyword is the first part of path                      if (!PipeToken.Equals(tokensByBackSlash[3]))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        if (tokensByBackSlash[4].StartsWith(NamedPipeInstanceNameHeader))                      {                          InstanceName = tokensByBackSlash[4].Substring(NamedPipeInstanceNameHeader.Length);                      }                        StringBuilder pipeNameBuilder = new StringBuilder();                        for (int i = 4; i < tokensByBackSlash.Length - 1; i++)                      {                          pipeNameBuilder.Append(tokensByBackSlash[i]);                          pipeNameBuilder.Append(Path.DirectorySeparatorChar);                      }                      // Append the last part without a "/"                      pipeNameBuilder.Append(tokensByBackSlash[tokensByBackSlash.Length - 1]);                      PipeName = pipeNameBuilder.ToString();                        if (string.IsNullOrWhiteSpace(InstanceName) && !DefaultPipeName.Equals(PipeName))                      {                          InstanceName = PipeToken + PipeName;                      }                        ServerName = IsLocalHost(host) ? Environment.MachineName : host;                      // Pipe hostname is the hostname after leading \\ which should be passed down as is to open Named Pipe.                      // For Named Pipes the ServerName makes sense for SPN creation only.                      PipeHostName = host;                  }                  catch (UriFormatException)                  {                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                    // DataSource is something like "\\pipename"                  if (ConnectionProtocol == DataSource.Protocol.None)                  {                      ConnectionProtocol = DataSource.Protocol.NP;                  }                  else if (ConnectionProtocol != DataSource.Protocol.NP)                  {                      // In case the path began with a "\\" and protocol was not Named Pipes                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                  return true;              }
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferNamedPipesInformation,The following statement contains a magic number: if (_dataSourceAfterTrimmingProtocol.StartsWith(PipeBeginning) || ConnectionProtocol == Protocol.NP)              {                  // If the data source is "np:servername"                  if (!_dataSourceAfterTrimmingProtocol.Contains(BackSlashSeparator))                  {                      PipeHostName = ServerName = _dataSourceAfterTrimmingProtocol;                      InferLocalServerName();                      PipeName = SNINpHandle.DefaultPipePath;                      return true;                  }                    try                  {                      string[] tokensByBackSlash = _dataSourceAfterTrimmingProtocol.Split(BackSlashSeparator);                        // The datasource is of the format \\host\pipe\sql\query [0]\[1]\[2]\[3]\[4]\[5]                      // It would at least have 6 parts.                       // Another valid Sql named pipe for an named instance is \\.\pipe\MSSQL$MYINSTANCE\sql\query                      if (tokensByBackSlash.Length < 6)                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        string host = tokensByBackSlash[2];                        if (string.IsNullOrEmpty(host))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        //Check if the "pipe" keyword is the first part of path                      if (!PipeToken.Equals(tokensByBackSlash[3]))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        if (tokensByBackSlash[4].StartsWith(NamedPipeInstanceNameHeader))                      {                          InstanceName = tokensByBackSlash[4].Substring(NamedPipeInstanceNameHeader.Length);                      }                        StringBuilder pipeNameBuilder = new StringBuilder();                        for (int i = 4; i < tokensByBackSlash.Length - 1; i++)                      {                          pipeNameBuilder.Append(tokensByBackSlash[i]);                          pipeNameBuilder.Append(Path.DirectorySeparatorChar);                      }                      // Append the last part without a "/"                      pipeNameBuilder.Append(tokensByBackSlash[tokensByBackSlash.Length - 1]);                      PipeName = pipeNameBuilder.ToString();                        if (string.IsNullOrWhiteSpace(InstanceName) && !DefaultPipeName.Equals(PipeName))                      {                          InstanceName = PipeToken + PipeName;                      }                        ServerName = IsLocalHost(host) ? Environment.MachineName : host;                      // Pipe hostname is the hostname after leading \\ which should be passed down as is to open Named Pipe.                      // For Named Pipes the ServerName makes sense for SPN creation only.                      PipeHostName = host;                  }                  catch (UriFormatException)                  {                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                    // DataSource is something like "\\pipename"                  if (ConnectionProtocol == DataSource.Protocol.None)                  {                      ConnectionProtocol = DataSource.Protocol.NP;                  }                  else if (ConnectionProtocol != DataSource.Protocol.NP)                  {                      // In case the path began with a "\\" and protocol was not Named Pipes                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                  return true;              }
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferNamedPipesInformation,The following statement contains a magic number: if (_dataSourceAfterTrimmingProtocol.StartsWith(PipeBeginning) || ConnectionProtocol == Protocol.NP)              {                  // If the data source is "np:servername"                  if (!_dataSourceAfterTrimmingProtocol.Contains(BackSlashSeparator))                  {                      PipeHostName = ServerName = _dataSourceAfterTrimmingProtocol;                      InferLocalServerName();                      PipeName = SNINpHandle.DefaultPipePath;                      return true;                  }                    try                  {                      string[] tokensByBackSlash = _dataSourceAfterTrimmingProtocol.Split(BackSlashSeparator);                        // The datasource is of the format \\host\pipe\sql\query [0]\[1]\[2]\[3]\[4]\[5]                      // It would at least have 6 parts.                       // Another valid Sql named pipe for an named instance is \\.\pipe\MSSQL$MYINSTANCE\sql\query                      if (tokensByBackSlash.Length < 6)                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        string host = tokensByBackSlash[2];                        if (string.IsNullOrEmpty(host))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        //Check if the "pipe" keyword is the first part of path                      if (!PipeToken.Equals(tokensByBackSlash[3]))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        if (tokensByBackSlash[4].StartsWith(NamedPipeInstanceNameHeader))                      {                          InstanceName = tokensByBackSlash[4].Substring(NamedPipeInstanceNameHeader.Length);                      }                        StringBuilder pipeNameBuilder = new StringBuilder();                        for (int i = 4; i < tokensByBackSlash.Length - 1; i++)                      {                          pipeNameBuilder.Append(tokensByBackSlash[i]);                          pipeNameBuilder.Append(Path.DirectorySeparatorChar);                      }                      // Append the last part without a "/"                      pipeNameBuilder.Append(tokensByBackSlash[tokensByBackSlash.Length - 1]);                      PipeName = pipeNameBuilder.ToString();                        if (string.IsNullOrWhiteSpace(InstanceName) && !DefaultPipeName.Equals(PipeName))                      {                          InstanceName = PipeToken + PipeName;                      }                        ServerName = IsLocalHost(host) ? Environment.MachineName : host;                      // Pipe hostname is the hostname after leading \\ which should be passed down as is to open Named Pipe.                      // For Named Pipes the ServerName makes sense for SPN creation only.                      PipeHostName = host;                  }                  catch (UriFormatException)                  {                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                    // DataSource is something like "\\pipename"                  if (ConnectionProtocol == DataSource.Protocol.None)                  {                      ConnectionProtocol = DataSource.Protocol.NP;                  }                  else if (ConnectionProtocol != DataSource.Protocol.NP)                  {                      // In case the path began with a "\\" and protocol was not Named Pipes                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                  return true;              }
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferNamedPipesInformation,The following statement contains a magic number: if (_dataSourceAfterTrimmingProtocol.StartsWith(PipeBeginning) || ConnectionProtocol == Protocol.NP)              {                  // If the data source is "np:servername"                  if (!_dataSourceAfterTrimmingProtocol.Contains(BackSlashSeparator))                  {                      PipeHostName = ServerName = _dataSourceAfterTrimmingProtocol;                      InferLocalServerName();                      PipeName = SNINpHandle.DefaultPipePath;                      return true;                  }                    try                  {                      string[] tokensByBackSlash = _dataSourceAfterTrimmingProtocol.Split(BackSlashSeparator);                        // The datasource is of the format \\host\pipe\sql\query [0]\[1]\[2]\[3]\[4]\[5]                      // It would at least have 6 parts.                       // Another valid Sql named pipe for an named instance is \\.\pipe\MSSQL$MYINSTANCE\sql\query                      if (tokensByBackSlash.Length < 6)                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        string host = tokensByBackSlash[2];                        if (string.IsNullOrEmpty(host))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        //Check if the "pipe" keyword is the first part of path                      if (!PipeToken.Equals(tokensByBackSlash[3]))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        if (tokensByBackSlash[4].StartsWith(NamedPipeInstanceNameHeader))                      {                          InstanceName = tokensByBackSlash[4].Substring(NamedPipeInstanceNameHeader.Length);                      }                        StringBuilder pipeNameBuilder = new StringBuilder();                        for (int i = 4; i < tokensByBackSlash.Length - 1; i++)                      {                          pipeNameBuilder.Append(tokensByBackSlash[i]);                          pipeNameBuilder.Append(Path.DirectorySeparatorChar);                      }                      // Append the last part without a "/"                      pipeNameBuilder.Append(tokensByBackSlash[tokensByBackSlash.Length - 1]);                      PipeName = pipeNameBuilder.ToString();                        if (string.IsNullOrWhiteSpace(InstanceName) && !DefaultPipeName.Equals(PipeName))                      {                          InstanceName = PipeToken + PipeName;                      }                        ServerName = IsLocalHost(host) ? Environment.MachineName : host;                      // Pipe hostname is the hostname after leading \\ which should be passed down as is to open Named Pipe.                      // For Named Pipes the ServerName makes sense for SPN creation only.                      PipeHostName = host;                  }                  catch (UriFormatException)                  {                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                    // DataSource is something like "\\pipename"                  if (ConnectionProtocol == DataSource.Protocol.None)                  {                      ConnectionProtocol = DataSource.Protocol.NP;                  }                  else if (ConnectionProtocol != DataSource.Protocol.NP)                  {                      // In case the path began with a "\\" and protocol was not Named Pipes                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                  return true;              }
Magic Number,System.Data.SqlClient.SNI,DataSource,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SNIProxy.cs,InferNamedPipesInformation,The following statement contains a magic number: if (_dataSourceAfterTrimmingProtocol.StartsWith(PipeBeginning) || ConnectionProtocol == Protocol.NP)              {                  // If the data source is "np:servername"                  if (!_dataSourceAfterTrimmingProtocol.Contains(BackSlashSeparator))                  {                      PipeHostName = ServerName = _dataSourceAfterTrimmingProtocol;                      InferLocalServerName();                      PipeName = SNINpHandle.DefaultPipePath;                      return true;                  }                    try                  {                      string[] tokensByBackSlash = _dataSourceAfterTrimmingProtocol.Split(BackSlashSeparator);                        // The datasource is of the format \\host\pipe\sql\query [0]\[1]\[2]\[3]\[4]\[5]                      // It would at least have 6 parts.                       // Another valid Sql named pipe for an named instance is \\.\pipe\MSSQL$MYINSTANCE\sql\query                      if (tokensByBackSlash.Length < 6)                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        string host = tokensByBackSlash[2];                        if (string.IsNullOrEmpty(host))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        //Check if the "pipe" keyword is the first part of path                      if (!PipeToken.Equals(tokensByBackSlash[3]))                      {                          ReportSNIError(SNIProviders.NP_PROV);                          return false;                      }                        if (tokensByBackSlash[4].StartsWith(NamedPipeInstanceNameHeader))                      {                          InstanceName = tokensByBackSlash[4].Substring(NamedPipeInstanceNameHeader.Length);                      }                        StringBuilder pipeNameBuilder = new StringBuilder();                        for (int i = 4; i < tokensByBackSlash.Length - 1; i++)                      {                          pipeNameBuilder.Append(tokensByBackSlash[i]);                          pipeNameBuilder.Append(Path.DirectorySeparatorChar);                      }                      // Append the last part without a "/"                      pipeNameBuilder.Append(tokensByBackSlash[tokensByBackSlash.Length - 1]);                      PipeName = pipeNameBuilder.ToString();                        if (string.IsNullOrWhiteSpace(InstanceName) && !DefaultPipeName.Equals(PipeName))                      {                          InstanceName = PipeToken + PipeName;                      }                        ServerName = IsLocalHost(host) ? Environment.MachineName : host;                      // Pipe hostname is the hostname after leading \\ which should be passed down as is to open Named Pipe.                      // For Named Pipes the ServerName makes sense for SPN creation only.                      PipeHostName = host;                  }                  catch (UriFormatException)                  {                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                    // DataSource is something like "\\pipename"                  if (ConnectionProtocol == DataSource.Protocol.None)                  {                      ConnectionProtocol = DataSource.Protocol.NP;                  }                  else if (ConnectionProtocol != DataSource.Protocol.NP)                  {                      // In case the path began with a "\\" and protocol was not Named Pipes                      ReportSNIError(SNIProviders.NP_PROV);                      return false;                  }                  return true;              }
Magic Number,System.Data.SqlClient.SNI,SslOverTdsStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SslOverTdsStream.cs,Read,The following statement contains a magic number: if (_encapsulate)              {                  if (_packetBytes == 0)                  {                      // Account for split packets                      while (readBytes < TdsEnums.HEADER_LEN)                      {                          readBytes += _stream.Read(packetData' readBytes' TdsEnums.HEADER_LEN - readBytes);                      }                        _packetBytes = (packetData[TdsEnums.HEADER_LEN_FIELD_OFFSET] << 8) | packetData[TdsEnums.HEADER_LEN_FIELD_OFFSET + 1];                      _packetBytes -= TdsEnums.HEADER_LEN;                  }                    if (count > _packetBytes)                  {                      count = _packetBytes;                  }              }
Magic Number,System.Data.SqlClient.SNI,SslOverTdsStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SslOverTdsStream.cs,Write,The following statement contains a magic number: while (count > 0)              {                  // During the SSL negotiation phase' SSL is tunnelled over TDS packet type 0x12. After                  // negotiation' the underlying socket only sees SSL frames.                  //                  if (_encapsulate)                  {                      if (count > PACKET_SIZE_WITHOUT_HEADER)                      {                          currentCount = PACKET_SIZE_WITHOUT_HEADER;                      }                      else                      {                          currentCount = count;                      }                        count -= currentCount;                        // Prepend buffer data with TDS prelogin header                      byte[] combinedBuffer = new byte[TdsEnums.HEADER_LEN + currentCount];                        // We can only send 4088 bytes in one packet. Header[1] is set to 1 if this is a                       // partial packet (whether or not count != 0).                      //                       combinedBuffer[0] = PRELOGIN_PACKET_TYPE;                      combinedBuffer[1] = (byte)(count > 0 ? 0 : 1);                      combinedBuffer[2] = (byte)((currentCount + TdsEnums.HEADER_LEN) / 0x100);                      combinedBuffer[3] = (byte)((currentCount + TdsEnums.HEADER_LEN) % 0x100);                      combinedBuffer[4] = 0;                      combinedBuffer[5] = 0;                      combinedBuffer[6] = 0;                      combinedBuffer[7] = 0;                        for(int i = TdsEnums.HEADER_LEN; i < combinedBuffer.Length; i++)                      {                          combinedBuffer[i] = buffer[currentOffset + (i - TdsEnums.HEADER_LEN)];                      }                        _stream.Write(combinedBuffer' 0' combinedBuffer.Length);                  }                  else                  {                      currentCount = count;                      count = 0;                        _stream.Write(buffer' currentOffset' currentCount);                  }                    _stream.Flush();                  currentOffset += currentCount;              }
Magic Number,System.Data.SqlClient.SNI,SslOverTdsStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SslOverTdsStream.cs,Write,The following statement contains a magic number: while (count > 0)              {                  // During the SSL negotiation phase' SSL is tunnelled over TDS packet type 0x12. After                  // negotiation' the underlying socket only sees SSL frames.                  //                  if (_encapsulate)                  {                      if (count > PACKET_SIZE_WITHOUT_HEADER)                      {                          currentCount = PACKET_SIZE_WITHOUT_HEADER;                      }                      else                      {                          currentCount = count;                      }                        count -= currentCount;                        // Prepend buffer data with TDS prelogin header                      byte[] combinedBuffer = new byte[TdsEnums.HEADER_LEN + currentCount];                        // We can only send 4088 bytes in one packet. Header[1] is set to 1 if this is a                       // partial packet (whether or not count != 0).                      //                       combinedBuffer[0] = PRELOGIN_PACKET_TYPE;                      combinedBuffer[1] = (byte)(count > 0 ? 0 : 1);                      combinedBuffer[2] = (byte)((currentCount + TdsEnums.HEADER_LEN) / 0x100);                      combinedBuffer[3] = (byte)((currentCount + TdsEnums.HEADER_LEN) % 0x100);                      combinedBuffer[4] = 0;                      combinedBuffer[5] = 0;                      combinedBuffer[6] = 0;                      combinedBuffer[7] = 0;                        for(int i = TdsEnums.HEADER_LEN; i < combinedBuffer.Length; i++)                      {                          combinedBuffer[i] = buffer[currentOffset + (i - TdsEnums.HEADER_LEN)];                      }                        _stream.Write(combinedBuffer' 0' combinedBuffer.Length);                  }                  else                  {                      currentCount = count;                      count = 0;                        _stream.Write(buffer' currentOffset' currentCount);                  }                    _stream.Flush();                  currentOffset += currentCount;              }
Magic Number,System.Data.SqlClient.SNI,SslOverTdsStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SslOverTdsStream.cs,Write,The following statement contains a magic number: while (count > 0)              {                  // During the SSL negotiation phase' SSL is tunnelled over TDS packet type 0x12. After                  // negotiation' the underlying socket only sees SSL frames.                  //                  if (_encapsulate)                  {                      if (count > PACKET_SIZE_WITHOUT_HEADER)                      {                          currentCount = PACKET_SIZE_WITHOUT_HEADER;                      }                      else                      {                          currentCount = count;                      }                        count -= currentCount;                        // Prepend buffer data with TDS prelogin header                      byte[] combinedBuffer = new byte[TdsEnums.HEADER_LEN + currentCount];                        // We can only send 4088 bytes in one packet. Header[1] is set to 1 if this is a                       // partial packet (whether or not count != 0).                      //                       combinedBuffer[0] = PRELOGIN_PACKET_TYPE;                      combinedBuffer[1] = (byte)(count > 0 ? 0 : 1);                      combinedBuffer[2] = (byte)((currentCount + TdsEnums.HEADER_LEN) / 0x100);                      combinedBuffer[3] = (byte)((currentCount + TdsEnums.HEADER_LEN) % 0x100);                      combinedBuffer[4] = 0;                      combinedBuffer[5] = 0;                      combinedBuffer[6] = 0;                      combinedBuffer[7] = 0;                        for(int i = TdsEnums.HEADER_LEN; i < combinedBuffer.Length; i++)                      {                          combinedBuffer[i] = buffer[currentOffset + (i - TdsEnums.HEADER_LEN)];                      }                        _stream.Write(combinedBuffer' 0' combinedBuffer.Length);                  }                  else                  {                      currentCount = count;                      count = 0;                        _stream.Write(buffer' currentOffset' currentCount);                  }                    _stream.Flush();                  currentOffset += currentCount;              }
Magic Number,System.Data.SqlClient.SNI,SslOverTdsStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SslOverTdsStream.cs,Write,The following statement contains a magic number: while (count > 0)              {                  // During the SSL negotiation phase' SSL is tunnelled over TDS packet type 0x12. After                  // negotiation' the underlying socket only sees SSL frames.                  //                  if (_encapsulate)                  {                      if (count > PACKET_SIZE_WITHOUT_HEADER)                      {                          currentCount = PACKET_SIZE_WITHOUT_HEADER;                      }                      else                      {                          currentCount = count;                      }                        count -= currentCount;                        // Prepend buffer data with TDS prelogin header                      byte[] combinedBuffer = new byte[TdsEnums.HEADER_LEN + currentCount];                        // We can only send 4088 bytes in one packet. Header[1] is set to 1 if this is a                       // partial packet (whether or not count != 0).                      //                       combinedBuffer[0] = PRELOGIN_PACKET_TYPE;                      combinedBuffer[1] = (byte)(count > 0 ? 0 : 1);                      combinedBuffer[2] = (byte)((currentCount + TdsEnums.HEADER_LEN) / 0x100);                      combinedBuffer[3] = (byte)((currentCount + TdsEnums.HEADER_LEN) % 0x100);                      combinedBuffer[4] = 0;                      combinedBuffer[5] = 0;                      combinedBuffer[6] = 0;                      combinedBuffer[7] = 0;                        for(int i = TdsEnums.HEADER_LEN; i < combinedBuffer.Length; i++)                      {                          combinedBuffer[i] = buffer[currentOffset + (i - TdsEnums.HEADER_LEN)];                      }                        _stream.Write(combinedBuffer' 0' combinedBuffer.Length);                  }                  else                  {                      currentCount = count;                      count = 0;                        _stream.Write(buffer' currentOffset' currentCount);                  }                    _stream.Flush();                  currentOffset += currentCount;              }
Magic Number,System.Data.SqlClient.SNI,SslOverTdsStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SslOverTdsStream.cs,Write,The following statement contains a magic number: while (count > 0)              {                  // During the SSL negotiation phase' SSL is tunnelled over TDS packet type 0x12. After                  // negotiation' the underlying socket only sees SSL frames.                  //                  if (_encapsulate)                  {                      if (count > PACKET_SIZE_WITHOUT_HEADER)                      {                          currentCount = PACKET_SIZE_WITHOUT_HEADER;                      }                      else                      {                          currentCount = count;                      }                        count -= currentCount;                        // Prepend buffer data with TDS prelogin header                      byte[] combinedBuffer = new byte[TdsEnums.HEADER_LEN + currentCount];                        // We can only send 4088 bytes in one packet. Header[1] is set to 1 if this is a                       // partial packet (whether or not count != 0).                      //                       combinedBuffer[0] = PRELOGIN_PACKET_TYPE;                      combinedBuffer[1] = (byte)(count > 0 ? 0 : 1);                      combinedBuffer[2] = (byte)((currentCount + TdsEnums.HEADER_LEN) / 0x100);                      combinedBuffer[3] = (byte)((currentCount + TdsEnums.HEADER_LEN) % 0x100);                      combinedBuffer[4] = 0;                      combinedBuffer[5] = 0;                      combinedBuffer[6] = 0;                      combinedBuffer[7] = 0;                        for(int i = TdsEnums.HEADER_LEN; i < combinedBuffer.Length; i++)                      {                          combinedBuffer[i] = buffer[currentOffset + (i - TdsEnums.HEADER_LEN)];                      }                        _stream.Write(combinedBuffer' 0' combinedBuffer.Length);                  }                  else                  {                      currentCount = count;                      count = 0;                        _stream.Write(buffer' currentOffset' currentCount);                  }                    _stream.Flush();                  currentOffset += currentCount;              }
Magic Number,System.Data.SqlClient.SNI,SslOverTdsStream,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SslOverTdsStream.cs,Write,The following statement contains a magic number: while (count > 0)              {                  // During the SSL negotiation phase' SSL is tunnelled over TDS packet type 0x12. After                  // negotiation' the underlying socket only sees SSL frames.                  //                  if (_encapsulate)                  {                      if (count > PACKET_SIZE_WITHOUT_HEADER)                      {                          currentCount = PACKET_SIZE_WITHOUT_HEADER;                      }                      else                      {                          currentCount = count;                      }                        count -= currentCount;                        // Prepend buffer data with TDS prelogin header                      byte[] combinedBuffer = new byte[TdsEnums.HEADER_LEN + currentCount];                        // We can only send 4088 bytes in one packet. Header[1] is set to 1 if this is a                       // partial packet (whether or not count != 0).                      //                       combinedBuffer[0] = PRELOGIN_PACKET_TYPE;                      combinedBuffer[1] = (byte)(count > 0 ? 0 : 1);                      combinedBuffer[2] = (byte)((currentCount + TdsEnums.HEADER_LEN) / 0x100);                      combinedBuffer[3] = (byte)((currentCount + TdsEnums.HEADER_LEN) % 0x100);                      combinedBuffer[4] = 0;                      combinedBuffer[5] = 0;                      combinedBuffer[6] = 0;                      combinedBuffer[7] = 0;                        for(int i = TdsEnums.HEADER_LEN; i < combinedBuffer.Length; i++)                      {                          combinedBuffer[i] = buffer[currentOffset + (i - TdsEnums.HEADER_LEN)];                      }                        _stream.Write(combinedBuffer' 0' combinedBuffer.Length);                  }                  else                  {                      currentCount = count;                      count = 0;                        _stream.Write(buffer' currentOffset' currentCount);                  }                    _stream.Flush();                  currentOffset += currentCount;              }
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetPortByInstanceName,The following statement contains a magic number: if (responsePacket == null || responsePacket.Length <= 3 || responsePacket[0] != SvrResp ||                  BitConverter.ToUInt16(responsePacket' 1) != responsePacket.Length - 3)              {                  throw new SocketException();              }
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetPortByInstanceName,The following statement contains a magic number: if (responsePacket == null || responsePacket.Length <= 3 || responsePacket[0] != SvrResp ||                  BitConverter.ToUInt16(responsePacket' 1) != responsePacket.Length - 3)              {                  throw new SocketException();              }
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetPortByInstanceName,The following statement contains a magic number: string serverMessage = Encoding.ASCII.GetString(responsePacket' 3' responsePacket.Length - 3);
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetPortByInstanceName,The following statement contains a magic number: string serverMessage = Encoding.ASCII.GetString(responsePacket' 3' responsePacket.Length - 3);
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetDacPortByInstanceName,The following statement contains a magic number: if (responsePacket == null || responsePacket.Length <= 4 || responsePacket[0] != SvrResp ||                  BitConverter.ToUInt16(responsePacket' 1) != RespSize || responsePacket[3] != ProtocolVersion)              {                  throw new SocketException();              }
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetDacPortByInstanceName,The following statement contains a magic number: if (responsePacket == null || responsePacket.Length <= 4 || responsePacket[0] != SvrResp ||                  BitConverter.ToUInt16(responsePacket' 1) != RespSize || responsePacket[3] != ProtocolVersion)              {                  throw new SocketException();              }
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,GetDacPortByInstanceName,The following statement contains a magic number: int dacPort = BitConverter.ToUInt16(responsePacket' 4);
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,CreateDacPortInfoRequest,The following statement contains a magic number: byte[] requestPacket = new byte[byteCount + 2];
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,CreateDacPortInfoRequest,The following statement contains a magic number: Encoding.ASCII.GetBytes(instanceName' 0' instanceName.Length' requestPacket' 2);
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,SendUDPRequest,The following statement contains a magic number: Debug.Assert(port >= 0 && port <= 65535' "Invalid port");
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,SendUDPRequest,The following statement contains a magic number: const int sendTimeOutMs = 1000;
Magic Number,System.Data.SqlClient.SNI,SSRP,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SNI\SSRP.cs,SendUDPRequest,The following statement contains a magic number: const int receiveTimeOutMs = 1000;
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\NetEventSource.Common.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The following statement contains a magic number: const int prefixLength = 4;
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,Encrypt,The following statement contains a magic number: return resultSize + 4;
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The following statement contains a magic number: const int prefixLength = 4;
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The following statement contains a magic number: unchecked              {                  output[0] = (byte)((resultSize) & 0xFF);                  output[1] = (byte)(((resultSize) >> 8) & 0xFF);                  output[2] = (byte)(((resultSize) >> 16) & 0xFF);                  output[3] = (byte)(((resultSize) >> 24) & 0xFF);              }
Magic Number,System.Net.Security,NegotiateStreamPal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Security\NegotiateStreamPal.Unix.cs,MakeSignature,The following statement contains a magic number: return resultSize + 4;
Missing Default,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetValue,The following switch statement is missing a default case: switch (metaData.SqlDbType)                  {                      case SqlDbType.BigInt:                          result = GetInt64_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Binary:                          result = GetByteArray_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Bit:                          result = GetBoolean_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Char:                          result = GetString_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.DateTime:                          result = GetDateTime_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Decimal:                          result = GetSqlDecimal_Unchecked(sink' getters' ordinal).Value;                          break;                      case SqlDbType.Float:                          result = GetDouble_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Image:                          result = GetByteArray_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Int:                          result = GetInt32_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Money:                          result = GetSqlMoney_Unchecked(sink' getters' ordinal).Value;                          break;                      case SqlDbType.NChar:                          result = GetString_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.NText:                          result = GetString_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.NVarChar:                          result = GetString_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Real:                          result = GetSingle_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.UniqueIdentifier:                          result = GetGuid_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.SmallDateTime:                          result = GetDateTime_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.SmallInt:                          result = GetInt16_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.SmallMoney:                          result = GetSqlMoney_Unchecked(sink' getters' ordinal).Value;                          break;                      case SqlDbType.Text:                          result = GetString_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Timestamp:                          result = GetByteArray_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.TinyInt:                          result = GetByte_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.VarBinary:                          result = GetByteArray_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.VarChar:                          result = GetString_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Variant:                          metaData = getters.GetVariantType(sink' ordinal);                          sink.ProcessMessagesAndThrow();                          Debug.Assert(SqlDbType.Variant != metaData.SqlDbType' "Variant-within-variant causes endless recursion!");                          result = GetValue(sink' getters' ordinal' metaData);                          break;                      case SqlDbType.Xml:                          result = GetSqlXml_Unchecked(sink' getters' ordinal).Value;                          break;                      case SqlDbType.Udt:                          result = GetUdt_LengthChecked(sink' getters' ordinal' metaData);                          break;                  }
Missing Default,Microsoft.SqlServer.Server,ValueUtilsSmi,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\Microsoft\SqlServer\Server\ValueUtilsSmi.cs,GetSqlValue,The following switch statement is missing a default case: switch (metaData.SqlDbType)                  {                      case SqlDbType.BigInt:                          result = new SqlInt64(GetInt64_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Binary:                          result = GetSqlBinary_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Bit:                          result = new SqlBoolean(GetBoolean_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Char:                          result = new SqlString(GetString_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.DateTime:                          result = new SqlDateTime(GetDateTime_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Decimal:                          result = GetSqlDecimal_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Float:                          result = new SqlDouble(GetDouble_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Image:                          result = GetSqlBinary_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Int:                          result = new SqlInt32(GetInt32_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Money:                          result = GetSqlMoney_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.NChar:                          result = new SqlString(GetString_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.NText:                          result = new SqlString(GetString_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.NVarChar:                          result = new SqlString(GetString_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Real:                          result = new SqlSingle(GetSingle_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.UniqueIdentifier:                          result = new SqlGuid(GetGuid_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.SmallDateTime:                          result = new SqlDateTime(GetDateTime_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.SmallInt:                          result = new SqlInt16(GetInt16_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.SmallMoney:                          result = GetSqlMoney_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Text:                          result = new SqlString(GetString_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Timestamp:                          result = GetSqlBinary_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.TinyInt:                          result = new SqlByte(GetByte_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.VarBinary:                          result = GetSqlBinary_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.VarChar:                          result = new SqlString(GetString_Unchecked(sink' getters' ordinal));                          break;                      case SqlDbType.Variant:                          metaData = getters.GetVariantType(sink' ordinal);                          sink.ProcessMessagesAndThrow();                          Debug.Assert(SqlDbType.Variant != metaData.SqlDbType' "Variant-within-variant causes endless recursion!");                          result = GetSqlValue(sink' getters' ordinal' metaData);                          break;                      case SqlDbType.Xml:                          result = GetSqlXml_Unchecked(sink' getters' ordinal);                          break;                      case SqlDbType.Udt:                          result = GetUdt_LengthChecked(sink' getters' ordinal' metaData);                          break;                  }
Missing Default,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,GetTypeFromStorageType,The following switch statement is missing a default case: switch (_type)                  {                      case SqlBuffer.StorageType.Empty: return null;                      case SqlBuffer.StorageType.Boolean: return typeof(SqlBoolean);                      case SqlBuffer.StorageType.Byte: return typeof(SqlByte);                      case SqlBuffer.StorageType.DateTime: return typeof(SqlDateTime);                      case SqlBuffer.StorageType.Decimal: return typeof(SqlDecimal);                      case SqlBuffer.StorageType.Double: return typeof(SqlDouble);                      case SqlBuffer.StorageType.Int16: return typeof(SqlInt16);                      case SqlBuffer.StorageType.Int32: return typeof(SqlInt32);                      case SqlBuffer.StorageType.Int64: return typeof(SqlInt64);                      case SqlBuffer.StorageType.Money: return typeof(SqlMoney);                      case SqlBuffer.StorageType.Single: return typeof(SqlSingle);                      case SqlBuffer.StorageType.String: return typeof(SqlString);                      case SqlBuffer.StorageType.SqlCachedBuffer: return typeof(SqlString);                      case SqlBuffer.StorageType.SqlBinary: return typeof(object);                      case SqlBuffer.StorageType.SqlGuid: return typeof(object);                      case SqlBuffer.StorageType.SqlXml: return typeof(SqlXml);                  }
Missing Default,System.Data.SqlClient,SqlBuffer,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBuffer.cs,GetTypeFromStorageType,The following switch statement is missing a default case: switch (_type)                  {                      case SqlBuffer.StorageType.Empty: return null;                      case SqlBuffer.StorageType.Boolean: return typeof(Boolean);                      case SqlBuffer.StorageType.Byte: return typeof(Byte);                      case SqlBuffer.StorageType.DateTime: return typeof(DateTime);                      case SqlBuffer.StorageType.Decimal: return typeof(Decimal);                      case SqlBuffer.StorageType.Double: return typeof(Double);                      case SqlBuffer.StorageType.Int16: return typeof(Int16);                      case SqlBuffer.StorageType.Int32: return typeof(Int32);                      case SqlBuffer.StorageType.Int64: return typeof(Int64);                      case SqlBuffer.StorageType.Money: return typeof(Decimal);                      case SqlBuffer.StorageType.Single: return typeof(Single);                      case SqlBuffer.StorageType.String: return typeof(String);                      case SqlBuffer.StorageType.SqlBinary: return typeof(Byte[]);                      case SqlBuffer.StorageType.SqlCachedBuffer: return typeof(string);                      case SqlBuffer.StorageType.SqlGuid: return typeof(Guid);                      case SqlBuffer.StorageType.SqlXml: return typeof(string);                  }
Missing Default,System.Data.SqlClient,SqlBulkCopy,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlBulkCopy.cs,WriteRowSourceToServerCommon,The following switch statement is missing a default case: switch (_rowSourceType)                              {                                  case ValueSourceType.DataTable:                                      index = ((DataTable)_rowSource).Columns.IndexOf(unquotedColumnName);                                      break;                                  case ValueSourceType.RowArray:                                      index = ((DataRow[])_rowSource)[0].Table.Columns.IndexOf(unquotedColumnName);                                      break;                                  case ValueSourceType.DbDataReader:                                  case ValueSourceType.IDataReader:                                      try                                      {                                          index = ((IDataReader)_rowSource).GetOrdinal(unquotedColumnName);                                      }                                      catch (IndexOutOfRangeException e)                                      {                                          throw (SQL.BulkLoadNonMatchingColumnName(unquotedColumnName' e));                                      }                                      break;                              }
Missing Default,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,BuildSchemaTable,The following switch statement is missing a default case: switch (col.type)                      {                          case SqlDbType.Date:                              schemaRow[size] = TdsEnums.WHIDBEY_DATE_LENGTH;                              break;                          case SqlDbType.Time:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for Time column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_TIME_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTime2:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTime2 column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIME2_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                          case SqlDbType.DateTimeOffset:                              Debug.Assert(TdsEnums.UNKNOWN_PRECISION_SCALE == col.scale || (0 <= col.scale && col.scale <= 7)' "Invalid scale for DateTimeOffset column: " + col.scale);                              schemaRow[size] = TdsEnums.WHIDBEY_DATETIMEOFFSET_LENGTH[TdsEnums.UNKNOWN_PRECISION_SCALE != col.scale ? col.scale : col.metaType.Scale];                              break;                      }
Missing Default,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryHasMoreResults,The following switch statement is missing a default case: switch (token)                      {                          case TdsEnums.SQLALTROW:                              if (_altRowStatus == ALTROWSTATUS.Null)                              {                                  // cache the regular metadata                                  _altMetaDataSetCollection.metaDataSet = _metaData;                                  _metaData = null;                              }                              else                              {                                  Debug.Assert(_altRowStatus == ALTROWSTATUS.Done' "invalid AltRowStatus");                              }                              _altRowStatus = ALTROWSTATUS.AltRow;                              _hasRows = true;                              moreResults = true;                              return true;                          case TdsEnums.SQLROW:                          case TdsEnums.SQLNBCROW:                              // always happens if there is a row following an altrow                              moreResults = true;                              return true;                          case TdsEnums.SQLDONE:                              Debug.Assert(_altRowStatus == ALTROWSTATUS.Done || _altRowStatus == ALTROWSTATUS.Null' "invalid AltRowStatus");                              _altRowStatus = ALTROWSTATUS.Null;                              _metaData = null;                              _altMetaDataSetCollection = null;                              moreResults = true;                              return true;                          case TdsEnums.SQLCOLMETADATA:                              moreResults = true;                              return true;                      }
Missing Default,System.Data.SqlClient,SqlDataReader,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlDataReader.cs,TryHasMoreRows,The following switch statement is missing a default case: switch (_altRowStatus)                  {                      case ALTROWSTATUS.AltRow:                          moreRows = true;                          return true;                      case ALTROWSTATUS.Done:                          moreRows = false;                          return true;                  }
Missing Default,System.Data.SqlClient,SqlStreamingXml,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\SqlStream.cs,WriteXmlElement,The following switch statement is missing a default case: switch (_xmlReader.NodeType)              {                  case XmlNodeType.Element:                      _xmlWriter.WriteStartElement(_xmlReader.Prefix' _xmlReader.LocalName' _xmlReader.NamespaceURI);                      _xmlWriter.WriteAttributes(_xmlReader' true);                      if (_xmlReader.IsEmptyElement)                      {                          _xmlWriter.WriteEndElement();                          break;                      }                      break;                  case XmlNodeType.Text:                      if (canReadChunk)                      {                          if (writeNodeBuffer == null)                          {                              writeNodeBuffer = new char[WriteNodeBufferSize];                          }                          int read;                          while ((read = _xmlReader.ReadValueChunk(writeNodeBuffer' 0' WriteNodeBufferSize)) > 0)                          {                              _xmlWriter.WriteChars(writeNodeBuffer' 0' read);                          }                      }                      else                      {                          _xmlWriter.WriteString(_xmlReader.Value);                      }                      break;                  case XmlNodeType.Whitespace:                  case XmlNodeType.SignificantWhitespace:                      _xmlWriter.WriteWhitespace(_xmlReader.Value);                      break;                  case XmlNodeType.CDATA:                      _xmlWriter.WriteCData(_xmlReader.Value);                      break;                  case XmlNodeType.EntityReference:                      _xmlWriter.WriteEntityRef(_xmlReader.Name);                      break;                  case XmlNodeType.XmlDeclaration:                  case XmlNodeType.ProcessingInstruction:                      _xmlWriter.WriteProcessingInstruction(_xmlReader.Name' _xmlReader.Value);                      break;                  case XmlNodeType.DocumentType:                      _xmlWriter.WriteDocType(_xmlReader.Name' _xmlReader.GetAttribute("PUBLIC")' _xmlReader.GetAttribute("SYSTEM")' _xmlReader.Value);                      break;                  case XmlNodeType.Comment:                      _xmlWriter.WriteComment(_xmlReader.Value);                      break;                  case XmlNodeType.EndElement:                      _xmlWriter.WriteFullEndElement();                      break;              }
Missing Default,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSNIError,The following switch statement is missing a default case: switch (details.sniErrorNumber)                  {                      case (int)SNINativeMethodWrapper.SniSpecialErrors.MultiSubnetFailoverWithMoreThan64IPs:                          // Connecting with the MultiSubnetFailover connection option to a SQL Server instance configured with more than 64 IP addresses is not supported.                          throw SQL.MultiSubnetFailoverWithMoreThan64IPs();                        case (int)SNINativeMethodWrapper.SniSpecialErrors.MultiSubnetFailoverWithInstanceSpecified:                          // Connecting to a named SQL Server instance using the MultiSubnetFailover connection option is not supported.                          throw SQL.MultiSubnetFailoverWithInstanceSpecified();                        case (int)SNINativeMethodWrapper.SniSpecialErrors.MultiSubnetFailoverWithNonTcpProtocol:                          // Connecting to a SQL Server instance using the MultiSubnetFailover connection option is only supported when using the TCP protocol.                          throw SQL.MultiSubnetFailoverWithNonTcpProtocol();                          // continue building SqlError instance                  }
Missing Default,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSqlStatistics,The following switch statement is missing a default case: switch (curCmd)                  {                      case TdsEnums.INSERT:                      case TdsEnums.DELETE:                      case TdsEnums.UPDATE:                      case TdsEnums.MERGE:                          _statistics.SafeIncrement(ref _statistics._iduCount);                          _statistics.SafeAdd(ref _statistics._iduRows' count);                          if (!_statisticsIsInTransaction)                          {                              _statistics.SafeIncrement(ref _statistics._transactions);                          }                            break;                        case TdsEnums.SELECT:                          _statistics.SafeIncrement(ref _statistics._selectCount);                          _statistics.SafeAdd(ref _statistics._selectRows' count);                          break;                        case TdsEnums.BEGINXACT:                          if (!_statisticsIsInTransaction)                          {                              _statistics.SafeIncrement(ref _statistics._transactions);                          }                          _statisticsIsInTransaction = true;                          break;                        case TdsEnums.OPENCURSOR:                          _statistics.SafeIncrement(ref _statistics._cursorOpens);                          break;                        case TdsEnums.ABORT:                          _statisticsIsInTransaction = false;                          break;                        case TdsEnums.ENDXACT:                          _statisticsIsInTransaction = false;                          break;                  }
Missing Default,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,ProcessSqlStatistics,The following switch statement is missing a default case: switch (curCmd)                  {                      case TdsEnums.BEGINXACT:                          _statisticsIsInTransaction = true;                          break;                        case TdsEnums.ABORT:                      case TdsEnums.ENDXACT:                          _statisticsIsInTransaction = false;                          break;                  }
Missing Default,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,TryGetTokenLength,The following switch statement is missing a default case: switch (token)              { // rules about SQLLenMask no longer apply to new tokens (as of 7.4)                  case TdsEnums.SQLFEATUREEXTACK:                      tokenLength = -1;                      return true;                  case TdsEnums.SQLSESSIONSTATE:                      return stateObj.TryReadInt32(out tokenLength);              }
Missing Default,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteBulkCopyValue,The following switch statement is missing a default case: switch (metatype.SqlDbType)                      {                          case SqlDbType.Text:                          case SqlDbType.NText:                          case SqlDbType.Image:                              stateObj.WriteByteArray(s_longDataHeader' s_longDataHeader.Length' 0);                              WriteTokenLength(metadata.tdsType' ccbStringBytes == 0 ? ccb : ccbStringBytes' stateObj);                              break;                            case SqlDbType.VarChar:                          case SqlDbType.NVarChar:                          case SqlDbType.VarBinary:                          case SqlDbType.Xml:                          case SqlDbType.Udt:                              // plp data                              WriteUnsignedLong(TdsEnums.SQL_PLP_UNKNOWNLEN' stateObj);                              break;                      }
Missing Default,System.Data.SqlClient,TdsParser,C:\selectedRepos\dotnet_corefx\src\System.Data.SqlClient\src\System\Data\SqlClient\TdsParser.cs,WriteTokenLength,The following switch statement is missing a default case: switch (tokenLength)                  {                      case 1:                          stateObj.WriteByte((byte)length);                          break;                        case 2:                          WriteShort(length' stateObj);                          break;                        case 4:                          WriteInt(length' stateObj);                          break;                        case 8:                          // In the metadata case we write 0xffff for partial length prefixed types.                          //  For actual data length preceding data' WriteDataLength should be used.                          WriteShort(TdsEnums.SQL_USHORTVARMAXLEN' stateObj);                          break;                  }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidCommandType,The following switch statement is missing a default case: switch (value)              {                  case CommandType.Text:                  case CommandType.StoredProcedure:                  case CommandType.TableDirect:                      Debug.Assert(false' "valid CommandType " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidIsolationLevel,The following switch statement is missing a default case: switch (value)              {                  case IsolationLevel.Unspecified:                  case IsolationLevel.Chaos:                  case IsolationLevel.ReadUncommitted:                  case IsolationLevel.ReadCommitted:                  case IsolationLevel.RepeatableRead:                  case IsolationLevel.Serializable:                  case IsolationLevel.Snapshot:                      Debug.Fail("valid IsolationLevel " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidParameterDirection,The following switch statement is missing a default case: switch (value)              {                  case ParameterDirection.Input:                  case ParameterDirection.Output:                  case ParameterDirection.InputOutput:                  case ParameterDirection.ReturnValue:                      Debug.Assert(false' "valid ParameterDirection " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidUpdateRowSource,The following switch statement is missing a default case: switch (value)              {                  case UpdateRowSource.None:                  case UpdateRowSource.OutputParameters:                  case UpdateRowSource.FirstReturnedRecord:                  case UpdateRowSource.Both:                      Debug.Assert(false' "valid UpdateRowSource " + value.ToString());                      break;              }
Missing Default,System.Data.Common,ADP,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\AdapterUtil.cs,InvalidDataRowVersion,The following switch statement is missing a default case: switch (value)              {                  case DataRowVersion.Default:                  case DataRowVersion.Current:                  case DataRowVersion.Original:                  case DataRowVersion.Proposed:                      Debug.Fail($"Invalid DataRowVersion {value}");                      break;              }
Missing Default,System.Data.Common,MultipartIdentifier,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Data\Common\MultipartIdentifier.cs,ParseMultipartIdentifier,The following switch statement is missing a default case: switch (state)                  {                      case MPIState.MPI_Value:                          {                              int quoteIndex;                              if (IsWhitespace(testchar))                              {    // Is White Space then skip the whitespace                                  continue;                              }                              else                              if (testchar == separator)                              {  // If we found a separator' no string was found' initialize the string we are parsing to Empty and the next one to Empty.                                 // This is NOT a redundant setting of string.Empty it solves the case where we are parsing ".foo" and we should be returning null' null' empty' foo                                  parsedNames[stringCount] = string.Empty;                                  IncrementStringCount(name' parsedNames' ref stringCount' property);                              }                              else                              if (-1 != (quoteIndex = leftQuote.IndexOf(testchar)))                              { // If we are a left quote                                                                                                                                                            rightQuoteChar = rightQuote[quoteIndex]; // record the corresponding right quote for the left quote                                  sb.Length = 0;                                  if (!removequotes)                                  {                                      sb.Append(testchar);                                  }                                  state = MPIState.MPI_ParseQuote;                              }                              else                              if (-1 != rightQuote.IndexOf(testchar))                              { // If we shouldn't see a right quote                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              {                                  sb.Length = 0;                                  sb.Append(testchar);                                  state = MPIState.MPI_ParseNonQuote;                              }                              break;                          }                        case MPIState.MPI_ParseNonQuote:                          {                              if (testchar == separator)                              {                                  parsedNames[stringCount] = sb.ToString(); // set the currently parsed string                                  IncrementStringCount(name' parsedNames' ref stringCount' property);                                  state = MPIState.MPI_Value;                              }                              else // Quotes are not valid inside a non-quoted name                              if (-1 != rightQuote.IndexOf(testchar))                              {                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              if (-1 != leftQuote.IndexOf(testchar))                              {                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              if (IsWhitespace(testchar))                              { // If it is Whitespace                                   parsedNames[stringCount] = sb.ToString(); // Set the currently parsed string                                  if (null == whitespaceSB)                                  {                                      whitespaceSB = new StringBuilder();                                  }                                  whitespaceSB.Length = 0;                                  whitespaceSB.Append(testchar);  // start to record the whitespace' if we are parsing a name like "foo bar" we should return "foo bar"                                  state = MPIState.MPI_LookForNextCharOrSeparator;                              }                              else                              {                                  sb.Append(testchar);                              }                              break;                          }                        case MPIState.MPI_LookForNextCharOrSeparator:                          {                              if (!IsWhitespace(testchar))                              { // If it is not whitespace                                  if (testchar == separator)                                  {                                      IncrementStringCount(name' parsedNames' ref stringCount' property);                                      state = MPIState.MPI_Value;                                  }                                  else                                  { // If its not a separator and not whitespace                                      sb.Append(whitespaceSB);                                      sb.Append(testchar);                                      parsedNames[stringCount] = sb.ToString(); // Need to set the name here in case the string ends here.                                      state = MPIState.MPI_ParseNonQuote;                                  }                              }                              else                              {                                  whitespaceSB.Append(testchar);                              }                              break;                          }                        case MPIState.MPI_ParseQuote:                          {                              if (testchar == rightQuoteChar)                              {    // if se are on a right quote see if we are escaping the right quote or ending the quoted string                                                              if (!removequotes)                                  {                                      sb.Append(testchar);                                  }                                  state = MPIState.MPI_RightQuote;                              }                              else                              {                                  sb.Append(testchar); // Append what we are currently parsing                              }                              break;                          }                        case MPIState.MPI_RightQuote:                          {                              if (testchar == rightQuoteChar)                              { // If the next char is another right quote then we were escaping the right quote                                  sb.Append(testchar);                                  state = MPIState.MPI_ParseQuote;                              }                              else                              if (testchar == separator)                              {      // If its a separator then record what we've parsed                                  parsedNames[stringCount] = sb.ToString();                                  IncrementStringCount(name' parsedNames' ref stringCount' property);                                  state = MPIState.MPI_Value;                              }                              else                              if (!IsWhitespace(testchar))                              { // If it is not whitespace we got problems                                  throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                              }                              else                              {                          // It is a whitespace character so the following char should be whitespace' separator' or end of string anything else is bad                                  parsedNames[stringCount] = sb.ToString();                                  state = MPIState.MPI_LookForSeparator;                              }                              break;                          }                        case MPIState.MPI_LookForSeparator:                          {                              if (!IsWhitespace(testchar))                              { // If it is not whitespace                                  if (testchar == separator)                                  { // If it is a separator                                       IncrementStringCount(name' parsedNames' ref stringCount' property);                                      state = MPIState.MPI_Value;                                  }                                  else                                  { // Otherwise not a separator                                      throw ADP.InvalidMultipartNameIncorrectUsageOfQuotes(property' name);                                  }                              }                              break;                          }                  }
