Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Square,The method has 106 lines of code.
Long Method,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Multiply,The method has 122 lines of code.
Long Method,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The method has 183 lines of code.
Long Method,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The method has 165 lines of code.
Long Method,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The method has 165 lines of code.
Long Method,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The method has 105 lines of code.
Long Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The method has 209 lines of code.
Long Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToString,The method has 130 lines of code.
Long Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatFixed,The method has 106 lines of code.
Long Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The method has 365 lines of code.
Complex Method,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,Cyclomatic complexity of the method is 10
Complex Method,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,Cyclomatic complexity of the method is 13
Complex Method,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,Cyclomatic complexity of the method is 11
Complex Method,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Pow,Cyclomatic complexity of the method is 8
Complex Method,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,Cyclomatic complexity of the method is 16
Complex Method,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,Cyclomatic complexity of the method is 10
Complex Method,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,Cyclomatic complexity of the method is 21
Complex Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,Cyclomatic complexity of the method is 25
Complex Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,Cyclomatic complexity of the method is 8
Complex Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatFixed,Cyclomatic complexity of the method is 17
Complex Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatGeneral,Cyclomatic complexity of the method is 8
Complex Method,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,Cyclomatic complexity of the method is 17
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Add,The method has 6 parameters. Parameters: left' leftLength' right' rightLength' bits' bitsLength
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Subtract,The method has 6 parameters. Parameters: left' leftLength' right' rightLength' bits' bitsLength
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The method has 6 parameters. Parameters: left' leftLength' right' rightLength' bits' bitsLength
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractDivisor,The method has 5 parameters. Parameters: left' leftLength' right' rightLength' q
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,DivideGuessTooBig,The method has 5 parameters. Parameters: q' valHi' valLo' divHi' divLo
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LehmerCore,The method has 6 parameters. Parameters: xBuffer' yBuffer' a' b' c' d
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,PowCore,The method has 5 parameters. Parameters: power' modulus' value' result' temp
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,PowCore,The method has 5 parameters. Parameters: power' modulus' value' result' temp
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,PowCore,The method has 5 parameters. Parameters: power' reducer' value' result' temp
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,PowCore,The method has 5 parameters. Parameters: power' reducer' value' result' temp
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Multiply,The method has 6 parameters. Parameters: left' leftLength' right' rightLength' bits' bitsLength
Long Parameter List,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractCore,The method has 6 parameters. Parameters: left' leftLength' right' rightLength' core' coreLength
Long Parameter List,System.Numerics,FastReducer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.FastReducer.cs,DivMul,The method has 6 parameters. Parameters: left' leftLength' right' rightLength' bits' k
Long Parameter List,System.Numerics,FastReducer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.FastReducer.cs,SubMod,The method has 6 parameters. Parameters: left' leftLength' right' rightLength' modulus' k
Long Parameter List,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The method has 5 parameters. Parameters: mode' destination' isUnsigned' isBigEndian' bytesWritten
Long Parameter List,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The method has 8 parameters. Parameters: targetSpan' value' format' digits' info' destination' charsWritten' spanSuccess
Long Parameter List,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,TryFormatBigInteger,The method has 5 parameters. Parameters: value' format' info' destination' charsWritten
Long Parameter List,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The method has 8 parameters. Parameters: targetSpan' value' formatString' formatSpan' info' destination' charsWritten' spanSuccess
Long Parameter List,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The method has 5 parameters. Parameters: dbl' sign' exp' man' fFinite
Long Parameter List,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The method has 5 parameters. Parameters: x' y' b' bPrime' v
Long Parameter List,System.Globalization,FormatProvider,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.BigInteger.cs,FormatBigInteger,The method has 8 parameters. Parameters: sb' precision' scale' sign' format' numberFormatInfo' digits' startIndex
Long Parameter List,System.Globalization,FormatProvider,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.BigInteger.cs,TryStringToBigInteger,The method has 7 parameters. Parameters: s' styles' numberFormatInfo' receiver' precision' scale' sign
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The method has 6 parameters. Parameters: str' options' number' sb' numfmt' parseDecimal
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,TryStringToNumber,The method has 6 parameters. Parameters: str' options' number' sb' numfmt' parseDecimal
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToString,The method has 6 parameters. Parameters: sb' number' format' nMaxDigits' info' isDecimal
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatCurrency,The method has 5 parameters. Parameters: sb' number' nMinDigits' nMaxDigits' info
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatFixed,The method has 8 parameters. Parameters: sb' number' nMinDigits' nMaxDigits' info' groupDigits' sDecimal' sGroup
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatNumber,The method has 5 parameters. Parameters: sb' number' nMinDigits' nMaxDigits' info
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatScientific,The method has 6 parameters. Parameters: sb' number' nMinDigits' nMaxDigits' info' expChar
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatExponent,The method has 6 parameters. Parameters: sb' info' value' expChar' minDigits' positiveSign
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatGeneral,The method has 7 parameters. Parameters: sb' number' nMinDigits' nMaxDigits' info' expChar' bSuppressScientific
Long Parameter List,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatPercent,The method has 5 parameters. Parameters: sb' number' nMinDigits' nMaxDigits' info
Long Statement,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,ModPow,The length of the statement  "                uint bits = trivialValue && trivialExponent ? BigIntegerCalculator.Pow(NumericsHelpers.Abs(value._sign)' NumericsHelpers.Abs(exponent._sign)' NumericsHelpers.Abs(modulus._sign)) : " is 179.
Long Statement,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,ModPow,The length of the statement  "                            trivialValue ? BigIntegerCalculator.Pow(NumericsHelpers.Abs(value._sign)' exponent._bits' NumericsHelpers.Abs(modulus._sign)) : " is 127.
Long Statement,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,ModPow,The length of the statement  "                            trivialExponent ? BigIntegerCalculator.Pow(value._bits' NumericsHelpers.Abs(exponent._sign)' NumericsHelpers.Abs(modulus._sign)) : " is 130.
Long Statement,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,ModPow,The length of the statement  "                uint[] bits = trivialValue && trivialExponent ? BigIntegerCalculator.Pow(NumericsHelpers.Abs(value._sign)' NumericsHelpers.Abs(exponent._sign)' modulus._bits) : " is 160.
Long Statement,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The length of the statement  "            Debug.Assert(mode == GetBytesMode.AllocateArray || mode == GetBytesMode.Count || mode == GetBytesMode.Span' $"Unexpected mode {mode}."); " is 136.
Long Statement,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The length of the statement  "            Debug.Assert(mode == GetBytesMode.Span || destination.IsEmpty' $"If we're not in span mode' we shouldn't have been passed a destination."); " is 139.
Long Statement,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryFormat,The length of the statement  "            return BigNumber.TryFormatBigInteger(this' format' NumberFormatInfo.GetInstance(provider)' destination' out charsWritten); " is 122.
Long Statement,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,TryParseBigInteger,The length of the statement  "                if (!FormatProvider.TryStringToBigInteger(value' style' info' bignumber.digits' out bignumber.precision' out bignumber.scale' out bignumber.sign)) " is 146.
Long Statement,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,ToString,The length of the statement  "            return string.Format(CultureInfo.CurrentCulture' "({0}' {1})"' m_real.ToString(format' CultureInfo.CurrentCulture)' m_imaginary.ToString(format' CultureInfo.CurrentCulture)); " is 174.
Long Statement,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,ToString,The length of the statement  "            return string.Format(provider' "({0}' {1})"' m_real.ToString(format' provider)' m_imaginary.ToString(format' provider)); " is 120.
Long Statement,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The length of the statement  "            // (https://www.researchgate.net/profile/Ping_Tang3/publication/220493330_Implementing_the_Complex_Arcsine_and_Arccosine_Functions_Using_Exception_Handling/links/55b244b208ae9289a085245d.pdf) " is 191.
Long Statement,System.Globalization,FormatProvider,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.BigInteger.cs,TryStringToBigInteger,The length of the statement  "                // Just in case a bug is ever introduced into TryStringToNumber that violates this' set the pointer that numberBuffer.digits returns " is 132.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                    // The idea here is to match the currency separators and on failure match the number separators to keep the perf of VB's IsNumeric fast. " is 136.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                    // The values of decSep are setup to use the correct relevant separator (currency in the if part and decimal in the else part). " is 127.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                bool bigNumber = (sb != null); // When a StringBuilder is provided then we use it in place of the number.digits char[50] " is 120.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                    if (!IsWhite(ch) || (options & NumberStyles.AllowLeadingWhite) == 0 || ((state & StateSign) != 0 && ((state & StateCurrency) == 0 && numfmt.NumberNegativePattern != 2))) " is 169.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                        if ((((options & NumberStyles.AllowLeadingSign) != 0) && (state & StateSign) == 0) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || ((next = MatchChars(p' numfmt.NegativeSign)) != null && (number.sign = true)))) " is 221.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                    if ((ch >= '0' && ch <= '9') || (((options & NumberStyles.AllowHexSpecifier) != 0) && ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')))) " is 142.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                    else if (((options & NumberStyles.AllowDecimalPoint) != 0) && ((state & StateDecimal) == 0) && ((next = MatchChars(p' decSep)) != null || ((parsingCurrency) && (state & StateCurrency) == 0) && (next = MatchChars(p' numfmt.NumberDecimalSeparator)) != null)) " is 256.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                    else if (((options & NumberStyles.AllowThousands) != 0) && ((state & StateDigits) != 0) && ((state & StateDecimal) == 0) && ((next = MatchChars(p' groupSep)) != null || ((parsingCurrency) && (state & StateCurrency) == 0) && (next = MatchChars(p' numfmt.NumberGroupSeparator)) != null)) " is 285.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The length of the statement  "                            if (((options & NumberStyles.AllowTrailingSign) != 0 && ((state & StateSign) == 0)) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || (((next = MatchChars(p' numfmt.NegativeSign)) != null) && (number.sign = true)))) " is 224.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The length of the statement  "                return format.Length == 0 || c == '\0' ? // For compat' treat '\0' as the end of the specifier' even if the specifier extends beyond it. " is 136.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToString,The length of the statement  "                            RoundNumber(ref number' number.scale + nMaxDigits); // Don't change this line to use digPos since digCount could have its sign changed. " is 135.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatCurrency,The length of the statement  "                            FormatFixed(ref sb' ref number' nMinDigits' nMaxDigits' info' info.CurrencyGroupSizes' info.CurrencyDecimalSeparator' info.CurrencyGroupSeparator); " is 147.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatNumber,The length of the statement  "                            FormatFixed(ref sb' ref number' nMinDigits' nMaxDigits' info' info.NumberGroupSizes' info.NumberDecimalSeparator' info.NumberGroupSeparator); " is 141.
Long Statement,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatPercent,The length of the statement  "                            FormatFixed(ref sb' ref number' nMinDigits' nMaxDigits' info' info.PercentGroupSizes' info.PercentDecimalSeparator' info.PercentGroupSeparator); " is 144.
Long Statement,System.Text,ValueStringBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Text\ValueStringBuilder.cs,Append,The length of the statement  "            if (s.Length == 1 && pos < _chars.Length) // very common case' e.g. appending strings from NumberFormatInfo like separators' percent symbols' etc. " is 146.
Complex Conditional,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,ParseFormatSpecifier,The conditional expression  "ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z'"  is complex.
Complex Conditional,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The conditional expression  "fmt == 'g' || fmt == 'G' || fmt == 'r' || fmt == 'R'"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The conditional expression  "!IsWhite(ch) || (options & NumberStyles.AllowLeadingWhite) == 0 || ((state & StateSign) != 0 && ((state & StateCurrency) == 0 && numfmt.NumberNegativePattern != 2))"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The conditional expression  "(((options & NumberStyles.AllowLeadingSign) != 0) && (state & StateSign) == 0) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || ((next = MatchChars(p' numfmt.NegativeSign)) != null && (number.sign = true)))"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The conditional expression  "(ch >= '0' && ch <= '9') || (((options & NumberStyles.AllowHexSpecifier) != 0) && ((ch >= 'a' && ch <= 'f') || (ch >= 'A' && ch <= 'F')))"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The conditional expression  "ch != '0' || (state & StateNonZero) != 0 || (bigNumber && ((options & NumberStyles.AllowHexSpecifier) != 0))"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The conditional expression  "((options & NumberStyles.AllowDecimalPoint) != 0) && ((state & StateDecimal) == 0) && ((next = MatchChars(p' decSep)) != null || ((parsingCurrency) && (state & StateCurrency) == 0) && (next = MatchChars(p' numfmt.NumberDecimalSeparator)) != null)"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The conditional expression  "((options & NumberStyles.AllowThousands) != 0) && ((state & StateDigits) != 0) && ((state & StateDecimal) == 0) && ((next = MatchChars(p' groupSep)) != null || ((parsingCurrency) && (state & StateCurrency) == 0) && (next = MatchChars(p' numfmt.NumberGroupSeparator)) != null)"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The conditional expression  "((options & NumberStyles.AllowTrailingSign) != 0 && ((state & StateSign) == 0)) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || (((next = MatchChars(p' numfmt.NegativeSign)) != null) && (number.sign = true)))"  is complex.
Complex Conditional,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The conditional expression  "(src < format.Length && pFormat[src] == '0') ||                                          (src + 1 < format.Length && (pFormat[src] == '+' || pFormat[src] == '-') && pFormat[src + 1] == '0')"  is complex.
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Add,The following statement contains a magic number: long carry = digit >> 32;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Add,The following statement contains a magic number: for (int i = 1; i < left.Length; i++)              {                  digit = left[i] + carry;                  bits[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Add,The following statement contains a magic number: for (; i < rightLength; i++)              {                  long digit = (left[i] + carry) + right[i];                  bits[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Add,The following statement contains a magic number: for (; i < leftLength; i++)              {                  long digit = left[i] + carry;                  bits[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,AddSelf,The following statement contains a magic number: for (; i < rightLength; i++)              {                  long digit = (left[i] + carry) + right[i];                  left[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,AddSelf,The following statement contains a magic number: for (; carry != 0 && i < leftLength; i++)              {                  long digit = left[i] + carry;                  left[i] = (uint)digit;                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Subtract,The following statement contains a magic number: Debug.Assert(left[0] >= right || left.Length >= 2);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Subtract,The following statement contains a magic number: long carry = digit >> 32;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Subtract,The following statement contains a magic number: for (int i = 1; i < left.Length; i++)              {                  digit = left[i] + carry;                  bits[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Subtract,The following statement contains a magic number: for (; i < rightLength; i++)              {                  long digit = (left[i] + carry) - right[i];                  bits[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Subtract,The following statement contains a magic number: for (; i < leftLength; i++)              {                  long digit = left[i] + carry;                  bits[i] = (uint)digit;                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractSelf,The following statement contains a magic number: for (; i < rightLength; i++)              {                  long digit = (left[i] + carry) - right[i];                  left[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractSelf,The following statement contains a magic number: for (; carry != 0 && i < leftLength; i++)              {                  long digit = left[i] + carry;                  left[i] = (uint)digit;                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: for (int i = left.Length - 1; i >= 0; i--)              {                  ulong value = (carry << 32) | left[i];                  ulong digit = value / right;                  quotient[i] = (uint)digit;                  carry = value - digit * right;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: for (int i = left.Length - 1; i >= 0; i--)              {                  ulong value = (carry << 32) | left[i];                  ulong digit = value / right;                  quotient[i] = (uint)digit;                  carry = value - digit * right;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Remainder,The following statement contains a magic number: for (int i = left.Length - 1; i >= 0; i--)              {                  ulong value = (carry << 32) | left[i];                  carry = value % right;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: uint divLo = rightLength > 1 ? right[rightLength - 2] : 0;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: int backShift = 32 - shift;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: if (shift > 0)              {                  uint divNx = rightLength > 2 ? right[rightLength - 3] : 0;                    divHi = (divHi << shift) | (divLo >> backShift);                  divLo = (divLo << shift) | (divNx >> backShift);              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: if (shift > 0)              {                  uint divNx = rightLength > 2 ? right[rightLength - 3] : 0;                    divHi = (divHi << shift) | (divLo >> backShift);                  divLo = (divLo << shift) | (divNx >> backShift);              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: for (int i = leftLength; i >= rightLength; i--)              {                  int n = i - rightLength;                  uint t = i < leftLength ? left[i] : 0;                    ulong valHi = ((ulong)t << 32) | left[i - 1];                  uint valLo = i > 1 ? left[i - 2] : 0;                    // We shifted the divisor' we shift the dividend too                  if (shift > 0)                  {                      uint valNx = i > 2 ? left[i - 3] : 0;                        valHi = (valHi << shift) | (valLo >> backShift);                      valLo = (valLo << shift) | (valNx >> backShift);                  }                    // First guess for the current digit of the quotient'                  // which naturally must have only 32 bits...                  ulong digit = valHi / divHi;                  if (digit > 0xFFFFFFFF)                      digit = 0xFFFFFFFF;                    // Our first guess may be a little bit to big                  while (DivideGuessTooBig(digit' valHi' valLo' divHi' divLo))                      --digit;                    if (digit > 0)                  {                      // Now it's time to subtract our current quotient                      uint carry = SubtractDivisor(left + n' leftLength - n'                                                   right' rightLength' digit);                      if (carry != t)                      {                          Debug.Assert(carry == t + 1);                            // Our guess was still exactly one too high                          carry = AddDivisor(left + n' leftLength - n'                                             right' rightLength);                          --digit;                            Debug.Assert(carry == 1);                      }                  }                    // We have the digit!                  if (bitsLength != 0)                      bits[n] = (uint)digit;                  if (i < leftLength)                      left[i] = 0;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: for (int i = leftLength; i >= rightLength; i--)              {                  int n = i - rightLength;                  uint t = i < leftLength ? left[i] : 0;                    ulong valHi = ((ulong)t << 32) | left[i - 1];                  uint valLo = i > 1 ? left[i - 2] : 0;                    // We shifted the divisor' we shift the dividend too                  if (shift > 0)                  {                      uint valNx = i > 2 ? left[i - 3] : 0;                        valHi = (valHi << shift) | (valLo >> backShift);                      valLo = (valLo << shift) | (valNx >> backShift);                  }                    // First guess for the current digit of the quotient'                  // which naturally must have only 32 bits...                  ulong digit = valHi / divHi;                  if (digit > 0xFFFFFFFF)                      digit = 0xFFFFFFFF;                    // Our first guess may be a little bit to big                  while (DivideGuessTooBig(digit' valHi' valLo' divHi' divLo))                      --digit;                    if (digit > 0)                  {                      // Now it's time to subtract our current quotient                      uint carry = SubtractDivisor(left + n' leftLength - n'                                                   right' rightLength' digit);                      if (carry != t)                      {                          Debug.Assert(carry == t + 1);                            // Our guess was still exactly one too high                          carry = AddDivisor(left + n' leftLength - n'                                             right' rightLength);                          --digit;                            Debug.Assert(carry == 1);                      }                  }                    // We have the digit!                  if (bitsLength != 0)                      bits[n] = (uint)digit;                  if (i < leftLength)                      left[i] = 0;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: for (int i = leftLength; i >= rightLength; i--)              {                  int n = i - rightLength;                  uint t = i < leftLength ? left[i] : 0;                    ulong valHi = ((ulong)t << 32) | left[i - 1];                  uint valLo = i > 1 ? left[i - 2] : 0;                    // We shifted the divisor' we shift the dividend too                  if (shift > 0)                  {                      uint valNx = i > 2 ? left[i - 3] : 0;                        valHi = (valHi << shift) | (valLo >> backShift);                      valLo = (valLo << shift) | (valNx >> backShift);                  }                    // First guess for the current digit of the quotient'                  // which naturally must have only 32 bits...                  ulong digit = valHi / divHi;                  if (digit > 0xFFFFFFFF)                      digit = 0xFFFFFFFF;                    // Our first guess may be a little bit to big                  while (DivideGuessTooBig(digit' valHi' valLo' divHi' divLo))                      --digit;                    if (digit > 0)                  {                      // Now it's time to subtract our current quotient                      uint carry = SubtractDivisor(left + n' leftLength - n'                                                   right' rightLength' digit);                      if (carry != t)                      {                          Debug.Assert(carry == t + 1);                            // Our guess was still exactly one too high                          carry = AddDivisor(left + n' leftLength - n'                                             right' rightLength);                          --digit;                            Debug.Assert(carry == 1);                      }                  }                    // We have the digit!                  if (bitsLength != 0)                      bits[n] = (uint)digit;                  if (i < leftLength)                      left[i] = 0;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Divide,The following statement contains a magic number: for (int i = leftLength; i >= rightLength; i--)              {                  int n = i - rightLength;                  uint t = i < leftLength ? left[i] : 0;                    ulong valHi = ((ulong)t << 32) | left[i - 1];                  uint valLo = i > 1 ? left[i - 2] : 0;                    // We shifted the divisor' we shift the dividend too                  if (shift > 0)                  {                      uint valNx = i > 2 ? left[i - 3] : 0;                        valHi = (valHi << shift) | (valLo >> backShift);                      valLo = (valLo << shift) | (valNx >> backShift);                  }                    // First guess for the current digit of the quotient'                  // which naturally must have only 32 bits...                  ulong digit = valHi / divHi;                  if (digit > 0xFFFFFFFF)                      digit = 0xFFFFFFFF;                    // Our first guess may be a little bit to big                  while (DivideGuessTooBig(digit' valHi' valLo' divHi' divLo))                      --digit;                    if (digit > 0)                  {                      // Now it's time to subtract our current quotient                      uint carry = SubtractDivisor(left + n' leftLength - n'                                                   right' rightLength' digit);                      if (carry != t)                      {                          Debug.Assert(carry == t + 1);                            // Our guess was still exactly one too high                          carry = AddDivisor(left + n' leftLength - n'                                             right' rightLength);                          --digit;                            Debug.Assert(carry == 1);                      }                  }                    // We have the digit!                  if (bitsLength != 0)                      bits[n] = (uint)digit;                  if (i < leftLength)                      left[i] = 0;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,AddDivisor,The following statement contains a magic number: for (int i = 0; i < rightLength; i++)              {                  ulong digit = (left[i] + carry) + right[i];                  left[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractDivisor,The following statement contains a magic number: for (int i = 0; i < rightLength; i++)              {                  carry += right[i] * q;                  uint digit = unchecked((uint)carry);                  carry = carry >> 32;                  if (left[i] < digit)                      ++carry;                  left[i] = unchecked(left[i] - digit);              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,DivideGuessTooBig,The following statement contains a magic number: chkHi = chkHi + (chkLo >> 32);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if (value == 0)                  return 32;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0)              {                  count += 16;                  value = value << 16;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xFFFF0000) == 0)              {                  count += 16;                  value = value << 16;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xFF000000) == 0)              {                  count += 8;                  value = value << 8;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xFF000000) == 0)              {                  count += 8;                  value = value << 8;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xF0000000) == 0)              {                  count += 4;                  value = value << 4;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xF0000000) == 0)              {                  count += 4;                  value = value << 4;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xC0000000) == 0)              {                  count += 2;                  value = value << 2;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LeadingZeros,The following statement contains a magic number: if ((value & 0xC0000000) == 0)              {                  count += 2;                  value = value << 2;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: Debug.Assert(left.Length >= 2);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: Debug.Assert(right.Length >= 2);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: Debug.Assert(left.GetLength() >= 2);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: Debug.Assert(right.GetLength() >= 2);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: while (right.GetLength() > 2)              {                  ulong x' y;                    ExtractDigits(ref left' ref right' out x' out y);                    uint a = 1U' b = 0U;                  uint c = 0U' d = 1U;                    int iteration = 0;                    // Lehmer's guessing                  while (y != 0)                  {                      ulong q' r' s' t;                        // Odd iteration                      q = x / y;                        if (q > 0xFFFFFFFF)                          break;                        r = a + q * c;                      s = b + q * d;                      t = x - q * y;                        if (r > 0x7FFFFFFF || s > 0x7FFFFFFF)                          break;                      if (t < s || t + r > y - c)                          break;                        a = (uint)r;                      b = (uint)s;                      x = t;                        ++iteration;                      if (x == b)                          break;                        // Even iteration                      q = y / x;                        if (q > 0xFFFFFFFF)                          break;                        r = d + q * b;                      s = c + q * a;                      t = y - q * x;                        if (r > 0x7FFFFFFF || s > 0x7FFFFFFF)                          break;                      if (t < s || t + r > x - b)                          break;                        d = (uint)r;                      c = (uint)s;                      y = t;                        ++iteration;                      if (y == c)                          break;                  }                    if (b == 0)                  {                      // Euclid's step                      left.Reduce(ref right);                        BitsBuffer temp = left;                      left = right;                      right = temp;                  }                  else                  {                      // Lehmer's step                      LehmerCore(ref left' ref right' a' b' c' d);                        if (iteration % 2 == 1)                      {                          // Ensure left is larger than right                          BitsBuffer temp = left;                          left = right;                          right = temp;                      }                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: while (right.GetLength() > 2)              {                  ulong x' y;                    ExtractDigits(ref left' ref right' out x' out y);                    uint a = 1U' b = 0U;                  uint c = 0U' d = 1U;                    int iteration = 0;                    // Lehmer's guessing                  while (y != 0)                  {                      ulong q' r' s' t;                        // Odd iteration                      q = x / y;                        if (q > 0xFFFFFFFF)                          break;                        r = a + q * c;                      s = b + q * d;                      t = x - q * y;                        if (r > 0x7FFFFFFF || s > 0x7FFFFFFF)                          break;                      if (t < s || t + r > y - c)                          break;                        a = (uint)r;                      b = (uint)s;                      x = t;                        ++iteration;                      if (x == b)                          break;                        // Even iteration                      q = y / x;                        if (q > 0xFFFFFFFF)                          break;                        r = d + q * b;                      s = c + q * a;                      t = y - q * x;                        if (r > 0x7FFFFFFF || s > 0x7FFFFFFF)                          break;                      if (t < s || t + r > x - b)                          break;                        d = (uint)r;                      c = (uint)s;                      y = t;                        ++iteration;                      if (y == c)                          break;                  }                    if (b == 0)                  {                      // Euclid's step                      left.Reduce(ref right);                        BitsBuffer temp = left;                      left = right;                      right = temp;                  }                  else                  {                      // Lehmer's step                      LehmerCore(ref left' ref right' a' b' c' d);                        if (iteration % 2 == 1)                      {                          // Ensure left is larger than right                          BitsBuffer temp = left;                          left = right;                          right = temp;                      }                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: if (right.GetLength() > 0)              {                  // Euclid's step                  left.Reduce(ref right);                    uint[] xBits = right.GetBits();                  uint[] yBits = left.GetBits();                    ulong x = ((ulong)xBits[1] << 32) | xBits[0];                  ulong y = ((ulong)yBits[1] << 32) | yBits[0];                    left.Overwrite(Gcd(x' y));                  right.Overwrite(0);              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Gcd,The following statement contains a magic number: if (right.GetLength() > 0)              {                  // Euclid's step                  left.Reduce(ref right);                    uint[] xBits = right.GetBits();                  uint[] yBits = left.GetBits();                    ulong x = ((ulong)xBits[1] << 32) | xBits[0];                  ulong y = ((ulong)yBits[1] << 32) | yBits[0];                    left.Overwrite(Gcd(x' y));                  right.Overwrite(0);              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: Debug.Assert(xBuffer.GetLength() >= 3);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: Debug.Assert(yBuffer.GetLength() >= 3);
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: ulong xm = xBits[xLength - 2];
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: ulong xl = xBits[xLength - 3];
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: switch (xLength - yLength)              {                  case 0:                      yh = yBits[yLength - 1];                      ym = yBits[yLength - 2];                      yl = yBits[yLength - 3];                      break;                    case 1:                      yh = 0UL;                      ym = yBits[yLength - 1];                      yl = yBits[yLength - 2];                      break;                    case 2:                      yh = 0UL;                      ym = 0UL;                      yl = yBits[yLength - 1];                      break;                    default:                      yh = 0UL;                      ym = 0UL;                      yl = 0UL;                      break;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: switch (xLength - yLength)              {                  case 0:                      yh = yBits[yLength - 1];                      ym = yBits[yLength - 2];                      yl = yBits[yLength - 3];                      break;                    case 1:                      yh = 0UL;                      ym = yBits[yLength - 1];                      yl = yBits[yLength - 2];                      break;                    case 2:                      yh = 0UL;                      ym = 0UL;                      yl = yBits[yLength - 1];                      break;                    default:                      yh = 0UL;                      ym = 0UL;                      yl = 0UL;                      break;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: switch (xLength - yLength)              {                  case 0:                      yh = yBits[yLength - 1];                      ym = yBits[yLength - 2];                      yl = yBits[yLength - 3];                      break;                    case 1:                      yh = 0UL;                      ym = yBits[yLength - 1];                      yl = yBits[yLength - 2];                      break;                    case 2:                      yh = 0UL;                      ym = 0UL;                      yl = yBits[yLength - 1];                      break;                    default:                      yh = 0UL;                      ym = 0UL;                      yl = 0UL;                      break;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: switch (xLength - yLength)              {                  case 0:                      yh = yBits[yLength - 1];                      ym = yBits[yLength - 2];                      yl = yBits[yLength - 3];                      break;                    case 1:                      yh = 0UL;                      ym = yBits[yLength - 1];                      yl = yBits[yLength - 2];                      break;                    case 2:                      yh = 0UL;                      ym = 0UL;                      yl = yBits[yLength - 1];                      break;                    default:                      yh = 0UL;                      ym = 0UL;                      yl = 0UL;                      break;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: x = ((xh << 32 + z) | (xm << z) | (xl >> 32 - z)) >> 1;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: x = ((xh << 32 + z) | (xm << z) | (xl >> 32 - z)) >> 1;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: y = ((yh << 32 + z) | (ym << z) | (yl >> 32 - z)) >> 1;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,ExtractDigits,The following statement contains a magic number: y = ((yh << 32 + z) | (ym << z) | (yl >> 32 - z)) >> 1;
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LehmerCore,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  long xDigit = a * x[i] - b * y[i] + xCarry;                  long yDigit = d * y[i] - c * x[i] + yCarry;                  xCarry = xDigit >> 32;                  yCarry = yDigit >> 32;                  x[i] = unchecked((uint)xDigit);                  y[i] = unchecked((uint)yDigit);              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,LehmerCore,The following statement contains a magic number: for (int i = 0; i < length; i++)              {                  long xDigit = a * x[i] - b * y[i] + xCarry;                  long yDigit = d * y[i] - c * x[i] + yCarry;                  xCarry = xDigit >> 32;                  yCarry = yDigit >> 32;                  x[i] = unchecked((uint)xDigit);                  y[i] = unchecked((uint)yDigit);              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,PowCore,The following statement contains a magic number: for (int i = 0; i < power.Length - 1; i++)              {                  uint p = power[i];                  for (int j = 0; j < 32; j++)                  {                      if ((p & 1) == 1)                          result = (result * value) % modulus;                      value = (value * value) % modulus;                      p = p >> 1;                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,PowCore,The following statement contains a magic number: for (int i = 0; i < power.Length - 1; i++)              {                  uint p = power[i];                  for (int j = 0; j < 32; j++)                  {                      if ((p & 1) == 1)                      {                          result.MultiplySelf(ref value' ref temp);                          result.Reduce(modulus);                      }                      value.SquareSelf(ref temp);                      value.Reduce(modulus);                      p = p >> 1;                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,PowCore,The following statement contains a magic number: for (int i = 0; i < power.Length - 1; i++)              {                  uint p = power[i];                  for (int j = 0; j < 32; j++)                  {                      if ((p & 1) == 1)                      {                          result.MultiplySelf(ref value' ref temp);                          result.Reduce(ref reducer);                      }                      value.SquareSelf(ref temp);                      value.Reduce(ref reducer);                      p = p >> 1;                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Square,The following statement contains a magic number: if (valueLength < SquareThreshold)              {                  // Squares the bits using the "grammar-school" method.                  // Envisioning the "rhombus" of a pen-and-paper calculation                  // we see that computing z_i+j += a_j * a_i can be optimized                  // since a_j * a_i = a_i * a_j (we're squaring after all!).                  // Thus' we directly get z_i+j += 2 * a_j * a_i + c.                    // ATTENTION: an ordinary multiplication is safe' because                  // z_i+j + a_j * a_i + c <= 2(2^32 - 1) + (2^32 - 1)^2 =                  // = 2^64 - 1 (which perfectly matches with ulong!). But                  // here we would need an UInt65... Hence' we split these                  // operation and do some extra shifts.                    for (int i = 0; i < valueLength; i++)                  {                      ulong carry = 0UL;                      for (int j = 0; j < i; j++)                      {                          ulong digit1 = bits[i + j] + carry;                          ulong digit2 = (ulong)value[j] * value[i];                          bits[i + j] = unchecked((uint)(digit1 + (digit2 << 1)));                          carry = (digit2 + (digit1 >> 1)) >> 31;                      }                      ulong digits = (ulong)value[i] * value[i] + carry;                      bits[i + i] = unchecked((uint)digits);                      bits[i + i + 1] = (uint)(digits >> 32);                  }              }              else              {                  // Based on the Toom-Cook multiplication we split value                  // into two smaller values' doing recursive squaring.                  // The special form of this multiplication' where we                  // split both operands into two operands' is also known                  // as the Karatsuba algorithm...                    // https://en.wikipedia.org/wiki/Toom-Cook_multiplication                  // https://en.wikipedia.org/wiki/Karatsuba_algorithm                    // Say we want to compute z = a * a ...                    // ... we need to determine our new length (just the half)                  int n = valueLength >> 1;                  int n2 = n << 1;                    // ... split value like a = (a_1 << n) + a_0                  uint* valueLow = value;                  int valueLowLength = n;                  uint* valueHigh = value + n;                  int valueHighLength = valueLength - n;                    // ... prepare our result array (to reuse its memory)                  uint* bitsLow = bits;                  int bitsLowLength = n2;                  uint* bitsHigh = bits + n2;                  int bitsHighLength = bitsLength - n2;                    // ... compute z_0 = a_0 * a_0 (squaring again!)                  Square(valueLow' valueLowLength'                         bitsLow' bitsLowLength);                    // ... compute z_2 = a_1 * a_1 (squaring again!)                  Square(valueHigh' valueHighLength'                         bitsHigh' bitsHighLength);                    int foldLength = valueHighLength + 1;                  int coreLength = foldLength + foldLength;                    if (coreLength < AllocationThreshold)                  {                      uint* fold = stackalloc uint[foldLength];                      uint* core = stackalloc uint[coreLength];                        // ... compute z_a = a_1 + a_0 (call it fold...)                      Add(valueHigh' valueHighLength'                          valueLow' valueLowLength'                          fold' foldLength);                        // ... compute z_1 = z_a * z_a - z_0 - z_2                      Square(fold' foldLength'                             core' coreLength);                      SubtractCore(bitsHigh' bitsHighLength'                                   bitsLow' bitsLowLength'                                   core' coreLength);                        // ... and finally merge the result! :-)                      AddSelf(bits + n' bitsLength - n' core' coreLength);                  }                  else                  {                      fixed (uint* fold = new uint[foldLength]'                                   core = new uint[coreLength])                      {                          // ... compute z_a = a_1 + a_0 (call it fold...)                          Add(valueHigh' valueHighLength'                              valueLow' valueLowLength'                              fold' foldLength);                            // ... compute z_1 = z_a * z_a - z_0 - z_2                          Square(fold' foldLength'                                 core' coreLength);                          SubtractCore(bitsHigh' bitsHighLength'                                       bitsLow' bitsLowLength'                                       core' coreLength);                            // ... and finally merge the result! :-)                          AddSelf(bits + n' bitsLength - n' core' coreLength);                      }                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Square,The following statement contains a magic number: if (valueLength < SquareThreshold)              {                  // Squares the bits using the "grammar-school" method.                  // Envisioning the "rhombus" of a pen-and-paper calculation                  // we see that computing z_i+j += a_j * a_i can be optimized                  // since a_j * a_i = a_i * a_j (we're squaring after all!).                  // Thus' we directly get z_i+j += 2 * a_j * a_i + c.                    // ATTENTION: an ordinary multiplication is safe' because                  // z_i+j + a_j * a_i + c <= 2(2^32 - 1) + (2^32 - 1)^2 =                  // = 2^64 - 1 (which perfectly matches with ulong!). But                  // here we would need an UInt65... Hence' we split these                  // operation and do some extra shifts.                    for (int i = 0; i < valueLength; i++)                  {                      ulong carry = 0UL;                      for (int j = 0; j < i; j++)                      {                          ulong digit1 = bits[i + j] + carry;                          ulong digit2 = (ulong)value[j] * value[i];                          bits[i + j] = unchecked((uint)(digit1 + (digit2 << 1)));                          carry = (digit2 + (digit1 >> 1)) >> 31;                      }                      ulong digits = (ulong)value[i] * value[i] + carry;                      bits[i + i] = unchecked((uint)digits);                      bits[i + i + 1] = (uint)(digits >> 32);                  }              }              else              {                  // Based on the Toom-Cook multiplication we split value                  // into two smaller values' doing recursive squaring.                  // The special form of this multiplication' where we                  // split both operands into two operands' is also known                  // as the Karatsuba algorithm...                    // https://en.wikipedia.org/wiki/Toom-Cook_multiplication                  // https://en.wikipedia.org/wiki/Karatsuba_algorithm                    // Say we want to compute z = a * a ...                    // ... we need to determine our new length (just the half)                  int n = valueLength >> 1;                  int n2 = n << 1;                    // ... split value like a = (a_1 << n) + a_0                  uint* valueLow = value;                  int valueLowLength = n;                  uint* valueHigh = value + n;                  int valueHighLength = valueLength - n;                    // ... prepare our result array (to reuse its memory)                  uint* bitsLow = bits;                  int bitsLowLength = n2;                  uint* bitsHigh = bits + n2;                  int bitsHighLength = bitsLength - n2;                    // ... compute z_0 = a_0 * a_0 (squaring again!)                  Square(valueLow' valueLowLength'                         bitsLow' bitsLowLength);                    // ... compute z_2 = a_1 * a_1 (squaring again!)                  Square(valueHigh' valueHighLength'                         bitsHigh' bitsHighLength);                    int foldLength = valueHighLength + 1;                  int coreLength = foldLength + foldLength;                    if (coreLength < AllocationThreshold)                  {                      uint* fold = stackalloc uint[foldLength];                      uint* core = stackalloc uint[coreLength];                        // ... compute z_a = a_1 + a_0 (call it fold...)                      Add(valueHigh' valueHighLength'                          valueLow' valueLowLength'                          fold' foldLength);                        // ... compute z_1 = z_a * z_a - z_0 - z_2                      Square(fold' foldLength'                             core' coreLength);                      SubtractCore(bitsHigh' bitsHighLength'                                   bitsLow' bitsLowLength'                                   core' coreLength);                        // ... and finally merge the result! :-)                      AddSelf(bits + n' bitsLength - n' core' coreLength);                  }                  else                  {                      fixed (uint* fold = new uint[foldLength]'                                   core = new uint[coreLength])                      {                          // ... compute z_a = a_1 + a_0 (call it fold...)                          Add(valueHigh' valueHighLength'                              valueLow' valueLowLength'                              fold' foldLength);                            // ... compute z_1 = z_a * z_a - z_0 - z_2                          Square(fold' foldLength'                                 core' coreLength);                          SubtractCore(bitsHigh' bitsHighLength'                                       bitsLow' bitsLowLength'                                       core' coreLength);                            // ... and finally merge the result! :-)                          AddSelf(bits + n' bitsLength - n' core' coreLength);                      }                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Multiply,The following statement contains a magic number: for (; i < left.Length; i++)              {                  ulong digits = (ulong)left[i] * right + carry;                  bits[i] = unchecked((uint)digits);                  carry = digits >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Multiply,The following statement contains a magic number: if (rightLength < MultiplyThreshold)              {                  // Multiplies the bits using the "grammar-school" method.                  // Envisioning the "rhombus" of a pen-and-paper calculation                  // should help getting the idea of these two loops...                  // The inner multiplication operations are safe' because                  // z_i+j + a_j * b_i + c <= 2(2^32 - 1) + (2^32 - 1)^2 =                  // = 2^64 - 1 (which perfectly matches with ulong!).                    for (int i = 0; i < rightLength; i++)                  {                      ulong carry = 0UL;                      for (int j = 0; j < leftLength; j++)                      {                          ulong digits = bits[i + j] + carry                              + (ulong)left[j] * right[i];                          bits[i + j] = unchecked((uint)digits);                          carry = digits >> 32;                      }                      bits[i + leftLength] = (uint)carry;                  }              }              else              {                  // Based on the Toom-Cook multiplication we split left/right                  // into two smaller values' doing recursive multiplication.                  // The special form of this multiplication' where we                  // split both operands into two operands' is also known                  // as the Karatsuba algorithm...                    // https://en.wikipedia.org/wiki/Toom-Cook_multiplication                  // https://en.wikipedia.org/wiki/Karatsuba_algorithm                    // Say we want to compute z = a * b ...                    // ... we need to determine our new length (just the half)                  int n = rightLength >> 1;                  int n2 = n << 1;                    // ... split left like a = (a_1 << n) + a_0                  uint* leftLow = left;                  int leftLowLength = n;                  uint* leftHigh = left + n;                  int leftHighLength = leftLength - n;                    // ... split right like b = (b_1 << n) + b_0                  uint* rightLow = right;                  int rightLowLength = n;                  uint* rightHigh = right + n;                  int rightHighLength = rightLength - n;                    // ... prepare our result array (to reuse its memory)                  uint* bitsLow = bits;                  int bitsLowLength = n2;                  uint* bitsHigh = bits + n2;                  int bitsHighLength = bitsLength - n2;                    // ... compute z_0 = a_0 * b_0 (multiply again)                  Multiply(leftLow' leftLowLength'                           rightLow' rightLowLength'                           bitsLow' bitsLowLength);                    // ... compute z_2 = a_1 * b_1 (multiply again)                  Multiply(leftHigh' leftHighLength'                           rightHigh' rightHighLength'                           bitsHigh' bitsHighLength);                    int leftFoldLength = leftHighLength + 1;                  int rightFoldLength = rightHighLength + 1;                  int coreLength = leftFoldLength + rightFoldLength;                    if (coreLength < AllocationThreshold)                  {                      uint* leftFold = stackalloc uint[leftFoldLength];                      uint* rightFold = stackalloc uint[rightFoldLength];                      uint* core = stackalloc uint[coreLength];                        // ... compute z_a = a_1 + a_0 (call it fold...)                      Add(leftHigh' leftHighLength'                          leftLow' leftLowLength'                          leftFold' leftFoldLength);                        // ... compute z_b = b_1 + b_0 (call it fold...)                      Add(rightHigh' rightHighLength'                          rightLow' rightLowLength'                          rightFold' rightFoldLength);                        // ... compute z_1 = z_a * z_b - z_0 - z_2                      Multiply(leftFold' leftFoldLength'                               rightFold' rightFoldLength'                               core' coreLength);                      SubtractCore(bitsHigh' bitsHighLength'                                   bitsLow' bitsLowLength'                                   core' coreLength);                        // ... and finally merge the result! :-)                      AddSelf(bits + n' bitsLength - n' core' coreLength);                  }                  else                  {                      fixed (uint* leftFold = new uint[leftFoldLength]'                                   rightFold = new uint[rightFoldLength]'                                   core = new uint[coreLength])                      {                          // ... compute z_a = a_1 + a_0 (call it fold...)                          Add(leftHigh' leftHighLength'                              leftLow' leftLowLength'                              leftFold' leftFoldLength);                            // ... compute z_b = b_1 + b_0 (call it fold...)                          Add(rightHigh' rightHighLength'                              rightLow' rightLowLength'                              rightFold' rightFoldLength);                            // ... compute z_1 = z_a * z_b - z_0 - z_2                          Multiply(leftFold' leftFoldLength'                                   rightFold' rightFoldLength'                                   core' coreLength);                          SubtractCore(bitsHigh' bitsHighLength'                                       bitsLow' bitsLowLength'                                       core' coreLength);                            // ... and finally merge the result! :-)                          AddSelf(bits + n' bitsLength - n' core' coreLength);                      }                  }              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractCore,The following statement contains a magic number: for (; i < rightLength; i++)              {                  long digit = (core[i] + carry) - left[i] - right[i];                  core[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractCore,The following statement contains a magic number: for (; i < leftLength; i++)              {                  long digit = (core[i] + carry) - left[i];                  core[i] = unchecked((uint)digit);                  carry = digit >> 32;              }
Magic Number,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,SubtractCore,The following statement contains a magic number: for (; carry != 0 && i < coreLength; i++)              {                  long digit = core[i] + carry;                  core[i] = (uint)digit;                  carry = digit >> 32;              }
Magic Number,System.Numerics,BitsBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.BitsBuffer.cs,Overwrite,The following statement contains a magic number: Debug.Assert(_bits.Length >= 2);
Magic Number,System.Numerics,BitsBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.BitsBuffer.cs,Overwrite,The following statement contains a magic number: if (_length > 2)                  {                      // Ensure leading zeros                      Array.Clear(_bits' 2' _length - 2);                  }
Magic Number,System.Numerics,BitsBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.BitsBuffer.cs,Overwrite,The following statement contains a magic number: if (_length > 2)                  {                      // Ensure leading zeros                      Array.Clear(_bits' 2' _length - 2);                  }
Magic Number,System.Numerics,BitsBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.BitsBuffer.cs,Overwrite,The following statement contains a magic number: if (_length > 2)                  {                      // Ensure leading zeros                      Array.Clear(_bits' 2' _length - 2);                  }
Magic Number,System.Numerics,BitsBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.BitsBuffer.cs,Overwrite,The following statement contains a magic number: uint hi = (uint)(value >> 32);
Magic Number,System.Numerics,BitsBuffer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.BitsBuffer.cs,Overwrite,The following statement contains a magic number: _length = hi != 0 ? 2 : lo != 0 ? 1 : 0;
Magic Number,System.Numerics,FastReducer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.FastReducer.cs,FastReducer,The following statement contains a magic number: uint[] r = new uint[modulus.Length * 2 + 1];
Magic Number,System.Numerics,FastReducer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.FastReducer.cs,FastReducer,The following statement contains a magic number: _q1 = new uint[modulus.Length * 2 + 2];
Magic Number,System.Numerics,FastReducer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.FastReducer.cs,FastReducer,The following statement contains a magic number: _q1 = new uint[modulus.Length * 2 + 2];
Magic Number,System.Numerics,FastReducer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.FastReducer.cs,FastReducer,The following statement contains a magic number: _q2 = new uint[modulus.Length * 2 + 1];
Magic Number,System.Numerics,FastReducer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.FastReducer.cs,Reduce,The following statement contains a magic number: Debug.Assert(value.Length <= _modulus.Length * 2);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (int.MinValue < value && value <= int.MaxValue)              {                  _sign = (int)value;                  _bits = null;              }              else if (value == int.MinValue)              {                  this = s_bnMinInt;              }              else              {                  ulong x = 0;                  if (value < 0)                  {                      x = unchecked((ulong)-value);                      _sign = -1;                  }                  else                  {                      x = (ulong)value;                      _sign = +1;                  }                    if (x <= uint.MaxValue)                  {                      _bits = new uint[1];                      _bits[0] = (uint)x;                  }                  else                  {                      _bits = new uint[2];                      _bits[0] = unchecked((uint)x);                      _bits[1] = (uint)(x >> kcbitUint);                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (value <= int.MaxValue)              {                  _sign = (int)value;                  _bits = null;              }              else if (value <= uint.MaxValue)              {                  _sign = +1;                  _bits = new uint[1];                  _bits[0] = (uint)value;              }              else              {                  _sign = +1;                  _bits = new uint[2];                  _bits[0] = unchecked((uint)value);                  _bits[1] = (uint)(value >> kcbitUint);              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: Debug.Assert(man < (1UL << 53));
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: Debug.Assert(exp <= 0 || man >= (1UL << 52));
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (exp <= 0)              {                  if (exp <= -kcbitUlong)                  {                      this = Zero;                      return;                  }                  this = man >> -exp;                  if (sign < 0)                      _sign = -_sign;              }              else if (exp <= 11)              {                  this = man << exp;                  if (sign < 0)                      _sign = -_sign;              }              else              {                  // Overflow into at least 3 uints.                  // Move the leading 1 to the high bit.                  man <<= 11;                  exp -= 11;                    // Compute cu and cbit so that exp == 32 * cu - cbit and 0 <= cbit < 32.                  int cu = (exp - 1) / kcbitUint + 1;                  int cbit = cu * kcbitUint - exp;                  Debug.Assert(0 <= cbit && cbit < kcbitUint);                  Debug.Assert(cu >= 1);                    // Populate the uints.                  _bits = new uint[cu + 2];                  _bits[cu + 1] = (uint)(man >> (cbit + kcbitUint));                  _bits[cu] = unchecked((uint)(man >> cbit));                  if (cbit > 0)                      _bits[cu - 1] = unchecked((uint)man) << (kcbitUint - cbit);                  _sign = sign;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (exp <= 0)              {                  if (exp <= -kcbitUlong)                  {                      this = Zero;                      return;                  }                  this = man >> -exp;                  if (sign < 0)                      _sign = -_sign;              }              else if (exp <= 11)              {                  this = man << exp;                  if (sign < 0)                      _sign = -_sign;              }              else              {                  // Overflow into at least 3 uints.                  // Move the leading 1 to the high bit.                  man <<= 11;                  exp -= 11;                    // Compute cu and cbit so that exp == 32 * cu - cbit and 0 <= cbit < 32.                  int cu = (exp - 1) / kcbitUint + 1;                  int cbit = cu * kcbitUint - exp;                  Debug.Assert(0 <= cbit && cbit < kcbitUint);                  Debug.Assert(cu >= 1);                    // Populate the uints.                  _bits = new uint[cu + 2];                  _bits[cu + 1] = (uint)(man >> (cbit + kcbitUint));                  _bits[cu] = unchecked((uint)(man >> cbit));                  if (cbit > 0)                      _bits[cu - 1] = unchecked((uint)man) << (kcbitUint - cbit);                  _sign = sign;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (exp <= 0)              {                  if (exp <= -kcbitUlong)                  {                      this = Zero;                      return;                  }                  this = man >> -exp;                  if (sign < 0)                      _sign = -_sign;              }              else if (exp <= 11)              {                  this = man << exp;                  if (sign < 0)                      _sign = -_sign;              }              else              {                  // Overflow into at least 3 uints.                  // Move the leading 1 to the high bit.                  man <<= 11;                  exp -= 11;                    // Compute cu and cbit so that exp == 32 * cu - cbit and 0 <= cbit < 32.                  int cu = (exp - 1) / kcbitUint + 1;                  int cbit = cu * kcbitUint - exp;                  Debug.Assert(0 <= cbit && cbit < kcbitUint);                  Debug.Assert(cu >= 1);                    // Populate the uints.                  _bits = new uint[cu + 2];                  _bits[cu + 1] = (uint)(man >> (cbit + kcbitUint));                  _bits[cu] = unchecked((uint)(man >> cbit));                  if (cbit > 0)                      _bits[cu - 1] = unchecked((uint)man) << (kcbitUint - cbit);                  _sign = sign;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (exp <= 0)              {                  if (exp <= -kcbitUlong)                  {                      this = Zero;                      return;                  }                  this = man >> -exp;                  if (sign < 0)                      _sign = -_sign;              }              else if (exp <= 11)              {                  this = man << exp;                  if (sign < 0)                      _sign = -_sign;              }              else              {                  // Overflow into at least 3 uints.                  // Move the leading 1 to the high bit.                  man <<= 11;                  exp -= 11;                    // Compute cu and cbit so that exp == 32 * cu - cbit and 0 <= cbit < 32.                  int cu = (exp - 1) / kcbitUint + 1;                  int cbit = cu * kcbitUint - exp;                  Debug.Assert(0 <= cbit && cbit < kcbitUint);                  Debug.Assert(cu >= 1);                    // Populate the uints.                  _bits = new uint[cu + 2];                  _bits[cu + 1] = (uint)(man >> (cbit + kcbitUint));                  _bits[cu] = unchecked((uint)(man >> cbit));                  if (cbit > 0)                      _bits[cu - 1] = unchecked((uint)man) << (kcbitUint - cbit);                  _sign = sign;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: Debug.Assert(bits.Length == 4 && (bits[3] & DecimalScaleFactorMask) == 0);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: Debug.Assert(bits.Length == 4 && (bits[3] & DecimalScaleFactorMask) == 0);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: int size = 3;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = s_bnZeroInt;              }              else if (size == 1 && bits[0] > 0)              {                  // bits[0] is the absolute value of this decimal                  // if bits[0] < 0 then it is too large to be packed into _sign                  _sign = bits[0];                  _sign *= ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;                  _bits = null;              }              else              {                  _bits = new uint[size];                    unchecked                  {                      _bits[0] = (uint)bits[0];                      if (size > 1)                          _bits[1] = (uint)bits[1];                      if (size > 2)                          _bits[2] = (uint)bits[2];                  }                    _sign = ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = s_bnZeroInt;              }              else if (size == 1 && bits[0] > 0)              {                  // bits[0] is the absolute value of this decimal                  // if bits[0] < 0 then it is too large to be packed into _sign                  _sign = bits[0];                  _sign *= ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;                  _bits = null;              }              else              {                  _bits = new uint[size];                    unchecked                  {                      _bits[0] = (uint)bits[0];                      if (size > 1)                          _bits[1] = (uint)bits[1];                      if (size > 2)                          _bits[2] = (uint)bits[2];                  }                    _sign = ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = s_bnZeroInt;              }              else if (size == 1 && bits[0] > 0)              {                  // bits[0] is the absolute value of this decimal                  // if bits[0] < 0 then it is too large to be packed into _sign                  _sign = bits[0];                  _sign *= ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;                  _bits = null;              }              else              {                  _bits = new uint[size];                    unchecked                  {                      _bits[0] = (uint)bits[0];                      if (size > 1)                          _bits[1] = (uint)bits[1];                      if (size > 2)                          _bits[2] = (uint)bits[2];                  }                    _sign = ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = s_bnZeroInt;              }              else if (size == 1 && bits[0] > 0)              {                  // bits[0] is the absolute value of this decimal                  // if bits[0] < 0 then it is too large to be packed into _sign                  _sign = bits[0];                  _sign *= ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;                  _bits = null;              }              else              {                  _bits = new uint[size];                    unchecked                  {                      _bits[0] = (uint)bits[0];                      if (size > 1)                          _bits[1] = (uint)bits[1];                      if (size > 2)                          _bits[2] = (uint)bits[2];                  }                    _sign = ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (size == 0)              {                  this = s_bnZeroInt;              }              else if (size == 1 && bits[0] > 0)              {                  // bits[0] is the absolute value of this decimal                  // if bits[0] < 0 then it is too large to be packed into _sign                  _sign = bits[0];                  _sign *= ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;                  _bits = null;              }              else              {                  _bits = new uint[size];                    unchecked                  {                      _bits[0] = (uint)bits[0];                      if (size > 1)                          _bits[1] = (uint)bits[1];                      if (size > 2)                          _bits[2] = (uint)bits[2];                  }                    _sign = ((bits[3] & DecimalSignMask) != 0) ? -1 : +1;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount > 0)              {                  byte mostSignificantByte = isBigEndian ? value[0] : value[byteCount - 1];                  isNegative = (mostSignificantByte & 0x80) != 0 && !isUnsigned;                    if (mostSignificantByte == 0)                  {                      // Try to conserve space as much as possible by checking for wasted leading byte[] entries                       if (isBigEndian)                      {                          int offset = 1;                            while (offset < byteCount && value[offset] == 0)                          {                              offset++;                          }                            value = value.Slice(offset);                          byteCount = value.Length;                      }                      else                      {                          byteCount -= 2;                            while (byteCount >= 0 && value[byteCount] == 0)                          {                              byteCount--;                          }                            byteCount++;                      }                  }              }              else              {                  isNegative = false;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,BigInteger,The following statement contains a magic number: if (byteCount <= 4)              {                  _sign = isNegative ? unchecked((int)0xffffffff) : 0;                    if (isBigEndian)                  {                      for (int i = 0; i < byteCount; i++)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                  else                  {                      for (int i = byteCount - 1; i >= 0; i--)                      {                          _sign = (_sign << 8) | value[i];                      }                  }                    _bits = null;                  if (_sign < 0 && !isNegative)                  {                      // Int32 overflow                      // Example: Int64 value 2362232011 (0xCB' 0xCC' 0xCC' 0x8C' 0x0)                      // can be naively packed into 4 bytes (due to the leading 0x0)                      // it overflows into the int32 sign bit                      _bits = new uint[1] { unchecked((uint)_sign) };                      _sign = +1;                  }                  if (_sign == int.MinValue)                  {                      this = s_bnMinInt;                  }              }              else              {                  int unalignedBytes = byteCount % 4;                  int dwordCount = byteCount / 4 + (unalignedBytes == 0 ? 0 : 1);                  uint[] val = new uint[dwordCount];                  int byteCountMinus1 = byteCount - 1;                    // Copy all dwords' except don't do the last one if it's not a full four bytes                  int curDword' curByte;                    if (isBigEndian)                  {                      curByte = byteCount - sizeof(int);                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte++;                          }                            curByte -= 8;                      }                  }                  else                  {                      curByte = sizeof(int) - 1;                      for (curDword = 0; curDword < dwordCount - (unalignedBytes == 0 ? 0 : 1); curDword++)                      {                          for (int byteInDword = 0; byteInDword < 4; byteInDword++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                              curByte--;                          }                            curByte += 8;                      }                  }                    // Copy the last dword specially if it's not aligned                  if (unalignedBytes != 0)                  {                      if (isNegative)                      {                          val[dwordCount - 1] = 0xffffffff;                      }                        if (isBigEndian)                      {                          for (curByte = 0; curByte < unalignedBytes; curByte++)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                      else                      {                          for (curByte = byteCountMinus1; curByte >= byteCount - unalignedBytes; curByte--)                          {                              byte curByteValue = value[curByte];                              val[curDword] = (val[curDword] << 8) | curByteValue;                          }                      }                  }                    if (isNegative)                  {                      NumericsHelpers.DangerousMakeTwosComplement(val); // Mutates val                        // Pack _bits to remove any wasted space after the twos complement                      int len = val.Length - 1;                      while (len >= 0 && val[len] == 0) len--;                      len++;                        if (len == 1)                      {                          switch (val[0])                          {                              case 1: // abs(-1)                                  this = s_bnMinusOneInt;                                  return;                                case kuMaskHighBit: // abs(Int32.MinValue)                                  this = s_bnMinInt;                                  return;                                default:                                  if (unchecked((int)val[0]) > 0)                                  {                                      _sign = (-1) * ((int)val[0]);                                      _bits = null;                                      AssertValid();                                      return;                                  }                                    break;                          }                      }                        if (len != val.Length)                      {                          _sign = -1;                          _bits = new uint[len];                          Array.Copy(val' 0' _bits' 0' len);                      }                      else                      {                          _sign = -1;                          _bits = val;                      }                  }                  else                  {                      _sign = +1;                      _bits = val;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: ulong m = value._bits.Length > 1 ? value._bits[value._bits.Length - 2] : 0;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: ulong l = value._bits.Length > 2 ? value._bits[value._bits.Length - 3] : 0;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: ulong l = value._bits.Length > 2 ? value._bits[value._bits.Length - 3] : 0;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: long b = (long)value._bits.Length * 32 - c;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: ulong x = (h << 32 + c) | (m << c) | (l >> 32 - c);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: ulong x = (h << 32 + c) | (m << c) | (l >> 32 - c);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: return Math.Log(x' baseValue) + (b - 64) / Math.Log(baseValue' 2);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log,The following statement contains a magic number: return Math.Log(x' baseValue) + (b - 64) / Math.Log(baseValue' 2);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Log10,The following statement contains a magic number: return Log(value' 10);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,GreatestCommonDivisor,The following statement contains a magic number: if (rightBits.Length == 2)              {                  uint[] tempBits = BigIntegerCalculator.Remainder(leftBits' rightBits);                    ulong left = ((ulong)rightBits[1] << 32) | rightBits[0];                  ulong right = ((ulong)tempBits[1] << 32) | tempBits[0];                    return BigIntegerCalculator.Gcd(left' right);              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,GreatestCommonDivisor,The following statement contains a magic number: if (rightBits.Length == 2)              {                  uint[] tempBits = BigIntegerCalculator.Remainder(leftBits' rightBits);                    ulong left = ((ulong)rightBits[1] << 32) | rightBits[0];                  ulong right = ((ulong)tempBits[1] << 32) | tempBits[0];                    return BigIntegerCalculator.Gcd(left' right);              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,GreatestCommonDivisor,The following statement contains a magic number: if (rightBits.Length == 2)              {                  uint[] tempBits = BigIntegerCalculator.Remainder(leftBits' rightBits);                    ulong left = ((ulong)rightBits[1] << 32) | rightBits[0];                  ulong right = ((ulong)tempBits[1] << 32) | tempBits[0];                    return BigIntegerCalculator.Gcd(left' right);              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Equals,The following statement contains a magic number: if ((_sign ^ other) < 0 || (cu = _bits.Length) > 2)                  return false;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,Equals,The following statement contains a magic number: if (cu > 2)                  return false;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: if ((_sign ^ other) < 0 || (cu = _bits.Length) > 2)                  return _sign;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: ulong uuTmp = cu == 2 ? NumericsHelpers.MakeUlong(_bits[1]' _bits[0]) : _bits[0];
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: if (cu > 2)                  return +1;
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,CompareTo,The following statement contains a magic number: ulong uuTmp = cu == 2 ? NumericsHelpers.MakeUlong(_bits[1]' _bits[0]) : _bits[0];
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if ((msb = unchecked((byte)(highDword >> 24))) != highByte)              {                  msbIndex = 3;              }              else if ((msb = unchecked((byte)(highDword >> 16))) != highByte)              {                  msbIndex = 2;              }              else if ((msb = unchecked((byte)(highDword >> 8))) != highByte)              {                  msbIndex = 1;              }              else              {                  msb = unchecked((byte)highDword);                  msbIndex = 0;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if ((msb = unchecked((byte)(highDword >> 24))) != highByte)              {                  msbIndex = 3;              }              else if ((msb = unchecked((byte)(highDword >> 16))) != highByte)              {                  msbIndex = 2;              }              else if ((msb = unchecked((byte)(highDword >> 8))) != highByte)              {                  msbIndex = 1;              }              else              {                  msb = unchecked((byte)highDword);                  msbIndex = 0;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if ((msb = unchecked((byte)(highDword >> 24))) != highByte)              {                  msbIndex = 3;              }              else if ((msb = unchecked((byte)(highDword >> 16))) != highByte)              {                  msbIndex = 2;              }              else if ((msb = unchecked((byte)(highDword >> 8))) != highByte)              {                  msbIndex = 1;              }              else              {                  msb = unchecked((byte)highDword);                  msbIndex = 0;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if ((msb = unchecked((byte)(highDword >> 24))) != highByte)              {                  msbIndex = 3;              }              else if ((msb = unchecked((byte)(highDword >> 16))) != highByte)              {                  msbIndex = 2;              }              else if ((msb = unchecked((byte)(highDword >> 8))) != highByte)              {                  msbIndex = 1;              }              else              {                  msb = unchecked((byte)highDword);                  msbIndex = 0;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if ((msb = unchecked((byte)(highDword >> 24))) != highByte)              {                  msbIndex = 3;              }              else if ((msb = unchecked((byte)(highDword >> 16))) != highByte)              {                  msbIndex = 2;              }              else if ((msb = unchecked((byte)(highDword >> 8))) != highByte)              {                  msbIndex = 1;              }              else              {                  msb = unchecked((byte)highDword);                  msbIndex = 0;              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (bits != null)              {                  length = checked(4 * (bits.Length - 1) + length);              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (bits != null)              {                  for (int i = 0; i < bits.Length - 1; i++)                  {                      uint dword = bits[i];                        if (sign == -1)                      {                          dword = ~dword;                          if (i <= nonZeroDwordIndex)                          {                              dword = unchecked(dword + 1U);                          }                      }                        destination[curByte] = unchecked((byte)dword);                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 8));                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 16));                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 24));                      curByte += increment;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (bits != null)              {                  for (int i = 0; i < bits.Length - 1; i++)                  {                      uint dword = bits[i];                        if (sign == -1)                      {                          dword = ~dword;                          if (i <= nonZeroDwordIndex)                          {                              dword = unchecked(dword + 1U);                          }                      }                        destination[curByte] = unchecked((byte)dword);                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 8));                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 16));                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 24));                      curByte += increment;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (bits != null)              {                  for (int i = 0; i < bits.Length - 1; i++)                  {                      uint dword = bits[i];                        if (sign == -1)                      {                          dword = ~dword;                          if (i <= nonZeroDwordIndex)                          {                              dword = unchecked(dword + 1U);                          }                      }                        destination[curByte] = unchecked((byte)dword);                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 8));                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 16));                      curByte += increment;                      destination[curByte] = unchecked((byte)(dword >> 24));                      curByte += increment;                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: Debug.Assert(msbIndex >= 0 && msbIndex <= 3);
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (msbIndex != 0)              {                  curByte += increment;                  destination[curByte] = unchecked((byte)(highDword >> 8));                  if (msbIndex != 1)                  {                      curByte += increment;                      destination[curByte] = unchecked((byte)(highDword >> 16));                      if (msbIndex != 2)                      {                          curByte += increment;                          destination[curByte] = unchecked((byte)(highDword >> 24));                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (msbIndex != 0)              {                  curByte += increment;                  destination[curByte] = unchecked((byte)(highDword >> 8));                  if (msbIndex != 1)                  {                      curByte += increment;                      destination[curByte] = unchecked((byte)(highDword >> 16));                      if (msbIndex != 2)                      {                          curByte += increment;                          destination[curByte] = unchecked((byte)(highDword >> 24));                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (msbIndex != 0)              {                  curByte += increment;                  destination[curByte] = unchecked((byte)(highDword >> 8));                  if (msbIndex != 1)                  {                      curByte += increment;                      destination[curByte] = unchecked((byte)(highDword >> 16));                      if (msbIndex != 2)                      {                          curByte += increment;                          destination[curByte] = unchecked((byte)(highDword >> 24));                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: if (msbIndex != 0)              {                  curByte += increment;                  destination[curByte] = unchecked((byte)(highDword >> 8));                  if (msbIndex != 1)                  {                      curByte += increment;                      destination[curByte] = unchecked((byte)(highDword >> 16));                      if (msbIndex != 2)                      {                          curByte += increment;                          destination[curByte] = unchecked((byte)(highDword >> 24));                      }                  }              }
Magic Number,System.Numerics,BigInteger,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigInteger.cs,TryGetBytes,The following statement contains a magic number: Debug.Assert(isBigEndian || (!needExtraByte && curByte == length - 1) || (needExtraByte && curByte == length - 2));
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,HexNumberToBigInteger,The following statement contains a magic number: byte[] bits = new byte[(len / 2) + (len % 2)];
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,HexNumberToBigInteger,The following statement contains a magic number: byte[] bits = new byte[(len / 2) + (len % 2)];
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,HexNumberToBigInteger,The following statement contains a magic number: for (int i = len - 1; i > -1; i--)              {                  char c = number.digits[i];                    byte b;                  if (c >= '0' && c <= '9')                  {                      b = (byte)(c - '0');                  }                  else if (c >= 'A' && c <= 'F')                  {                      b = (byte)((c - 'A') + 10);                  }                  else                  {                      Debug.Assert(c >= 'a' && c <= 'f');                      b = (byte)((c - 'a') + 10);                  }                  if (i == 0 && (b & 0x08) == 0x08)                      isNegative = true;                    if (shift)                  {                      bits[bitIndex] = (byte)(bits[bitIndex] | (b << 4));                      bitIndex++;                  }                  else                  {                      bits[bitIndex] = isNegative ? (byte)(b | 0xF0) : (b);                  }                  shift = !shift;              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,HexNumberToBigInteger,The following statement contains a magic number: for (int i = len - 1; i > -1; i--)              {                  char c = number.digits[i];                    byte b;                  if (c >= '0' && c <= '9')                  {                      b = (byte)(c - '0');                  }                  else if (c >= 'A' && c <= 'F')                  {                      b = (byte)((c - 'A') + 10);                  }                  else                  {                      Debug.Assert(c >= 'a' && c <= 'f');                      b = (byte)((c - 'a') + 10);                  }                  if (i == 0 && (b & 0x08) == 0x08)                      isNegative = true;                    if (shift)                  {                      bits[bitIndex] = (byte)(bits[bitIndex] | (b << 4));                      bitIndex++;                  }                  else                  {                      bits[bitIndex] = isNegative ? (byte)(b | 0xF0) : (b);                  }                  shift = !shift;              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,HexNumberToBigInteger,The following statement contains a magic number: for (int i = len - 1; i > -1; i--)              {                  char c = number.digits[i];                    byte b;                  if (c >= '0' && c <= '9')                  {                      b = (byte)(c - '0');                  }                  else if (c >= 'A' && c <= 'F')                  {                      b = (byte)((c - 'A') + 10);                  }                  else                  {                      Debug.Assert(c >= 'a' && c <= 'f');                      b = (byte)((c - 'a') + 10);                  }                  if (i == 0 && (b & 0x08) == 0x08)                      isNegative = true;                    if (shift)                  {                      bits[bitIndex] = (byte)(bits[bitIndex] | (b << 4));                      bitIndex++;                  }                  else                  {                      bits[bitIndex] = isNegative ? (byte)(b | 0xF0) : (b);                  }                  shift = !shift;              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,NumberToBigInteger,The following statement contains a magic number: BigInteger ten = 10;
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,ParseFormatSpecifier,The following statement contains a magic number: if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')              {                  i++;                  int n = -1;                    if (i < format.Length && format[i] >= '0' && format[i] <= '9')                  {                      n = format[i++] - '0';                      while (i < format.Length && format[i] >= '0' && format[i] <= '9')                      {                          n = n * 10 + (format[i++] - '0');                          if (n >= 10)                              break;                      }                  }                  if (i >= format.Length || format[i] == '\0')                  {                      digits = n;                      return ch;                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,ParseFormatSpecifier,The following statement contains a magic number: if (ch >= 'A' && ch <= 'Z' || ch >= 'a' && ch <= 'z')              {                  i++;                  int n = -1;                    if (i < format.Length && format[i] >= '0' && format[i] <= '9')                  {                      n = format[i++] - '0';                      while (i < format.Length && format[i] >= '0' && format[i] <= '9')                      {                          n = n * 10 + (format[i++] - '0');                          if (n >= 10)                              break;                      }                  }                  if (i >= format.Length || format[i] == '\0')                  {                      digits = n;                      return ch;                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The following statement contains a magic number: Span<byte> bits = stackalloc byte[64];
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The following statement contains a magic number: Span<char> stackSpace = stackalloc char[128];
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The following statement contains a magic number: if (cur > -1)              {                  // [FF..F8] drop the high F as the two's complement negative number remains clear                  // [F7..08] retain the high bits as the two's complement number is wrong without it                  // [07..00] drop the high 0 as the two's complement positive number remains clear                  bool clearHighF = false;                  byte head = bits[cur];                    if (head > 0xF7)                  {                      head -= 0xF0;                      clearHighF = true;                  }                    if (head < 0x08 || clearHighF)                  {                      // {0xF8-0xFF} print as {8-F}                      // {0x00-0x07} print as {0-7}                      sb.Append(head < 10 ?                          (char)(head + '0') :                          format == 'X' ? (char)((head & 0xF) - 10 + 'A') : (char)((head & 0xF) - 10 + 'a'));                      cur--;                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The following statement contains a magic number: if (cur > -1)              {                  // [FF..F8] drop the high F as the two's complement negative number remains clear                  // [F7..08] retain the high bits as the two's complement number is wrong without it                  // [07..00] drop the high 0 as the two's complement positive number remains clear                  bool clearHighF = false;                  byte head = bits[cur];                    if (head > 0xF7)                  {                      head -= 0xF0;                      clearHighF = true;                  }                    if (head < 0x08 || clearHighF)                  {                      // {0xF8-0xFF} print as {8-F}                      // {0x00-0x07} print as {0-7}                      sb.Append(head < 10 ?                          (char)(head + '0') :                          format == 'X' ? (char)((head & 0xF) - 10 + 'A') : (char)((head & 0xF) - 10 + 'a'));                      cur--;                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The following statement contains a magic number: if (cur > -1)              {                  // [FF..F8] drop the high F as the two's complement negative number remains clear                  // [F7..08] retain the high bits as the two's complement number is wrong without it                  // [07..00] drop the high 0 as the two's complement positive number remains clear                  bool clearHighF = false;                  byte head = bits[cur];                    if (head > 0xF7)                  {                      head -= 0xF0;                      clearHighF = true;                  }                    if (head < 0x08 || clearHighF)                  {                      // {0xF8-0xFF} print as {8-F}                      // {0x00-0x07} print as {0-7}                      sb.Append(head < 10 ?                          (char)(head + '0') :                          format == 'X' ? (char)((head & 0xF) - 10 + 'A') : (char)((head & 0xF) - 10 + 'a'));                      cur--;                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The following statement contains a magic number: if (cur > -1)              {                  Span<char> chars = sb.AppendSpan((cur + 1) * 2);                  int charsPos = 0;                  string hexValues = format == 'x' ? "0123456789abcdef" : "0123456789ABCDEF";                  while (cur > -1)                  {                      byte b = bits[cur--];                      chars[charsPos++] = hexValues[b >> 4];                      chars[charsPos++] = hexValues[b & 0xF];                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigIntegerToHex,The following statement contains a magic number: if (cur > -1)              {                  Span<char> chars = sb.AppendSpan((cur + 1) * 2);                  int charsPos = 0;                  string hexValues = format == 'x' ? "0123456789abcdef" : "0123456789ABCDEF";                  while (cur > -1)                  {                      byte b = bits[cur--];                      chars[charsPos++] = hexValues[b >> 4];                      chars[charsPos++] = hexValues[b & 0xF];                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: const uint kuBase = 1000000000;
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: const int kcchBase = 9;
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: try              {                  cuMax = checked(cuSrc * 10 / 9 + 2);              }              catch (OverflowException e) { throw new FormatException(SR.Format_TooLarge' e); }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: try              {                  cuMax = checked(cuSrc * 10 / 9 + 2);              }              catch (OverflowException e) { throw new FormatException(SR.Format_TooLarge' e); }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: try              {                  cuMax = checked(cuSrc * 10 / 9 + 2);              }              catch (OverflowException e) { throw new FormatException(SR.Format_TooLarge' e); }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: for (int iuDst = 0; iuDst < cuDst - 1; iuDst++)              {                  uint uDig = rguDst[iuDst];                  Debug.Assert(uDig < kuBase);                  for (int cch = kcchBase; --cch >= 0;)                  {                      rgch[--ichDst] = (char)('0' + uDig % 10);                      uDig /= 10;                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: for (int iuDst = 0; iuDst < cuDst - 1; iuDst++)              {                  uint uDig = rguDst[iuDst];                  Debug.Assert(uDig < kuBase);                  for (int cch = kcchBase; --cch >= 0;)                  {                      rgch[--ichDst] = (char)('0' + uDig % 10);                      uDig /= 10;                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: for (uint uDig = rguDst[cuDst - 1]; uDig != 0;)              {                  rgch[--ichDst] = (char)('0' + uDig % 10);                  uDig /= 10;              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: for (uint uDig = rguDst[cuDst - 1]; uDig != 0;)              {                  rgch[--ichDst] = (char)('0' + uDig % 10);                  uDig /= 10;              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: if (!decimalFmt)              {                  // sign = true for negative and false for 0 and positive values                  bool sign = (value._sign < 0);                  // The cut-off point to switch (G)eneral from (F)ixed-point to (E)xponential form                  int precision = 29;                  int scale = cchMax - ichDst;                    Span<char> stackSpace = stackalloc char[128]; // arbitrary stack cut-off                  var sb = new ValueStringBuilder(stackSpace);                  FormatProvider.FormatBigInteger(ref sb' precision' scale' sign' formatSpan' info' rgch' ichDst);                    if (targetSpan)                  {                      spanSuccess = sb.TryCopyTo(destination' out charsWritten);                      return null;                  }                  else                  {                      charsWritten = 0;                      spanSuccess = false;                      return sb.ToString();                  }              }
Magic Number,System.Numerics,BigNumber,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigNumber.cs,FormatBigInteger,The following statement contains a magic number: if (!decimalFmt)              {                  // sign = true for negative and false for 0 and positive values                  bool sign = (value._sign < 0);                  // The cut-off point to switch (G)eneral from (F)ixed-point to (E)xponential form                  int precision = 29;                  int scale = cchMax - ichDst;                    Span<char> stackSpace = stackalloc char[128]; // arbitrary stack cut-off                  var sb = new ValueStringBuilder(stackSpace);                  FormatProvider.FormatBigInteger(ref sb' precision' scale' sign' formatSpan' info' rgch' ichDst);                    if (targetSpan)                  {                      spanSuccess = sb.TryCopyTo(destination' out charsWritten);                      return null;                  }                  else                  {                      charsWritten = 0;                      spanSuccess = false;                      return sb.ToString();                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.uu >> 62) & 2);
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: sign = 1 - ((int)(du.uu >> 62) & 2);
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: exp = (int)(du.uu >> 52) & 0x7FF;
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  fFinite = true;                  if (man != 0)                      exp = -1074;              }              else if (exp == 0x7FF)              {                  // NaN or Infinite.                  fFinite = false;                  exp = int.MaxValue;              }              else              {                  fFinite = true;                  man |= 0x0010000000000000;                  exp -= 1075;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleParts,The following statement contains a magic number: if (exp == 0)              {                  // Denormalized number.                  fFinite = true;                  if (man != 0)                      exp = -1074;              }              else if (exp == 0x7FF)              {                  // NaN or Infinite.                  fFinite = false;                  exp = int.MaxValue;              }              else              {                  fFinite = true;                  man |= 0x0010000000000000;                  exp -= 1075;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)                  du.uu = 0;              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                  exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                          Debug.Assert(du.uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)                  du.uu = 0;              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                  exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                          Debug.Assert(du.uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)                  du.uu = 0;              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                  exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                          Debug.Assert(du.uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,GetDoubleFromParts,The following statement contains a magic number: if (man == 0)                  du.uu = 0;              else              {                  // Normalize so that 0x0010 0000 0000 0000 is the highest bit set.                  int cbitShift = CbitHighZero(man) - 11;                  if (cbitShift < 0)                      man >>= -cbitShift;                  else                      man <<= cbitShift;                  exp -= cbitShift;                  Debug.Assert((man & 0xFFF0000000000000) == 0x0010000000000000);                    // Move the point to just behind the leading 1: 0x001.0 0000 0000 0000                  // (52 bits) and skew the exponent (by 0x3FF == 1023).                  exp += 1075;                    if (exp >= 0x7FF)                  {                      // Infinity.                      du.uu = 0x7FF0000000000000;                  }                  else if (exp <= 0)                  {                      // Denormalized.                      exp--;                      if (exp < -52)                      {                          // Underflow to zero.                          du.uu = 0;                      }                      else                      {                          du.uu = man >> -exp;                          Debug.Assert(du.uu != 0);                      }                  }                  else                  {                      // Mask off the implicit high bit.                      du.uu = (man & 0x000FFFFFFFFFFFFF) | ((ulong)exp << 52);                  }              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,Abs,The following statement contains a magic number: unchecked              {                  uint mask = (uint)(a >> 31);                  return ((uint)a ^ mask) - mask;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CombineHash,The following statement contains a magic number: return ((u1 << 7) | (u1 >> 25)) ^ u2;
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CombineHash,The following statement contains a magic number: return ((u1 << 7) | (u1 >> 25)) ^ u2;
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if (u == 0)                  return 32;
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFFFF0000) == 0)              {                  cbit += 16;                  u <<= 16;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xFF000000) == 0)              {                  cbit += 8;                  u <<= 8;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xF0000000) == 0)              {                  cbit += 4;                  u <<= 4;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((u & 0xC0000000) == 0)              {                  cbit += 2;                  u <<= 2;              }
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: if ((uu & 0xFFFFFFFF00000000) == 0)                  return 32 + CbitHighZero((uint)uu);
Magic Number,System.Numerics,NumericsHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\NumericsHelpers.cs,CbitHighZero,The following statement contains a magic number: return CbitHighZero((uint)(uu >> 32));
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Log1P,The following statement contains a magic number: if (xp1 == 1.0)              {                  return x;              }              else if (x < 0.75)              {                  // This is accurate to within 5 ulp with any floating-point system that uses a guard digit'                  // as proven in Theorem 4 of "What Every Computer Scientist Should Know About Floating-Point                  // Arithmetic" (https://docs.oracle.com/cd/E19957-01/806-3568/ncg_goldberg.html)                  return x * Math.Log(xp1) / (xp1 - 1.0);              }              else              {                  return Math.Log(xp1);              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,GetHashCode,The following statement contains a magic number: int n1 = 99999997;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sin,The following statement contains a magic number: double sinh = (p - q) * 0.5;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sin,The following statement contains a magic number: double cosh = (p + q) * 0.5;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Cos,The following statement contains a magic number: double sinh = (p - q) * 0.5;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Cos,The following statement contains a magic number: double cosh = (p + q) * 0.5;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Tan,The following statement contains a magic number: double x2 = 2.0 * value.m_real;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Tan,The following statement contains a magic number: double y2 = 2.0 * value.m_imaginary;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Tan,The following statement contains a magic number: double cosh = (p + q) * 0.5;
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Tan,The following statement contains a magic number: if (Math.Abs(value.m_imaginary) <= 4.0)              {                  double sinh = (p - q) * 0.5;                  double D = Math.Cos(x2) + cosh;                  return new Complex(Math.Sin(x2) / D' sinh / D);              }              else              {                  double D = 1.0 + Math.Cos(x2) / cosh;                  return new Complex(Math.Sin(x2) / cosh / D' Math.Tanh(y2) / D);              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Tan,The following statement contains a magic number: if (Math.Abs(value.m_imaginary) <= 4.0)              {                  double sinh = (p - q) * 0.5;                  double D = Math.Cos(x2) + cosh;                  return new Complex(Math.Sin(x2) / D' sinh / D);              }              else              {                  double D = 1.0 + Math.Cos(x2) / cosh;                  return new Complex(Math.Sin(x2) / cosh / D' Math.Tanh(y2) / D);              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Atan,The following statement contains a magic number: Complex two = new Complex(2.0' 0.0);
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Asin_Internal,The following statement contains a magic number: if ((x > s_asinOverflowThreshold) || (y > s_asinOverflowThreshold))              {                  b = -1.0;                  bPrime = x / y;                    double small' big;                  if (x < y)                  {                      small = x;                      big = y;                  }                  else                  {                      small = y;                      big = x;                  }                  double ratio = small / big;                  v = s_log2 + Math.Log(big) + 0.5 * Log1P(ratio * ratio);              }              else              {                  double r = Hypot((x + 1.0)' y);                  double s = Hypot((x - 1.0)' y);                    double a = (r + s) * 0.5;                  b = x / a;                    if (b > 0.75)                  {                      if (x <= 1.0)                      {                          double amx = (y * y / (r + (x + 1.0)) + (s + (1.0 - x))) * 0.5;                          bPrime = x / Math.Sqrt((a + x) * amx);                      }                      else                      {                          // In this case' amx ~ y^2. Since we take the square root of amx' we should                          // pull y out from under the square root so we don't lose its contribution                          // when y^2 underflows.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (x - 1.0))) * 0.5;                          bPrime = x / y / Math.Sqrt((a + x) * t);                      }                  }                  else                  {                      bPrime = -1.0;                  }                    if (a < 1.5)                  {                      if (x < 1.0)                      {                          // This is another case where our expression is proportional to y^2 and                          // we take its square root' so again we pull out a factor of y from                          // under the square root.                          double t = (1.0 / (r + (x + 1.0)) + 1.0 / (s + (1.0 - x))) * 0.5;                          double am1 = y * y * t;                          v = Log1P(am1 + y * Math.Sqrt(t * (a + 1.0)));                      }                      else                      {                          double am1 = (y * y / (r + (x + 1.0)) + (s + (x - 1.0))) * 0.5;                          v = Log1P(am1 + Math.Sqrt(am1 * (a + 1.0)));                      }                  }                  else                  {                      // Because of the test above' we can be sure that a * a will not overflow.                      v = Math.Log(a + Math.Sqrt((a - 1.0) * (a + 1.0)));                  }              }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Numerics,Complex,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\Complex.cs,Sqrt,The following statement contains a magic number: if (value.m_imaginary == 0.0)              {                  // Handle the trivial case quickly.                  if (value.m_real < 0.0)                  {                      return new Complex(0.0' Math.Sqrt(-value.m_real));                  }                  else                  {                      return new Complex(Math.Sqrt(value.m_real)' 0.0);                  }              }              else              {                    // One way to compute Sqrt(z) is just to call Pow(z' 0.5)' which coverts to polar coordinates                  // (sqrt + atan)' halves the phase' and reconverts to cartesian coordinates (cos + sin).                  // Not only is this more expensive than necessary' it also fails to preserve certain expected                  // symmetries' such as that the square root of a pure negative is a pure imaginary' and that the                  // square root of a pure imaginary has exactly equal real and imaginary parts. This all goes                  // back to the fact that Math.PI is not stored with infinite precision' so taking half of Math.PI                  // does not land us on an argument with cosine exactly equal to zero.                    // To find a fast and symmetry-respecting formula for complex square root'                  // note x + i y = \sqrt{a + i b} implies x^2 + 2 i x y - y^2 = a + i b'                  // so x^2 - y^2 = a and 2 x y = b. Cross-substitute and use the quadratic formula to obtain                  //   x = \sqrt{\frac{\sqrt{a^2 + b^2} + a}{2}}  y = \pm \sqrt{\frac{\sqrt{a^2 + b^2} - a}{2}}                  // There is just one complication: depending on the sign on a' either x or y suffers from                  // cancelation when |b| << |a|. We can get aroud this by noting that our formulas imply                  // x^2 y^2 = b^2 / 4' so |x| |y| = |b| / 2. So after computing the one that doesn't suffer                  // from cancelation' we can compute the other with just a division. This is basically just                  // the right way to evaluate the quadratic formula without cancelation.                    // All this reduces our total cost to two sqrts and a few flops' and it respects the desired                  // symmetries. Much better than atan + cos + sin!                    // The signs are a matter of choice of branch cut' which is traditionally taken so x > 0 and sign(y) = sign(b).                          // If the components are too large' Hypot will overflow' even though the subsequent sqrt would                  // make the result representable. To avoid this' we re-scale (by exact powers of 2 for accuracy)                  // when we encounter very large components to avoid intermediate infinities.                  bool rescale = false;                  if ((Math.Abs(value.m_real) >= s_sqrtRescaleThreshold) || (Math.Abs(value.m_imaginary) >= s_sqrtRescaleThreshold))                  {                      if (double.IsInfinity(value.m_imaginary) && !double.IsNaN(value.m_real))                      {                          // We need to handle infinite imaginary parts specially because otherwise                          // our formulas below produce inf/inf = NaN. The NaN test is necessary                          // so that we return NaN rather than (+inf'inf) for (NaN'inf).                          return (new Complex(double.PositiveInfinity' value.m_imaginary));                      }                      else                      {                          value.m_real *= 0.25;                          value.m_imaginary *= 0.25;                          rescale = true;                      }                  }                     // This is the core of the algorithm. Everything else is special case handling.                  double x' y;                  if (value.m_real >= 0.0)                  {                      x = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) + value.m_real) * 0.5);                      y = value.m_imaginary / (2.0 * x);                  }                  else                  {                      y = Math.Sqrt((Hypot(value.m_real' value.m_imaginary) - value.m_real) * 0.5);                      if (value.m_imaginary < 0.0) y = -y;                      x = value.m_imaginary / (2.0 * y);                  }                    if (rescale)                  {                      x *= 2.0;                      y *= 2.0;                  }                    return new Complex(x' y);                }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The following statement contains a magic number: while (true)                  {                      // Eat whitespace unless we've found a sign which isn't followed by a currency symbol.                      // "-Kr 1231.47" is legal but "- 1231.47" is not.                      if (!IsWhite(ch) || (options & NumberStyles.AllowLeadingWhite) == 0 || ((state & StateSign) != 0 && ((state & StateCurrency) == 0 && numfmt.NumberNegativePattern != 2)))                      {                          if ((((options & NumberStyles.AllowLeadingSign) != 0) && (state & StateSign) == 0) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || ((next = MatchChars(p' numfmt.NegativeSign)) != null && (number.sign = true))))                          {                              state |= StateSign;                              p = next - 1;                          }                          else if (ch == '(' && ((options & NumberStyles.AllowParentheses) != 0) && ((state & StateSign) == 0))                          {                              state |= StateSign | StateParens;                              number.sign = true;                          }                          else if (currSymbol != null && (next = MatchChars(p' currSymbol)) != null)                          {                              state |= StateCurrency;                              currSymbol = null;                                  // We already found the currency symbol. There should not be more currency symbols. Set                              // currSymbol to NULL so that we won't search it again in the later code path.                              p = next - 1;                          }                          else                          {                              break;                          }                      }                      ch = *++p;                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The following statement contains a magic number: if ((state & StateDigits) != 0)                  {                      if ((ch == 'E' || ch == 'e') && ((options & NumberStyles.AllowExponent) != 0))                      {                          char* temp = p;                          ch = *++p;                          if ((next = MatchChars(p' numfmt.PositiveSign)) != null)                          {                              ch = *(p = next);                          }                          else if ((next = MatchChars(p' numfmt.NegativeSign)) != null)                          {                              ch = *(p = next);                              negExp = true;                          }                          if (ch >= '0' && ch <= '9')                          {                              int exp = 0;                              do                              {                                  exp = exp * 10 + (ch - '0');                                  ch = *++p;                                  if (exp > 1000)                                  {                                      exp = 9999;                                      while (ch >= '0' && ch <= '9')                                      {                                          ch = *++p;                                      }                                  }                              } while (ch >= '0' && ch <= '9');                              if (negExp)                              {                                  exp = -exp;                              }                              number.scale += exp;                          }                          else                          {                              p = temp;                              ch = *p;                          }                      }                      while (true)                      {                          if (!IsWhite(ch) || (options & NumberStyles.AllowTrailingWhite) == 0)                          {                              if (((options & NumberStyles.AllowTrailingSign) != 0 && ((state & StateSign) == 0)) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || (((next = MatchChars(p' numfmt.NegativeSign)) != null) && (number.sign = true))))                              {                                  state |= StateSign;                                  p = next - 1;                              }                              else if (ch == ')' && ((state & StateParens) != 0))                              {                                  state &= ~StateParens;                              }                              else if (currSymbol != null && (next = MatchChars(p' currSymbol)) != null)                              {                                  currSymbol = null;                                  p = next - 1;                              }                              else                              {                                  break;                              }                          }                          ch = *++p;                      }                      if ((state & StateParens) == 0)                      {                          if ((state & StateNonZero) == 0)                          {                              if (!parseDecimal)                              {                                  number.scale = 0;                              }                              if ((state & StateDecimal) == 0)                              {                                  number.sign = false;                              }                          }                          str = p;                          return true;                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The following statement contains a magic number: if ((state & StateDigits) != 0)                  {                      if ((ch == 'E' || ch == 'e') && ((options & NumberStyles.AllowExponent) != 0))                      {                          char* temp = p;                          ch = *++p;                          if ((next = MatchChars(p' numfmt.PositiveSign)) != null)                          {                              ch = *(p = next);                          }                          else if ((next = MatchChars(p' numfmt.NegativeSign)) != null)                          {                              ch = *(p = next);                              negExp = true;                          }                          if (ch >= '0' && ch <= '9')                          {                              int exp = 0;                              do                              {                                  exp = exp * 10 + (ch - '0');                                  ch = *++p;                                  if (exp > 1000)                                  {                                      exp = 9999;                                      while (ch >= '0' && ch <= '9')                                      {                                          ch = *++p;                                      }                                  }                              } while (ch >= '0' && ch <= '9');                              if (negExp)                              {                                  exp = -exp;                              }                              number.scale += exp;                          }                          else                          {                              p = temp;                              ch = *p;                          }                      }                      while (true)                      {                          if (!IsWhite(ch) || (options & NumberStyles.AllowTrailingWhite) == 0)                          {                              if (((options & NumberStyles.AllowTrailingSign) != 0 && ((state & StateSign) == 0)) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || (((next = MatchChars(p' numfmt.NegativeSign)) != null) && (number.sign = true))))                              {                                  state |= StateSign;                                  p = next - 1;                              }                              else if (ch == ')' && ((state & StateParens) != 0))                              {                                  state &= ~StateParens;                              }                              else if (currSymbol != null && (next = MatchChars(p' currSymbol)) != null)                              {                                  currSymbol = null;                                  p = next - 1;                              }                              else                              {                                  break;                              }                          }                          ch = *++p;                      }                      if ((state & StateParens) == 0)                      {                          if ((state & StateNonZero) == 0)                          {                              if (!parseDecimal)                              {                                  number.scale = 0;                              }                              if ((state & StateDecimal) == 0)                              {                                  number.sign = false;                              }                          }                          str = p;                          return true;                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseNumber,The following statement contains a magic number: if ((state & StateDigits) != 0)                  {                      if ((ch == 'E' || ch == 'e') && ((options & NumberStyles.AllowExponent) != 0))                      {                          char* temp = p;                          ch = *++p;                          if ((next = MatchChars(p' numfmt.PositiveSign)) != null)                          {                              ch = *(p = next);                          }                          else if ((next = MatchChars(p' numfmt.NegativeSign)) != null)                          {                              ch = *(p = next);                              negExp = true;                          }                          if (ch >= '0' && ch <= '9')                          {                              int exp = 0;                              do                              {                                  exp = exp * 10 + (ch - '0');                                  ch = *++p;                                  if (exp > 1000)                                  {                                      exp = 9999;                                      while (ch >= '0' && ch <= '9')                                      {                                          ch = *++p;                                      }                                  }                              } while (ch >= '0' && ch <= '9');                              if (negExp)                              {                                  exp = -exp;                              }                              number.scale += exp;                          }                          else                          {                              p = temp;                              ch = *p;                          }                      }                      while (true)                      {                          if (!IsWhite(ch) || (options & NumberStyles.AllowTrailingWhite) == 0)                          {                              if (((options & NumberStyles.AllowTrailingSign) != 0 && ((state & StateSign) == 0)) && ((next = MatchChars(p' numfmt.PositiveSign)) != null || (((next = MatchChars(p' numfmt.NegativeSign)) != null) && (number.sign = true))))                              {                                  state |= StateSign;                                  p = next - 1;                              }                              else if (ch == ')' && ((state & StateParens) != 0))                              {                                  state &= ~StateParens;                              }                              else if (currSymbol != null && (next = MatchChars(p' currSymbol)) != null)                              {                                  currSymbol = null;                                  p = next - 1;                              }                              else                              {                                  break;                              }                          }                          ch = *++p;                      }                      if ((state & StateParens) == 0)                      {                          if ((state & StateNonZero) == 0)                          {                              if (!parseDecimal)                              {                                  number.scale = 0;                              }                              if ((state & StateDecimal) == 0)                              {                                  number.sign = false;                              }                          }                          str = p;                          return true;                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,Int32ToDecChars,The following statement contains a magic number: while (--digits >= 0 || value != 0)                  {                      buffer[--index] = (char)(value % 10 + '0');                      value /= 10;                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,Int32ToDecChars,The following statement contains a magic number: while (--digits >= 0 || value != 0)                  {                      buffer[--index] = (char)(value % 10 + '0');                      value /= 10;                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,ParseFormatSpecifier,The following statement contains a magic number: if (format.Length > 0)                  {                      // If the format begins with a symbol' see if it's a standard format                      // with or without a specified number of digits.                      c = format[0];                      if ((uint)(c - 'A') <= 'Z' - 'A' ||                          (uint)(c - 'a') <= 'z' - 'a')                      {                          // Fast path for sole symbol' e.g. "D"                          if (format.Length == 1)                          {                              digits = -1;                              return c;                          }                            if (format.Length == 2)                          {                              // Fast path for symbol and single digit' e.g. "X4"                              int d = format[1] - '0';                              if ((uint)d < 10)                              {                                  digits = d;                                  return c;                              }                          }                          else if (format.Length == 3)                          {                              // Fast path for symbol and double digit' e.g. "F12"                              int d1 = format[1] - '0'' d2 = format[2] - '0';                              if ((uint)d1 < 10 && (uint)d2 < 10)                              {                                  digits = d1 * 10 + d2;                                  return c;                              }                          }                            // Fallback for symbol and any length digits.  The digits value must be >= 0 && <= 99'                          // but it can begin with any number of 0s' and thus we may need to check more than two                          // digits.  Further' for compat' we need to stop when we hit a null char.                          int n = 0;                          int i = 1;                          while (i < format.Length && (((uint)format[i] - '0') < 10) && n < 10)                          {                              n = (n * 10) + format[i++] - '0';                          }                            // If we're at the end of the digits rather than having stopped because we hit something                          // other than a digit or overflowed' return the standard format info.                          if (i == format.Length || format[i] == '\0')                          {                              digits = n;                              return c;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToString,The following statement contains a magic number: switch (format)                  {                      case 'C':                      case 'c':                          {                              nMinDigits = nMaxDigits >= 0 ? nMaxDigits : info.CurrencyDecimalDigits;                              if (nMaxDigits < 0)                              {                                  nMaxDigits = info.CurrencyDecimalDigits;                              }                                RoundNumber(ref number' number.scale + nMaxDigits); // Don't change this line to use digPos since digCount could have its sign changed.                                FormatCurrency(ref sb' ref number' nMinDigits' nMaxDigits' info);                                break;                          }                        case 'F':                      case 'f':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = info.NumberDecimalDigits;                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                                RoundNumber(ref number' number.scale + nMaxDigits);                                if (number.sign)                              {                                  sb.Append(info.NegativeSign);                              }                                FormatFixed(ref sb' ref number' nMinDigits' nMaxDigits' info' null' info.NumberDecimalSeparator' null);                                break;                          }                        case 'N':                      case 'n':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = info.NumberDecimalDigits; // Since we are using digits in our calculation                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                                RoundNumber(ref number' number.scale + nMaxDigits);                                FormatNumber(ref sb' ref number' nMinDigits' nMaxDigits' info);                                break;                          }                        case 'E':                      case 'e':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = 6;                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                              nMaxDigits++;                                RoundNumber(ref number' nMaxDigits);                                if (number.sign)                              {                                  sb.Append(info.NegativeSign);                              }                                FormatScientific(ref sb' ref number' nMinDigits' nMaxDigits' info' format);                                break;                          }                        case 'G':                      case 'g':                          {                              bool enableRounding = true;                              if (nMaxDigits < 1)                              {                                  if (isDecimal && (nMaxDigits == -1))                                  {                                      // Default to 29 digits precision only for G formatting without a precision specifier                                      // This ensures that the PAL code pads out to the correct place even when we use the default precision                                      nMaxDigits = nMinDigits = DECIMAL_PRECISION;                                      enableRounding = false;  // Turn off rounding for ECMA compliance to output trailing 0's after decimal as significant                                  }                                  else                                  {                                      // This ensures that the PAL code pads out to the correct place even when we use the default precision                                      nMaxDigits = nMinDigits = number.precision;                                  }                              }                              else                                  nMinDigits = nMaxDigits;                                if (enableRounding) // Don't round for G formatting without precision                              {                                  RoundNumber(ref number' nMaxDigits); // This also fixes up the minus zero case                              }                              else                              {                                  if (isDecimal && (number.digits[0] == 0))                                  {                                      // Minus zero should be formatted as 0                                      number.sign = false;                                  }                              }                                if (number.sign)                              {                                  sb.Append(info.NegativeSign);                              }                                FormatGeneral(ref sb' ref number' nMinDigits' nMaxDigits' info' (char)(format - ('G' - 'E'))' !enableRounding);                                break;                          }                        case 'P':                      case 'p':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = info.PercentDecimalDigits;                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                              number.scale += 2;                                RoundNumber(ref number' number.scale + nMaxDigits);                                FormatPercent(ref sb' ref number' nMinDigits' nMaxDigits' info);                                break;                          }                        default:                          throw new FormatException(SR.Argument_BadFormatSpecifier);                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToString,The following statement contains a magic number: switch (format)                  {                      case 'C':                      case 'c':                          {                              nMinDigits = nMaxDigits >= 0 ? nMaxDigits : info.CurrencyDecimalDigits;                              if (nMaxDigits < 0)                              {                                  nMaxDigits = info.CurrencyDecimalDigits;                              }                                RoundNumber(ref number' number.scale + nMaxDigits); // Don't change this line to use digPos since digCount could have its sign changed.                                FormatCurrency(ref sb' ref number' nMinDigits' nMaxDigits' info);                                break;                          }                        case 'F':                      case 'f':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = info.NumberDecimalDigits;                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                                RoundNumber(ref number' number.scale + nMaxDigits);                                if (number.sign)                              {                                  sb.Append(info.NegativeSign);                              }                                FormatFixed(ref sb' ref number' nMinDigits' nMaxDigits' info' null' info.NumberDecimalSeparator' null);                                break;                          }                        case 'N':                      case 'n':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = info.NumberDecimalDigits; // Since we are using digits in our calculation                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                                RoundNumber(ref number' number.scale + nMaxDigits);                                FormatNumber(ref sb' ref number' nMinDigits' nMaxDigits' info);                                break;                          }                        case 'E':                      case 'e':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = 6;                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                              nMaxDigits++;                                RoundNumber(ref number' nMaxDigits);                                if (number.sign)                              {                                  sb.Append(info.NegativeSign);                              }                                FormatScientific(ref sb' ref number' nMinDigits' nMaxDigits' info' format);                                break;                          }                        case 'G':                      case 'g':                          {                              bool enableRounding = true;                              if (nMaxDigits < 1)                              {                                  if (isDecimal && (nMaxDigits == -1))                                  {                                      // Default to 29 digits precision only for G formatting without a precision specifier                                      // This ensures that the PAL code pads out to the correct place even when we use the default precision                                      nMaxDigits = nMinDigits = DECIMAL_PRECISION;                                      enableRounding = false;  // Turn off rounding for ECMA compliance to output trailing 0's after decimal as significant                                  }                                  else                                  {                                      // This ensures that the PAL code pads out to the correct place even when we use the default precision                                      nMaxDigits = nMinDigits = number.precision;                                  }                              }                              else                                  nMinDigits = nMaxDigits;                                if (enableRounding) // Don't round for G formatting without precision                              {                                  RoundNumber(ref number' nMaxDigits); // This also fixes up the minus zero case                              }                              else                              {                                  if (isDecimal && (number.digits[0] == 0))                                  {                                      // Minus zero should be formatted as 0                                      number.sign = false;                                  }                              }                                if (number.sign)                              {                                  sb.Append(info.NegativeSign);                              }                                FormatGeneral(ref sb' ref number' nMinDigits' nMaxDigits' info' (char)(format - ('G' - 'E'))' !enableRounding);                                break;                          }                        case 'P':                      case 'p':                          {                              if (nMaxDigits < 0)                              {                                  nMaxDigits = nMinDigits = info.PercentDecimalDigits;                              }                              else                              {                                  nMinDigits = nMaxDigits;                              }                              number.scale += 2;                                RoundNumber(ref number' number.scale + nMaxDigits);                                FormatPercent(ref sb' ref number' nMinDigits' nMaxDigits' info);                                break;                          }                        default:                          throw new FormatException(SR.Argument_BadFormatSpecifier);                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatScientific,The following statement contains a magic number: FormatExponent(ref sb' info' e' expChar' 3' true);
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatExponent,The following statement contains a magic number: char* digits = stackalloc char[11];
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatExponent,The following statement contains a magic number: int index = 10;
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatExponent,The following statement contains a magic number: int i = 10 - index;
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatGeneral,The following statement contains a magic number: if (!bSuppressScientific)                  {                      // Don't switch to scientific notation                      if (digPos > nMaxDigits || digPos < -3)                      {                          digPos = 1;                          scientific = true;                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FormatGeneral,The following statement contains a magic number: if (scientific)                  {                      FormatExponent(ref sb' info' number.scale - 1' expChar' 2' true);                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: section = FindSection(format' dig[0] == 0 ? 2 : number.sign ? 1 : 0);
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: while (true)                  {                      digitCount = 0;                      decimalPos = -1;                      firstDigit = 0x7FFFFFFF;                      lastDigit = 0;                      scientific = false;                      thousandPos = -1;                      thousandSeps = false;                      scaleAdjust = 0;                      src = section;                        fixed (char* pFormat = &format.DangerousGetPinnableReference())                      {                          while (src < format.Length && (ch = pFormat[src++]) != 0 && ch != ';')                          {                              switch (ch)                              {                                  case '#':                                      digitCount++;                                      break;                                  case '0':                                      if (firstDigit == 0x7FFFFFFF)                                      {                                          firstDigit = digitCount;                                      }                                      digitCount++;                                      lastDigit = digitCount;                                      break;                                  case '.':                                      if (decimalPos < 0)                                      {                                          decimalPos = digitCount;                                      }                                      break;                                  case ''':                                      if (digitCount > 0 && decimalPos < 0)                                      {                                          if (thousandPos >= 0)                                          {                                              if (thousandPos == digitCount)                                              {                                                  thousandCount++;                                                  break;                                              }                                              thousandSeps = true;                                          }                                          thousandPos = digitCount;                                          thousandCount = 1;                                      }                                      break;                                  case '%':                                      scaleAdjust += 2;                                      break;                                  case '\x2030':                                      scaleAdjust += 3;                                      break;                                  case '\'':                                  case '"':                                      while (src < format.Length && pFormat[src] != 0 && pFormat[src++] != ch)                                          ;                                      break;                                  case '\\':                                      if (src < format.Length && pFormat[src] != 0)                                      {                                          src++;                                      }                                      break;                                  case 'E':                                  case 'e':                                      if ((src < format.Length && pFormat[src] == '0') ||                                          (src + 1 < format.Length && (pFormat[src] == '+' || pFormat[src] == '-') && pFormat[src + 1] == '0'))                                      {                                          while (++src < format.Length && pFormat[src] == '0');                                          scientific = true;                                      }                                      break;                              }                          }                      }                        if (decimalPos < 0)                      {                          decimalPos = digitCount;                      }                        if (thousandPos >= 0)                      {                          if (thousandPos == decimalPos)                          {                              scaleAdjust -= thousandCount * 3;                          }                          else                          {                              thousandSeps = true;                          }                      }                        if (dig[0] != 0)                      {                          number.scale += scaleAdjust;                          int pos = scientific ? digitCount : number.scale + digitCount - decimalPos;                          RoundNumber(ref number' pos);                          if (dig[0] == 0)                          {                              src = FindSection(format' 2);                              if (src != section)                              {                                  section = src;                                  continue;                              }                          }                      }                      else                      {                          number.sign = false;   // We need to format -0 without the sign set.                          number.scale = 0;      // Decimals with scale ('0.00') should be rounded.                      }                        break;                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: while (true)                  {                      digitCount = 0;                      decimalPos = -1;                      firstDigit = 0x7FFFFFFF;                      lastDigit = 0;                      scientific = false;                      thousandPos = -1;                      thousandSeps = false;                      scaleAdjust = 0;                      src = section;                        fixed (char* pFormat = &format.DangerousGetPinnableReference())                      {                          while (src < format.Length && (ch = pFormat[src++]) != 0 && ch != ';')                          {                              switch (ch)                              {                                  case '#':                                      digitCount++;                                      break;                                  case '0':                                      if (firstDigit == 0x7FFFFFFF)                                      {                                          firstDigit = digitCount;                                      }                                      digitCount++;                                      lastDigit = digitCount;                                      break;                                  case '.':                                      if (decimalPos < 0)                                      {                                          decimalPos = digitCount;                                      }                                      break;                                  case ''':                                      if (digitCount > 0 && decimalPos < 0)                                      {                                          if (thousandPos >= 0)                                          {                                              if (thousandPos == digitCount)                                              {                                                  thousandCount++;                                                  break;                                              }                                              thousandSeps = true;                                          }                                          thousandPos = digitCount;                                          thousandCount = 1;                                      }                                      break;                                  case '%':                                      scaleAdjust += 2;                                      break;                                  case '\x2030':                                      scaleAdjust += 3;                                      break;                                  case '\'':                                  case '"':                                      while (src < format.Length && pFormat[src] != 0 && pFormat[src++] != ch)                                          ;                                      break;                                  case '\\':                                      if (src < format.Length && pFormat[src] != 0)                                      {                                          src++;                                      }                                      break;                                  case 'E':                                  case 'e':                                      if ((src < format.Length && pFormat[src] == '0') ||                                          (src + 1 < format.Length && (pFormat[src] == '+' || pFormat[src] == '-') && pFormat[src + 1] == '0'))                                      {                                          while (++src < format.Length && pFormat[src] == '0');                                          scientific = true;                                      }                                      break;                              }                          }                      }                        if (decimalPos < 0)                      {                          decimalPos = digitCount;                      }                        if (thousandPos >= 0)                      {                          if (thousandPos == decimalPos)                          {                              scaleAdjust -= thousandCount * 3;                          }                          else                          {                              thousandSeps = true;                          }                      }                        if (dig[0] != 0)                      {                          number.scale += scaleAdjust;                          int pos = scientific ? digitCount : number.scale + digitCount - decimalPos;                          RoundNumber(ref number' pos);                          if (dig[0] == 0)                          {                              src = FindSection(format' 2);                              if (src != section)                              {                                  section = src;                                  continue;                              }                          }                      }                      else                      {                          number.sign = false;   // We need to format -0 without the sign set.                          number.scale = 0;      // Decimals with scale ('0.00') should be rounded.                      }                        break;                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: while (true)                  {                      digitCount = 0;                      decimalPos = -1;                      firstDigit = 0x7FFFFFFF;                      lastDigit = 0;                      scientific = false;                      thousandPos = -1;                      thousandSeps = false;                      scaleAdjust = 0;                      src = section;                        fixed (char* pFormat = &format.DangerousGetPinnableReference())                      {                          while (src < format.Length && (ch = pFormat[src++]) != 0 && ch != ';')                          {                              switch (ch)                              {                                  case '#':                                      digitCount++;                                      break;                                  case '0':                                      if (firstDigit == 0x7FFFFFFF)                                      {                                          firstDigit = digitCount;                                      }                                      digitCount++;                                      lastDigit = digitCount;                                      break;                                  case '.':                                      if (decimalPos < 0)                                      {                                          decimalPos = digitCount;                                      }                                      break;                                  case ''':                                      if (digitCount > 0 && decimalPos < 0)                                      {                                          if (thousandPos >= 0)                                          {                                              if (thousandPos == digitCount)                                              {                                                  thousandCount++;                                                  break;                                              }                                              thousandSeps = true;                                          }                                          thousandPos = digitCount;                                          thousandCount = 1;                                      }                                      break;                                  case '%':                                      scaleAdjust += 2;                                      break;                                  case '\x2030':                                      scaleAdjust += 3;                                      break;                                  case '\'':                                  case '"':                                      while (src < format.Length && pFormat[src] != 0 && pFormat[src++] != ch)                                          ;                                      break;                                  case '\\':                                      if (src < format.Length && pFormat[src] != 0)                                      {                                          src++;                                      }                                      break;                                  case 'E':                                  case 'e':                                      if ((src < format.Length && pFormat[src] == '0') ||                                          (src + 1 < format.Length && (pFormat[src] == '+' || pFormat[src] == '-') && pFormat[src + 1] == '0'))                                      {                                          while (++src < format.Length && pFormat[src] == '0');                                          scientific = true;                                      }                                      break;                              }                          }                      }                        if (decimalPos < 0)                      {                          decimalPos = digitCount;                      }                        if (thousandPos >= 0)                      {                          if (thousandPos == decimalPos)                          {                              scaleAdjust -= thousandCount * 3;                          }                          else                          {                              thousandSeps = true;                          }                      }                        if (dig[0] != 0)                      {                          number.scale += scaleAdjust;                          int pos = scientific ? digitCount : number.scale + digitCount - decimalPos;                          RoundNumber(ref number' pos);                          if (dig[0] == 0)                          {                              src = FindSection(format' 2);                              if (src != section)                              {                                  section = src;                                  continue;                              }                          }                      }                      else                      {                          number.sign = false;   // We need to format -0 without the sign set.                          number.scale = 0;      // Decimals with scale ('0.00') should be rounded.                      }                        break;                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: while (true)                  {                      digitCount = 0;                      decimalPos = -1;                      firstDigit = 0x7FFFFFFF;                      lastDigit = 0;                      scientific = false;                      thousandPos = -1;                      thousandSeps = false;                      scaleAdjust = 0;                      src = section;                        fixed (char* pFormat = &format.DangerousGetPinnableReference())                      {                          while (src < format.Length && (ch = pFormat[src++]) != 0 && ch != ';')                          {                              switch (ch)                              {                                  case '#':                                      digitCount++;                                      break;                                  case '0':                                      if (firstDigit == 0x7FFFFFFF)                                      {                                          firstDigit = digitCount;                                      }                                      digitCount++;                                      lastDigit = digitCount;                                      break;                                  case '.':                                      if (decimalPos < 0)                                      {                                          decimalPos = digitCount;                                      }                                      break;                                  case ''':                                      if (digitCount > 0 && decimalPos < 0)                                      {                                          if (thousandPos >= 0)                                          {                                              if (thousandPos == digitCount)                                              {                                                  thousandCount++;                                                  break;                                              }                                              thousandSeps = true;                                          }                                          thousandPos = digitCount;                                          thousandCount = 1;                                      }                                      break;                                  case '%':                                      scaleAdjust += 2;                                      break;                                  case '\x2030':                                      scaleAdjust += 3;                                      break;                                  case '\'':                                  case '"':                                      while (src < format.Length && pFormat[src] != 0 && pFormat[src++] != ch)                                          ;                                      break;                                  case '\\':                                      if (src < format.Length && pFormat[src] != 0)                                      {                                          src++;                                      }                                      break;                                  case 'E':                                  case 'e':                                      if ((src < format.Length && pFormat[src] == '0') ||                                          (src + 1 < format.Length && (pFormat[src] == '+' || pFormat[src] == '-') && pFormat[src + 1] == '0'))                                      {                                          while (++src < format.Length && pFormat[src] == '0');                                          scientific = true;                                      }                                      break;                              }                          }                      }                        if (decimalPos < 0)                      {                          decimalPos = digitCount;                      }                        if (thousandPos >= 0)                      {                          if (thousandPos == decimalPos)                          {                              scaleAdjust -= thousandCount * 3;                          }                          else                          {                              thousandSeps = true;                          }                      }                        if (dig[0] != 0)                      {                          number.scale += scaleAdjust;                          int pos = scientific ? digitCount : number.scale + digitCount - decimalPos;                          RoundNumber(ref number' pos);                          if (dig[0] == 0)                          {                              src = FindSection(format' 2);                              if (src != section)                              {                                  section = src;                                  continue;                              }                          }                      }                      else                      {                          number.sign = false;   // We need to format -0 without the sign set.                          number.scale = 0;      // Decimals with scale ('0.00') should be rounded.                      }                        break;                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: Span<int> thousandsSepPos = stackalloc int[4];
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: if (thousandSeps)                  {                      // We need to precompute this outside the number formatting loop                      if (info.NumberGroupSeparator.Length > 0)                      {                          // We need this array to figure out where to insert the thousands separator. We would have to traverse the string                          // backwards. PIC formatting always traverses forwards. These indices are precomputed to tell us where to insert                          // the thousands separator so we can get away with traversing forwards. Note we only have to compute up to digPos.                          // The max is not bound since you can have formatting strings of the form "000'000.."' and this                          // should handle that case too.                            int[] groupDigits = info.NumberGroupSizes;                            int groupSizeIndex = 0;     // Index into the groupDigits array.                          int groupTotalSizeCount = 0;                          int groupSizeLen = groupDigits.Length;    // The length of groupDigits array.                          if (groupSizeLen != 0)                          {                              groupTotalSizeCount = groupDigits[groupSizeIndex];   // The current running total of group size.                          }                            int groupSize = groupTotalSizeCount;                            int totalDigits = digPos + ((adjust < 0) ? adjust : 0); // Actual number of digits in o/p                          int numDigits = (firstDigit > totalDigits) ? firstDigit : totalDigits;                          while (numDigits > groupTotalSizeCount)                          {                              if (groupSize == 0)                              {                                  break;                              }                                ++thousandsSepCtr;                              if (thousandsSepCtr >= thousandsSepPos.Length)                              {                                  var newThousandsSepPos = new int[thousandsSepPos.Length * 2];                                  bool copied = thousandsSepPos.TryCopyTo(newThousandsSepPos);                                  Debug.Assert(copied' "Expect copy to succeed' as the new array is larger than the original");                                  thousandsSepPos = newThousandsSepPos;                              }                                thousandsSepPos[thousandsSepCtr] = groupTotalSizeCount;                              if (groupSizeIndex < groupSizeLen - 1)                              {                                  groupSizeIndex++;                                  groupSize = groupDigits[groupSizeIndex];                              }                              groupTotalSizeCount += groupSize;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: fixed (char* pFormat = &format.DangerousGetPinnableReference())                  {                      char* cur = dig;                        while (src < format.Length && (ch = pFormat[src++]) != 0 && ch != ';')                      {                          if (adjust > 0)                          {                              switch (ch)                              {                                  case '#':                                  case '0':                                  case '.':                                      while (adjust > 0)                                      {                                          // digPos will be one greater than thousandsSepPos[thousandsSepCtr] since we are at                                          // the character after which the groupSeparator needs to be appended.                                          sb.Append(*cur != 0 ? *cur++ : '0');                                          if (thousandSeps && digPos > 1 && thousandsSepCtr >= 0)                                          {                                              if (digPos == thousandsSepPos[thousandsSepCtr] + 1)                                              {                                                  sb.Append(info.NumberGroupSeparator);                                                  thousandsSepCtr--;                                              }                                          }                                          digPos--;                                          adjust--;                                      }                                      break;                              }                          }                            switch (ch)                          {                              case '#':                              case '0':                                  {                                      if (adjust < 0)                                      {                                          adjust++;                                          ch = digPos <= firstDigit ? '0' : '\0';                                      }                                      else                                      {                                          ch = *cur != 0 ? *cur++ : digPos > lastDigit ? '0' : '\0';                                      }                                      if (ch != 0)                                      {                                          sb.Append(ch);                                          if (thousandSeps && digPos > 1 && thousandsSepCtr >= 0)                                          {                                              if (digPos == thousandsSepPos[thousandsSepCtr] + 1)                                              {                                                  sb.Append(info.NumberGroupSeparator);                                                  thousandsSepCtr--;                                              }                                          }                                      }                                        digPos--;                                      break;                                  }                              case '.':                                  {                                      if (digPos != 0 || decimalWritten)                                      {                                          // For compatibility' don't echo repeated decimals                                          break;                                      }                                      // If the format has trailing zeros or the format has a decimal and digits remain                                      if (lastDigit < 0 || (decimalPos < digitCount && *cur != 0))                                      {                                          sb.Append(info.NumberDecimalSeparator);                                          decimalWritten = true;                                      }                                      break;                                  }                              case '\x2030':                                  sb.Append(info.PerMilleSymbol);                                  break;                              case '%':                                  sb.Append(info.PercentSymbol);                                  break;                              case ''':                                  break;                              case '\'':                              case '"':                                  while (src < format.Length && pFormat[src] != 0 && pFormat[src] != ch)                                  {                                      sb.Append(pFormat[src++]);                                  }                                    if (src < format.Length && pFormat[src] != 0)                                  {                                      src++;                                  }                                  break;                              case '\\':                                  if (src < format.Length && pFormat[src] != 0)                                  {                                      sb.Append(pFormat[src++]);                                  }                                  break;                              case 'E':                              case 'e':                                  {                                      bool positiveSign = false;                                      int i = 0;                                      if (scientific)                                      {                                          if (src < format.Length && pFormat[src] == '0')                                          {                                              // Handles E0' which should format the same as E-0                                              i++;                                          }                                          else if (src+1 < format.Length && pFormat[src] == '+' && pFormat[src + 1] == '0')                                          {                                              // Handles E+0                                              positiveSign = true;                                          }                                          else if (src+1 < format.Length && pFormat[src] == '-' && pFormat[src + 1] == '0')                                          {                                              // Handles E-0                                              // Do nothing' this is just a place holder s.t. we don't break out of the loop.                                          }                                          else                                          {                                              sb.Append(ch);                                              break;                                          }                                            while (++src < format.Length && pFormat[src] == '0')                                          {                                              i++;                                          }                                          if (i > 10)                                          {                                              i = 10;                                          }                                            int exp = dig[0] == 0 ? 0 : number.scale - decimalPos;                                          FormatExponent(ref sb' info' exp' ch' i' positiveSign);                                          scientific = false;                                      }                                      else                                      {                                          sb.Append(ch); // Copy E or e to output                                          if (src < format.Length)                                          {                                              if (pFormat[src] == '+' || pFormat[src] == '-')                                              {                                                  sb.Append(pFormat[src++]);                                              }                                              while (src < format.Length && pFormat[src] == '0')                                              {                                                  sb.Append(pFormat[src++]);                                              }                                          }                                      }                                      break;                                  }                              default:                                  sb.Append(ch);                                  break;                          }                      }                  }
Magic Number,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following statement contains a magic number: fixed (char* pFormat = &format.DangerousGetPinnableReference())                  {                      char* cur = dig;                        while (src < format.Length && (ch = pFormat[src++]) != 0 && ch != ';')                      {                          if (adjust > 0)                          {                              switch (ch)                              {                                  case '#':                                  case '0':                                  case '.':                                      while (adjust > 0)                                      {                                          // digPos will be one greater than thousandsSepPos[thousandsSepCtr] since we are at                                          // the character after which the groupSeparator needs to be appended.                                          sb.Append(*cur != 0 ? *cur++ : '0');                                          if (thousandSeps && digPos > 1 && thousandsSepCtr >= 0)                                          {                                              if (digPos == thousandsSepPos[thousandsSepCtr] + 1)                                              {                                                  sb.Append(info.NumberGroupSeparator);                                                  thousandsSepCtr--;                                              }                                          }                                          digPos--;                                          adjust--;                                      }                                      break;                              }                          }                            switch (ch)                          {                              case '#':                              case '0':                                  {                                      if (adjust < 0)                                      {                                          adjust++;                                          ch = digPos <= firstDigit ? '0' : '\0';                                      }                                      else                                      {                                          ch = *cur != 0 ? *cur++ : digPos > lastDigit ? '0' : '\0';                                      }                                      if (ch != 0)                                      {                                          sb.Append(ch);                                          if (thousandSeps && digPos > 1 && thousandsSepCtr >= 0)                                          {                                              if (digPos == thousandsSepPos[thousandsSepCtr] + 1)                                              {                                                  sb.Append(info.NumberGroupSeparator);                                                  thousandsSepCtr--;                                              }                                          }                                      }                                        digPos--;                                      break;                                  }                              case '.':                                  {                                      if (digPos != 0 || decimalWritten)                                      {                                          // For compatibility' don't echo repeated decimals                                          break;                                      }                                      // If the format has trailing zeros or the format has a decimal and digits remain                                      if (lastDigit < 0 || (decimalPos < digitCount && *cur != 0))                                      {                                          sb.Append(info.NumberDecimalSeparator);                                          decimalWritten = true;                                      }                                      break;                                  }                              case '\x2030':                                  sb.Append(info.PerMilleSymbol);                                  break;                              case '%':                                  sb.Append(info.PercentSymbol);                                  break;                              case ''':                                  break;                              case '\'':                              case '"':                                  while (src < format.Length && pFormat[src] != 0 && pFormat[src] != ch)                                  {                                      sb.Append(pFormat[src++]);                                  }                                    if (src < format.Length && pFormat[src] != 0)                                  {                                      src++;                                  }                                  break;                              case '\\':                                  if (src < format.Length && pFormat[src] != 0)                                  {                                      sb.Append(pFormat[src++]);                                  }                                  break;                              case 'E':                              case 'e':                                  {                                      bool positiveSign = false;                                      int i = 0;                                      if (scientific)                                      {                                          if (src < format.Length && pFormat[src] == '0')                                          {                                              // Handles E0' which should format the same as E-0                                              i++;                                          }                                          else if (src+1 < format.Length && pFormat[src] == '+' && pFormat[src + 1] == '0')                                          {                                              // Handles E+0                                              positiveSign = true;                                          }                                          else if (src+1 < format.Length && pFormat[src] == '-' && pFormat[src + 1] == '0')                                          {                                              // Handles E-0                                              // Do nothing' this is just a place holder s.t. we don't break out of the loop.                                          }                                          else                                          {                                              sb.Append(ch);                                              break;                                          }                                            while (++src < format.Length && pFormat[src] == '0')                                          {                                              i++;                                          }                                          if (i > 10)                                          {                                              i = 10;                                          }                                            int exp = dig[0] == 0 ? 0 : number.scale - decimalPos;                                          FormatExponent(ref sb' info' exp' ch' i' positiveSign);                                          scientific = false;                                      }                                      else                                      {                                          sb.Append(ch); // Copy E or e to output                                          if (src < format.Length)                                          {                                              if (pFormat[src] == '+' || pFormat[src] == '-')                                              {                                                  sb.Append(pFormat[src++]);                                              }                                              while (src < format.Length && pFormat[src] == '0')                                              {                                                  sb.Append(pFormat[src++]);                                              }                                          }                                      }                                      break;                                  }                              default:                                  sb.Append(ch);                                  break;                          }                      }                  }
Magic Number,System.Text,ValueStringBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Text\ValueStringBuilder.cs,Grow,The following statement contains a magic number: char[] poolArray = ArrayPool<char>.Shared.Rent(Math.Max(_pos + requiredAdditionalCapacity' _chars.Length * 2));
Duplicate Code,System.Numerics,BigIntegerCalculator,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Numerics\BigIntegerCalculator.AddSub.cs,Multiply,The method contains a code clone-set at the following line numbers (starting from the method definition): ((93' 113)' (120' 140))
Missing Default,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,FindSection,The following switch statement is missing a default case: switch (ch = pFormat[src++])                          {                              case '\'':                              case '"':                                  while (src < format.Length && pFormat[src] != 0 && pFormat[src++] != ch)                                      ;                                  break;                              case '\\':                                  if (src < format.Length && pFormat[src] != 0)                                  {                                      src++;                                  }                                  break;                              case ';':                                  if (--section != 0)                                  {                                      break;                                  }                                    if (src < format.Length && pFormat[src] != 0 && pFormat[src] != ';')                                  {                                      return src;                                  }                                    goto case '\0';                              case '\0':                                  return 0;                          }
Missing Default,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following switch statement is missing a default case: switch (ch)                              {                                  case '#':                                      digitCount++;                                      break;                                  case '0':                                      if (firstDigit == 0x7FFFFFFF)                                      {                                          firstDigit = digitCount;                                      }                                      digitCount++;                                      lastDigit = digitCount;                                      break;                                  case '.':                                      if (decimalPos < 0)                                      {                                          decimalPos = digitCount;                                      }                                      break;                                  case ''':                                      if (digitCount > 0 && decimalPos < 0)                                      {                                          if (thousandPos >= 0)                                          {                                              if (thousandPos == digitCount)                                              {                                                  thousandCount++;                                                  break;                                              }                                              thousandSeps = true;                                          }                                          thousandPos = digitCount;                                          thousandCount = 1;                                      }                                      break;                                  case '%':                                      scaleAdjust += 2;                                      break;                                  case '\x2030':                                      scaleAdjust += 3;                                      break;                                  case '\'':                                  case '"':                                      while (src < format.Length && pFormat[src] != 0 && pFormat[src++] != ch)                                          ;                                      break;                                  case '\\':                                      if (src < format.Length && pFormat[src] != 0)                                      {                                          src++;                                      }                                      break;                                  case 'E':                                  case 'e':                                      if ((src < format.Length && pFormat[src] == '0') ||                                          (src + 1 < format.Length && (pFormat[src] == '+' || pFormat[src] == '-') && pFormat[src + 1] == '0'))                                      {                                          while (++src < format.Length && pFormat[src] == '0');                                          scientific = true;                                      }                                      break;                              }
Missing Default,System.Globalization,Number,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Numerics\src\System\Globalization\FormatProvider.NumberBuffer.cs,NumberToStringFormat,The following switch statement is missing a default case: switch (ch)                              {                                  case '#':                                  case '0':                                  case '.':                                      while (adjust > 0)                                      {                                          // digPos will be one greater than thousandsSepPos[thousandsSepCtr] since we are at                                          // the character after which the groupSeparator needs to be appended.                                          sb.Append(*cur != 0 ? *cur++ : '0');                                          if (thousandSeps && digPos > 1 && thousandsSepCtr >= 0)                                          {                                              if (digPos == thousandsSepPos[thousandsSepCtr] + 1)                                              {                                                  sb.Append(info.NumberGroupSeparator);                                                  thousandsSepCtr--;                                              }                                          }                                          digPos--;                                          adjust--;                                      }                                      break;                              }
