Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The method has 149 lines of code.
Long Method,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,CalculateFC,The method has 119 lines of code.
Long Method,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The method has 588 lines of code.
Long Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanRegex,The method has 177 lines of code.
Long Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanCharClass,The method has 155 lines of code.
Long Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The method has 205 lines of code.
Long Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanDollar,The method has 101 lines of code.
Long Method,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The method has 220 lines of code.
Long Method,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,GenerateFindFirstChar,The method has 388 lines of code.
Long Method,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,GenerateOneCode,The method has 1298 lines of code.
Complex Method,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,Regex,Cyclomatic complexity of the method is 9
Complex Method,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,Cyclomatic complexity of the method is 19
Complex Method,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,AddLowercaseRange,Cyclomatic complexity of the method is 9
Complex Method,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,Canonicalize,Cyclomatic complexity of the method is 9
Complex Method,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,SetDescription,Cyclomatic complexity of the method is 14
Complex Method,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,AnchorDescription,Cyclomatic complexity of the method is 10
Complex Method,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,FindFirstChar,Cyclomatic complexity of the method is 9
Complex Method,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,ReduceRep,Cyclomatic complexity of the method is 8
Complex Method,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,ReduceAlternation,Cyclomatic complexity of the method is 8
Complex Method,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,Description,Cyclomatic complexity of the method is 10
Complex Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanRegex,Cyclomatic complexity of the method is 15
Complex Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanCharClass,Cyclomatic complexity of the method is 12
Complex Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBasicBackslash,Cyclomatic complexity of the method is 10
Complex Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanDollar,Cyclomatic complexity of the method is 10
Complex Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,AssignNameSlots,Cyclomatic complexity of the method is 10
Complex Method,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,IsTrueQuantifier,Cyclomatic complexity of the method is 8
Complex Method,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,Scan,Cyclomatic complexity of the method is 10
Complex Method,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,RegexCodeFromRegexTree,Cyclomatic complexity of the method is 9
Long Parameter List,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,Replace,The method has 5 parameters. Parameters: input' pattern' replacement' options' matchTimeout
Long Parameter List,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,Replace,The method has 5 parameters. Parameters: input' pattern' evaluator' options' matchTimeout
Long Parameter List,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,Run,The method has 6 parameters. Parameters: quick' prevlen' input' beginning' length' startat
Long Parameter List,System.Text.RegularExpressions,CachedCodeEntry,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,CachedCodeEntry,The method has 8 parameters. Parameters: key' capnames' capslist' code' caps' capsize' runner' repl
Long Parameter List,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,CharInClassInternal,The method has 5 parameters. Parameters: ch' set' start' mySetLength' myCategoryLength
Long Parameter List,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,CharInCategory,The method has 5 parameters. Parameters: ch' set' start' mySetLength' myCategoryLength
Long Parameter List,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,RegexCode,The method has 9 parameters. Parameters: codes' stringlist' trackcount' caps' capsize' bmPrefix' fcPrefix' anchors' rightToLeft
Long Parameter List,System.Text.RegularExpressions,RegexCompilationInfo,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompilationInfo.cs,RegexCompilationInfo,The method has 5 parameters. Parameters: pattern' options' name' fullnamespace' ispublic
Long Parameter List,System.Text.RegularExpressions,RegexCompilationInfo,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompilationInfo.cs,RegexCompilationInfo,The method has 6 parameters. Parameters: pattern' options' name' fullnamespace' ispublic' matchTimeout
Long Parameter List,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Match,The method has 6 parameters. Parameters: regex' capcount' text' begpos' len' startpos
Long Parameter List,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Reset,The method has 5 parameters. Parameters: regex' text' textbeg' textend' textstart
Long Parameter List,System.Text.RegularExpressions,MatchSparse,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,MatchSparse,The method has 7 parameters. Parameters: regex' caps' capcount' text' begpos' len' startpos
Long Parameter List,System.Text.RegularExpressions,MatchCollection,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatchCollection.cs,MatchCollection,The method has 5 parameters. Parameters: regex' input' beginning' length' startat
Long Parameter List,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ParseReplacement,The method has 5 parameters. Parameters: rep' caps' capsize' capnames' op
Long Parameter List,System.Text.RegularExpressions,RegexReplacement,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexReplacement.cs,Replace,The method has 5 parameters. Parameters: evaluator' regex' input' count' startat
Long Parameter List,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,Scan,The method has 7 parameters. Parameters: regex' text' textbeg' textend' textstart' prevlen' quick
Long Parameter List,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,Scan,The method has 8 parameters. Parameters: regex' text' textbeg' textend' textstart' prevlen' quick' timeout
Long Parameter List,System.Text.RegularExpressions,RegexTree,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexTree.cs,RegexTree,The method has 7 parameters. Parameters: root' caps' capnumlist' captop' capnames' capslist' opts
Long Identifier,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,,The length of the parameter DefaultMatchTimeout_ConfigKeyName is 33.
Long Statement,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,InitDefaultMatchTimeout,The length of the statement  "                    throw new ArgumentOutOfRangeException(SR.Format(SR.IllegalDefaultRegexMatchTimeoutInAppDomain' DefaultMatchTimeout_ConfigKeyName' defaultMatchTimeOut)); " is 152.
Long Statement,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,InitDefaultMatchTimeout,The length of the statement  "            throw new InvalidCastException(SR.Format(SR.IllegalDefaultRegexMatchTimeoutInAppDomain' DefaultMatchTimeout_ConfigKeyName' defaultMatchTimeoutObj)); " is 148.
Long Statement,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,MatchPattern,The length of the statement  "                    Debug.Assert(textinfo.ToLower(_pattern[i]) == _pattern[i]' "pattern should be converted to lower case in constructor!"); " is 120.
Long Statement,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,Dump,The length of the statement  "                        sb.Append(indent + "  " + Regex.Escape(Convert.ToString((char)i' CultureInfo.InvariantCulture)) + " " + _negativeASCII[i].ToString(CultureInfo.InvariantCulture) + "\n"); " is 169.
Long Statement,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,AddCharClass,The length of the statement  "            else if (_canonical && RangeCount() > 0 && cc.RangeCount() > 0 && cc.GetRangeAt(0)._first <= GetRangeAt(RangeCount() - 1)._last) " is 128.
Long Statement,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,SingletonChar,The length of the statement  "            Debug.Assert(IsSingleton(set) || IsSingletonInverse(set)' "Tried to get the singleton char out of a non singleton character class"); " is 132.
Long Statement,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,ParseRecursive,The length of the statement  "            return new RegexCharClass(charClass[start + FLAGS] == 1' ranges' new StringBuilder(charClass.Substring(end' myCategoryLength))' sub); " is 133.
Long Statement,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,FirstChars,The length of the statement  "            CultureInfo culture = ((t._options & RegexOptions.CultureInvariant) != 0) ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture; " is 134.
Long Statement,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Dump,The length of the statement  "                    System.Diagnostics.Debug.WriteLine("  (" + _matches[i][j * 2].ToString(CultureInfo.InvariantCulture) + "'" + _matches[i][j * 2 + 1].ToString(CultureInfo.InvariantCulture) + ") " + text); " is 186.
Long Statement,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,Description,The length of the statement  "                    ArgSb.Append("(index = " + _m.ToString(CultureInfo.InvariantCulture) + "' unindex = " + _n.ToString(CultureInfo.InvariantCulture) + ")"); " is 137.
Long Statement,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,Description,The length of the statement  "                    ArgSb.Append("(Min = " + _m.ToString(CultureInfo.InvariantCulture) + "' Max = " + (_n == int.MaxValue ? "inf" : Convert.ToString(_n' CultureInfo.InvariantCulture)) + ")"); " is 171.
Long Statement,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,Parse,The length of the statement  "            p = new RegexParser((op & RegexOptions.CultureInvariant) != 0 ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture); " is 123.
Long Statement,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ParseReplacement,The length of the statement  "            p = new RegexParser((op & RegexOptions.CultureInvariant) != 0 ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture); " is 123.
Long Statement,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,Scan,The length of the statement  "                    Debug.WriteLine("Search range: from " + runtextbeg.ToString(CultureInfo.InvariantCulture) + " to " + runtextend.ToString(CultureInfo.InvariantCulture)); " is 152.
Long Statement,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,Scan,The length of the statement  "                    Debug.WriteLine("Firstchar search starting at " + runtextpos.ToString(CultureInfo.InvariantCulture) + " stopping at " + stoppos.ToString(CultureInfo.InvariantCulture)); " is 168.
Long Statement,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The length of the statement  "                    runmatch = new MatchSparse(runregex' runregex.caps' runregex.capsize' runtext' runtextbeg' runtextend - runtextbeg' runtextstart); " is 130.
Long Statement,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,RegexCodeFromRegexTree,The length of the statement  "            CultureInfo culture = (tree._options & RegexOptions.CultureInvariant) != 0 ? CultureInfo.InvariantCulture : CultureInfo.CurrentCulture; " is 135.
Long Statement,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,RegexRunnerField,The length of the statement  "            return typeof(RegexRunner).GetField(fieldname' BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static); " is 139.
Long Statement,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,RegexRunnerMethod,The length of the statement  "            return typeof(RegexRunner).GetMethod(methname' BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance | BindingFlags.Static); " is 139.
Long Statement,System.Text.RegularExpressions,RegexLWCGCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexLWCGCompiler.cs,FactoryInstanceFromCode,The length of the statement  "            DynamicMethod firstCharMethod = DefineDynamicMethod("FindFirstChar" + regexnumString' typeof(bool)' typeof(CompiledRegexRunner)); " is 129.
Long Statement,System.Text.RegularExpressions,RegexLWCGCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexLWCGCompiler.cs,FactoryInstanceFromCode,The length of the statement  "            DynamicMethod trackCountMethod = DefineDynamicMethod("InitTrackCount" + regexnumString' null' typeof(CompiledRegexRunner)); " is 123.
Long Statement,System.Text.RegularExpressions,RegexLWCGCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexLWCGCompiler.cs,DefineDynamicMethod,The length of the statement  "            DynamicMethod dm = new DynamicMethod(methname' attribs' conventions' returntype' s_paramTypes' hostType' false /*skipVisibility*/); " is 131.
Complex Conditional,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,AddCharClass,The conditional expression  "_canonical && RangeCount() > 0 && cc.RangeCount() > 0 && cc.GetRangeAt(0)._first <= GetRangeAt(RangeCount() - 1)._last"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,AddSet,The conditional expression  "_canonical && RangeCount() > 0 && set.Length > 0 &&                  set[0] <= GetRangeAt(RangeCount() - 1)._last"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,IsEmpty,The conditional expression  "charClass[CATEGORYLENGTH] == 0 && charClass[FLAGS] == 0 && charClass[SETLENGTH] == 0 && !IsSubtraction(charClass)"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,IsSingleton,The conditional expression  "set[FLAGS] == 0 && set[CATEGORYLENGTH] == 0 && set[SETLENGTH] == 2 && !IsSubtraction(set) &&                  (set[SETSTART] == LastChar || set[SETSTART] + 1 == set[SETSTART + 1])"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,IsSingletonInverse,The conditional expression  "set[FLAGS] == 1 && set[CATEGORYLENGTH] == 0 && set[SETLENGTH] == 2 && !IsSubtraction(set) &&                  (set[SETSTART] == LastChar || set[SETSTART] + 1 == set[SETSTART + 1])"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,FindFirstChar,The conditional expression  "(0 != (_code._anchors & RegexFCD.Beginning) && runtextpos > runtextbeg) ||                          (0 != (_code._anchors & RegexFCD.Start) && runtextpos > runtextstart)"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,FindFirstChar,The conditional expression  "(0 != (_code._anchors & RegexFCD.End) && runtextpos < runtextend) ||                          (0 != (_code._anchors & RegexFCD.EndZ) && (runtextpos < runtextend - 1 ||                                                                 (runtextpos == runtextend - 1 && CharAt(runtextpos) != '\n'))) ||                          (0 != (_code._anchors & RegexFCD.Start) && runtextpos < runtextstart)"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,ReduceRep,The conditional expression  "!(childType >= Oneloop && childType <= Setloop && type == Loop ||                            childType >= Onelazy && childType <= Setlazy && type == Lazyloop)"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,ReduceAlternation,The conditional expression  "!wasLastSet || optionsLast != optionsAt || lastNodeCannotMerge || !RegexCharClass.IsMergeable(at._str)"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanRegex,The conditional expression  "CharsRight() > 0 && (!IsStopperX(ch = RightChar()) || ch == '{' && !IsTrueQuantifier())"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanRegex,The conditional expression  "CharsRight() > 0 && (!IsSpecial(ch = RightChar()) || ch == '{' && !IsTrueQuantifier())"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanCharClass,The conditional expression  "CharsRight() >= 1 && ch == '-' && !fTranslatedChar && RightChar() == '[' && !firstChar"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The conditional expression  "CharsRight() == 0 || RightChar() != '?' || (RightChar() == '?' && (CharsRight() > 1 && RightChar(1) == ')'))"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The conditional expression  "(capnum != -1 || proceed == true) && CharsRight() > 0 && RightChar() == '-'"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The conditional expression  "(capnum != -1 || uncapnum != -1) && CharsRight() > 0 && MoveRightGetChar() == close"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The conditional expression  "charsRight >= 4 && (rightchar2 == '<' && RightChar(3) != '!' && RightChar(3) != '=')"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBlank,The conditional expression  "CharsRight() >= 3 && RightChar(2) == '#' &&                               RightChar(1) == '?' && RightChar() == '('"  is complex.
Complex Conditional,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBlank,The conditional expression  "CharsRight() < 3 || RightChar(2) != '#' ||                          RightChar(1) != '?' || RightChar() != '('"  is complex.
Magic Number,System.Text.RegularExpressions,Regex,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\Regex.cs,GroupNumberFromName,The following statement contains a magic number: for (int i = 0; i < name.Length; i++)              {                  char ch = name[i];                    if (ch > '9' || ch < '0')                      return -1;                    result *= 10;                  result += (ch - '0');              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: _negativeASCII = new int[128];
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: for (int i = 0; i < 128; i++)                  _negativeASCII[i] = last - beforefirst;
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: _lowASCII = 127;
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: for (examine = last; examine != beforefirst; examine -= bump)              {                  ch = pattern[examine];                    if (ch < 128)                  {                      if (_lowASCII > ch)                          _lowASCII = ch;                        if (_highASCII < ch)                          _highASCII = ch;                        if (_negativeASCII[ch] == last - beforefirst)                          _negativeASCII[ch] = last - examine;                  }                  else                  {                      int i = ch >> 8;                      int j = ch & 0xFF;                        if (_negativeUnicode == null)                      {                          _negativeUnicode = new int[256][];                      }                        if (_negativeUnicode[i] == null)                      {                          int[] newarray = new int[256];                            for (int k = 0; k < newarray.Length; k++)                              newarray[k] = last - beforefirst;                            if (i == 0)                          {                              Array.Copy(_negativeASCII' 0' newarray' 0' 128);                              _negativeASCII = newarray;                          }                            _negativeUnicode[i] = newarray;                      }                        if (_negativeUnicode[i][j] == last - beforefirst)                          _negativeUnicode[i][j] = last - examine;                  }              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: for (examine = last; examine != beforefirst; examine -= bump)              {                  ch = pattern[examine];                    if (ch < 128)                  {                      if (_lowASCII > ch)                          _lowASCII = ch;                        if (_highASCII < ch)                          _highASCII = ch;                        if (_negativeASCII[ch] == last - beforefirst)                          _negativeASCII[ch] = last - examine;                  }                  else                  {                      int i = ch >> 8;                      int j = ch & 0xFF;                        if (_negativeUnicode == null)                      {                          _negativeUnicode = new int[256][];                      }                        if (_negativeUnicode[i] == null)                      {                          int[] newarray = new int[256];                            for (int k = 0; k < newarray.Length; k++)                              newarray[k] = last - beforefirst;                            if (i == 0)                          {                              Array.Copy(_negativeASCII' 0' newarray' 0' 128);                              _negativeASCII = newarray;                          }                            _negativeUnicode[i] = newarray;                      }                        if (_negativeUnicode[i][j] == last - beforefirst)                          _negativeUnicode[i][j] = last - examine;                  }              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: for (examine = last; examine != beforefirst; examine -= bump)              {                  ch = pattern[examine];                    if (ch < 128)                  {                      if (_lowASCII > ch)                          _lowASCII = ch;                        if (_highASCII < ch)                          _highASCII = ch;                        if (_negativeASCII[ch] == last - beforefirst)                          _negativeASCII[ch] = last - examine;                  }                  else                  {                      int i = ch >> 8;                      int j = ch & 0xFF;                        if (_negativeUnicode == null)                      {                          _negativeUnicode = new int[256][];                      }                        if (_negativeUnicode[i] == null)                      {                          int[] newarray = new int[256];                            for (int k = 0; k < newarray.Length; k++)                              newarray[k] = last - beforefirst;                            if (i == 0)                          {                              Array.Copy(_negativeASCII' 0' newarray' 0' 128);                              _negativeASCII = newarray;                          }                            _negativeUnicode[i] = newarray;                      }                        if (_negativeUnicode[i][j] == last - beforefirst)                          _negativeUnicode[i][j] = last - examine;                  }              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: for (examine = last; examine != beforefirst; examine -= bump)              {                  ch = pattern[examine];                    if (ch < 128)                  {                      if (_lowASCII > ch)                          _lowASCII = ch;                        if (_highASCII < ch)                          _highASCII = ch;                        if (_negativeASCII[ch] == last - beforefirst)                          _negativeASCII[ch] = last - examine;                  }                  else                  {                      int i = ch >> 8;                      int j = ch & 0xFF;                        if (_negativeUnicode == null)                      {                          _negativeUnicode = new int[256][];                      }                        if (_negativeUnicode[i] == null)                      {                          int[] newarray = new int[256];                            for (int k = 0; k < newarray.Length; k++)                              newarray[k] = last - beforefirst;                            if (i == 0)                          {                              Array.Copy(_negativeASCII' 0' newarray' 0' 128);                              _negativeASCII = newarray;                          }                            _negativeUnicode[i] = newarray;                      }                        if (_negativeUnicode[i][j] == last - beforefirst)                          _negativeUnicode[i][j] = last - examine;                  }              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,RegexBoyerMoore,The following statement contains a magic number: for (examine = last; examine != beforefirst; examine -= bump)              {                  ch = pattern[examine];                    if (ch < 128)                  {                      if (_lowASCII > ch)                          _lowASCII = ch;                        if (_highASCII < ch)                          _highASCII = ch;                        if (_negativeASCII[ch] == last - beforefirst)                          _negativeASCII[ch] = last - examine;                  }                  else                  {                      int i = ch >> 8;                      int j = ch & 0xFF;                        if (_negativeUnicode == null)                      {                          _negativeUnicode = new int[256][];                      }                        if (_negativeUnicode[i] == null)                      {                          int[] newarray = new int[256];                            for (int k = 0; k < newarray.Length; k++)                              newarray[k] = last - beforefirst;                            if (i == 0)                          {                              Array.Copy(_negativeASCII' 0' newarray' 0' 128);                              _negativeASCII = newarray;                          }                            _negativeUnicode[i] = newarray;                      }                        if (_negativeUnicode[i][j] == last - beforefirst)                          _negativeUnicode[i][j] = last - examine;                  }              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,Scan,The following statement contains a magic number: for (; ;)              {                  if (test >= endlimit || test < beglimit)                      return -1;                    chTest = text[test];                    if (_caseInsensitive)                      chTest = _culture.TextInfo.ToLower(chTest);                    if (chTest != chMatch)                  {                      if (chTest < 128)                          advance = _negativeASCII[chTest];                      else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))                          advance = unicodeLookup[chTest & 0xFF];                      else                          advance = defadv;                        test += advance;                  }                  else                  { // if (chTest == chMatch)                      test2 = test;                      match = startmatch;                        for (; ;)                      {                          if (match == endmatch)                              return (_rightToLeft ? test2 + 1 : test2);                            match -= bump;                          test2 -= bump;                            chTest = text[test2];                            if (_caseInsensitive)                              chTest = _culture.TextInfo.ToLower(chTest);                            if (chTest != _pattern[match])                          {                              advance = _positive[match];                              if ((chTest & 0xFF80) == 0)                                  test2 = (match - startmatch) + _negativeASCII[chTest];                              else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))                                  test2 = (match - startmatch) + unicodeLookup[chTest & 0xFF];                              else                              {                                  test += advance;                                  break;                              }                                if (_rightToLeft ? test2 < advance : test2 > advance)                                  advance = test2;                                test += advance;                              break;                          }                      }                  }              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,Scan,The following statement contains a magic number: for (; ;)              {                  if (test >= endlimit || test < beglimit)                      return -1;                    chTest = text[test];                    if (_caseInsensitive)                      chTest = _culture.TextInfo.ToLower(chTest);                    if (chTest != chMatch)                  {                      if (chTest < 128)                          advance = _negativeASCII[chTest];                      else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))                          advance = unicodeLookup[chTest & 0xFF];                      else                          advance = defadv;                        test += advance;                  }                  else                  { // if (chTest == chMatch)                      test2 = test;                      match = startmatch;                        for (; ;)                      {                          if (match == endmatch)                              return (_rightToLeft ? test2 + 1 : test2);                            match -= bump;                          test2 -= bump;                            chTest = text[test2];                            if (_caseInsensitive)                              chTest = _culture.TextInfo.ToLower(chTest);                            if (chTest != _pattern[match])                          {                              advance = _positive[match];                              if ((chTest & 0xFF80) == 0)                                  test2 = (match - startmatch) + _negativeASCII[chTest];                              else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))                                  test2 = (match - startmatch) + unicodeLookup[chTest & 0xFF];                              else                              {                                  test += advance;                                  break;                              }                                if (_rightToLeft ? test2 < advance : test2 > advance)                                  advance = test2;                                test += advance;                              break;                          }                      }                  }              }
Magic Number,System.Text.RegularExpressions,RegexBoyerMoore,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexBoyerMoore.cs,Scan,The following statement contains a magic number: for (; ;)              {                  if (test >= endlimit || test < beglimit)                      return -1;                    chTest = text[test];                    if (_caseInsensitive)                      chTest = _culture.TextInfo.ToLower(chTest);                    if (chTest != chMatch)                  {                      if (chTest < 128)                          advance = _negativeASCII[chTest];                      else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))                          advance = unicodeLookup[chTest & 0xFF];                      else                          advance = defadv;                        test += advance;                  }                  else                  { // if (chTest == chMatch)                      test2 = test;                      match = startmatch;                        for (; ;)                      {                          if (match == endmatch)                              return (_rightToLeft ? test2 + 1 : test2);                            match -= bump;                          test2 -= bump;                            chTest = text[test2];                            if (_caseInsensitive)                              chTest = _culture.TextInfo.ToLower(chTest);                            if (chTest != _pattern[match])                          {                              advance = _positive[match];                              if ((chTest & 0xFF80) == 0)                                  test2 = (match - startmatch) + _negativeASCII[chTest];                              else if (null != _negativeUnicode && (null != (unicodeLookup = _negativeUnicode[chTest >> 8])))                                  test2 = (match - startmatch) + unicodeLookup[chTest & 0xFF];                              else                              {                                  test += advance;                                  break;                              }                                if (_rightToLeft ? test2 < advance : test2 > advance)                                  advance = test2;                                test += advance;                              break;                          }                      }                  }              }
Magic Number,System.Text.RegularExpressions,CaptureCollection,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCaptureCollection.cs,GetCapture,The following statement contains a magic number: if (_captures == null)              {                  _captures = new Capture[_capcount];                  for (int j = 0; j < _capcount - 1; j++)                  {                      _captures[j] = new Capture(_group._text' _group._caps[j * 2]' _group._caps[j * 2 + 1]);                  }              }
Magic Number,System.Text.RegularExpressions,CaptureCollection,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCaptureCollection.cs,GetCapture,The following statement contains a magic number: if (_captures == null)              {                  _captures = new Capture[_capcount];                  for (int j = 0; j < _capcount - 1; j++)                  {                      _captures[j] = new Capture(_group._text' _group._caps[j * 2]' _group._caps[j * 2 + 1]);                  }              }
Magic Number,System.Text.RegularExpressions,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCaptureCollection.cs,MoveNext,The following statement contains a magic number: if (_index == -2)                      return false;
Magic Number,System.Text.RegularExpressions,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCaptureCollection.cs,MoveNext,The following statement contains a magic number: if (match == null)                  {                      _index = -2;                      return false;                  }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,RegexCharClass,The following statement contains a magic number: _rangelist = new List<SingleRange>(6);
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,AddSet,The following statement contains a magic number: for (i = 0; i < set.Length - 1; i += 2)              {                  _rangelist.Add(new SingleRange(set[i]' (char)(set[i + 1] - 1)));              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,AddLowercaseRange,The following statement contains a magic number: for (i = 0' iMax = s_lcTable.Length; i < iMax;)              {                  iMid = (i + iMax) / 2;                  if (s_lcTable[iMid]._chMax < chMin)                      i = iMid + 1;                  else                      iMax = iMid;              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,ConvertOldStringsToClass,The following statement contains a magic number: StringBuilder sb = StringBuilderCache.Acquire(set.Length + category.Length + 3);
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,ConvertOldStringsToClass,The following statement contains a magic number: if (set.Length >= 2 && set[0] == '\0' && set[1] == '\0')              {                  sb.Append((char)0x1);                  sb.Append((char)(set.Length - 2));                  sb.Append((char)category.Length);                  sb.Append(set.Substring(2));              }              else              {                  sb.Append((char)0x0);                  sb.Append((char)set.Length);                  sb.Append((char)category.Length);                  sb.Append(set);              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,ConvertOldStringsToClass,The following statement contains a magic number: if (set.Length >= 2 && set[0] == '\0' && set[1] == '\0')              {                  sb.Append((char)0x1);                  sb.Append((char)(set.Length - 2));                  sb.Append((char)category.Length);                  sb.Append(set.Substring(2));              }              else              {                  sb.Append((char)0x0);                  sb.Append((char)set.Length);                  sb.Append((char)category.Length);                  sb.Append(set);              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,ConvertOldStringsToClass,The following statement contains a magic number: if (set.Length >= 2 && set[0] == '\0' && set[1] == '\0')              {                  sb.Append((char)0x1);                  sb.Append((char)(set.Length - 2));                  sb.Append((char)category.Length);                  sb.Append(set.Substring(2));              }              else              {                  sb.Append((char)0x0);                  sb.Append((char)set.Length);                  sb.Append((char)category.Length);                  sb.Append(set);              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,IsSingleton,The following statement contains a magic number: if (set[FLAGS] == 0 && set[CATEGORYLENGTH] == 0 && set[SETLENGTH] == 2 && !IsSubtraction(set) &&                  (set[SETSTART] == LastChar || set[SETSTART] + 1 == set[SETSTART + 1]))                  return true;              else                  return false;
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,IsSingletonInverse,The following statement contains a magic number: if (set[FLAGS] == 1 && set[CATEGORYLENGTH] == 0 && set[SETLENGTH] == 2 && !IsSubtraction(set) &&                  (set[SETSTART] == LastChar || set[SETSTART] + 1 == set[SETSTART + 1]))                  return true;              else                  return false;
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,CharInClassInternal,The following statement contains a magic number: while (min != max)              {                  mid = (min + max) / 2;                  if (ch < set[mid])                      max = mid;                  else                      min = mid + 1;              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,ToStringClass,The following statement contains a magic number: int rangeLen = _rangelist.Count * 2;
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,ToStringClass,The following statement contains a magic number: StringBuilder sb = StringBuilderCache.Acquire(rangeLen + _categories.Length + 3);
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,SetFromProperty,The following statement contains a magic number: while (min != max)              {                  int mid = (min + max) / 2;                  int res = string.Compare(capname' s_propTable[mid][0]' StringComparison.Ordinal);                  if (res < 0)                      max = mid;                  else if (res > 0)                      min = mid + 1;                  else                  {                      string set = s_propTable[mid][1];                      Debug.Assert(!string.IsNullOrEmpty(set)' "Found a null/empty element in RegexCharClass prop table");                      if (invert)                      {                          if (set[0] == NullChar)                          {                              return set.Substring(1);                          }                          return NullCharString + set;                      }                      else                      {                          return set;                      }                  }              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,SetDescription,The following statement contains a magic number: while (index < SETSTART + set[SETLENGTH])              {                  ch1 = set[index];                  if (index + 1 < set.Length)                      ch2 = (char)(set[index + 1] - 1);                  else                      ch2 = LastChar;                    desc.Append(CharDescription(ch1));                    if (ch2 != ch1)                  {                      if (ch1 + 1 != ch2)                          desc.Append('-');                      desc.Append(CharDescription(ch2));                  }                  index += 2;              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,CharDescription,The following statement contains a magic number: if (ch < 256)              {                  sb.Append("\\x");                  shift = 8;              }              else              {                  sb.Append("\\u");                  shift = 16;              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,CharDescription,The following statement contains a magic number: if (ch < 256)              {                  sb.Append("\\x");                  shift = 8;              }              else              {                  sb.Append("\\u");                  shift = 16;              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,CharDescription,The following statement contains a magic number: if (ch < 256)              {                  sb.Append("\\x");                  shift = 8;              }              else              {                  sb.Append("\\u");                  shift = 16;              }
Magic Number,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,CharDescription,The following statement contains a magic number: while (shift > 0)              {                  shift -= 4;                  sb.Append(Hex[(ch >> shift) & 0xF]);              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeSize,The following statement contains a magic number: switch (opcode)              {                  case Nothing:                  case Bol:                  case Eol:                  case Boundary:                  case Nonboundary:                  case ECMABoundary:                  case NonECMABoundary:                  case Beginning:                  case Start:                  case EndZ:                  case End:                  case Nullmark:                  case Setmark:                  case Getmark:                  case Setjump:                  case Backjump:                  case Forejump:                  case Stop:                      return 1;                    case One:                  case Notone:                  case Multi:                  case Ref:                  case Testref:                  case Goto:                  case Nullcount:                  case Setcount:                  case Lazybranch:                  case Branchmark:                  case Lazybranchmark:                  case Prune:                  case Set:                      return 2;                    case Capturemark:                  case Branchcount:                  case Lazybranchcount:                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setlazy:                  case Setrep:                  case Setloop:                      return 3;                    default:                      throw new ArgumentException(SR.Format(SR.UnexpectedOpcode' opcode.ToString(CultureInfo.CurrentCulture)));              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeSize,The following statement contains a magic number: switch (opcode)              {                  case Nothing:                  case Bol:                  case Eol:                  case Boundary:                  case Nonboundary:                  case ECMABoundary:                  case NonECMABoundary:                  case Beginning:                  case Start:                  case EndZ:                  case End:                  case Nullmark:                  case Setmark:                  case Getmark:                  case Setjump:                  case Backjump:                  case Forejump:                  case Stop:                      return 1;                    case One:                  case Notone:                  case Multi:                  case Ref:                  case Testref:                  case Goto:                  case Nullcount:                  case Setcount:                  case Lazybranch:                  case Branchmark:                  case Lazybranchmark:                  case Prune:                  case Set:                      return 2;                    case Capturemark:                  case Branchcount:                  case Lazybranchcount:                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setlazy:                  case Setrep:                  case Setloop:                      return 3;                    default:                      throw new ArgumentException(SR.Format(SR.UnexpectedOpcode' opcode.ToString(CultureInfo.CurrentCulture)));              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following statement contains a magic number: switch (opcode)              {                  case One:                  case Notone:                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                      sb.Append("Ch = ");                      sb.Append(RegexCharClass.CharDescription((char)_codes[offset + 1]));                      break;                    case Set:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("Set = ");                      sb.Append(RegexCharClass.SetDescription(_strings[_codes[offset + 1]]));                      break;                    case Multi:                      sb.Append("String = ");                      sb.Append(_strings[_codes[offset + 1]]);                      break;                    case Ref:                  case Testref:                      sb.Append("Index = ");                      sb.Append(_codes[offset + 1]);                      break;                    case Capturemark:                      sb.Append("Index = ");                      sb.Append(_codes[offset + 1]);                      if (_codes[offset + 2] != -1)                      {                          sb.Append("' Unindex = ");                          sb.Append(_codes[offset + 2]);                      }                      break;                    case Nullcount:                  case Setcount:                      sb.Append("Value = ");                      sb.Append(_codes[offset + 1]);                      break;                    case Goto:                  case Lazybranch:                  case Branchmark:                  case Lazybranchmark:                  case Branchcount:                  case Lazybranchcount:                      sb.Append("Addr = ");                      sb.Append(_codes[offset + 1]);                      break;              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following statement contains a magic number: switch (opcode)              {                  case One:                  case Notone:                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                      sb.Append("Ch = ");                      sb.Append(RegexCharClass.CharDescription((char)_codes[offset + 1]));                      break;                    case Set:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("Set = ");                      sb.Append(RegexCharClass.SetDescription(_strings[_codes[offset + 1]]));                      break;                    case Multi:                      sb.Append("String = ");                      sb.Append(_strings[_codes[offset + 1]]);                      break;                    case Ref:                  case Testref:                      sb.Append("Index = ");                      sb.Append(_codes[offset + 1]);                      break;                    case Capturemark:                      sb.Append("Index = ");                      sb.Append(_codes[offset + 1]);                      if (_codes[offset + 2] != -1)                      {                          sb.Append("' Unindex = ");                          sb.Append(_codes[offset + 2]);                      }                      break;                    case Nullcount:                  case Setcount:                      sb.Append("Value = ");                      sb.Append(_codes[offset + 1]);                      break;                    case Goto:                  case Lazybranch:                  case Branchmark:                  case Lazybranchmark:                  case Branchcount:                  case Lazybranchcount:                      sb.Append("Addr = ");                      sb.Append(_codes[offset + 1]);                      break;              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following statement contains a magic number: switch (opcode)              {                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("' Rep = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;                    case Branchcount:                  case Lazybranchcount:                      sb.Append("' Limit = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following statement contains a magic number: switch (opcode)              {                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("' Rep = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;                    case Branchcount:                  case Lazybranchcount:                      sb.Append("' Limit = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following statement contains a magic number: switch (opcode)              {                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("' Rep = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;                    case Branchcount:                  case Lazybranchcount:                      sb.Append("' Limit = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;              }
Magic Number,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following statement contains a magic number: switch (opcode)              {                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("' Rep = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;                    case Branchcount:                  case Lazybranchcount:                      sb.Append("' Limit = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;              }
Magic Number,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,AnchorDescription,The following statement contains a magic number: if (sb.Length >= 2)                  return (sb.ToString(2' sb.Length - 2));
Magic Number,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,AnchorDescription,The following statement contains a magic number: if (sb.Length >= 2)                  return (sb.ToString(2' sb.Length - 2));
Magic Number,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,AnchorDescription,The following statement contains a magic number: if (sb.Length >= 2)                  return (sb.ToString(2' sb.Length - 2));
Magic Number,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,RegexFCD,The following statement contains a magic number: _fcStack = new RegexFC[32];
Magic Number,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,RegexFCD,The following statement contains a magic number: _intStack = new int[32];
Magic Number,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,PushInt,The following statement contains a magic number: if (_intDepth >= _intStack.Length)              {                  int[] expanded = new int[_intDepth * 2];                    Array.Copy(_intStack' 0' expanded' 0' _intDepth);                    _intStack = expanded;              }
Magic Number,System.Text.RegularExpressions,RegexFCD,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexFCD.cs,PushFC,The following statement contains a magic number: if (_fcDepth >= _fcStack.Length)              {                  RegexFC[] expanded = new RegexFC[_fcDepth * 2];                    Array.Copy(_fcStack' 0' expanded' 0' _fcDepth);                  _fcStack = expanded;              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,RegexInterpreter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexInterpreter.cs,Go,The following statement contains a magic number: for (; ;)              {                  if (advance >= 0)                  {                      // https://github.com/dotnet/coreclr/pull/14850#issuecomment-342256447                      // Single common Advance call to reduce method size; and single method inline point                      Advance(advance);                      advance = -1;                  }  #if DEBUG                  if (runmatch.Debug)                  {                      DumpState();                  }  #endif                    CheckTimeout();                    switch (Operator())                  {                      case RegexCode.Stop:                          return;                        case RegexCode.Nothing:                          break;                        case RegexCode.Goto:                          Goto(Operand(0));                          continue;                        case RegexCode.Testref:                          if (!IsMatched(Operand(0)))                              break;                          advance = 1;                          continue;                        case RegexCode.Lazybranch:                          TrackPush(Textpos());                          advance = 1;                          continue;                        case RegexCode.Lazybranch | RegexCode.Back:                          TrackPop();                          Textto(TrackPeek());                          Goto(Operand(0));                          continue;                        case RegexCode.Setmark:                          StackPush(Textpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Nullmark:                          StackPush(-1);                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setmark | RegexCode.Back:                      case RegexCode.Nullmark | RegexCode.Back:                          StackPop();                          break;                        case RegexCode.Getmark:                          StackPop();                          TrackPush(StackPeek());                          Textto(StackPeek());                          advance = 0;                          continue;                        case RegexCode.Getmark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          break;                        case RegexCode.Capturemark:                          if (Operand(1) != -1 && !IsMatched(Operand(1)))                              break;                          StackPop();                          if (Operand(1) != -1)                              TransferCapture(Operand(0)' Operand(1)' StackPeek()' Textpos());                          else                              Capture(Operand(0)' StackPeek()' Textpos());                          TrackPush(StackPeek());                            advance = 2;                            continue;                        case RegexCode.Capturemark | RegexCode.Back:                          TrackPop();                          StackPush(TrackPeek());                          Uncapture();                          if (Operand(0) != -1 && Operand(1) != -1)                              Uncapture();                            break;                        case RegexCode.Branchmark:                          {                              int matched;                              StackPop();                                matched = Textpos() - StackPeek();                                if (matched != 0)                              {                     // Nonempty match -> loop now                                  TrackPush(StackPeek()' Textpos());  // Save old mark' textpos                                  StackPush(Textpos());               // Make new mark                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Empty match -> straight now                                  TrackPush2(StackPeek());            // Save old mark                                  advance = 1;                        // Straight                              }                              continue;                          }                        case RegexCode.Branchmark | RegexCode.Back:                          TrackPop(2);                          StackPop();                          Textto(TrackPeek(1));                       // Recall position                          TrackPush2(TrackPeek());                    // Save old mark                          advance = 1;                                // Straight                          continue;                        case RegexCode.Branchmark | RegexCode.Back2:                          TrackPop();                          StackPush(TrackPeek());                     // Recall old mark                          break;                                      // Backtrack                        case RegexCode.Lazybranchmark:                          {                              // We hit this the first time through a lazy loop and after each                              // successful match of the inner expression.  It simply continues                              // on and doesn't loop.                              StackPop();                                int oldMarkPos = StackPeek();                                if (Textpos() != oldMarkPos)                              {              // Nonempty match -> try to loop again by going to 'back' state                                  if (oldMarkPos != -1)                                      TrackPush(oldMarkPos' Textpos());   // Save old mark' textpos                                  else                                      TrackPush(Textpos()' Textpos());                              }                              else                              {                                  // The inner expression found an empty match' so we'll go directly to 'back2' if we                                  // backtrack.  In this case' we need to push something on the stack' since back2 pops.                                  // However' in the case of ()+? or similar' this empty match may be legitimate' so push the text                                  // position associated with that empty match.                                  StackPush(oldMarkPos);                                    TrackPush2(StackPeek());                // Save old mark                              }                              advance = 1;                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back:                          {                              // After the first time' Lazybranchmark | RegexCode.Back occurs                              // with each iteration of the loop' and therefore with every attempted                              // match of the inner expression.  We'll try to match the inner expression'                              // then go back to Lazybranchmark if successful.  If the inner expression                              // fails' we go to Lazybranchmark | RegexCode.Back2                              int pos;                                TrackPop(2);                              pos = TrackPeek(1);                              TrackPush2(TrackPeek());                // Save old mark                              StackPush(pos);                         // Make new mark                              Textto(pos);                            // Recall position                              Goto(Operand(0));                       // Loop                              continue;                          }                        case RegexCode.Lazybranchmark | RegexCode.Back2:                          // The lazy loop has failed.  We'll do a true backtrack and                          // start over before the lazy loop.                          StackPop();                          TrackPop();                          StackPush(TrackPeek());                      // Recall old mark                          break;                        case RegexCode.Setcount:                          StackPush(Textpos()' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Nullcount:                          StackPush(-1' Operand(0));                          TrackPush();                          advance = 1;                          continue;                        case RegexCode.Setcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Nullcount | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Branchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                              int matched = Textpos() - mark;                                if (count >= Operand(1) || (matched == 0 && count >= 0))                              {                                   // Max loops or empty match -> straight now                                  TrackPush2(mark' count);            // Save old mark' count                                  advance = 2;                        // Straight                              }                              else                              {                                  // Nonempty match -> count+loop now                                  TrackPush(mark);                    // remember mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              continue;                          }                        case RegexCode.Branchcount | RegexCode.Back:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (= current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          if (StackPeek(1) > 0)                          {                         // Positive -> can go straight                              Textto(StackPeek());                        // Zap to mark                              TrackPush2(TrackPeek()' StackPeek(1) - 1);  // Save old mark' old count                              advance = 2;                                // Straight                              continue;                          }                          StackPush(TrackPeek()' StackPeek(1) - 1);       // recall old mark' old count                          break;                        case RegexCode.Branchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          //  1: Previous count                          TrackPop(2);                          StackPush(TrackPeek()' TrackPeek(1));           // Recall old mark' old count                          break;                                          // Backtrack                          case RegexCode.Lazybranchcount:                          // StackPush:                          //  0: Mark                          //  1: Count                          {                              StackPop(2);                              int mark = StackPeek();                              int count = StackPeek(1);                                if (count < 0)                              {                        // Negative count -> loop now                                  TrackPush2(mark);                   // Save old mark                                  StackPush(Textpos()' count + 1);    // Make new mark' incr count                                  Goto(Operand(0));                   // Loop                              }                              else                              {                                  // Nonneg count -> straight now                                  TrackPush(mark' count' Textpos());  // Save mark' count' position                                  advance = 2;                        // Straight                              }                              continue;                          }                        case RegexCode.Lazybranchcount | RegexCode.Back:                          // TrackPush:                          //  0: Mark                          //  1: Count                          //  2: Textpos                          {                              TrackPop(3);                              int mark = TrackPeek();                              int textpos = TrackPeek(2);                                if (TrackPeek(1) < Operand(1) && textpos != mark)                              { // Under limit and not empty match -> loop                                  Textto(textpos);                            // Recall position                                  StackPush(textpos' TrackPeek(1) + 1);       // Make new mark' incr count                                  TrackPush2(mark);                           // Save old mark                                  Goto(Operand(0));                           // Loop                                  continue;                              }                              else                              {                                          // Max loops or empty match -> backtrack                                  StackPush(TrackPeek()' TrackPeek(1));       // Recall old mark' count                                  break;                                      // backtrack                              }                          }                        case RegexCode.Lazybranchcount | RegexCode.Back2:                          // TrackPush:                          //  0: Previous mark                          // StackPush:                          //  0: Mark (== current pos' discarded)                          //  1: Count                          TrackPop();                          StackPop(2);                          StackPush(TrackPeek()' StackPeek(1) - 1);   // Recall old mark' count                          break;                                      // Backtrack                        case RegexCode.Setjump:                          StackPush(Trackpos()' Crawlpos());                          TrackPush();                          advance = 0;                          continue;                        case RegexCode.Setjump | RegexCode.Back:                          StackPop(2);                          break;                        case RegexCode.Backjump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                            while (Crawlpos() != StackPeek(1))                              Uncapture();                            break;                        case RegexCode.Forejump:                          // StackPush:                          //  0: Saved trackpos                          //  1: Crawlpos                          StackPop(2);                          Trackto(StackPeek());                          TrackPush(StackPeek(1));                          advance = 0;                          continue;                        case RegexCode.Forejump | RegexCode.Back:                          // TrackPush:                          //  0: Crawlpos                          TrackPop();                            while (Crawlpos() != TrackPeek())                              Uncapture();                            break;                        case RegexCode.Bol:                          if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Eol:                          if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.Boundary:                          if (!IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Nonboundary:                          if (IsBoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.ECMABoundary:                          if (!IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.NonECMABoundary:                          if (IsECMABoundary(Textpos()' runtextbeg' runtextend))                              break;                          advance = 0;                          continue;                        case RegexCode.Beginning:                          if (Leftchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.Start:                          if (Textpos() != Textstart())                              break;                          advance = 0;                          continue;                        case RegexCode.EndZ:                          if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                              break;                          advance = 0;                          continue;                        case RegexCode.End:                          if (Rightchars() > 0)                              break;                          advance = 0;                          continue;                        case RegexCode.One:                          if (Forwardchars() < 1 || Forwardcharnext() != (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Notone:                          if (Forwardchars() < 1 || Forwardcharnext() == (char)Operand(0))                              break;                            advance = 1;                          continue;                        case RegexCode.Set:                          if (Forwardchars() < 1 || !RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                              break;                            advance = 1;                          continue;                        case RegexCode.Multi:                          {                              if (!Stringmatch(_code._strings[Operand(0)]))                                  break;                                advance = 1;                              continue;                          }                        case RegexCode.Ref:                          {                              int capnum = Operand(0);                                if (IsMatched(capnum))                              {                                  if (!Refmatch(MatchIndex(capnum)' MatchLength(capnum)))                                      break;                              }                              else                              {                                  if ((runregex.roptions & RegexOptions.ECMAScript) == 0)                                      break;                              }                                advance = 1;                              continue;                          }                        case RegexCode.Onerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() != ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Notonerep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                char ch = (char)Operand(0);                                while (c-- > 0)                                  if (Forwardcharnext() == ch)                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Setrep:                          {                              int c = Operand(1);                                if (Forwardchars() < c)                                  break;                                string set = _code._strings[Operand(0)];                                while (c-- > 0)                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                      goto BreakBackward;                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() != ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notoneloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                char ch = (char)Operand(0);                              int i;                                for (i = c; i > 0; i--)                              {                                  if (Forwardcharnext() == ch)                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                string set = _code._strings[Operand(0)];                              int i;                                for (i = c; i > 0; i--)                              {                                  if (!RegexCharClass.CharInClass(Forwardcharnext()' set))                                  {                                      Backwardnext();                                      break;                                  }                              }                                if (c > i)                                  TrackPush(c - i - 1' Textpos() - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Oneloop | RegexCode.Back:                      case RegexCode.Notoneloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setloop | RegexCode.Back:                          {                              TrackPop(2);                              int i = TrackPeek();                              int pos = TrackPeek(1);                                Textto(pos);                                if (i > 0)                                  TrackPush(i - 1' pos - Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy:                      case RegexCode.Notonelazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy:                          {                              int c = Operand(1);                                if (c > Forwardchars())                                  c = Forwardchars();                                if (c > 0)                                  TrackPush(c - 1' Textpos());                                advance = 2;                              continue;                          }                        case RegexCode.Onelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() != (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Notonelazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (Forwardcharnext() == (char)Operand(0))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        case RegexCode.Setlazy | RegexCode.Back:                          {                              TrackPop(2);                              int pos = TrackPeek(1);                              Textto(pos);                                if (!RegexCharClass.CharInClass(Forwardcharnext()' _code._strings[Operand(0)]))                                  break;                                int i = TrackPeek();                                if (i > 0)                                  TrackPush(i - 1' pos + Bump());                                advance = 2;                              continue;                          }                        default:                          throw NotImplemented.ByDesignWithMessage(SR.UnimplementedState);                  }                BreakBackward:                  ;                    // "break Backward" comes here:                  Backtrack();              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,GroupToStringImpl,The following statement contains a magic number: return _text.Substring(matches[(c - 1) * 2]' matches[(c * 2) - 1]);
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,GroupToStringImpl,The following statement contains a magic number: return _text.Substring(matches[(c - 1) * 2]' matches[(c * 2) - 1]);
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,AddMatch,The following statement contains a magic number: if (_matches[cap] == null)                  _matches[cap] = new int[2];
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,AddMatch,The following statement contains a magic number: if (capcount * 2 + 2 > _matches[cap].Length)              {                  int[] oldmatches = _matches[cap];                  int[] newmatches = new int[capcount * 8];                  for (int j = 0; j < capcount * 2; j++)                      newmatches[j] = oldmatches[j];                  _matches[cap] = newmatches;              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,AddMatch,The following statement contains a magic number: if (capcount * 2 + 2 > _matches[cap].Length)              {                  int[] oldmatches = _matches[cap];                  int[] newmatches = new int[capcount * 8];                  for (int j = 0; j < capcount * 2; j++)                      newmatches[j] = oldmatches[j];                  _matches[cap] = newmatches;              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,AddMatch,The following statement contains a magic number: if (capcount * 2 + 2 > _matches[cap].Length)              {                  int[] oldmatches = _matches[cap];                  int[] newmatches = new int[capcount * 8];                  for (int j = 0; j < capcount * 2; j++)                      newmatches[j] = oldmatches[j];                  _matches[cap] = newmatches;              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,AddMatch,The following statement contains a magic number: if (capcount * 2 + 2 > _matches[cap].Length)              {                  int[] oldmatches = _matches[cap];                  int[] newmatches = new int[capcount * 8];                  for (int j = 0; j < capcount * 2; j++)                      newmatches[j] = oldmatches[j];                  _matches[cap] = newmatches;              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,AddMatch,The following statement contains a magic number: _matches[cap][capcount * 2] = start;
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,AddMatch,The following statement contains a magic number: _matches[cap][capcount * 2 + 1] = len;
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,BalanceMatch,The following statement contains a magic number: target = capcount * 2 - 2;
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,BalanceMatch,The following statement contains a magic number: target = capcount * 2 - 2;
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,BalanceMatch,The following statement contains a magic number: if (_matches[cap][target] < 0)                  target = -3 - _matches[cap][target];
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,BalanceMatch,The following statement contains a magic number: target -= 2;
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,BalanceMatch,The following statement contains a magic number: if (target >= 0 && _matches[cap][target] < 0)                  AddMatch(cap' _matches[cap][target]' _matches[cap][target + 1]);              else                  AddMatch(cap' -3 - target' -4 - target /* == -3 - (target + 1) */ );
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,BalanceMatch,The following statement contains a magic number: if (target >= 0 && _matches[cap][target] < 0)                  AddMatch(cap' _matches[cap][target]' _matches[cap][target + 1]);              else                  AddMatch(cap' -3 - target' -4 - target /* == -3 - (target + 1) */ );
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,IsMatched,The following statement contains a magic number: return cap < _matchcount.Length && _matchcount[cap] > 0 && _matches[cap][_matchcount[cap] * 2 - 1] != (-3 + 1);
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,IsMatched,The following statement contains a magic number: return cap < _matchcount.Length && _matchcount[cap] > 0 && _matches[cap][_matchcount[cap] * 2 - 1] != (-3 + 1);
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,MatchIndex,The following statement contains a magic number: int i = _matches[cap][_matchcount[cap] * 2 - 2];
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,MatchIndex,The following statement contains a magic number: int i = _matches[cap][_matchcount[cap] * 2 - 2];
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,MatchIndex,The following statement contains a magic number: return _matches[cap][-3 - i];
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,MatchLength,The following statement contains a magic number: int i = _matches[cap][_matchcount[cap] * 2 - 1];
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,MatchLength,The following statement contains a magic number: return _matches[cap][-3 - i];
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Tidy,The following statement contains a magic number: if (_balancing)              {                  // The idea here is that we want to compact all of our unbalanced captures.  To do that we                  // use j basically as a count of how many unbalanced captures we have at any given time                  // (really j is an index' but j/2 is the count).  First we skip past all of the real captures                  // until we find a balance captures.  Then we check each subsequent entry.  If it's a balance                  // capture (it's negative)' we decrement j.  If it's a real capture' we increment j and copy                  // it down to the last free position.                  for (int cap = 0; cap < _matchcount.Length; cap++)                  {                      int limit;                      int[] matcharray;                        limit = _matchcount[cap] * 2;                      matcharray = _matches[cap];                        int i = 0;                      int j;                        for (i = 0; i < limit; i++)                      {                          if (matcharray[i] < 0)                              break;                      }                        for (j = i; i < limit; i++)                      {                          if (matcharray[i] < 0)                          {                              // skip negative values                              j--;                          }                          else                          {                              // but if we find something positive (an actual capture)' copy it back to the last                              // unbalanced position.                              if (i != j)                                  matcharray[j] = matcharray[i];                              j++;                          }                      }                        _matchcount[cap] = j / 2;                  }                    _balancing = false;              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Tidy,The following statement contains a magic number: if (_balancing)              {                  // The idea here is that we want to compact all of our unbalanced captures.  To do that we                  // use j basically as a count of how many unbalanced captures we have at any given time                  // (really j is an index' but j/2 is the count).  First we skip past all of the real captures                  // until we find a balance captures.  Then we check each subsequent entry.  If it's a balance                  // capture (it's negative)' we decrement j.  If it's a real capture' we increment j and copy                  // it down to the last free position.                  for (int cap = 0; cap < _matchcount.Length; cap++)                  {                      int limit;                      int[] matcharray;                        limit = _matchcount[cap] * 2;                      matcharray = _matches[cap];                        int i = 0;                      int j;                        for (i = 0; i < limit; i++)                      {                          if (matcharray[i] < 0)                              break;                      }                        for (j = i; i < limit; i++)                      {                          if (matcharray[i] < 0)                          {                              // skip negative values                              j--;                          }                          else                          {                              // but if we find something positive (an actual capture)' copy it back to the last                              // unbalanced position.                              if (i != j)                                  matcharray[j] = matcharray[i];                              j++;                          }                      }                        _matchcount[cap] = j / 2;                  }                    _balancing = false;              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Dump,The following statement contains a magic number: for (i = 0; i < _matchcount.Length; i++)              {                  System.Diagnostics.Debug.WriteLine("Capnum " + i.ToString(CultureInfo.InvariantCulture) + ":");                    for (j = 0; j < _matchcount[i]; j++)                  {                      string text = "";                        if (_matches[i][j * 2] >= 0)                          text = _text.Substring(_matches[i][j * 2]' _matches[i][j * 2 + 1]);                        System.Diagnostics.Debug.WriteLine("  (" + _matches[i][j * 2].ToString(CultureInfo.InvariantCulture) + "'" + _matches[i][j * 2 + 1].ToString(CultureInfo.InvariantCulture) + ") " + text);                  }              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Dump,The following statement contains a magic number: for (i = 0; i < _matchcount.Length; i++)              {                  System.Diagnostics.Debug.WriteLine("Capnum " + i.ToString(CultureInfo.InvariantCulture) + ":");                    for (j = 0; j < _matchcount[i]; j++)                  {                      string text = "";                        if (_matches[i][j * 2] >= 0)                          text = _text.Substring(_matches[i][j * 2]' _matches[i][j * 2 + 1]);                        System.Diagnostics.Debug.WriteLine("  (" + _matches[i][j * 2].ToString(CultureInfo.InvariantCulture) + "'" + _matches[i][j * 2 + 1].ToString(CultureInfo.InvariantCulture) + ") " + text);                  }              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Dump,The following statement contains a magic number: for (i = 0; i < _matchcount.Length; i++)              {                  System.Diagnostics.Debug.WriteLine("Capnum " + i.ToString(CultureInfo.InvariantCulture) + ":");                    for (j = 0; j < _matchcount[i]; j++)                  {                      string text = "";                        if (_matches[i][j * 2] >= 0)                          text = _text.Substring(_matches[i][j * 2]' _matches[i][j * 2 + 1]);                        System.Diagnostics.Debug.WriteLine("  (" + _matches[i][j * 2].ToString(CultureInfo.InvariantCulture) + "'" + _matches[i][j * 2 + 1].ToString(CultureInfo.InvariantCulture) + ") " + text);                  }              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Dump,The following statement contains a magic number: for (i = 0; i < _matchcount.Length; i++)              {                  System.Diagnostics.Debug.WriteLine("Capnum " + i.ToString(CultureInfo.InvariantCulture) + ":");                    for (j = 0; j < _matchcount[i]; j++)                  {                      string text = "";                        if (_matches[i][j * 2] >= 0)                          text = _text.Substring(_matches[i][j * 2]' _matches[i][j * 2 + 1]);                        System.Diagnostics.Debug.WriteLine("  (" + _matches[i][j * 2].ToString(CultureInfo.InvariantCulture) + "'" + _matches[i][j * 2 + 1].ToString(CultureInfo.InvariantCulture) + ") " + text);                  }              }
Magic Number,System.Text.RegularExpressions,Match,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexMatch.cs,Dump,The following statement contains a magic number: for (i = 0; i < _matchcount.Length; i++)              {                  System.Diagnostics.Debug.WriteLine("Capnum " + i.ToString(CultureInfo.InvariantCulture) + ":");                    for (j = 0; j < _matchcount[i]; j++)                  {                      string text = "";                        if (_matches[i][j * 2] >= 0)                          text = _text.Substring(_matches[i][j * 2]' _matches[i][j * 2 + 1]);                        System.Diagnostics.Debug.WriteLine("  (" + _matches[i][j * 2].ToString(CultureInfo.InvariantCulture) + "'" + _matches[i][j * 2 + 1].ToString(CultureInfo.InvariantCulture) + ") " + text);                  }              }
Magic Number,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,ReduceRep,The following statement contains a magic number: for (; ;)              {                  if (u.ChildCount() == 0)                      break;                    child = u.Child(0);                    // multiply reps of the same type only                  if (child.Type() != type)                  {                      int childType = child.Type();                        if (!(childType >= Oneloop && childType <= Setloop && type == Loop ||                            childType >= Onelazy && childType <= Setlazy && type == Lazyloop))                          break;                  }                    // child can be too lumpy to blur' e.g.' (a {100'105}) {3} or (a {2'})?                  // [but things like (a {2'})+ are not too lumpy...]                  if (u._m == 0 && child._m > 1 || child._n < child._m * 2)                      break;                    u = child;                  if (u._m > 0)                      u._m = min = ((int.MaxValue - 1) / u._m < min) ? int.MaxValue : u._m * min;                  if (u._n > 0)                      u._n = max = ((int.MaxValue - 1) / u._n < max) ? int.MaxValue : u._n * max;              }
Magic Number,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,AddChild,The following statement contains a magic number: if (_children == null)                  _children = new List<RegexNode>(4);
Magic Number,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,Dump,The following statement contains a magic number: for (; ;)              {                  if (CurNode._children != null && CurChild < CurNode._children.Count)                  {                      Stack.Add(CurChild + 1);                      CurNode = CurNode._children[CurChild];                      CurChild = 0;                        int Depth = Stack.Count;                      if (Depth > 32)                          Depth = 32;                        Debug.WriteLine(Space.Substring(0' Depth) + CurNode.Description());                  }                  else                  {                      if (Stack.Count == 0)                          break;                        CurChild = Stack[Stack.Count - 1];                      Stack.RemoveAt(Stack.Count - 1);                      CurNode = CurNode._next;                  }              }
Magic Number,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,Dump,The following statement contains a magic number: for (; ;)              {                  if (CurNode._children != null && CurChild < CurNode._children.Count)                  {                      Stack.Add(CurChild + 1);                      CurNode = CurNode._children[CurChild];                      CurChild = 0;                        int Depth = Stack.Count;                      if (Depth > 32)                          Depth = 32;                        Debug.WriteLine(Space.Substring(0' Depth) + CurNode.Description());                  }                  else                  {                      if (Stack.Count == 0)                          break;                        CurChild = Stack[Stack.Count - 1];                      Stack.RemoveAt(Stack.Count - 1);                      CurNode = CurNode._next;                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanCharClass,The following statement contains a magic number: for (; CharsRight() > 0; firstChar = false)              {                  bool fTranslatedChar = false;                  ch = MoveRightGetChar();                  if (ch == ']')                  {                      if (!firstChar)                      {                          closed = true;                          break;                      }                  }                  else if (ch == '\\' && CharsRight() > 0)                  {                      switch (ch = MoveRightGetChar())                      {                          case 'D':                          case 'd':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                  cc.AddDigit(UseOptionE()' ch == 'D'' _pattern);                              }                              continue;                            case 'S':                          case 's':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                  cc.AddSpace(UseOptionE()' ch == 'S');                              }                              continue;                            case 'W':                          case 'w':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                    cc.AddWord(UseOptionE()' ch == 'W');                              }                              continue;                            case 'p':                          case 'P':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                  cc.AddCategoryFromName(ParseProperty()' (ch != 'p')' caseInsensitive' _pattern);                              }                              else                                  ParseProperty();                                continue;                            case '-':                              if (!scanOnly)                                  cc.AddRange(ch' ch);                              continue;                            default:                              MoveLeft();                              ch = ScanCharEscape(); // non-literal character                              fTranslatedChar = true;                              break;          // this break will only break out of the switch                      }                  }                  else if (ch == '[')                  {                      // This is code for Posix style properties - [:Ll:] or [:IsTibetan:].                      // It currently doesn't do anything other than skip the whole thing!                      if (CharsRight() > 0 && RightChar() == ':' && !inRange)                      {                          string name;                          int savePos = Textpos();                            MoveRight();                          name = ScanCapname();                          if (CharsRight() < 2 || MoveRightGetChar() != ':' || MoveRightGetChar() != ']')                              Textto(savePos);                          // else lookup name (nyi)                      }                  }                      if (inRange)                  {                      inRange = false;                      if (!scanOnly)                      {                          if (ch == '[' && !fTranslatedChar && !firstChar)                          {                              // We thought we were in a range' but we're actually starting a subtraction.                              // In that case' we'll add chPrev to our char class' skip the opening [' and                              // scan the new character class recursively.                              cc.AddChar(chPrev);                              cc.AddSubtraction(ScanCharClass(caseInsensitive' false));                                if (CharsRight() > 0 && RightChar() != ']')                                  throw MakeException(SR.SubtractionMustBeLast);                          }                          else                          {                              // a regular range' like a-z                              if (chPrev > ch)                                  throw MakeException(SR.ReversedCharRange);                              cc.AddRange(chPrev' ch);                          }                      }                  }                  else if (CharsRight() >= 2 && RightChar() == '-' && RightChar(1) != ']')                  {                      // this could be the start of a range                      chPrev = ch;                      inRange = true;                      MoveRight();                  }                  else if (CharsRight() >= 1 && ch == '-' && !fTranslatedChar && RightChar() == '[' && !firstChar)                  {                      // we aren't in a range' and now there is a subtraction.  Usually this happens                      // only when a subtraction follows a range' like [a-z-[b]]                      if (!scanOnly)                      {                          MoveRight(1);                          cc.AddSubtraction(ScanCharClass(caseInsensitive' false));                            if (CharsRight() > 0 && RightChar() != ']')                              throw MakeException(SR.SubtractionMustBeLast);                      }                      else                      {                          MoveRight(1);                          ScanCharClass(caseInsensitive' true);                      }                  }                  else                  {                      if (!scanOnly)                          cc.AddRange(ch' ch);                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanCharClass,The following statement contains a magic number: for (; CharsRight() > 0; firstChar = false)              {                  bool fTranslatedChar = false;                  ch = MoveRightGetChar();                  if (ch == ']')                  {                      if (!firstChar)                      {                          closed = true;                          break;                      }                  }                  else if (ch == '\\' && CharsRight() > 0)                  {                      switch (ch = MoveRightGetChar())                      {                          case 'D':                          case 'd':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                  cc.AddDigit(UseOptionE()' ch == 'D'' _pattern);                              }                              continue;                            case 'S':                          case 's':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                  cc.AddSpace(UseOptionE()' ch == 'S');                              }                              continue;                            case 'W':                          case 'w':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                    cc.AddWord(UseOptionE()' ch == 'W');                              }                              continue;                            case 'p':                          case 'P':                              if (!scanOnly)                              {                                  if (inRange)                                      throw MakeException(SR.Format(SR.BadClassInCharRange' ch.ToString()));                                  cc.AddCategoryFromName(ParseProperty()' (ch != 'p')' caseInsensitive' _pattern);                              }                              else                                  ParseProperty();                                continue;                            case '-':                              if (!scanOnly)                                  cc.AddRange(ch' ch);                              continue;                            default:                              MoveLeft();                              ch = ScanCharEscape(); // non-literal character                              fTranslatedChar = true;                              break;          // this break will only break out of the switch                      }                  }                  else if (ch == '[')                  {                      // This is code for Posix style properties - [:Ll:] or [:IsTibetan:].                      // It currently doesn't do anything other than skip the whole thing!                      if (CharsRight() > 0 && RightChar() == ':' && !inRange)                      {                          string name;                          int savePos = Textpos();                            MoveRight();                          name = ScanCapname();                          if (CharsRight() < 2 || MoveRightGetChar() != ':' || MoveRightGetChar() != ']')                              Textto(savePos);                          // else lookup name (nyi)                      }                  }                      if (inRange)                  {                      inRange = false;                      if (!scanOnly)                      {                          if (ch == '[' && !fTranslatedChar && !firstChar)                          {                              // We thought we were in a range' but we're actually starting a subtraction.                              // In that case' we'll add chPrev to our char class' skip the opening [' and                              // scan the new character class recursively.                              cc.AddChar(chPrev);                              cc.AddSubtraction(ScanCharClass(caseInsensitive' false));                                if (CharsRight() > 0 && RightChar() != ']')                                  throw MakeException(SR.SubtractionMustBeLast);                          }                          else                          {                              // a regular range' like a-z                              if (chPrev > ch)                                  throw MakeException(SR.ReversedCharRange);                              cc.AddRange(chPrev' ch);                          }                      }                  }                  else if (CharsRight() >= 2 && RightChar() == '-' && RightChar(1) != ']')                  {                      // this could be the start of a range                      chPrev = ch;                      inRange = true;                      MoveRight();                  }                  else if (CharsRight() >= 1 && ch == '-' && !fTranslatedChar && RightChar() == '[' && !firstChar)                  {                      // we aren't in a range' and now there is a subtraction.  Usually this happens                      // only when a subtraction follows a range' like [a-z-[b]]                      if (!scanOnly)                      {                          MoveRight(1);                          cc.AddSubtraction(ScanCharClass(caseInsensitive' false));                            if (CharsRight() > 0 && RightChar() != ']')                              throw MakeException(SR.SubtractionMustBeLast);                      }                      else                      {                          MoveRight(1);                          ScanCharClass(caseInsensitive' true);                      }                  }                  else                  {                      if (!scanOnly)                          cc.AddRange(ch' ch);                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The following statement contains a magic number: for (; ;)              {                  if (CharsRight() == 0)                      break;                    switch (ch = MoveRightGetChar())                  {                      case ':':                          NodeType = RegexNode.Group;                          break;                        case '=':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Require;                          break;                        case '!':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Prevent;                          break;                        case '>':                          NodeType = RegexNode.Greedy;                          break;                        case '\'':                          close = '\'';                          goto case '<';                      // fallthrough                        case '<':                          if (CharsRight() == 0)                              goto BreakRecognize;                            switch (ch = MoveRightGetChar())                          {                              case '=':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Require;                                  break;                                case '!':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Prevent;                                  break;                                default:                                  MoveLeft();                                  int capnum = -1;                                  int uncapnum = -1;                                  bool proceed = false;                                    // grab part before -                                    if (ch >= '0' && ch <= '9')                                  {                                      capnum = ScanDecimal();                                        if (!IsCaptureSlot(capnum))                                          capnum = -1;                                        // check if we have bogus characters after the number                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                      if (capnum == 0)                                          throw MakeException(SR.CapnumNotZero);                                  }                                  else if (RegexCharClass.IsWordChar(ch))                                  {                                      string capname = ScanCapname();                                        if (IsCaptureName(capname))                                          capnum = CaptureSlotFromName(capname);                                        // check if we have bogus character after the name                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                  }                                  else if (ch == '-')                                  {                                      proceed = true;                                  }                                  else                                  {                                      // bad group name - starts with something other than a word character and isn't a number                                      throw MakeException(SR.InvalidGroupName);                                  }                                    // grab part after - if any                                    if ((capnum != -1 || proceed == true) && CharsRight() > 0 && RightChar() == '-')                                  {                                      MoveRight();                                      ch = RightChar();                                        if (ch >= '0' && ch <= '9')                                      {                                          uncapnum = ScanDecimal();                                            if (!IsCaptureSlot(uncapnum))                                              throw MakeException(SR.Format(SR.UndefinedBackref' uncapnum));                                            // check if we have bogus characters after the number                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else if (RegexCharClass.IsWordChar(ch))                                      {                                          string uncapname = ScanCapname();                                            if (IsCaptureName(uncapname))                                              uncapnum = CaptureSlotFromName(uncapname);                                          else                                              throw MakeException(SR.Format(SR.UndefinedNameRef' uncapname));                                            // check if we have bogus character after the name                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else                                      {                                          // bad group name - starts with something other than a word character and isn't a number                                          throw MakeException(SR.InvalidGroupName);                                      }                                  }                                    // actually make the node                                    if ((capnum != -1 || uncapnum != -1) && CharsRight() > 0 && MoveRightGetChar() == close)                                  {                                      return new RegexNode(RegexNode.Capture' _options' capnum' uncapnum);                                  }                                  goto BreakRecognize;                          }                          break;                        case '(':                          // alternation construct (?(...) | )                            int parenPos = Textpos();                          if (CharsRight() > 0)                          {                              ch = RightChar();                                // check if the alternation condition is a backref                              if (ch >= '0' && ch <= '9')                              {                                  int capnum = ScanDecimal();                                  if (CharsRight() > 0 && MoveRightGetChar() == ')')                                  {                                      if (IsCaptureSlot(capnum))                                          return new RegexNode(RegexNode.Testref' _options' capnum);                                      else                                          throw MakeException(SR.Format(SR.UndefinedReference' capnum.ToString(CultureInfo.CurrentCulture)));                                  }                                  else                                      throw MakeException(SR.Format(SR.MalformedReference' capnum.ToString(CultureInfo.CurrentCulture)));                              }                              else if (RegexCharClass.IsWordChar(ch))                              {                                  string capname = ScanCapname();                                    if (IsCaptureName(capname) && CharsRight() > 0 && MoveRightGetChar() == ')')                                      return new RegexNode(RegexNode.Testref' _options' CaptureSlotFromName(capname));                              }                          }                          // not a backref                          NodeType = RegexNode.Testgroup;                          Textto(parenPos - 1);       // jump to the start of the parentheses                          _ignoreNextParen = true;    // but make sure we don't try to capture the insides                            int charsRight = CharsRight();                          if (charsRight >= 3 && RightChar(1) == '?')                          {                              char rightchar2 = RightChar(2);                              // disallow comments in the condition                              if (rightchar2 == '#')                                  throw MakeException(SR.AlternationCantHaveComment);                                // disallow named capture group (?<..>..) in the condition                              if (rightchar2 == '\'')                                  throw MakeException(SR.AlternationCantCapture);                              else                              {                                  if (charsRight >= 4 && (rightchar2 == '<' && RightChar(3) != '!' && RightChar(3) != '='))                                      throw MakeException(SR.AlternationCantCapture);                              }                          }                            break;                          default:                          MoveLeft();                            NodeType = RegexNode.Group;                          // Disallow options in the children of a testgroup node                          if (_group._type != RegexNode.Testgroup)                              ScanOptions();                          if (CharsRight() == 0)                              goto BreakRecognize;                            if ((ch = MoveRightGetChar()) == ')')                              return null;                            if (ch != ':')                              goto BreakRecognize;                          break;                  }                    return new RegexNode(NodeType' _options);              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The following statement contains a magic number: for (; ;)              {                  if (CharsRight() == 0)                      break;                    switch (ch = MoveRightGetChar())                  {                      case ':':                          NodeType = RegexNode.Group;                          break;                        case '=':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Require;                          break;                        case '!':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Prevent;                          break;                        case '>':                          NodeType = RegexNode.Greedy;                          break;                        case '\'':                          close = '\'';                          goto case '<';                      // fallthrough                        case '<':                          if (CharsRight() == 0)                              goto BreakRecognize;                            switch (ch = MoveRightGetChar())                          {                              case '=':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Require;                                  break;                                case '!':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Prevent;                                  break;                                default:                                  MoveLeft();                                  int capnum = -1;                                  int uncapnum = -1;                                  bool proceed = false;                                    // grab part before -                                    if (ch >= '0' && ch <= '9')                                  {                                      capnum = ScanDecimal();                                        if (!IsCaptureSlot(capnum))                                          capnum = -1;                                        // check if we have bogus characters after the number                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                      if (capnum == 0)                                          throw MakeException(SR.CapnumNotZero);                                  }                                  else if (RegexCharClass.IsWordChar(ch))                                  {                                      string capname = ScanCapname();                                        if (IsCaptureName(capname))                                          capnum = CaptureSlotFromName(capname);                                        // check if we have bogus character after the name                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                  }                                  else if (ch == '-')                                  {                                      proceed = true;                                  }                                  else                                  {                                      // bad group name - starts with something other than a word character and isn't a number                                      throw MakeException(SR.InvalidGroupName);                                  }                                    // grab part after - if any                                    if ((capnum != -1 || proceed == true) && CharsRight() > 0 && RightChar() == '-')                                  {                                      MoveRight();                                      ch = RightChar();                                        if (ch >= '0' && ch <= '9')                                      {                                          uncapnum = ScanDecimal();                                            if (!IsCaptureSlot(uncapnum))                                              throw MakeException(SR.Format(SR.UndefinedBackref' uncapnum));                                            // check if we have bogus characters after the number                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else if (RegexCharClass.IsWordChar(ch))                                      {                                          string uncapname = ScanCapname();                                            if (IsCaptureName(uncapname))                                              uncapnum = CaptureSlotFromName(uncapname);                                          else                                              throw MakeException(SR.Format(SR.UndefinedNameRef' uncapname));                                            // check if we have bogus character after the name                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else                                      {                                          // bad group name - starts with something other than a word character and isn't a number                                          throw MakeException(SR.InvalidGroupName);                                      }                                  }                                    // actually make the node                                    if ((capnum != -1 || uncapnum != -1) && CharsRight() > 0 && MoveRightGetChar() == close)                                  {                                      return new RegexNode(RegexNode.Capture' _options' capnum' uncapnum);                                  }                                  goto BreakRecognize;                          }                          break;                        case '(':                          // alternation construct (?(...) | )                            int parenPos = Textpos();                          if (CharsRight() > 0)                          {                              ch = RightChar();                                // check if the alternation condition is a backref                              if (ch >= '0' && ch <= '9')                              {                                  int capnum = ScanDecimal();                                  if (CharsRight() > 0 && MoveRightGetChar() == ')')                                  {                                      if (IsCaptureSlot(capnum))                                          return new RegexNode(RegexNode.Testref' _options' capnum);                                      else                                          throw MakeException(SR.Format(SR.UndefinedReference' capnum.ToString(CultureInfo.CurrentCulture)));                                  }                                  else                                      throw MakeException(SR.Format(SR.MalformedReference' capnum.ToString(CultureInfo.CurrentCulture)));                              }                              else if (RegexCharClass.IsWordChar(ch))                              {                                  string capname = ScanCapname();                                    if (IsCaptureName(capname) && CharsRight() > 0 && MoveRightGetChar() == ')')                                      return new RegexNode(RegexNode.Testref' _options' CaptureSlotFromName(capname));                              }                          }                          // not a backref                          NodeType = RegexNode.Testgroup;                          Textto(parenPos - 1);       // jump to the start of the parentheses                          _ignoreNextParen = true;    // but make sure we don't try to capture the insides                            int charsRight = CharsRight();                          if (charsRight >= 3 && RightChar(1) == '?')                          {                              char rightchar2 = RightChar(2);                              // disallow comments in the condition                              if (rightchar2 == '#')                                  throw MakeException(SR.AlternationCantHaveComment);                                // disallow named capture group (?<..>..) in the condition                              if (rightchar2 == '\'')                                  throw MakeException(SR.AlternationCantCapture);                              else                              {                                  if (charsRight >= 4 && (rightchar2 == '<' && RightChar(3) != '!' && RightChar(3) != '='))                                      throw MakeException(SR.AlternationCantCapture);                              }                          }                            break;                          default:                          MoveLeft();                            NodeType = RegexNode.Group;                          // Disallow options in the children of a testgroup node                          if (_group._type != RegexNode.Testgroup)                              ScanOptions();                          if (CharsRight() == 0)                              goto BreakRecognize;                            if ((ch = MoveRightGetChar()) == ')')                              return null;                            if (ch != ':')                              goto BreakRecognize;                          break;                  }                    return new RegexNode(NodeType' _options);              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The following statement contains a magic number: for (; ;)              {                  if (CharsRight() == 0)                      break;                    switch (ch = MoveRightGetChar())                  {                      case ':':                          NodeType = RegexNode.Group;                          break;                        case '=':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Require;                          break;                        case '!':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Prevent;                          break;                        case '>':                          NodeType = RegexNode.Greedy;                          break;                        case '\'':                          close = '\'';                          goto case '<';                      // fallthrough                        case '<':                          if (CharsRight() == 0)                              goto BreakRecognize;                            switch (ch = MoveRightGetChar())                          {                              case '=':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Require;                                  break;                                case '!':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Prevent;                                  break;                                default:                                  MoveLeft();                                  int capnum = -1;                                  int uncapnum = -1;                                  bool proceed = false;                                    // grab part before -                                    if (ch >= '0' && ch <= '9')                                  {                                      capnum = ScanDecimal();                                        if (!IsCaptureSlot(capnum))                                          capnum = -1;                                        // check if we have bogus characters after the number                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                      if (capnum == 0)                                          throw MakeException(SR.CapnumNotZero);                                  }                                  else if (RegexCharClass.IsWordChar(ch))                                  {                                      string capname = ScanCapname();                                        if (IsCaptureName(capname))                                          capnum = CaptureSlotFromName(capname);                                        // check if we have bogus character after the name                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                  }                                  else if (ch == '-')                                  {                                      proceed = true;                                  }                                  else                                  {                                      // bad group name - starts with something other than a word character and isn't a number                                      throw MakeException(SR.InvalidGroupName);                                  }                                    // grab part after - if any                                    if ((capnum != -1 || proceed == true) && CharsRight() > 0 && RightChar() == '-')                                  {                                      MoveRight();                                      ch = RightChar();                                        if (ch >= '0' && ch <= '9')                                      {                                          uncapnum = ScanDecimal();                                            if (!IsCaptureSlot(uncapnum))                                              throw MakeException(SR.Format(SR.UndefinedBackref' uncapnum));                                            // check if we have bogus characters after the number                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else if (RegexCharClass.IsWordChar(ch))                                      {                                          string uncapname = ScanCapname();                                            if (IsCaptureName(uncapname))                                              uncapnum = CaptureSlotFromName(uncapname);                                          else                                              throw MakeException(SR.Format(SR.UndefinedNameRef' uncapname));                                            // check if we have bogus character after the name                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else                                      {                                          // bad group name - starts with something other than a word character and isn't a number                                          throw MakeException(SR.InvalidGroupName);                                      }                                  }                                    // actually make the node                                    if ((capnum != -1 || uncapnum != -1) && CharsRight() > 0 && MoveRightGetChar() == close)                                  {                                      return new RegexNode(RegexNode.Capture' _options' capnum' uncapnum);                                  }                                  goto BreakRecognize;                          }                          break;                        case '(':                          // alternation construct (?(...) | )                            int parenPos = Textpos();                          if (CharsRight() > 0)                          {                              ch = RightChar();                                // check if the alternation condition is a backref                              if (ch >= '0' && ch <= '9')                              {                                  int capnum = ScanDecimal();                                  if (CharsRight() > 0 && MoveRightGetChar() == ')')                                  {                                      if (IsCaptureSlot(capnum))                                          return new RegexNode(RegexNode.Testref' _options' capnum);                                      else                                          throw MakeException(SR.Format(SR.UndefinedReference' capnum.ToString(CultureInfo.CurrentCulture)));                                  }                                  else                                      throw MakeException(SR.Format(SR.MalformedReference' capnum.ToString(CultureInfo.CurrentCulture)));                              }                              else if (RegexCharClass.IsWordChar(ch))                              {                                  string capname = ScanCapname();                                    if (IsCaptureName(capname) && CharsRight() > 0 && MoveRightGetChar() == ')')                                      return new RegexNode(RegexNode.Testref' _options' CaptureSlotFromName(capname));                              }                          }                          // not a backref                          NodeType = RegexNode.Testgroup;                          Textto(parenPos - 1);       // jump to the start of the parentheses                          _ignoreNextParen = true;    // but make sure we don't try to capture the insides                            int charsRight = CharsRight();                          if (charsRight >= 3 && RightChar(1) == '?')                          {                              char rightchar2 = RightChar(2);                              // disallow comments in the condition                              if (rightchar2 == '#')                                  throw MakeException(SR.AlternationCantHaveComment);                                // disallow named capture group (?<..>..) in the condition                              if (rightchar2 == '\'')                                  throw MakeException(SR.AlternationCantCapture);                              else                              {                                  if (charsRight >= 4 && (rightchar2 == '<' && RightChar(3) != '!' && RightChar(3) != '='))                                      throw MakeException(SR.AlternationCantCapture);                              }                          }                            break;                          default:                          MoveLeft();                            NodeType = RegexNode.Group;                          // Disallow options in the children of a testgroup node                          if (_group._type != RegexNode.Testgroup)                              ScanOptions();                          if (CharsRight() == 0)                              goto BreakRecognize;                            if ((ch = MoveRightGetChar()) == ')')                              return null;                            if (ch != ':')                              goto BreakRecognize;                          break;                  }                    return new RegexNode(NodeType' _options);              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The following statement contains a magic number: for (; ;)              {                  if (CharsRight() == 0)                      break;                    switch (ch = MoveRightGetChar())                  {                      case ':':                          NodeType = RegexNode.Group;                          break;                        case '=':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Require;                          break;                        case '!':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Prevent;                          break;                        case '>':                          NodeType = RegexNode.Greedy;                          break;                        case '\'':                          close = '\'';                          goto case '<';                      // fallthrough                        case '<':                          if (CharsRight() == 0)                              goto BreakRecognize;                            switch (ch = MoveRightGetChar())                          {                              case '=':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Require;                                  break;                                case '!':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Prevent;                                  break;                                default:                                  MoveLeft();                                  int capnum = -1;                                  int uncapnum = -1;                                  bool proceed = false;                                    // grab part before -                                    if (ch >= '0' && ch <= '9')                                  {                                      capnum = ScanDecimal();                                        if (!IsCaptureSlot(capnum))                                          capnum = -1;                                        // check if we have bogus characters after the number                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                      if (capnum == 0)                                          throw MakeException(SR.CapnumNotZero);                                  }                                  else if (RegexCharClass.IsWordChar(ch))                                  {                                      string capname = ScanCapname();                                        if (IsCaptureName(capname))                                          capnum = CaptureSlotFromName(capname);                                        // check if we have bogus character after the name                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                  }                                  else if (ch == '-')                                  {                                      proceed = true;                                  }                                  else                                  {                                      // bad group name - starts with something other than a word character and isn't a number                                      throw MakeException(SR.InvalidGroupName);                                  }                                    // grab part after - if any                                    if ((capnum != -1 || proceed == true) && CharsRight() > 0 && RightChar() == '-')                                  {                                      MoveRight();                                      ch = RightChar();                                        if (ch >= '0' && ch <= '9')                                      {                                          uncapnum = ScanDecimal();                                            if (!IsCaptureSlot(uncapnum))                                              throw MakeException(SR.Format(SR.UndefinedBackref' uncapnum));                                            // check if we have bogus characters after the number                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else if (RegexCharClass.IsWordChar(ch))                                      {                                          string uncapname = ScanCapname();                                            if (IsCaptureName(uncapname))                                              uncapnum = CaptureSlotFromName(uncapname);                                          else                                              throw MakeException(SR.Format(SR.UndefinedNameRef' uncapname));                                            // check if we have bogus character after the name                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else                                      {                                          // bad group name - starts with something other than a word character and isn't a number                                          throw MakeException(SR.InvalidGroupName);                                      }                                  }                                    // actually make the node                                    if ((capnum != -1 || uncapnum != -1) && CharsRight() > 0 && MoveRightGetChar() == close)                                  {                                      return new RegexNode(RegexNode.Capture' _options' capnum' uncapnum);                                  }                                  goto BreakRecognize;                          }                          break;                        case '(':                          // alternation construct (?(...) | )                            int parenPos = Textpos();                          if (CharsRight() > 0)                          {                              ch = RightChar();                                // check if the alternation condition is a backref                              if (ch >= '0' && ch <= '9')                              {                                  int capnum = ScanDecimal();                                  if (CharsRight() > 0 && MoveRightGetChar() == ')')                                  {                                      if (IsCaptureSlot(capnum))                                          return new RegexNode(RegexNode.Testref' _options' capnum);                                      else                                          throw MakeException(SR.Format(SR.UndefinedReference' capnum.ToString(CultureInfo.CurrentCulture)));                                  }                                  else                                      throw MakeException(SR.Format(SR.MalformedReference' capnum.ToString(CultureInfo.CurrentCulture)));                              }                              else if (RegexCharClass.IsWordChar(ch))                              {                                  string capname = ScanCapname();                                    if (IsCaptureName(capname) && CharsRight() > 0 && MoveRightGetChar() == ')')                                      return new RegexNode(RegexNode.Testref' _options' CaptureSlotFromName(capname));                              }                          }                          // not a backref                          NodeType = RegexNode.Testgroup;                          Textto(parenPos - 1);       // jump to the start of the parentheses                          _ignoreNextParen = true;    // but make sure we don't try to capture the insides                            int charsRight = CharsRight();                          if (charsRight >= 3 && RightChar(1) == '?')                          {                              char rightchar2 = RightChar(2);                              // disallow comments in the condition                              if (rightchar2 == '#')                                  throw MakeException(SR.AlternationCantHaveComment);                                // disallow named capture group (?<..>..) in the condition                              if (rightchar2 == '\'')                                  throw MakeException(SR.AlternationCantCapture);                              else                              {                                  if (charsRight >= 4 && (rightchar2 == '<' && RightChar(3) != '!' && RightChar(3) != '='))                                      throw MakeException(SR.AlternationCantCapture);                              }                          }                            break;                          default:                          MoveLeft();                            NodeType = RegexNode.Group;                          // Disallow options in the children of a testgroup node                          if (_group._type != RegexNode.Testgroup)                              ScanOptions();                          if (CharsRight() == 0)                              goto BreakRecognize;                            if ((ch = MoveRightGetChar()) == ')')                              return null;                            if (ch != ':')                              goto BreakRecognize;                          break;                  }                    return new RegexNode(NodeType' _options);              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanGroupOpen,The following statement contains a magic number: for (; ;)              {                  if (CharsRight() == 0)                      break;                    switch (ch = MoveRightGetChar())                  {                      case ':':                          NodeType = RegexNode.Group;                          break;                        case '=':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Require;                          break;                        case '!':                          _options &= ~(RegexOptions.RightToLeft);                          NodeType = RegexNode.Prevent;                          break;                        case '>':                          NodeType = RegexNode.Greedy;                          break;                        case '\'':                          close = '\'';                          goto case '<';                      // fallthrough                        case '<':                          if (CharsRight() == 0)                              goto BreakRecognize;                            switch (ch = MoveRightGetChar())                          {                              case '=':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Require;                                  break;                                case '!':                                  if (close == '\'')                                      goto BreakRecognize;                                    _options |= RegexOptions.RightToLeft;                                  NodeType = RegexNode.Prevent;                                  break;                                default:                                  MoveLeft();                                  int capnum = -1;                                  int uncapnum = -1;                                  bool proceed = false;                                    // grab part before -                                    if (ch >= '0' && ch <= '9')                                  {                                      capnum = ScanDecimal();                                        if (!IsCaptureSlot(capnum))                                          capnum = -1;                                        // check if we have bogus characters after the number                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                      if (capnum == 0)                                          throw MakeException(SR.CapnumNotZero);                                  }                                  else if (RegexCharClass.IsWordChar(ch))                                  {                                      string capname = ScanCapname();                                        if (IsCaptureName(capname))                                          capnum = CaptureSlotFromName(capname);                                        // check if we have bogus character after the name                                      if (CharsRight() > 0 && !(RightChar() == close || RightChar() == '-'))                                          throw MakeException(SR.InvalidGroupName);                                  }                                  else if (ch == '-')                                  {                                      proceed = true;                                  }                                  else                                  {                                      // bad group name - starts with something other than a word character and isn't a number                                      throw MakeException(SR.InvalidGroupName);                                  }                                    // grab part after - if any                                    if ((capnum != -1 || proceed == true) && CharsRight() > 0 && RightChar() == '-')                                  {                                      MoveRight();                                      ch = RightChar();                                        if (ch >= '0' && ch <= '9')                                      {                                          uncapnum = ScanDecimal();                                            if (!IsCaptureSlot(uncapnum))                                              throw MakeException(SR.Format(SR.UndefinedBackref' uncapnum));                                            // check if we have bogus characters after the number                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else if (RegexCharClass.IsWordChar(ch))                                      {                                          string uncapname = ScanCapname();                                            if (IsCaptureName(uncapname))                                              uncapnum = CaptureSlotFromName(uncapname);                                          else                                              throw MakeException(SR.Format(SR.UndefinedNameRef' uncapname));                                            // check if we have bogus character after the name                                          if (CharsRight() > 0 && RightChar() != close)                                              throw MakeException(SR.InvalidGroupName);                                      }                                      else                                      {                                          // bad group name - starts with something other than a word character and isn't a number                                          throw MakeException(SR.InvalidGroupName);                                      }                                  }                                    // actually make the node                                    if ((capnum != -1 || uncapnum != -1) && CharsRight() > 0 && MoveRightGetChar() == close)                                  {                                      return new RegexNode(RegexNode.Capture' _options' capnum' uncapnum);                                  }                                  goto BreakRecognize;                          }                          break;                        case '(':                          // alternation construct (?(...) | )                            int parenPos = Textpos();                          if (CharsRight() > 0)                          {                              ch = RightChar();                                // check if the alternation condition is a backref                              if (ch >= '0' && ch <= '9')                              {                                  int capnum = ScanDecimal();                                  if (CharsRight() > 0 && MoveRightGetChar() == ')')                                  {                                      if (IsCaptureSlot(capnum))                                          return new RegexNode(RegexNode.Testref' _options' capnum);                                      else                                          throw MakeException(SR.Format(SR.UndefinedReference' capnum.ToString(CultureInfo.CurrentCulture)));                                  }                                  else                                      throw MakeException(SR.Format(SR.MalformedReference' capnum.ToString(CultureInfo.CurrentCulture)));                              }                              else if (RegexCharClass.IsWordChar(ch))                              {                                  string capname = ScanCapname();                                    if (IsCaptureName(capname) && CharsRight() > 0 && MoveRightGetChar() == ')')                                      return new RegexNode(RegexNode.Testref' _options' CaptureSlotFromName(capname));                              }                          }                          // not a backref                          NodeType = RegexNode.Testgroup;                          Textto(parenPos - 1);       // jump to the start of the parentheses                          _ignoreNextParen = true;    // but make sure we don't try to capture the insides                            int charsRight = CharsRight();                          if (charsRight >= 3 && RightChar(1) == '?')                          {                              char rightchar2 = RightChar(2);                              // disallow comments in the condition                              if (rightchar2 == '#')                                  throw MakeException(SR.AlternationCantHaveComment);                                // disallow named capture group (?<..>..) in the condition                              if (rightchar2 == '\'')                                  throw MakeException(SR.AlternationCantCapture);                              else                              {                                  if (charsRight >= 4 && (rightchar2 == '<' && RightChar(3) != '!' && RightChar(3) != '='))                                      throw MakeException(SR.AlternationCantCapture);                              }                          }                            break;                          default:                          MoveLeft();                            NodeType = RegexNode.Group;                          // Disallow options in the children of a testgroup node                          if (_group._type != RegexNode.Testgroup)                              ScanOptions();                          if (CharsRight() == 0)                              goto BreakRecognize;                            if ((ch = MoveRightGetChar()) == ')')                              return null;                            if (ch != ':')                              goto BreakRecognize;                          break;                  }                    return new RegexNode(NodeType' _options);              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBlank,The following statement contains a magic number: if (UseOptionX())              {                  for (; ;)                  {                      while (CharsRight() > 0 && IsSpace(RightChar()))                          MoveRight();                        if (CharsRight() == 0)                          break;                        if (RightChar() == '#')                      {                          while (CharsRight() > 0 && RightChar() != '\n')                              MoveRight();                      }                      else if (CharsRight() >= 3 && RightChar(2) == '#' &&                               RightChar(1) == '?' && RightChar() == '(')                      {                          while (CharsRight() > 0 && RightChar() != ')')                              MoveRight();                          if (CharsRight() == 0)                              throw MakeException(SR.UnterminatedComment);                          MoveRight();                      }                      else                          break;                  }              }              else              {                  for (; ;)                  {                      if (CharsRight() < 3 || RightChar(2) != '#' ||                          RightChar(1) != '?' || RightChar() != '(')                          return;                        while (CharsRight() > 0 && RightChar() != ')')                          MoveRight();                      if (CharsRight() == 0)                          throw MakeException(SR.UnterminatedComment);                      MoveRight();                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBlank,The following statement contains a magic number: if (UseOptionX())              {                  for (; ;)                  {                      while (CharsRight() > 0 && IsSpace(RightChar()))                          MoveRight();                        if (CharsRight() == 0)                          break;                        if (RightChar() == '#')                      {                          while (CharsRight() > 0 && RightChar() != '\n')                              MoveRight();                      }                      else if (CharsRight() >= 3 && RightChar(2) == '#' &&                               RightChar(1) == '?' && RightChar() == '(')                      {                          while (CharsRight() > 0 && RightChar() != ')')                              MoveRight();                          if (CharsRight() == 0)                              throw MakeException(SR.UnterminatedComment);                          MoveRight();                      }                      else                          break;                  }              }              else              {                  for (; ;)                  {                      if (CharsRight() < 3 || RightChar(2) != '#' ||                          RightChar(1) != '?' || RightChar() != '(')                          return;                        while (CharsRight() > 0 && RightChar() != ')')                          MoveRight();                      if (CharsRight() == 0)                          throw MakeException(SR.UnterminatedComment);                      MoveRight();                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBlank,The following statement contains a magic number: if (UseOptionX())              {                  for (; ;)                  {                      while (CharsRight() > 0 && IsSpace(RightChar()))                          MoveRight();                        if (CharsRight() == 0)                          break;                        if (RightChar() == '#')                      {                          while (CharsRight() > 0 && RightChar() != '\n')                              MoveRight();                      }                      else if (CharsRight() >= 3 && RightChar(2) == '#' &&                               RightChar(1) == '?' && RightChar() == '(')                      {                          while (CharsRight() > 0 && RightChar() != ')')                              MoveRight();                          if (CharsRight() == 0)                              throw MakeException(SR.UnterminatedComment);                          MoveRight();                      }                      else                          break;                  }              }              else              {                  for (; ;)                  {                      if (CharsRight() < 3 || RightChar(2) != '#' ||                          RightChar(1) != '?' || RightChar() != '(')                          return;                        while (CharsRight() > 0 && RightChar() != ')')                          MoveRight();                      if (CharsRight() == 0)                          throw MakeException(SR.UnterminatedComment);                      MoveRight();                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBlank,The following statement contains a magic number: if (UseOptionX())              {                  for (; ;)                  {                      while (CharsRight() > 0 && IsSpace(RightChar()))                          MoveRight();                        if (CharsRight() == 0)                          break;                        if (RightChar() == '#')                      {                          while (CharsRight() > 0 && RightChar() != '\n')                              MoveRight();                      }                      else if (CharsRight() >= 3 && RightChar(2) == '#' &&                               RightChar(1) == '?' && RightChar() == '(')                      {                          while (CharsRight() > 0 && RightChar() != ')')                              MoveRight();                          if (CharsRight() == 0)                              throw MakeException(SR.UnterminatedComment);                          MoveRight();                      }                      else                          break;                  }              }              else              {                  for (; ;)                  {                      if (CharsRight() < 3 || RightChar(2) != '#' ||                          RightChar(1) != '?' || RightChar() != '(')                          return;                        while (CharsRight() > 0 && RightChar() != ')')                          MoveRight();                      if (CharsRight() == 0)                          throw MakeException(SR.UnterminatedComment);                      MoveRight();                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBasicBackslash,The following statement contains a magic number: if (ch == 'k')              {                  if (CharsRight() >= 2)                  {                      MoveRight();                      ch = MoveRightGetChar();                        if (ch == '<' || ch == '\'')                      {                          angled = true;                          close = (ch == '\'') ? '\'' : '>';                      }                  }                    if (!angled || CharsRight() <= 0)                      throw MakeException(SR.MalformedNameRef);                    ch = RightChar();              }                // Note angle without \g                else if ((ch == '<' || ch == '\'') && CharsRight() > 1)              {                  angled = true;                  close = (ch == '\'') ? '\'' : '>';                    MoveRight();                  ch = RightChar();              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBasicBackslash,The following statement contains a magic number: if (angled && ch >= '0' && ch <= '9')              {                  int capnum = ScanDecimal();                    if (CharsRight() > 0 && MoveRightGetChar() == close)                  {                      if (IsCaptureSlot(capnum))                          return new RegexNode(RegexNode.Ref' _options' capnum);                      else                          throw MakeException(SR.Format(SR.UndefinedBackref' capnum.ToString(CultureInfo.CurrentCulture)));                  }              }                // Try to parse backreference or octal: \1                else if (!angled && ch >= '1' && ch <= '9')              {                  if (UseOptionE())                  {                      int capnum = -1;                      int newcapnum = (int)(ch - '0');                      int pos = Textpos() - 1;                      while (newcapnum <= _captop)                      {                          if (IsCaptureSlot(newcapnum) && (_caps == null || (int)_caps[newcapnum] < pos))                              capnum = newcapnum;                          MoveRight();                          if (CharsRight() == 0 || (ch = RightChar()) < '0' || ch > '9')                              break;                          newcapnum = newcapnum * 10 + (int)(ch - '0');                      }                      if (capnum >= 0)                          return new RegexNode(RegexNode.Ref' _options' capnum);                  }                  else                  {                      int capnum = ScanDecimal();                      if (IsCaptureSlot(capnum))                          return new RegexNode(RegexNode.Ref' _options' capnum);                      else if (capnum <= 9)                          throw MakeException(SR.Format(SR.UndefinedBackref' capnum.ToString(CultureInfo.CurrentCulture)));                  }              }                else if (angled && RegexCharClass.IsWordChar(ch))              {                  string capname = ScanCapname();                    if (CharsRight() > 0 && MoveRightGetChar() == close)                  {                      if (IsCaptureName(capname))                          return new RegexNode(RegexNode.Ref' _options' CaptureSlotFromName(capname));                      else                          throw MakeException(SR.Format(SR.UndefinedNameRef' capname));                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanBasicBackslash,The following statement contains a magic number: if (angled && ch >= '0' && ch <= '9')              {                  int capnum = ScanDecimal();                    if (CharsRight() > 0 && MoveRightGetChar() == close)                  {                      if (IsCaptureSlot(capnum))                          return new RegexNode(RegexNode.Ref' _options' capnum);                      else                          throw MakeException(SR.Format(SR.UndefinedBackref' capnum.ToString(CultureInfo.CurrentCulture)));                  }              }                // Try to parse backreference or octal: \1                else if (!angled && ch >= '1' && ch <= '9')              {                  if (UseOptionE())                  {                      int capnum = -1;                      int newcapnum = (int)(ch - '0');                      int pos = Textpos() - 1;                      while (newcapnum <= _captop)                      {                          if (IsCaptureSlot(newcapnum) && (_caps == null || (int)_caps[newcapnum] < pos))                              capnum = newcapnum;                          MoveRight();                          if (CharsRight() == 0 || (ch = RightChar()) < '0' || ch > '9')                              break;                          newcapnum = newcapnum * 10 + (int)(ch - '0');                      }                      if (capnum >= 0)                          return new RegexNode(RegexNode.Ref' _options' capnum);                  }                  else                  {                      int capnum = ScanDecimal();                      if (IsCaptureSlot(capnum))                          return new RegexNode(RegexNode.Ref' _options' capnum);                      else if (capnum <= 9)                          throw MakeException(SR.Format(SR.UndefinedBackref' capnum.ToString(CultureInfo.CurrentCulture)));                  }              }                else if (angled && RegexCharClass.IsWordChar(ch))              {                  string capname = ScanCapname();                    if (CharsRight() > 0 && MoveRightGetChar() == close)                  {                      if (IsCaptureName(capname))                          return new RegexNode(RegexNode.Ref' _options' CaptureSlotFromName(capname));                      else                          throw MakeException(SR.Format(SR.UndefinedNameRef' capname));                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanDollar,The following statement contains a magic number: if (ch >= '0' && ch <= '9')              {                  if (!angled && UseOptionE())                  {                      int capnum = -1;                      int newcapnum = (int)(ch - '0');                      MoveRight();                      if (IsCaptureSlot(newcapnum))                      {                          capnum = newcapnum;                          lastEndPos = Textpos();                      }                        while (CharsRight() > 0 && (ch = RightChar()) >= '0' && ch <= '9')                      {                          int digit = (int)(ch - '0');                          if (newcapnum > (MaxValueDiv10) || (newcapnum == (MaxValueDiv10) && digit > (MaxValueMod10)))                              throw MakeException(SR.CaptureGroupOutOfRange);                            newcapnum = newcapnum * 10 + digit;                            MoveRight();                          if (IsCaptureSlot(newcapnum))                          {                              capnum = newcapnum;                              lastEndPos = Textpos();                          }                      }                      Textto(lastEndPos);                      if (capnum >= 0)                          return new RegexNode(RegexNode.Ref' _options' capnum);                  }                  else                  {                      int capnum = ScanDecimal();                      if (!angled || CharsRight() > 0 && MoveRightGetChar() == '}')                      {                          if (IsCaptureSlot(capnum))                              return new RegexNode(RegexNode.Ref' _options' capnum);                      }                  }              }              else if (angled && RegexCharClass.IsWordChar(ch))              {                  string capname = ScanCapname();                    if (CharsRight() > 0 && MoveRightGetChar() == '}')                  {                      if (IsCaptureName(capname))                          return new RegexNode(RegexNode.Ref' _options' CaptureSlotFromName(capname));                  }              }              else if (!angled)              {                  int capnum = 1;                    switch (ch)                  {                      case '$':                          MoveRight();                          return new RegexNode(RegexNode.One' _options' '$');                        case '&':                          capnum = 0;                          break;                        case '`':                          capnum = RegexReplacement.LeftPortion;                          break;                        case '\'':                          capnum = RegexReplacement.RightPortion;                          break;                        case '+':                          capnum = RegexReplacement.LastGroup;                          break;                        case '_':                          capnum = RegexReplacement.WholeString;                          break;                  }                    if (capnum != 1)                  {                      MoveRight();                      return new RegexNode(RegexNode.Ref' _options' capnum);                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: c = 3;
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: for (i = 0; c > 0 && unchecked((uint)(d = RightChar() - '0')) <= 7; c -= 1)              {                  MoveRight();                  i *= 8;                  i += d;                  if (UseOptionE() && i >= 0x20)                      break;              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanOctal,The following statement contains a magic number: for (i = 0; c > 0 && unchecked((uint)(d = RightChar() - '0')) <= 7; c -= 1)              {                  MoveRight();                  i *= 8;                  i += d;                  if (UseOptionE() && i >= 0x20)                      break;              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanDecimal,The following statement contains a magic number: while (CharsRight() > 0 && unchecked((uint)(d = (char)(RightChar() - '0'))) <= 9)              {                  MoveRight();                    if (i > (MaxValueDiv10) || (i == (MaxValueDiv10) && d > (MaxValueMod10)))                      throw MakeException(SR.CaptureGroupOutOfRange);                    i *= 10;                  i += d;              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanDecimal,The following statement contains a magic number: while (CharsRight() > 0 && unchecked((uint)(d = (char)(RightChar() - '0'))) <= 9)              {                  MoveRight();                    if (i > (MaxValueDiv10) || (i == (MaxValueDiv10) && d > (MaxValueMod10)))                      throw MakeException(SR.CaptureGroupOutOfRange);                    i *= 10;                  i += d;              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - '0') <= 9)                  return d;
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if (unchecked((uint)(d = ch - 'a')) <= 5)                  return d + 0xa;
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,HexDigit,The following statement contains a magic number: if ((uint)(d = ch - 'A') <= 5)                  return d + 0xa;
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: switch (ch)              {                  case 'x':                      return ScanHex(2);                  case 'u':                      return ScanHex(4);                  case 'a':                      return '\u0007';                  case 'b':                      return '\b';                  case 'e':                      return '\u001B';                  case 'f':                      return '\f';                  case 'n':                      return '\n';                  case 'r':                      return '\r';                  case 't':                      return '\t';                  case 'v':                      return '\u000B';                  case 'c':                      return ScanControl();                  default:                      if (!UseOptionE() && RegexCharClass.IsWordChar(ch))                          throw MakeException(SR.Format(SR.UnrecognizedEscape' ch.ToString()));                      return ch;              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanCharEscape,The following statement contains a magic number: switch (ch)              {                  case 'x':                      return ScanHex(2);                  case 'u':                      return ScanHex(4);                  case 'a':                      return '\u0007';                  case 'b':                      return '\b';                  case 'e':                      return '\u001B';                  case 'f':                      return '\f';                  case 'n':                      return '\n';                  case 'r':                      return '\r';                  case 't':                      return '\t';                  case 'v':                      return '\u000B';                  case 'c':                      return ScanControl();                  default:                      if (!UseOptionE() && RegexCharClass.IsWordChar(ch))                          throw MakeException(SR.Format(SR.UnrecognizedEscape' ch.ToString()));                      return ch;              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ParseProperty,The following statement contains a magic number: if (CharsRight() < 3)              {                  throw MakeException(SR.IncompleteSlashP);              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,CountCaptures,The following statement contains a magic number: while (CharsRight() > 0)              {                  int pos = Textpos();                  ch = MoveRightGetChar();                  switch (ch)                  {                      case '\\':                          if (CharsRight() > 0)                              MoveRight();                          break;                        case '#':                          if (UseOptionX())                          {                              MoveLeft();                              ScanBlank();                          }                          break;                        case '[':                          ScanCharClass(false' true);                          break;                        case ')':                          if (!EmptyOptionsStack())                              PopOptions();                          break;                        case '(':                          if (CharsRight() >= 2 && RightChar(1) == '#' && RightChar() == '?')                          {                              MoveLeft();                              ScanBlank();                          }                          else                          {                              PushOptions();                              if (CharsRight() > 0 && RightChar() == '?')                              {                                  // we have (?...                                  MoveRight();                                    if (CharsRight() > 1 && (RightChar() == '<' || RightChar() == '\''))                                  {                                      // named group: (?<... or (?'...                                        MoveRight();                                      ch = RightChar();                                        if (ch != '0' && RegexCharClass.IsWordChar(ch))                                      {                                          //if (_ignoreNextParen)                                          //    throw MakeException(SR.AlternationCantCapture);                                          if (ch >= '1' && ch <= '9')                                              NoteCaptureSlot(ScanDecimal()' pos);                                          else                                              NoteCaptureName(ScanCapname()' pos);                                      }                                  }                                  else                                  {                                      // (?...                                        // get the options if it's an option construct (?cimsx-cimsx...)                                      ScanOptions();                                        if (CharsRight() > 0)                                      {                                          if (RightChar() == ')')                                          {                                              // (?cimsx-cimsx)                                              MoveRight();                                              PopKeepOptions();                                          }                                          else if (RightChar() == '(')                                          {                                              // alternation construct: (?(foo)yes|no)                                              // ignore the next paren so we don't capture the condition                                              _ignoreNextParen = true;                                                // break from here so we don't reset _ignoreNextParen                                              break;                                          }                                      }                                  }                              }                              else                              {                                  if (!UseOptionN() && !_ignoreNextParen)                                      NoteCaptureSlot(_autocap++' pos);                              }                          }                            _ignoreNextParen = false;                          break;                  }              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,AddGroup,The following statement contains a magic number: if (_group.Type() == RegexNode.Testgroup || _group.Type() == RegexNode.Testref)              {                  _group.AddChild(_concatenation.ReverseLeft());                    if (_group.Type() == RegexNode.Testref && _group.ChildCount() > 2 || _group.ChildCount() > 3)                      throw MakeException(SR.TooManyAlternates);              }              else              {                  _alternation.AddChild(_concatenation.ReverseLeft());                  _group.AddChild(_alternation);              }
Magic Number,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,AddGroup,The following statement contains a magic number: if (_group.Type() == RegexNode.Testgroup || _group.Type() == RegexNode.Testref)              {                  _group.AddChild(_concatenation.ReverseLeft());                    if (_group.Type() == RegexNode.Testref && _group.ChildCount() > 2 || _group.ChildCount() > 3)                      throw MakeException(SR.TooManyAlternates);              }              else              {                  _alternation.AddChild(_concatenation.ReverseLeft());                  _group.AddChild(_alternation);              }
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,Scan,The following statement contains a magic number: _timeout = _ignoreTimeout                                      ? (int)Regex.InfiniteMatchTimeout.TotalMilliseconds                                      : (int)(timeout.TotalMilliseconds + 0.5);
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: int tracksize = runtrackcount * 8;
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: int stacksize = runtrackcount * 8;
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: if (tracksize < 32)                  tracksize = 32;
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: if (tracksize < 32)                  tracksize = 32;
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: if (stacksize < 16)                  stacksize = 16;
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: if (stacksize < 16)                  stacksize = 16;
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: runcrawl = new int[32];
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,InitMatch,The following statement contains a magic number: runcrawlpos = 32;
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,EnsureStorage,The following statement contains a magic number: if (runstackpos < runtrackcount * 4)                  DoubleStack();
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,EnsureStorage,The following statement contains a magic number: if (runtrackpos < runtrackcount * 4)                  DoubleTrack();
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,DoubleTrack,The following statement contains a magic number: newtrack = new int[runtrack.Length * 2];
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,DoubleStack,The following statement contains a magic number: newstack = new int[runstack.Length * 2];
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,DoubleCrawl,The following statement contains a magic number: newcrawl = new int[runcrawl.Length * 2];
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,StackDescription,The following statement contains a magic number: if (sb.Length < 8)                  sb.Append(' '' 8 - sb.Length);
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,StackDescription,The following statement contains a magic number: if (sb.Length < 8)                  sb.Append(' '' 8 - sb.Length);
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,TextposDescription,The following statement contains a magic number: if (sb.Length < 8)                  sb.Append(' '' 8 - sb.Length);
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,TextposDescription,The following statement contains a magic number: if (sb.Length < 8)                  sb.Append(' '' 8 - sb.Length);
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,TextposDescription,The following statement contains a magic number: if (sb.Length >= 64)              {                  sb.Length = 61;                  sb.Append("...");              }              else              {                  sb.Append('$');              }
Magic Number,System.Text.RegularExpressions,RegexRunner,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexRunner.cs,TextposDescription,The following statement contains a magic number: if (sb.Length >= 64)              {                  sb.Length = 61;                  sb.Append("...");              }              else              {                  sb.Append('$');              }
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,RegexWriter,The following statement contains a magic number: _intStack = new int[32];
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,RegexWriter,The following statement contains a magic number: _emitted = new int[32];
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,PushInt,The following statement contains a magic number: if (_depth >= _intStack.Length)              {                  int[] expanded = new int[_depth * 2];                    Array.Copy(_intStack' 0' expanded' 0' _depth);                    _intStack = expanded;              }
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,Emit,The following statement contains a magic number: if (_counting)              {                  _count += 2;                  if (RegexCode.OpcodeBacktracks(op))                      _trackcount += 1;                  return;              }
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,Emit,The following statement contains a magic number: if (_counting)              {                  _count += 3;                  if (RegexCode.OpcodeBacktracks(op))                      _trackcount += 1;                  return;              }
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The following statement contains a magic number: switch (nodetype)              {                  case RegexNode.Concatenate | BeforeChild:                  case RegexNode.Concatenate | AfterChild:                  case RegexNode.Empty:                      break;                    case RegexNode.Alternate | BeforeChild:                      if (curIndex < node._children.Count - 1)                      {                          PushInt(CurPos());                          Emit(RegexCode.Lazybranch' 0);                      }                      break;                    case RegexNode.Alternate | AfterChild:                      {                          if (curIndex < node._children.Count - 1)                          {                              int LBPos = PopInt();                              PushInt(CurPos());                              Emit(RegexCode.Goto' 0);                              PatchJump(LBPos' CurPos());                          }                          else                          {                              int I;                              for (I = 0; I < curIndex; I++)                              {                                  PatchJump(PopInt()' CurPos());                              }                          }                          break;                      }                    case RegexNode.Testref | BeforeChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              Emit(RegexCode.Testref' MapCapnum(node._m));                              Emit(RegexCode.Forejump);                              break;                      }                      break;                    case RegexNode.Testref | AfterChild:                      switch (curIndex)                      {                          case 0:                              {                                  int Branchpos = PopInt();                                  PushInt(CurPos());                                  Emit(RegexCode.Goto' 0);                                  PatchJump(Branchpos' CurPos());                                  Emit(RegexCode.Forejump);                                  if (node._children.Count > 1)                                      break;                                  // else fallthrough                                  goto case 1;                              }                          case 1:                              PatchJump(PopInt()' CurPos());                              break;                      }                      break;                    case RegexNode.Testgroup | BeforeChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              Emit(RegexCode.Setmark);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              break;                      }                      break;                    case RegexNode.Testgroup | AfterChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                              break;                          case 1:                              int Branchpos = PopInt();                              PushInt(CurPos());                              Emit(RegexCode.Goto' 0);                              PatchJump(Branchpos' CurPos());                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                                if (node._children.Count > 2)                                  break;                              // else fallthrough                              goto case 2;                          case 2:                              PatchJump(PopInt()' CurPos());                              break;                      }                      break;                    case RegexNode.Loop | BeforeChild:                  case RegexNode.Lazyloop | BeforeChild:                        if (node._n < int.MaxValue || node._m > 1)                          Emit(node._m == 0 ? RegexCode.Nullcount : RegexCode.Setcount' node._m == 0 ? 0 : 1 - node._m);                      else                          Emit(node._m == 0 ? RegexCode.Nullmark : RegexCode.Setmark);                        if (node._m == 0)                      {                          PushInt(CurPos());                          Emit(RegexCode.Goto' 0);                      }                      PushInt(CurPos());                      break;                    case RegexNode.Loop | AfterChild:                  case RegexNode.Lazyloop | AfterChild:                      {                          int StartJumpPos = CurPos();                          int Lazy = (nodetype - (RegexNode.Loop | AfterChild));                            if (node._n < int.MaxValue || node._m > 1)                              Emit(RegexCode.Branchcount + Lazy' PopInt()' node._n == int.MaxValue ? int.MaxValue : node._n - node._m);                          else                              Emit(RegexCode.Branchmark + Lazy' PopInt());                            if (node._m == 0)                              PatchJump(PopInt()' StartJumpPos);                      }                      break;                    case RegexNode.Group | BeforeChild:                  case RegexNode.Group | AfterChild:                      break;                    case RegexNode.Capture | BeforeChild:                      Emit(RegexCode.Setmark);                      break;                    case RegexNode.Capture | AfterChild:                      Emit(RegexCode.Capturemark' MapCapnum(node._m)' MapCapnum(node._n));                      break;                    case RegexNode.Require | BeforeChild:                      // NOTE: the following line causes lookahead/lookbehind to be                      // NON-BACKTRACKING. It can be commented out with (*)                      Emit(RegexCode.Setjump);                          Emit(RegexCode.Setmark);                      break;                    case RegexNode.Require | AfterChild:                      Emit(RegexCode.Getmark);                        // NOTE: the following line causes lookahead/lookbehind to be                      // NON-BACKTRACKING. It can be commented out with (*)                      Emit(RegexCode.Forejump);                        break;                    case RegexNode.Prevent | BeforeChild:                      Emit(RegexCode.Setjump);                      PushInt(CurPos());                      Emit(RegexCode.Lazybranch' 0);                      break;                    case RegexNode.Prevent | AfterChild:                      Emit(RegexCode.Backjump);                      PatchJump(PopInt()' CurPos());                      Emit(RegexCode.Forejump);                      break;                    case RegexNode.Greedy | BeforeChild:                      Emit(RegexCode.Setjump);                      break;                    case RegexNode.Greedy | AfterChild:                      Emit(RegexCode.Forejump);                      break;                    case RegexNode.One:                  case RegexNode.Notone:                      Emit(node._type | bits' node._ch);                      break;                    case RegexNode.Notoneloop:                  case RegexNode.Notonelazy:                  case RegexNode.Oneloop:                  case RegexNode.Onelazy:                      if (node._m > 0)                          Emit(((node._type == RegexNode.Oneloop || node._type == RegexNode.Onelazy) ?                                RegexCode.Onerep : RegexCode.Notonerep) | bits' node._ch' node._m);                      if (node._n > node._m)                          Emit(node._type | bits' node._ch' node._n == int.MaxValue ?                               int.MaxValue : node._n - node._m);                      break;                    case RegexNode.Setloop:                  case RegexNode.Setlazy:                      if (node._m > 0)                          Emit(RegexCode.Setrep | bits' StringCode(node._str)' node._m);                      if (node._n > node._m)                          Emit(node._type | bits' StringCode(node._str)'                               (node._n == int.MaxValue) ? int.MaxValue : node._n - node._m);                      break;                    case RegexNode.Multi:                      Emit(node._type | bits' StringCode(node._str));                      break;                    case RegexNode.Set:                      Emit(node._type | bits' StringCode(node._str));                      break;                    case RegexNode.Ref:                      Emit(node._type | bits' MapCapnum(node._m));                      break;                    case RegexNode.Nothing:                  case RegexNode.Bol:                  case RegexNode.Eol:                  case RegexNode.Boundary:                  case RegexNode.Nonboundary:                  case RegexNode.ECMABoundary:                  case RegexNode.NonECMABoundary:                  case RegexNode.Beginning:                  case RegexNode.Start:                  case RegexNode.EndZ:                  case RegexNode.End:                      Emit(node._type);                      break;                    default:                      throw new ArgumentException(SR.Format(SR.UnexpectedOpcode' nodetype.ToString(CultureInfo.CurrentCulture)));              }
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The following statement contains a magic number: switch (nodetype)              {                  case RegexNode.Concatenate | BeforeChild:                  case RegexNode.Concatenate | AfterChild:                  case RegexNode.Empty:                      break;                    case RegexNode.Alternate | BeforeChild:                      if (curIndex < node._children.Count - 1)                      {                          PushInt(CurPos());                          Emit(RegexCode.Lazybranch' 0);                      }                      break;                    case RegexNode.Alternate | AfterChild:                      {                          if (curIndex < node._children.Count - 1)                          {                              int LBPos = PopInt();                              PushInt(CurPos());                              Emit(RegexCode.Goto' 0);                              PatchJump(LBPos' CurPos());                          }                          else                          {                              int I;                              for (I = 0; I < curIndex; I++)                              {                                  PatchJump(PopInt()' CurPos());                              }                          }                          break;                      }                    case RegexNode.Testref | BeforeChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              Emit(RegexCode.Testref' MapCapnum(node._m));                              Emit(RegexCode.Forejump);                              break;                      }                      break;                    case RegexNode.Testref | AfterChild:                      switch (curIndex)                      {                          case 0:                              {                                  int Branchpos = PopInt();                                  PushInt(CurPos());                                  Emit(RegexCode.Goto' 0);                                  PatchJump(Branchpos' CurPos());                                  Emit(RegexCode.Forejump);                                  if (node._children.Count > 1)                                      break;                                  // else fallthrough                                  goto case 1;                              }                          case 1:                              PatchJump(PopInt()' CurPos());                              break;                      }                      break;                    case RegexNode.Testgroup | BeforeChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              Emit(RegexCode.Setmark);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              break;                      }                      break;                    case RegexNode.Testgroup | AfterChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                              break;                          case 1:                              int Branchpos = PopInt();                              PushInt(CurPos());                              Emit(RegexCode.Goto' 0);                              PatchJump(Branchpos' CurPos());                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                                if (node._children.Count > 2)                                  break;                              // else fallthrough                              goto case 2;                          case 2:                              PatchJump(PopInt()' CurPos());                              break;                      }                      break;                    case RegexNode.Loop | BeforeChild:                  case RegexNode.Lazyloop | BeforeChild:                        if (node._n < int.MaxValue || node._m > 1)                          Emit(node._m == 0 ? RegexCode.Nullcount : RegexCode.Setcount' node._m == 0 ? 0 : 1 - node._m);                      else                          Emit(node._m == 0 ? RegexCode.Nullmark : RegexCode.Setmark);                        if (node._m == 0)                      {                          PushInt(CurPos());                          Emit(RegexCode.Goto' 0);                      }                      PushInt(CurPos());                      break;                    case RegexNode.Loop | AfterChild:                  case RegexNode.Lazyloop | AfterChild:                      {                          int StartJumpPos = CurPos();                          int Lazy = (nodetype - (RegexNode.Loop | AfterChild));                            if (node._n < int.MaxValue || node._m > 1)                              Emit(RegexCode.Branchcount + Lazy' PopInt()' node._n == int.MaxValue ? int.MaxValue : node._n - node._m);                          else                              Emit(RegexCode.Branchmark + Lazy' PopInt());                            if (node._m == 0)                              PatchJump(PopInt()' StartJumpPos);                      }                      break;                    case RegexNode.Group | BeforeChild:                  case RegexNode.Group | AfterChild:                      break;                    case RegexNode.Capture | BeforeChild:                      Emit(RegexCode.Setmark);                      break;                    case RegexNode.Capture | AfterChild:                      Emit(RegexCode.Capturemark' MapCapnum(node._m)' MapCapnum(node._n));                      break;                    case RegexNode.Require | BeforeChild:                      // NOTE: the following line causes lookahead/lookbehind to be                      // NON-BACKTRACKING. It can be commented out with (*)                      Emit(RegexCode.Setjump);                          Emit(RegexCode.Setmark);                      break;                    case RegexNode.Require | AfterChild:                      Emit(RegexCode.Getmark);                        // NOTE: the following line causes lookahead/lookbehind to be                      // NON-BACKTRACKING. It can be commented out with (*)                      Emit(RegexCode.Forejump);                        break;                    case RegexNode.Prevent | BeforeChild:                      Emit(RegexCode.Setjump);                      PushInt(CurPos());                      Emit(RegexCode.Lazybranch' 0);                      break;                    case RegexNode.Prevent | AfterChild:                      Emit(RegexCode.Backjump);                      PatchJump(PopInt()' CurPos());                      Emit(RegexCode.Forejump);                      break;                    case RegexNode.Greedy | BeforeChild:                      Emit(RegexCode.Setjump);                      break;                    case RegexNode.Greedy | AfterChild:                      Emit(RegexCode.Forejump);                      break;                    case RegexNode.One:                  case RegexNode.Notone:                      Emit(node._type | bits' node._ch);                      break;                    case RegexNode.Notoneloop:                  case RegexNode.Notonelazy:                  case RegexNode.Oneloop:                  case RegexNode.Onelazy:                      if (node._m > 0)                          Emit(((node._type == RegexNode.Oneloop || node._type == RegexNode.Onelazy) ?                                RegexCode.Onerep : RegexCode.Notonerep) | bits' node._ch' node._m);                      if (node._n > node._m)                          Emit(node._type | bits' node._ch' node._n == int.MaxValue ?                               int.MaxValue : node._n - node._m);                      break;                    case RegexNode.Setloop:                  case RegexNode.Setlazy:                      if (node._m > 0)                          Emit(RegexCode.Setrep | bits' StringCode(node._str)' node._m);                      if (node._n > node._m)                          Emit(node._type | bits' StringCode(node._str)'                               (node._n == int.MaxValue) ? int.MaxValue : node._n - node._m);                      break;                    case RegexNode.Multi:                      Emit(node._type | bits' StringCode(node._str));                      break;                    case RegexNode.Set:                      Emit(node._type | bits' StringCode(node._str));                      break;                    case RegexNode.Ref:                      Emit(node._type | bits' MapCapnum(node._m));                      break;                    case RegexNode.Nothing:                  case RegexNode.Bol:                  case RegexNode.Eol:                  case RegexNode.Boundary:                  case RegexNode.Nonboundary:                  case RegexNode.ECMABoundary:                  case RegexNode.NonECMABoundary:                  case RegexNode.Beginning:                  case RegexNode.Start:                  case RegexNode.EndZ:                  case RegexNode.End:                      Emit(node._type);                      break;                    default:                      throw new ArgumentException(SR.Format(SR.UnexpectedOpcode' nodetype.ToString(CultureInfo.CurrentCulture)));              }
Magic Number,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The following statement contains a magic number: switch (nodetype)              {                  case RegexNode.Concatenate | BeforeChild:                  case RegexNode.Concatenate | AfterChild:                  case RegexNode.Empty:                      break;                    case RegexNode.Alternate | BeforeChild:                      if (curIndex < node._children.Count - 1)                      {                          PushInt(CurPos());                          Emit(RegexCode.Lazybranch' 0);                      }                      break;                    case RegexNode.Alternate | AfterChild:                      {                          if (curIndex < node._children.Count - 1)                          {                              int LBPos = PopInt();                              PushInt(CurPos());                              Emit(RegexCode.Goto' 0);                              PatchJump(LBPos' CurPos());                          }                          else                          {                              int I;                              for (I = 0; I < curIndex; I++)                              {                                  PatchJump(PopInt()' CurPos());                              }                          }                          break;                      }                    case RegexNode.Testref | BeforeChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              Emit(RegexCode.Testref' MapCapnum(node._m));                              Emit(RegexCode.Forejump);                              break;                      }                      break;                    case RegexNode.Testref | AfterChild:                      switch (curIndex)                      {                          case 0:                              {                                  int Branchpos = PopInt();                                  PushInt(CurPos());                                  Emit(RegexCode.Goto' 0);                                  PatchJump(Branchpos' CurPos());                                  Emit(RegexCode.Forejump);                                  if (node._children.Count > 1)                                      break;                                  // else fallthrough                                  goto case 1;                              }                          case 1:                              PatchJump(PopInt()' CurPos());                              break;                      }                      break;                    case RegexNode.Testgroup | BeforeChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              Emit(RegexCode.Setmark);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              break;                      }                      break;                    case RegexNode.Testgroup | AfterChild:                      switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                              break;                          case 1:                              int Branchpos = PopInt();                              PushInt(CurPos());                              Emit(RegexCode.Goto' 0);                              PatchJump(Branchpos' CurPos());                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                                if (node._children.Count > 2)                                  break;                              // else fallthrough                              goto case 2;                          case 2:                              PatchJump(PopInt()' CurPos());                              break;                      }                      break;                    case RegexNode.Loop | BeforeChild:                  case RegexNode.Lazyloop | BeforeChild:                        if (node._n < int.MaxValue || node._m > 1)                          Emit(node._m == 0 ? RegexCode.Nullcount : RegexCode.Setcount' node._m == 0 ? 0 : 1 - node._m);                      else                          Emit(node._m == 0 ? RegexCode.Nullmark : RegexCode.Setmark);                        if (node._m == 0)                      {                          PushInt(CurPos());                          Emit(RegexCode.Goto' 0);                      }                      PushInt(CurPos());                      break;                    case RegexNode.Loop | AfterChild:                  case RegexNode.Lazyloop | AfterChild:                      {                          int StartJumpPos = CurPos();                          int Lazy = (nodetype - (RegexNode.Loop | AfterChild));                            if (node._n < int.MaxValue || node._m > 1)                              Emit(RegexCode.Branchcount + Lazy' PopInt()' node._n == int.MaxValue ? int.MaxValue : node._n - node._m);                          else                              Emit(RegexCode.Branchmark + Lazy' PopInt());                            if (node._m == 0)                              PatchJump(PopInt()' StartJumpPos);                      }                      break;                    case RegexNode.Group | BeforeChild:                  case RegexNode.Group | AfterChild:                      break;                    case RegexNode.Capture | BeforeChild:                      Emit(RegexCode.Setmark);                      break;                    case RegexNode.Capture | AfterChild:                      Emit(RegexCode.Capturemark' MapCapnum(node._m)' MapCapnum(node._n));                      break;                    case RegexNode.Require | BeforeChild:                      // NOTE: the following line causes lookahead/lookbehind to be                      // NON-BACKTRACKING. It can be commented out with (*)                      Emit(RegexCode.Setjump);                          Emit(RegexCode.Setmark);                      break;                    case RegexNode.Require | AfterChild:                      Emit(RegexCode.Getmark);                        // NOTE: the following line causes lookahead/lookbehind to be                      // NON-BACKTRACKING. It can be commented out with (*)                      Emit(RegexCode.Forejump);                        break;                    case RegexNode.Prevent | BeforeChild:                      Emit(RegexCode.Setjump);                      PushInt(CurPos());                      Emit(RegexCode.Lazybranch' 0);                      break;                    case RegexNode.Prevent | AfterChild:                      Emit(RegexCode.Backjump);                      PatchJump(PopInt()' CurPos());                      Emit(RegexCode.Forejump);                      break;                    case RegexNode.Greedy | BeforeChild:                      Emit(RegexCode.Setjump);                      break;                    case RegexNode.Greedy | AfterChild:                      Emit(RegexCode.Forejump);                      break;                    case RegexNode.One:                  case RegexNode.Notone:                      Emit(node._type | bits' node._ch);                      break;                    case RegexNode.Notoneloop:                  case RegexNode.Notonelazy:                  case RegexNode.Oneloop:                  case RegexNode.Onelazy:                      if (node._m > 0)                          Emit(((node._type == RegexNode.Oneloop || node._type == RegexNode.Onelazy) ?                                RegexCode.Onerep : RegexCode.Notonerep) | bits' node._ch' node._m);                      if (node._n > node._m)                          Emit(node._type | bits' node._ch' node._n == int.MaxValue ?                               int.MaxValue : node._n - node._m);                      break;                    case RegexNode.Setloop:                  case RegexNode.Setlazy:                      if (node._m > 0)                          Emit(RegexCode.Setrep | bits' StringCode(node._str)' node._m);                      if (node._n > node._m)                          Emit(node._type | bits' StringCode(node._str)'                               (node._n == int.MaxValue) ? int.MaxValue : node._n - node._m);                      break;                    case RegexNode.Multi:                      Emit(node._type | bits' StringCode(node._str));                      break;                    case RegexNode.Set:                      Emit(node._type | bits' StringCode(node._str));                      break;                    case RegexNode.Ref:                      Emit(node._type | bits' MapCapnum(node._m));                      break;                    case RegexNode.Nothing:                  case RegexNode.Bol:                  case RegexNode.Eol:                  case RegexNode.Boundary:                  case RegexNode.Nonboundary:                  case RegexNode.ECMABoundary:                  case RegexNode.NonECMABoundary:                  case RegexNode.Beginning:                  case RegexNode.Start:                  case RegexNode.EndZ:                  case RegexNode.End:                      Emit(node._type);                      break;                    default:                      throw new ArgumentException(SR.Format(SR.UnexpectedOpcode' nodetype.ToString(CultureInfo.CurrentCulture)));              }
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,AddBacktrackNote,The following statement contains a magic number: if (_notes == null || _notecount >= _notes.Length)              {                  BacktrackNote[] newnotes = new BacktrackNote[_notes == null ? 16 : _notes.Length * 2];                  if (_notes != null)                      System.Array.Copy(_notes' 0' newnotes' 0' _notecount);                  _notes = newnotes;              }
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,AddBacktrackNote,The following statement contains a magic number: if (_notes == null || _notecount >= _notes.Length)              {                  BacktrackNote[] newnotes = new BacktrackNote[_notes == null ? 16 : _notes.Length * 2];                  if (_notes != null)                      System.Array.Copy(_notes' 0' newnotes' 0' _notecount);                  _notes = newnotes;              }
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,Ldc,The following statement contains a magic number: if (i <= 127 && i >= -128)                  _ilg.Emit(OpCodes.Ldc_I4_S' (byte)i);              else                  _ilg.Emit(OpCodes.Ldc_I4' i);
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,Ldc,The following statement contains a magic number: if (i <= 127 && i >= -128)                  _ilg.Emit(OpCodes.Ldc_I4_S' (byte)i);              else                  _ilg.Emit(OpCodes.Ldc_I4' i);
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,Goto,The following statement contains a magic number: if (i < _codepos)              {                  Label l1 = DefineLabel();                    // When going backwards' ensure enough space.                  Ldloc(_trackposV);                  Ldc(_trackcount * 4);                  Ble(l1);                  Ldloc(_stackposV);                  Ldc(_trackcount * 3);                  BgtFar(_labels[i]);                  MarkLabel(l1);                  ReadyPushTrack();                  Ldc(AddGoto(i));                  DoPush();                  BrFar(_backtrack);              }              else              {                  BrFar(_labels[i]);              }
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,Goto,The following statement contains a magic number: if (i < _codepos)              {                  Label l1 = DefineLabel();                    // When going backwards' ensure enough space.                  Ldloc(_trackposV);                  Ldc(_trackcount * 4);                  Ble(l1);                  Ldloc(_stackposV);                  Ldc(_trackcount * 3);                  BgtFar(_labels[i]);                  MarkLabel(l1);                  ReadyPushTrack();                  Ldc(AddGoto(i));                  DoPush();                  BrFar(_backtrack);              }              else              {                  BrFar(_labels[i]);              }
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,GenerateFindFirstChar,The following statement contains a magic number: if (0 != (_anchors & (RegexFCD.Beginning | RegexFCD.Start | RegexFCD.EndZ | RegexFCD.End)))              {                  if (!_code._rightToLeft)                  {                      if (0 != (_anchors & RegexFCD.Beginning))                      {                          Label l1 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textbegF);                          Ble(l1);                          Ldthis();                          Ldthisfld(s_textendF);                          Stfld(s_textposF);                          Ldc(0);                          Ret();                          MarkLabel(l1);                      }                        if (0 != (_anchors & RegexFCD.Start))                      {                          Label l1 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textstartF);                          Ble(l1);                          Ldthis();                          Ldthisfld(s_textendF);                          Stfld(s_textposF);                          Ldc(0);                          Ret();                          MarkLabel(l1);                      }                        if (0 != (_anchors & RegexFCD.EndZ))                      {                          Label l1 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textendF);                          Ldc(1);                          Sub();                          Bge(l1);                          Ldthis();                          Ldthisfld(s_textendF);                          Ldc(1);                          Sub();                          Stfld(s_textposF);                          MarkLabel(l1);                      }                        if (0 != (_anchors & RegexFCD.End))                      {                          Label l1 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textendF);                          Bge(l1);                          Ldthis();                          Ldthisfld(s_textendF);                          Stfld(s_textposF);                          MarkLabel(l1);                      }                  }                  else                  {                      if (0 != (_anchors & RegexFCD.End))                      {                          Label l1 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textendF);                          Bge(l1);                          Ldthis();                          Ldthisfld(s_textbegF);                          Stfld(s_textposF);                          Ldc(0);                          Ret();                          MarkLabel(l1);                      }                        if (0 != (_anchors & RegexFCD.EndZ))                      {                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textendF);                          Ldc(1);                          Sub();                          Blt(l1);                          Ldthisfld(s_textposF);                          Ldthisfld(s_textendF);                          Beq(l2);                          Ldthisfld(s_textF);                          Ldthisfld(s_textposF);                          Callvirt(s_getcharM);                          Ldc((int)'\n');                          Beq(l2);                          MarkLabel(l1);                          Ldthis();                          Ldthisfld(s_textbegF);                          Stfld(s_textposF);                          Ldc(0);                          Ret();                          MarkLabel(l2);                      }                        if (0 != (_anchors & RegexFCD.Start))                      {                          Label l1 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textstartF);                          Bge(l1);                          Ldthis();                          Ldthisfld(s_textbegF);                          Stfld(s_textposF);                          Ldc(0);                          Ret();                          MarkLabel(l1);                      }                        if (0 != (_anchors & RegexFCD.Beginning))                      {                          Label l1 = DefineLabel();                          Ldthisfld(s_textposF);                          Ldthisfld(s_textbegF);                          Ble(l1);                          Ldthis();                          Ldthisfld(s_textbegF);                          Stfld(s_textposF);                          MarkLabel(l1);                      }                  }                    // <                      Ldc(1);                  Ret();              }              else if (_bmPrefix != null && _bmPrefix._negativeUnicode == null)              {                  // Compiled Boyer-Moore string matching                  // <                      LocalBuilder chV = _tempV;                  LocalBuilder testV = _tempV;                  LocalBuilder limitV = _temp2V;                  Label lDefaultAdvance = DefineLabel();                  Label lAdvance = DefineLabel();                  Label lFail = DefineLabel();                  Label lStart = DefineLabel();                  Label lOutOfRange = DefineLabel();                  Label lPartialMatch = DefineLabel();                      int chLast;                  int i;                  int beforefirst;                  int last;                  Label[] table;                    if (!_code._rightToLeft)                  {                      beforefirst = -1;                      last = _bmPrefix._pattern.Length - 1;                  }                  else                  {                      beforefirst = _bmPrefix._pattern.Length;                      last = 0;                  }                    chLast = _bmPrefix._pattern[last];                    Mvfldloc(s_textF' _textV);                  if (!_code._rightToLeft)                      Ldthisfld(s_textendF);                  else                      Ldthisfld(s_textbegF);                  Stloc(limitV);                    Ldthisfld(s_textposF);                  if (!_code._rightToLeft)                  {                      Ldc(_bmPrefix._pattern.Length - 1);                      Add();                  }                  else                  {                      Ldc(_bmPrefix._pattern.Length);                      Sub();                  }                  Stloc(_textposV);                  Br(lStart);                    MarkLabel(lDefaultAdvance);                    if (!_code._rightToLeft)                      Ldc(_bmPrefix._pattern.Length);                  else                      Ldc(-_bmPrefix._pattern.Length);                    MarkLabel(lAdvance);                    Ldloc(_textposV);                  Add();                  Stloc(_textposV);                    MarkLabel(lStart);                    Ldloc(_textposV);                  Ldloc(limitV);                  if (!_code._rightToLeft)                      BgeFar(lFail);                  else                      BltFar(lFail);                    Rightchar();                  if (_bmPrefix._caseInsensitive)                      CallToLower();                    Dup();                  Stloc(chV);                  Ldc(chLast);                  BeqFar(lPartialMatch);                    Ldloc(chV);                  Ldc(_bmPrefix._lowASCII);                  Sub();                  Dup();                  Stloc(chV);                  Ldc(_bmPrefix._highASCII - _bmPrefix._lowASCII);                  Bgtun(lDefaultAdvance);                    table = new Label[_bmPrefix._highASCII - _bmPrefix._lowASCII + 1];                    for (i = _bmPrefix._lowASCII; i <= _bmPrefix._highASCII; i++)                  {                      if (_bmPrefix._negativeASCII[i] == beforefirst)                          table[i - _bmPrefix._lowASCII] = lDefaultAdvance;                      else                          table[i - _bmPrefix._lowASCII] = DefineLabel();                  }                    Ldloc(chV);                  _ilg.Emit(OpCodes.Switch' table);                    for (i = _bmPrefix._lowASCII; i <= _bmPrefix._highASCII; i++)                  {                      if (_bmPrefix._negativeASCII[i] == beforefirst)                          continue;                        MarkLabel(table[i - _bmPrefix._lowASCII]);                        Ldc(_bmPrefix._negativeASCII[i]);                      BrFar(lAdvance);                  }                    MarkLabel(lPartialMatch);                    Ldloc(_textposV);                  Stloc(testV);                    for (i = _bmPrefix._pattern.Length - 2; i >= 0; i--)                  {                      Label lNext = DefineLabel();                      int charindex;                        if (!_code._rightToLeft)                          charindex = i;                      else                          charindex = _bmPrefix._pattern.Length - 1 - i;                        Ldloc(_textV);                      Ldloc(testV);                      Ldc(1);                      Sub(_code._rightToLeft);                      Dup();                      Stloc(testV);                      Callvirt(s_getcharM);                      if (_bmPrefix._caseInsensitive)                          CallToLower();                        Ldc(_bmPrefix._pattern[charindex]);                      Beq(lNext);                      Ldc(_bmPrefix._positive[charindex]);                      BrFar(lAdvance);                        MarkLabel(lNext);                    }                    Ldthis();                  Ldloc(testV);                  if (_code._rightToLeft)                  {                      Ldc(1);                      Add();                  }                  Stfld(s_textposF);                  Ldc(1);                  Ret();                    MarkLabel(lFail);                    Ldthis();                  if (!_code._rightToLeft)                      Ldthisfld(s_textendF);                  else                      Ldthisfld(s_textbegF);                  Stfld(s_textposF);                  Ldc(0);                  Ret();              }              else if (_fcPrefix == null)              {                  Ldc(1);                  Ret();              }              else              {                  LocalBuilder cV = _temp2V;                  LocalBuilder chV = _tempV;                  Label l1 = DefineLabel();                  Label l2 = DefineLabel();                  Label l3 = DefineLabel();                  Label l4 = DefineLabel();                  Label l5 = DefineLabel();                    Mvfldloc(s_textposF' _textposV);                  Mvfldloc(s_textF' _textV);                    if (!_code._rightToLeft)                  {                      Ldthisfld(s_textendF);                      Ldloc(_textposV);                  }                  else                  {                      Ldloc(_textposV);                      Ldthisfld(s_textbegF);                  }                  Sub();                  Stloc(cV);                    Ldloc(cV);                  Ldc(0);                  BleFar(l4);                    MarkLabel(l1);                    Ldloc(cV);                  Ldc(1);                  Sub();                  Stloc(cV);                    if (_code._rightToLeft)                      Leftcharnext();                  else                      Rightcharnext();                    if (_fcPrefix.CaseInsensitive)                      CallToLower();                    if (!RegexCharClass.IsSingleton(_fcPrefix.Prefix))                  {                      Ldstr(_fcPrefix.Prefix);                      Call(s_charInSetM);                        BrtrueFar(l2);                  }                  else                  {                      Ldc(RegexCharClass.SingletonChar(_fcPrefix.Prefix));                      Beq(l2);                  }                    MarkLabel(l5);                    Ldloc(cV);                  Ldc(0);                  if (!RegexCharClass.IsSingleton(_fcPrefix.Prefix))                      BgtFar(l1);                  else                      Bgt(l1);                    Ldc(0);                  BrFar(l3);                    MarkLabel(l2);                    /*          // CURRENTLY DISABLED                              // If for some reason we have a prefix we didn't use' use it now.                                                if (_bmPrefix != null) {                                  if (!_code._rightToLeft) {                                      Ldthisfld(_textendF);                                      Ldloc(_textposV);                                  }                                  else {                                      Ldloc(_textposV);                                      Ldthisfld(_textbegF);                                  }                                  Sub();                                  Ldc(_bmPrefix._pattern.Length - 1);                                  BltFar(l5);                                                                    for (int i = 1; i < _bmPrefix._pattern.Length; i++) {                                      Ldloc(_textV);                                      Ldloc(_textposV);                                      if (!_code._rightToLeft) {                                          Ldc(i - 1);                                          Add();                                      }                                      else {                                          Ldc(i);                                          Sub();                                      }                                      Callvirt(_getcharM);                                      if (!_code._rightToLeft)                                          Ldc(_bmPrefix._pattern[i]);                                      else                                          Ldc(_bmPrefix._pattern[_bmPrefix._pattern.Length - 1 - i]);                                      BneFar(l5);                                  }                              }                  */                    Ldloc(_textposV);                  Ldc(1);                  Sub(_code._rightToLeft);                  Stloc(_textposV);                  Ldc(1);                    MarkLabel(l3);                    Mvlocfld(_textposV' s_textposF);                  Ret();                    MarkLabel(l4);                  Ldc(0);                  Ret();              }
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,GenerateOneCode,The following statement contains a magic number: switch (_regexopcode)              {                  case RegexCode.Stop:                      //: return;                      Mvlocfld(_textposV' s_textposF);       // update _textpos                      Ret();                      break;                    case RegexCode.Nothing:                      //: break Backward;                      Back();                      break;                    case RegexCode.Goto:                      //: Goto(Operand(0));                      Goto(Operand(0));                      break;                    case RegexCode.Testref:                      //: if (!_match.IsMatched(Operand(0)))                      //:     break Backward;                      Ldthis();                      Ldc(Operand(0));                      Callvirt(s_ismatchedM);                      BrfalseFar(_backtrack);                      break;                    case RegexCode.Lazybranch:                      //: Track(Textpos());                      PushTrack(_textposV);                      Track();                      break;                    case RegexCode.Lazybranch | RegexCode.Back:                      //: Trackframe(1);                      //: Textto(Tracked(0));                      //: Goto(Operand(0));                      PopTrack();                      Stloc(_textposV);                      Goto(Operand(0));                      break;                    case RegexCode.Nullmark:                      //: Stack(-1);                      //: Track();                      ReadyPushStack();                      Ldc(-1);                      DoPush();                      TrackUnique(Stackpop);                      break;                    case RegexCode.Setmark:                      //: Stack(Textpos());                      //: Track();                      PushStack(_textposV);                      TrackUnique(Stackpop);                      break;                    case RegexCode.Nullmark | RegexCode.Back:                  case RegexCode.Setmark | RegexCode.Back:                      //: Stackframe(1);                      //: break Backward;                      PopDiscardStack();                      Back();                      break;                    case RegexCode.Getmark:                      //: Stackframe(1);                      //: Track(Stacked(0));                      //: Textto(Stacked(0));                      ReadyPushTrack();                      PopStack();                      Dup();                      Stloc(_textposV);                      DoPush();                        Track();                      break;                    case RegexCode.Getmark | RegexCode.Back:                      //: Trackframe(1);                      //: Stack(Tracked(0));                      //: break Backward;                      ReadyPushStack();                      PopTrack();                      DoPush();                      Back();                      break;                    case RegexCode.Capturemark:                      //: if (!IsMatched(Operand(1)))                      //:     break Backward;                      //: Stackframe(1);                      //: if (Operand(1) != -1)                      //:     TransferCapture(Operand(0)' Operand(1)' Stacked(0)' Textpos());                      //: else                      //:     Capture(Operand(0)' Stacked(0)' Textpos());                      //: Track(Stacked(0));                        //: Stackframe(1);                      //: Capture(Operand(0)' Stacked(0)' Textpos());                      //: Track(Stacked(0));                        if (Operand(1) != -1)                      {                          Ldthis();                          Ldc(Operand(1));                          Callvirt(s_ismatchedM);                          BrfalseFar(_backtrack);                      }                        PopStack();                      Stloc(_tempV);                        if (Operand(1) != -1)                      {                          Ldthis();                          Ldc(Operand(0));                          Ldc(Operand(1));                          Ldloc(_tempV);                          Ldloc(_textposV);                          Callvirt(s_transferM);                      }                      else                      {                          Ldthis();                          Ldc(Operand(0));                          Ldloc(_tempV);                          Ldloc(_textposV);                          Callvirt(s_captureM);                      }                        PushTrack(_tempV);                        if (Operand(0) != -1 && Operand(1) != -1)                          TrackUnique(Capback2);                      else                          TrackUnique(Capback);                        break;                      case RegexCode.Capturemark | RegexCode.Back:                      //: Trackframe(1);                      //: Stack(Tracked(0));                      //: Uncapture();                      //: if (Operand(0) != -1 && Operand(1) != -1)                      //:     Uncapture();                      //: break Backward;                      ReadyPushStack();                      PopTrack();                      DoPush();                      Ldthis();                      Callvirt(s_uncaptureM);                      if (Operand(0) != -1 && Operand(1) != -1)                      {                          Ldthis();                          Callvirt(s_uncaptureM);                      }                      Back();                      break;                    case RegexCode.Branchmark:                      //: Stackframe(1);                      //:                       //: if (Textpos() != Stacked(0))                      //: {                                   // Nonempty match -> loop now                      //:     Track(Stacked(0)' Textpos());   // Save old mark' textpos                      //:     Stack(Textpos());               // Make new mark                      //:     Goto(Operand(0));               // Loop                      //: }                      //: else                      //: {                                   // Empty match -> straight now                      //:     Track2(Stacked(0));             // Save old mark                      //:     Advance(1);                     // Straight                      //: }                      //: continue Forward;                      {                          LocalBuilder mark = _tempV;                          Label l1 = DefineLabel();                            PopStack();                          Dup();                          Stloc(mark);                            // Stacked(0) -> temp                          PushTrack(mark);                          Ldloc(_textposV);                          Beq(l1);                                // mark == textpos -> branch                            // (matched != 0)                            PushTrack(_textposV);                          PushStack(_textposV);                          Track();                          Goto(Operand(0));                       // Goto(Operand(0))                            // else                            MarkLabel(l1);                          TrackUnique2(Branchmarkback2);                          break;                      }                    case RegexCode.Branchmark | RegexCode.Back:                      //: Trackframe(2);                      //: Stackframe(1);                      //: Textto(Tracked(1));                     // Recall position                      //: Track2(Tracked(0));                     // Save old mark                      //: Advance(1);                      PopTrack();                      Stloc(_textposV);                      PopStack();                      Pop();                      // track spot 0 is already in place                      TrackUnique2(Branchmarkback2);                      Advance();                      break;                    case RegexCode.Branchmark | RegexCode.Back2:                      //: Trackframe(1);                      //: Stack(Tracked(0));                      // Recall old mark                      //: break Backward;                         // Backtrack                      ReadyPushStack();                      PopTrack();                      DoPush();                      Back();                      break;                      case RegexCode.Lazybranchmark:                      //: StackPop();                      //: int oldMarkPos = StackPeek();                      //:                       //: if (Textpos() != oldMarkPos) {         // Nonempty match -> next loop                      //: {                                   // Nonempty match -> next loop                      //:     if (oldMarkPos != -1)                      //:         Track(Stacked(0)' Textpos());   // Save old mark' textpos                      //:     else                      //:         TrackPush(Textpos()' Textpos());                         //: }                      //: else                      //: {                                   // Empty match -> no loop                      //:     Track2(Stacked(0));             // Save old mark                      //: }                      //: Advance(1);                      //: continue Forward;                      {                          LocalBuilder mark = _tempV;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                          Label l3 = DefineLabel();                            PopStack();                          Dup();                          Stloc(mark);                      // Stacked(0) -> temp                            // if (oldMarkPos != -1)                          Ldloc(mark);                          Ldc(-1);                          Beq(l2);                                // mark == -1 -> branch                          PushTrack(mark);                          Br(l3);                          // else                          MarkLabel(l2);                          PushTrack(_textposV);                          MarkLabel(l3);                            // if (Textpos() != mark)                          Ldloc(_textposV);                          Beq(l1);                                // mark == textpos -> branch                          PushTrack(_textposV);                          Track();                          Br(AdvanceLabel());                 // Advance (near)                                                              // else                          MarkLabel(l1);                          ReadyPushStack();                   // push the current textPos on the stack.                                                               // May be ignored by 'back2' or used by a true empty match.                          Ldloc(mark);                            DoPush();                          TrackUnique2(Lazybranchmarkback2);                            break;                      }                    case RegexCode.Lazybranchmark | RegexCode.Back:                      //: Trackframe(2);                      //: Track2(Tracked(0));                     // Save old mark                      //: Stack(Textpos());                       // Make new mark                      //: Textto(Tracked(1));                     // Recall position                      //: Goto(Operand(0));                       // Loop                        PopTrack();                      Stloc(_textposV);                      PushStack(_textposV);                      TrackUnique2(Lazybranchmarkback2);                      Goto(Operand(0));                      break;                    case RegexCode.Lazybranchmark | RegexCode.Back2:                      //: Stackframe(1);                      //: Trackframe(1);                      //: Stack(Tracked(0));                  // Recall old mark                      //: break Backward;                      ReadyReplaceStack(0);                      PopTrack();                      DoReplace();                      Back();                      break;                    case RegexCode.Nullcount:                      //: Stack(-1' Operand(0));                      //: Track();                      ReadyPushStack();                      Ldc(-1);                      DoPush();                      ReadyPushStack();                      Ldc(Operand(0));                      DoPush();                      TrackUnique(Stackpop2);                      break;                    case RegexCode.Setcount:                      //: Stack(Textpos()' Operand(0));                      //: Track();                      PushStack(_textposV);                      ReadyPushStack();                      Ldc(Operand(0));                      DoPush();                      TrackUnique(Stackpop2);                      break;                      case RegexCode.Nullcount | RegexCode.Back:                  case RegexCode.Setcount | RegexCode.Back:                      //: Stackframe(2);                      //: break Backward;                      PopDiscardStack(2);                      Back();                      break;                      case RegexCode.Branchcount:                      //: Stackframe(2);                      //: int mark = Stacked(0);                      //: int count = Stacked(1);                      //:                       //: if (count >= Operand(1) || Textpos() == mark && count >= 0)                      //: {                                   // Max loops or empty match -> straight now                      //:     Track2(mark' count);            // Save old mark' count                      //:     Advance(2);                     // Straight                      //: }                      //: else                      //: {                                   // Nonempty match -> count+loop now                      //:     Track(mark);                    // remember mark                      //:     Stack(Textpos()' count + 1);    // Make new mark' incr count                      //:     Goto(Operand(0));               // Loop                      //: }                      //: continue Forward;                      {                          LocalBuilder count = _tempV;                          LocalBuilder mark = _temp2V;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            PopStack();                          Stloc(count);                           // count -> temp                          PopStack();                          Dup();                          Stloc(mark);                            // mark -> temp2                          PushTrack(mark);                            Ldloc(_textposV);                          Bne(l1);                                // mark != textpos -> l1                          Ldloc(count);                          Ldc(0);                          Bge(l2);                                // count >= 0 && mark == textpos -> l2                            MarkLabel(l1);                          Ldloc(count);                          Ldc(Operand(1));                          Bge(l2);                                // count >= Operand(1) -> l2                            // else                          PushStack(_textposV);                          ReadyPushStack();                          Ldloc(count);                           // mark already on track                          Ldc(1);                          Add();                          DoPush();                          Track();                          Goto(Operand(0));                            // if (count >= Operand(1) || Textpos() == mark)                          MarkLabel(l2);                          PushTrack(count);                       // mark already on track                          TrackUnique2(Branchcountback2);                          break;                      }                    case RegexCode.Branchcount | RegexCode.Back:                      //: Trackframe(1);                      //: Stackframe(2);                      //: if (Stacked(1) > 0)                     // Positive -> can go straight                      //: {                      //:     Textto(Stacked(0));                 // Zap to mark                      //:     Track2(Tracked(0)' Stacked(1) - 1); // Save old mark' old count                      //:     Advance(2);                         // Straight                      //:     continue Forward;                      //: }                      //: Stack(Tracked(0)' Stacked(1) - 1);      // recall old mark' old count                      //: break Backward;                      {                            LocalBuilder count = _tempV;                          Label l1 = DefineLabel();                          PopStack();                          Ldc(1);                          Sub();                          Dup();                          Stloc(count);                          Ldc(0);                          Blt(l1);                            // if (count >= 0)                          PopStack();                          Stloc(_textposV);                          PushTrack(count);                       // Tracked(0) is alredy on the track                          TrackUnique2(Branchcountback2);                          Advance();                            // else                          MarkLabel(l1);                          ReadyReplaceStack(0);                          PopTrack();                          DoReplace();                          PushStack(count);                          Back();                          break;                      }                    case RegexCode.Branchcount | RegexCode.Back2:                      //: Trackframe(2);                      //: Stack(Tracked(0)' Tracked(1));      // Recall old mark' old count                      //: break Backward;                     // Backtrack                        PopTrack();                      Stloc(_tempV);                      ReadyPushStack();                      PopTrack();                      DoPush();                      PushStack(_tempV);                      Back();                      break;                    case RegexCode.Lazybranchcount:                      //: Stackframe(2);                      //: int mark = Stacked(0);                      //: int count = Stacked(1);                      //:                      //: if (count < 0)                      //: {                                   // Negative count -> loop now                      //:     Track2(mark);                   // Save old mark                      //:     Stack(Textpos()' count + 1);    // Make new mark' incr count                      //:     Goto(Operand(0));               // Loop                      //: }                      //: else                      //: {                                   // Nonneg count or empty match -> straight now                      //:     Track(mark' count' Textpos());  // Save mark' count' position                      //: }                      {                          LocalBuilder count = _tempV;                          LocalBuilder mark = _temp2V;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                          Label l3 = _labels[NextCodepos()];                            PopStack();                          Stloc(count);                           // count -> temp                          PopStack();                          Stloc(mark);                            // mark -> temp2                            Ldloc(count);                          Ldc(0);                          Bge(l1);                                // count >= 0 -> l1                            // if (count < 0)                          PushTrack(mark);                          PushStack(_textposV);                          ReadyPushStack();                          Ldloc(count);                          Ldc(1);                          Add();                          DoPush();                          TrackUnique2(Lazybranchcountback2);                          Goto(Operand(0));                            // else                          MarkLabel(l1);                          PushTrack(mark);                          PushTrack(count);                          PushTrack(_textposV);                          Track();                          break;                      }                    case RegexCode.Lazybranchcount | RegexCode.Back:                      //: Trackframe(3);                      //: int mark = Tracked(0);                      //: int textpos = Tracked(2);                      //: if (Tracked(1) < Operand(1) && textpos != mark)                      //: {                                       // Under limit and not empty match -> loop                      //:     Textto(Tracked(2));                 // Recall position                      //:     Stack(Textpos()' Tracked(1) + 1);   // Make new mark' incr count                      //:     Track2(Tracked(0));                 // Save old mark                      //:     Goto(Operand(0));                   // Loop                      //:     continue Forward;                      //: }                      //: else                      //: {                      //:     Stack(Tracked(0)' Tracked(1));      // Recall old mark' count                      //:     break Backward;                     // backtrack                      //: }                      {                          Label l1 = DefineLabel();                          LocalBuilder cV = _tempV;                          PopTrack();                          Stloc(_textposV);                          PopTrack();                          Dup();                          Stloc(cV);                          Ldc(Operand(1));                          Bge(l1);                                // Tracked(1) >= Operand(1) -> l1                            Ldloc(_textposV);                          TopTrack();                          Beq(l1);                                // textpos == mark -> l1                            PushStack(_textposV);                          ReadyPushStack();                          Ldloc(cV);                          Ldc(1);                          Add();                          DoPush();                          TrackUnique2(Lazybranchcountback2);                          Goto(Operand(0));                            MarkLabel(l1);                          ReadyPushStack();                          PopTrack();                          DoPush();                          PushStack(cV);                          Back();                          break;                      }                    case RegexCode.Lazybranchcount | RegexCode.Back2:                      // <                                ReadyReplaceStack(1);                      PopTrack();                      DoReplace();                      ReadyReplaceStack(0);                      TopStack();                      Ldc(1);                      Sub();                      DoReplace();                      Back();                      break;                      case RegexCode.Setjump:                      //: Stack(Trackpos()' Crawlpos());                      //: Track();                      ReadyPushStack();                      Ldthisfld(s_trackF);                      Ldlen();                      Ldloc(_trackposV);                      Sub();                      DoPush();                      ReadyPushStack();                      Ldthis();                      Callvirt(s_crawlposM);                      DoPush();                      TrackUnique(Stackpop2);                      break;                    case RegexCode.Setjump | RegexCode.Back:                      //: Stackframe(2);                      PopDiscardStack(2);                      Back();                      break;                      case RegexCode.Backjump:                      //: Stackframe(2);                      //: Trackto(Stacked(0));                      //: while (Crawlpos() != Stacked(1))                      //:     Uncapture();                      //: break Backward;                      {                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            PopStack();                          Ldthisfld(s_trackF);                          Ldlen();                          PopStack();                          Sub();                          Stloc(_trackposV);                          Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Beq(l2);                            MarkLabel(l1);                          Ldthis();                          Callvirt(s_uncaptureM);                          Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Bne(l1);                            MarkLabel(l2);                          Pop();                          Back();                          break;                      }                    case RegexCode.Forejump:                      //: Stackframe(2);                      //: Trackto(Stacked(0));                      //: Track(Stacked(1));                      PopStack();                      Stloc(_tempV);                      Ldthisfld(s_trackF);                      Ldlen();                      PopStack();                      Sub();                      Stloc(_trackposV);                      PushTrack(_tempV);                      TrackUnique(Forejumpback);                      break;                    case RegexCode.Forejump | RegexCode.Back:                      //: Trackframe(1);                      //: while (Crawlpos() != Tracked(0))                      //:     Uncapture();                      //: break Backward;                      {                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            PopTrack();                            Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Beq(l2);                            MarkLabel(l1);                          Ldthis();                          Callvirt(s_uncaptureM);                          Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Bne(l1);                            MarkLabel(l2);                          Pop();                          Back();                          break;                      }                    case RegexCode.Bol:                      //: if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                      //:     break Backward;                      {                          Label l1 = _labels[NextCodepos()];                          Ldloc(_textposV);                          Ldloc(_textbegV);                          Ble(l1);                          Leftchar();                          Ldc((int)'\n');                          BneFar(_backtrack);                          break;                      }                    case RegexCode.Eol:                      //: if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                      //:     break Backward;                      {                          Label l1 = _labels[NextCodepos()];                          Ldloc(_textposV);                          Ldloc(_textendV);                          Bge(l1);                          Rightchar();                          Ldc((int)'\n');                          BneFar(_backtrack);                          break;                      }                    case RegexCode.Boundary:                  case RegexCode.Nonboundary:                      //: if (!IsBoundary(Textpos()' _textbeg' _textend))                      //:     break Backward;                      Ldthis();                      Ldloc(_textposV);                      Ldloc(_textbegV);                      Ldloc(_textendV);                      Callvirt(s_isboundaryM);                      if (Code() == RegexCode.Boundary)                          BrfalseFar(_backtrack);                      else                          BrtrueFar(_backtrack);                      break;                    case RegexCode.ECMABoundary:                  case RegexCode.NonECMABoundary:                      //: if (!IsECMABoundary(Textpos()' _textbeg' _textend))                      //:     break Backward;                      Ldthis();                      Ldloc(_textposV);                      Ldloc(_textbegV);                      Ldloc(_textendV);                      Callvirt(s_isECMABoundaryM);                      if (Code() == RegexCode.ECMABoundary)                          BrfalseFar(_backtrack);                      else                          BrtrueFar(_backtrack);                      break;                    case RegexCode.Beginning:                      //: if (Leftchars() > 0)                      //:    break Backward;                      Ldloc(_textposV);                      Ldloc(_textbegV);                      BgtFar(_backtrack);                      break;                    case RegexCode.Start:                      //: if (Textpos() != Textstart())                      //:    break Backward;                      Ldloc(_textposV);                      Ldthisfld(s_textstartF);                      BneFar(_backtrack);                      break;                    case RegexCode.EndZ:                      //: if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                      //:    break Backward;                      Ldloc(_textposV);                      Ldloc(_textendV);                      Ldc(1);                      Sub();                      BltFar(_backtrack);                      Ldloc(_textposV);                      Ldloc(_textendV);                      Bge(_labels[NextCodepos()]);                      Rightchar();                      Ldc((int)'\n');                      BneFar(_backtrack);                      break;                    case RegexCode.End:                      //: if (Rightchars() > 0)                      //:    break Backward;                      Ldloc(_textposV);                      Ldloc(_textendV);                      BltFar(_backtrack);                      break;                    case RegexCode.One:                  case RegexCode.Notone:                  case RegexCode.Set:                  case RegexCode.One | RegexCode.Rtl:                  case RegexCode.Notone | RegexCode.Rtl:                  case RegexCode.Set | RegexCode.Rtl:                  case RegexCode.One | RegexCode.Ci:                  case RegexCode.Notone | RegexCode.Ci:                  case RegexCode.Set | RegexCode.Ci:                  case RegexCode.One | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notone | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Set | RegexCode.Ci | RegexCode.Rtl:                        //: if (Rightchars() < 1 || Rightcharnext() != (char)Operand(0))                      //:    break Backward;                      Ldloc(_textposV);                        if (!IsRtl())                      {                          Ldloc(_textendV);                          BgeFar(_backtrack);                          Rightcharnext();                      }                      else                      {                          Ldloc(_textbegV);                          BleFar(_backtrack);                          Leftcharnext();                      }                        if (IsCi())                          CallToLower();                        if (Code() == RegexCode.Set)                      {                            Ldstr(_strings[Operand(0)]);                          Call(s_charInSetM);                            BrfalseFar(_backtrack);                      }                      else                      {                          Ldc(Operand(0));                          if (Code() == RegexCode.One)                              BneFar(_backtrack);                          else                              BeqFar(_backtrack);                      }                      break;                    case RegexCode.Multi:                  case RegexCode.Multi | RegexCode.Ci:                      //                      // <                      //: String Str = _strings[Operand(0)];                      //: int i' c;                      //: if (Rightchars() < (c = Str.Length))                      //:     break Backward;                      //: for (i = 0; c > 0; i++' c--)                      //:     if (Str[i] != Rightcharnext())                      //:         break Backward;                      {                          int i;                          string str;                            str = _strings[Operand(0)];                            Ldc(str.Length);                          Ldloc(_textendV);                          Ldloc(_textposV);                          Sub();                          BgtFar(_backtrack);                            // unroll the string                          for (i = 0; i < str.Length; i++)                          {                              Ldloc(_textV);                              Ldloc(_textposV);                              if (i != 0)                              {                                  Ldc(i);                                  Add();                              }                              Callvirt(s_getcharM);                              if (IsCi())                                  CallToLower();                                Ldc((int)str[i]);                              BneFar(_backtrack);                          }                            Ldloc(_textposV);                          Ldc(str.Length);                          Add();                          Stloc(_textposV);                          break;                      }                      case RegexCode.Multi | RegexCode.Rtl:                  case RegexCode.Multi | RegexCode.Ci | RegexCode.Rtl:                      //: String Str = _strings[Operand(0)];                      //: int c;                      //: if (Leftchars() < (c = Str.Length))                      //:     break Backward;                      //: while (c > 0)                      //:     if (Str[--c] != Leftcharnext())                      //:         break Backward;                      {                          int i;                          string str;                            str = _strings[Operand(0)];                            Ldc(str.Length);                          Ldloc(_textposV);                          Ldloc(_textbegV);                          Sub();                          BgtFar(_backtrack);                            // unroll the string                          for (i = str.Length; i > 0;)                          {                              i--;                              Ldloc(_textV);                              Ldloc(_textposV);                              Ldc(str.Length - i);                              Sub();                              Callvirt(s_getcharM);                              if (IsCi())                              {                                  CallToLower();                              }                              Ldc((int)str[i]);                              BneFar(_backtrack);                          }                            Ldloc(_textposV);                          Ldc(str.Length);                          Sub();                          Stloc(_textposV);                            break;                      }                    case RegexCode.Ref:                  case RegexCode.Ref | RegexCode.Rtl:                  case RegexCode.Ref | RegexCode.Ci:                  case RegexCode.Ref | RegexCode.Ci | RegexCode.Rtl:                      //: int capnum = Operand(0);                      //: int j' c;                      //: if (!_match.IsMatched(capnum)) {                      //:     if (!RegexOptions.ECMAScript)                      //:         break Backward;                      //: } else {                      //:     if (Rightchars() < (c = _match.MatchLength(capnum)))                      //:         break Backward;                      //:     for (j = _match.MatchIndex(capnum); c > 0; j++' c--)                      //:         if (CharAt(j) != Rightcharnext())                      //:             break Backward;                      //: }                      {                          LocalBuilder lenV = _tempV;                          LocalBuilder indexV = _temp2V;                          Label l1 = DefineLabel();                            Ldthis();                          Ldc(Operand(0));                          Callvirt(s_ismatchedM);                          if ((_options & RegexOptions.ECMAScript) != 0)                              Brfalse(AdvanceLabel());                          else                              BrfalseFar(_backtrack); // !IsMatched() -> back                            Ldthis();                          Ldc(Operand(0));                          Callvirt(s_matchlengthM);                          Dup();                          Stloc(lenV);                          if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          BgtFar(_backtrack);         // Matchlength() > Rightchars() -> back                            Ldthis();                          Ldc(Operand(0));                          Callvirt(s_matchindexM);                          if (!IsRtl())                          {                              Ldloc(lenV);                              Add(IsRtl());                          }                          Stloc(indexV);              // index += len                            Ldloc(_textposV);                          Ldloc(lenV);                          Add(IsRtl());                          Stloc(_textposV);           // texpos += len                            MarkLabel(l1);                          Ldloc(lenV);                          Ldc(0);                          Ble(AdvanceLabel());                          Ldloc(_textV);                          Ldloc(indexV);                          Ldloc(lenV);                          if (IsRtl())                          {                              Ldc(1);                              Sub();                              Dup();                              Stloc(lenV);                          }                          Sub(IsRtl());                          Callvirt(s_getcharM);                          if (IsCi())                              CallToLower();                            Ldloc(_textV);                          Ldloc(_textposV);                          Ldloc(lenV);                          if (!IsRtl())                          {                              Dup();                              Ldc(1);                              Sub();                              Stloc(lenV);                          }                          Sub(IsRtl());                          Callvirt(s_getcharM);                          if (IsCi())                              CallToLower();                            Beq(l1);                          Back();                          break;                      }                      case RegexCode.Onerep:                  case RegexCode.Notonerep:                  case RegexCode.Setrep:                  case RegexCode.Onerep | RegexCode.Rtl:                  case RegexCode.Notonerep | RegexCode.Rtl:                  case RegexCode.Setrep | RegexCode.Rtl:                  case RegexCode.Onerep | RegexCode.Ci:                  case RegexCode.Notonerep | RegexCode.Ci:                  case RegexCode.Setrep | RegexCode.Ci:                  case RegexCode.Onerep | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notonerep | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Setrep | RegexCode.Ci | RegexCode.Rtl:                      //: int c = Operand(1);                      //: if (Rightchars() < c)                      //:     break Backward;                      //: char ch = (char)Operand(0);                      //: while (c-- > 0)                      //:     if (Rightcharnext() != ch)                      //:         break Backward;                      {                          LocalBuilder lenV = _tempV;                          Label l1 = DefineLabel();                            int c = Operand(1);                            if (c == 0)                              break;                            Ldc(c);                          if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          BgtFar(_backtrack);         // Matchlength() > Rightchars() -> back                            Ldloc(_textposV);                          Ldc(c);                          Add(IsRtl());                          Stloc(_textposV);           // texpos += len                            Ldc(c);                          Stloc(lenV);                            MarkLabel(l1);                          Ldloc(_textV);                          Ldloc(_textposV);                          Ldloc(lenV);                          if (IsRtl())                          {                              Ldc(1);                              Sub();                              Dup();                              Stloc(lenV);                              Add();                          }                          else                          {                              Dup();                              Ldc(1);                              Sub();                              Stloc(lenV);                              Sub();                          }                          Callvirt(s_getcharM);                          if (IsCi())                              CallToLower();                            if (Code() == RegexCode.Setrep)                          {                              Ldstr(_strings[Operand(0)]);                              Call(s_charInSetM);                                BrfalseFar(_backtrack);                          }                          else                          {                              Ldc(Operand(0));                              if (Code() == RegexCode.Onerep)                                  BneFar(_backtrack);                              else                                  BeqFar(_backtrack);                          }                          Ldloc(lenV);                          Ldc(0);                          if (Code() == RegexCode.Setrep)                              BgtFar(l1);                          else                              Bgt(l1);                          break;                      }                      case RegexCode.Oneloop:                  case RegexCode.Notoneloop:                  case RegexCode.Setloop:                  case RegexCode.Oneloop | RegexCode.Rtl:                  case RegexCode.Notoneloop | RegexCode.Rtl:                  case RegexCode.Setloop | RegexCode.Rtl:                  case RegexCode.Oneloop | RegexCode.Ci:                  case RegexCode.Notoneloop | RegexCode.Ci:                  case RegexCode.Setloop | RegexCode.Ci:                  case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl:                      //: int c = Operand(1);                      //: if (c > Rightchars())                      //:     c = Rightchars();                      //: char ch = (char)Operand(0);                      //: int i;                      //: for (i = c; i > 0; i--)                      //: {                      //:     if (Rightcharnext() != ch)                      //:     {                      //:         Leftnext();                      //:         break;                      //:     }                      //: }                      //: if (c > i)                      //:     Track(c - i - 1' Textpos() - 1);                        {                          LocalBuilder cV = _tempV;                          LocalBuilder lenV = _temp2V;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            int c = Operand(1);                            if (c == 0)                              break;                          if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          if (c != int.MaxValue)                          {                              Label l4 = DefineLabel();                              Dup();                              Ldc(c);                              Blt(l4);                              Pop();                              Ldc(c);                              MarkLabel(l4);                          }                          Dup();                          Stloc(lenV);                          Ldc(1);                          Add();                          Stloc(cV);                            MarkLabel(l1);                          Ldloc(cV);                          Ldc(1);                          Sub();                          Dup();                          Stloc(cV);                          Ldc(0);                          if (Code() == RegexCode.Setloop)                              BleFar(l2);                          else                              Ble(l2);                            if (IsRtl())                              Leftcharnext();                          else                              Rightcharnext();                          if (IsCi())                              CallToLower();                            if (Code() == RegexCode.Setloop)                          {                              Ldstr(_strings[Operand(0)]);                              Call(s_charInSetM);                                BrtrueFar(l1);                          }                          else                          {                              Ldc(Operand(0));                              if (Code() == RegexCode.Oneloop)                                  Beq(l1);                              else                                  Bne(l1);                          }                            Ldloc(_textposV);                          Ldc(1);                          Sub(IsRtl());                          Stloc(_textposV);                            MarkLabel(l2);                          Ldloc(lenV);                          Ldloc(cV);                          Ble(AdvanceLabel());                            ReadyPushTrack();                          Ldloc(lenV);                          Ldloc(cV);                          Sub();                          Ldc(1);                          Sub();                          DoPush();                            ReadyPushTrack();                          Ldloc(_textposV);                          Ldc(1);                          Sub(IsRtl());                          DoPush();                            Track();                          break;                      }                    case RegexCode.Oneloop | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Back:                  case RegexCode.Oneloop | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                      //: Trackframe(2);                      //: int i   = Tracked(0);                      //: int pos = Tracked(1);                      //: Textto(pos);                      //: if (i > 0)                      //:     Track(i - 1' pos - 1);                      //: Advance(2);                      PopTrack();                      Stloc(_textposV);                      PopTrack();                      Stloc(_tempV);                      Ldloc(_tempV);                      Ldc(0);                      BleFar(AdvanceLabel());                      ReadyPushTrack();                      Ldloc(_tempV);                      Ldc(1);                      Sub();                      DoPush();                      ReadyPushTrack();                      Ldloc(_textposV);                      Ldc(1);                      Sub(IsRtl());                      DoPush();                      Trackagain();                      Advance();                      break;                    case RegexCode.Onelazy:                  case RegexCode.Notonelazy:                  case RegexCode.Setlazy:                  case RegexCode.Onelazy | RegexCode.Rtl:                  case RegexCode.Notonelazy | RegexCode.Rtl:                  case RegexCode.Setlazy | RegexCode.Rtl:                  case RegexCode.Onelazy | RegexCode.Ci:                  case RegexCode.Notonelazy | RegexCode.Ci:                  case RegexCode.Setlazy | RegexCode.Ci:                  case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl:                      //: int c = Operand(1);                      //: if (c > Rightchars())                      //:     c = Rightchars();                      //: if (c > 0)                      //:     Track(c - 1' Textpos());                      {                          LocalBuilder cV = _tempV;                            int c = Operand(1);                            if (c == 0)                              break;                            if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          if (c != int.MaxValue)                          {                              Label l4 = DefineLabel();                              Dup();                              Ldc(c);                              Blt(l4);                              Pop();                              Ldc(c);                              MarkLabel(l4);                          }                          Dup();                          Stloc(cV);                          Ldc(0);                          Ble(AdvanceLabel());                          ReadyPushTrack();                          Ldloc(cV);                          Ldc(1);                          Sub();                          DoPush();                          PushTrack(_textposV);                          Track();                          break;                      }                    case RegexCode.Onelazy | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Back:                  case RegexCode.Onelazy | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                      //: Trackframe(2);                      //: int pos = Tracked(1);                      //: Textto(pos);                      //: if (Rightcharnext() != (char)Operand(0))                      //:     break Backward;                      //: int i = Tracked(0);                      //: if (i > 0)                      //:     Track(i - 1' pos + 1);                        PopTrack();                      Stloc(_textposV);                      PopTrack();                      Stloc(_temp2V);                        if (!IsRtl())                          Rightcharnext();                      else                          Leftcharnext();                        if (IsCi())                          CallToLower();                        if (Code() == RegexCode.Setlazy)                      {                          Ldstr(_strings[Operand(0)]);                          Call(s_charInSetM);                            BrfalseFar(_backtrack);                      }                      else                      {                          Ldc(Operand(0));                          if (Code() == RegexCode.Onelazy)                              BneFar(_backtrack);                          else                              BeqFar(_backtrack);                      }                        Ldloc(_temp2V);                      Ldc(0);                      BleFar(AdvanceLabel());                      ReadyPushTrack();                      Ldloc(_temp2V);                      Ldc(1);                      Sub();                      DoPush();                      PushTrack(_textposV);                      Trackagain();                      Advance();                      break;                    default:                      throw new NotImplementedException(SR.UnimplementedState);              }
Magic Number,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,GenerateOneCode,The following statement contains a magic number: switch (_regexopcode)              {                  case RegexCode.Stop:                      //: return;                      Mvlocfld(_textposV' s_textposF);       // update _textpos                      Ret();                      break;                    case RegexCode.Nothing:                      //: break Backward;                      Back();                      break;                    case RegexCode.Goto:                      //: Goto(Operand(0));                      Goto(Operand(0));                      break;                    case RegexCode.Testref:                      //: if (!_match.IsMatched(Operand(0)))                      //:     break Backward;                      Ldthis();                      Ldc(Operand(0));                      Callvirt(s_ismatchedM);                      BrfalseFar(_backtrack);                      break;                    case RegexCode.Lazybranch:                      //: Track(Textpos());                      PushTrack(_textposV);                      Track();                      break;                    case RegexCode.Lazybranch | RegexCode.Back:                      //: Trackframe(1);                      //: Textto(Tracked(0));                      //: Goto(Operand(0));                      PopTrack();                      Stloc(_textposV);                      Goto(Operand(0));                      break;                    case RegexCode.Nullmark:                      //: Stack(-1);                      //: Track();                      ReadyPushStack();                      Ldc(-1);                      DoPush();                      TrackUnique(Stackpop);                      break;                    case RegexCode.Setmark:                      //: Stack(Textpos());                      //: Track();                      PushStack(_textposV);                      TrackUnique(Stackpop);                      break;                    case RegexCode.Nullmark | RegexCode.Back:                  case RegexCode.Setmark | RegexCode.Back:                      //: Stackframe(1);                      //: break Backward;                      PopDiscardStack();                      Back();                      break;                    case RegexCode.Getmark:                      //: Stackframe(1);                      //: Track(Stacked(0));                      //: Textto(Stacked(0));                      ReadyPushTrack();                      PopStack();                      Dup();                      Stloc(_textposV);                      DoPush();                        Track();                      break;                    case RegexCode.Getmark | RegexCode.Back:                      //: Trackframe(1);                      //: Stack(Tracked(0));                      //: break Backward;                      ReadyPushStack();                      PopTrack();                      DoPush();                      Back();                      break;                    case RegexCode.Capturemark:                      //: if (!IsMatched(Operand(1)))                      //:     break Backward;                      //: Stackframe(1);                      //: if (Operand(1) != -1)                      //:     TransferCapture(Operand(0)' Operand(1)' Stacked(0)' Textpos());                      //: else                      //:     Capture(Operand(0)' Stacked(0)' Textpos());                      //: Track(Stacked(0));                        //: Stackframe(1);                      //: Capture(Operand(0)' Stacked(0)' Textpos());                      //: Track(Stacked(0));                        if (Operand(1) != -1)                      {                          Ldthis();                          Ldc(Operand(1));                          Callvirt(s_ismatchedM);                          BrfalseFar(_backtrack);                      }                        PopStack();                      Stloc(_tempV);                        if (Operand(1) != -1)                      {                          Ldthis();                          Ldc(Operand(0));                          Ldc(Operand(1));                          Ldloc(_tempV);                          Ldloc(_textposV);                          Callvirt(s_transferM);                      }                      else                      {                          Ldthis();                          Ldc(Operand(0));                          Ldloc(_tempV);                          Ldloc(_textposV);                          Callvirt(s_captureM);                      }                        PushTrack(_tempV);                        if (Operand(0) != -1 && Operand(1) != -1)                          TrackUnique(Capback2);                      else                          TrackUnique(Capback);                        break;                      case RegexCode.Capturemark | RegexCode.Back:                      //: Trackframe(1);                      //: Stack(Tracked(0));                      //: Uncapture();                      //: if (Operand(0) != -1 && Operand(1) != -1)                      //:     Uncapture();                      //: break Backward;                      ReadyPushStack();                      PopTrack();                      DoPush();                      Ldthis();                      Callvirt(s_uncaptureM);                      if (Operand(0) != -1 && Operand(1) != -1)                      {                          Ldthis();                          Callvirt(s_uncaptureM);                      }                      Back();                      break;                    case RegexCode.Branchmark:                      //: Stackframe(1);                      //:                       //: if (Textpos() != Stacked(0))                      //: {                                   // Nonempty match -> loop now                      //:     Track(Stacked(0)' Textpos());   // Save old mark' textpos                      //:     Stack(Textpos());               // Make new mark                      //:     Goto(Operand(0));               // Loop                      //: }                      //: else                      //: {                                   // Empty match -> straight now                      //:     Track2(Stacked(0));             // Save old mark                      //:     Advance(1);                     // Straight                      //: }                      //: continue Forward;                      {                          LocalBuilder mark = _tempV;                          Label l1 = DefineLabel();                            PopStack();                          Dup();                          Stloc(mark);                            // Stacked(0) -> temp                          PushTrack(mark);                          Ldloc(_textposV);                          Beq(l1);                                // mark == textpos -> branch                            // (matched != 0)                            PushTrack(_textposV);                          PushStack(_textposV);                          Track();                          Goto(Operand(0));                       // Goto(Operand(0))                            // else                            MarkLabel(l1);                          TrackUnique2(Branchmarkback2);                          break;                      }                    case RegexCode.Branchmark | RegexCode.Back:                      //: Trackframe(2);                      //: Stackframe(1);                      //: Textto(Tracked(1));                     // Recall position                      //: Track2(Tracked(0));                     // Save old mark                      //: Advance(1);                      PopTrack();                      Stloc(_textposV);                      PopStack();                      Pop();                      // track spot 0 is already in place                      TrackUnique2(Branchmarkback2);                      Advance();                      break;                    case RegexCode.Branchmark | RegexCode.Back2:                      //: Trackframe(1);                      //: Stack(Tracked(0));                      // Recall old mark                      //: break Backward;                         // Backtrack                      ReadyPushStack();                      PopTrack();                      DoPush();                      Back();                      break;                      case RegexCode.Lazybranchmark:                      //: StackPop();                      //: int oldMarkPos = StackPeek();                      //:                       //: if (Textpos() != oldMarkPos) {         // Nonempty match -> next loop                      //: {                                   // Nonempty match -> next loop                      //:     if (oldMarkPos != -1)                      //:         Track(Stacked(0)' Textpos());   // Save old mark' textpos                      //:     else                      //:         TrackPush(Textpos()' Textpos());                         //: }                      //: else                      //: {                                   // Empty match -> no loop                      //:     Track2(Stacked(0));             // Save old mark                      //: }                      //: Advance(1);                      //: continue Forward;                      {                          LocalBuilder mark = _tempV;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                          Label l3 = DefineLabel();                            PopStack();                          Dup();                          Stloc(mark);                      // Stacked(0) -> temp                            // if (oldMarkPos != -1)                          Ldloc(mark);                          Ldc(-1);                          Beq(l2);                                // mark == -1 -> branch                          PushTrack(mark);                          Br(l3);                          // else                          MarkLabel(l2);                          PushTrack(_textposV);                          MarkLabel(l3);                            // if (Textpos() != mark)                          Ldloc(_textposV);                          Beq(l1);                                // mark == textpos -> branch                          PushTrack(_textposV);                          Track();                          Br(AdvanceLabel());                 // Advance (near)                                                              // else                          MarkLabel(l1);                          ReadyPushStack();                   // push the current textPos on the stack.                                                               // May be ignored by 'back2' or used by a true empty match.                          Ldloc(mark);                            DoPush();                          TrackUnique2(Lazybranchmarkback2);                            break;                      }                    case RegexCode.Lazybranchmark | RegexCode.Back:                      //: Trackframe(2);                      //: Track2(Tracked(0));                     // Save old mark                      //: Stack(Textpos());                       // Make new mark                      //: Textto(Tracked(1));                     // Recall position                      //: Goto(Operand(0));                       // Loop                        PopTrack();                      Stloc(_textposV);                      PushStack(_textposV);                      TrackUnique2(Lazybranchmarkback2);                      Goto(Operand(0));                      break;                    case RegexCode.Lazybranchmark | RegexCode.Back2:                      //: Stackframe(1);                      //: Trackframe(1);                      //: Stack(Tracked(0));                  // Recall old mark                      //: break Backward;                      ReadyReplaceStack(0);                      PopTrack();                      DoReplace();                      Back();                      break;                    case RegexCode.Nullcount:                      //: Stack(-1' Operand(0));                      //: Track();                      ReadyPushStack();                      Ldc(-1);                      DoPush();                      ReadyPushStack();                      Ldc(Operand(0));                      DoPush();                      TrackUnique(Stackpop2);                      break;                    case RegexCode.Setcount:                      //: Stack(Textpos()' Operand(0));                      //: Track();                      PushStack(_textposV);                      ReadyPushStack();                      Ldc(Operand(0));                      DoPush();                      TrackUnique(Stackpop2);                      break;                      case RegexCode.Nullcount | RegexCode.Back:                  case RegexCode.Setcount | RegexCode.Back:                      //: Stackframe(2);                      //: break Backward;                      PopDiscardStack(2);                      Back();                      break;                      case RegexCode.Branchcount:                      //: Stackframe(2);                      //: int mark = Stacked(0);                      //: int count = Stacked(1);                      //:                       //: if (count >= Operand(1) || Textpos() == mark && count >= 0)                      //: {                                   // Max loops or empty match -> straight now                      //:     Track2(mark' count);            // Save old mark' count                      //:     Advance(2);                     // Straight                      //: }                      //: else                      //: {                                   // Nonempty match -> count+loop now                      //:     Track(mark);                    // remember mark                      //:     Stack(Textpos()' count + 1);    // Make new mark' incr count                      //:     Goto(Operand(0));               // Loop                      //: }                      //: continue Forward;                      {                          LocalBuilder count = _tempV;                          LocalBuilder mark = _temp2V;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            PopStack();                          Stloc(count);                           // count -> temp                          PopStack();                          Dup();                          Stloc(mark);                            // mark -> temp2                          PushTrack(mark);                            Ldloc(_textposV);                          Bne(l1);                                // mark != textpos -> l1                          Ldloc(count);                          Ldc(0);                          Bge(l2);                                // count >= 0 && mark == textpos -> l2                            MarkLabel(l1);                          Ldloc(count);                          Ldc(Operand(1));                          Bge(l2);                                // count >= Operand(1) -> l2                            // else                          PushStack(_textposV);                          ReadyPushStack();                          Ldloc(count);                           // mark already on track                          Ldc(1);                          Add();                          DoPush();                          Track();                          Goto(Operand(0));                            // if (count >= Operand(1) || Textpos() == mark)                          MarkLabel(l2);                          PushTrack(count);                       // mark already on track                          TrackUnique2(Branchcountback2);                          break;                      }                    case RegexCode.Branchcount | RegexCode.Back:                      //: Trackframe(1);                      //: Stackframe(2);                      //: if (Stacked(1) > 0)                     // Positive -> can go straight                      //: {                      //:     Textto(Stacked(0));                 // Zap to mark                      //:     Track2(Tracked(0)' Stacked(1) - 1); // Save old mark' old count                      //:     Advance(2);                         // Straight                      //:     continue Forward;                      //: }                      //: Stack(Tracked(0)' Stacked(1) - 1);      // recall old mark' old count                      //: break Backward;                      {                            LocalBuilder count = _tempV;                          Label l1 = DefineLabel();                          PopStack();                          Ldc(1);                          Sub();                          Dup();                          Stloc(count);                          Ldc(0);                          Blt(l1);                            // if (count >= 0)                          PopStack();                          Stloc(_textposV);                          PushTrack(count);                       // Tracked(0) is alredy on the track                          TrackUnique2(Branchcountback2);                          Advance();                            // else                          MarkLabel(l1);                          ReadyReplaceStack(0);                          PopTrack();                          DoReplace();                          PushStack(count);                          Back();                          break;                      }                    case RegexCode.Branchcount | RegexCode.Back2:                      //: Trackframe(2);                      //: Stack(Tracked(0)' Tracked(1));      // Recall old mark' old count                      //: break Backward;                     // Backtrack                        PopTrack();                      Stloc(_tempV);                      ReadyPushStack();                      PopTrack();                      DoPush();                      PushStack(_tempV);                      Back();                      break;                    case RegexCode.Lazybranchcount:                      //: Stackframe(2);                      //: int mark = Stacked(0);                      //: int count = Stacked(1);                      //:                      //: if (count < 0)                      //: {                                   // Negative count -> loop now                      //:     Track2(mark);                   // Save old mark                      //:     Stack(Textpos()' count + 1);    // Make new mark' incr count                      //:     Goto(Operand(0));               // Loop                      //: }                      //: else                      //: {                                   // Nonneg count or empty match -> straight now                      //:     Track(mark' count' Textpos());  // Save mark' count' position                      //: }                      {                          LocalBuilder count = _tempV;                          LocalBuilder mark = _temp2V;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                          Label l3 = _labels[NextCodepos()];                            PopStack();                          Stloc(count);                           // count -> temp                          PopStack();                          Stloc(mark);                            // mark -> temp2                            Ldloc(count);                          Ldc(0);                          Bge(l1);                                // count >= 0 -> l1                            // if (count < 0)                          PushTrack(mark);                          PushStack(_textposV);                          ReadyPushStack();                          Ldloc(count);                          Ldc(1);                          Add();                          DoPush();                          TrackUnique2(Lazybranchcountback2);                          Goto(Operand(0));                            // else                          MarkLabel(l1);                          PushTrack(mark);                          PushTrack(count);                          PushTrack(_textposV);                          Track();                          break;                      }                    case RegexCode.Lazybranchcount | RegexCode.Back:                      //: Trackframe(3);                      //: int mark = Tracked(0);                      //: int textpos = Tracked(2);                      //: if (Tracked(1) < Operand(1) && textpos != mark)                      //: {                                       // Under limit and not empty match -> loop                      //:     Textto(Tracked(2));                 // Recall position                      //:     Stack(Textpos()' Tracked(1) + 1);   // Make new mark' incr count                      //:     Track2(Tracked(0));                 // Save old mark                      //:     Goto(Operand(0));                   // Loop                      //:     continue Forward;                      //: }                      //: else                      //: {                      //:     Stack(Tracked(0)' Tracked(1));      // Recall old mark' count                      //:     break Backward;                     // backtrack                      //: }                      {                          Label l1 = DefineLabel();                          LocalBuilder cV = _tempV;                          PopTrack();                          Stloc(_textposV);                          PopTrack();                          Dup();                          Stloc(cV);                          Ldc(Operand(1));                          Bge(l1);                                // Tracked(1) >= Operand(1) -> l1                            Ldloc(_textposV);                          TopTrack();                          Beq(l1);                                // textpos == mark -> l1                            PushStack(_textposV);                          ReadyPushStack();                          Ldloc(cV);                          Ldc(1);                          Add();                          DoPush();                          TrackUnique2(Lazybranchcountback2);                          Goto(Operand(0));                            MarkLabel(l1);                          ReadyPushStack();                          PopTrack();                          DoPush();                          PushStack(cV);                          Back();                          break;                      }                    case RegexCode.Lazybranchcount | RegexCode.Back2:                      // <                                ReadyReplaceStack(1);                      PopTrack();                      DoReplace();                      ReadyReplaceStack(0);                      TopStack();                      Ldc(1);                      Sub();                      DoReplace();                      Back();                      break;                      case RegexCode.Setjump:                      //: Stack(Trackpos()' Crawlpos());                      //: Track();                      ReadyPushStack();                      Ldthisfld(s_trackF);                      Ldlen();                      Ldloc(_trackposV);                      Sub();                      DoPush();                      ReadyPushStack();                      Ldthis();                      Callvirt(s_crawlposM);                      DoPush();                      TrackUnique(Stackpop2);                      break;                    case RegexCode.Setjump | RegexCode.Back:                      //: Stackframe(2);                      PopDiscardStack(2);                      Back();                      break;                      case RegexCode.Backjump:                      //: Stackframe(2);                      //: Trackto(Stacked(0));                      //: while (Crawlpos() != Stacked(1))                      //:     Uncapture();                      //: break Backward;                      {                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            PopStack();                          Ldthisfld(s_trackF);                          Ldlen();                          PopStack();                          Sub();                          Stloc(_trackposV);                          Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Beq(l2);                            MarkLabel(l1);                          Ldthis();                          Callvirt(s_uncaptureM);                          Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Bne(l1);                            MarkLabel(l2);                          Pop();                          Back();                          break;                      }                    case RegexCode.Forejump:                      //: Stackframe(2);                      //: Trackto(Stacked(0));                      //: Track(Stacked(1));                      PopStack();                      Stloc(_tempV);                      Ldthisfld(s_trackF);                      Ldlen();                      PopStack();                      Sub();                      Stloc(_trackposV);                      PushTrack(_tempV);                      TrackUnique(Forejumpback);                      break;                    case RegexCode.Forejump | RegexCode.Back:                      //: Trackframe(1);                      //: while (Crawlpos() != Tracked(0))                      //:     Uncapture();                      //: break Backward;                      {                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            PopTrack();                            Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Beq(l2);                            MarkLabel(l1);                          Ldthis();                          Callvirt(s_uncaptureM);                          Dup();                          Ldthis();                          Callvirt(s_crawlposM);                          Bne(l1);                            MarkLabel(l2);                          Pop();                          Back();                          break;                      }                    case RegexCode.Bol:                      //: if (Leftchars() > 0 && CharAt(Textpos() - 1) != '\n')                      //:     break Backward;                      {                          Label l1 = _labels[NextCodepos()];                          Ldloc(_textposV);                          Ldloc(_textbegV);                          Ble(l1);                          Leftchar();                          Ldc((int)'\n');                          BneFar(_backtrack);                          break;                      }                    case RegexCode.Eol:                      //: if (Rightchars() > 0 && CharAt(Textpos()) != '\n')                      //:     break Backward;                      {                          Label l1 = _labels[NextCodepos()];                          Ldloc(_textposV);                          Ldloc(_textendV);                          Bge(l1);                          Rightchar();                          Ldc((int)'\n');                          BneFar(_backtrack);                          break;                      }                    case RegexCode.Boundary:                  case RegexCode.Nonboundary:                      //: if (!IsBoundary(Textpos()' _textbeg' _textend))                      //:     break Backward;                      Ldthis();                      Ldloc(_textposV);                      Ldloc(_textbegV);                      Ldloc(_textendV);                      Callvirt(s_isboundaryM);                      if (Code() == RegexCode.Boundary)                          BrfalseFar(_backtrack);                      else                          BrtrueFar(_backtrack);                      break;                    case RegexCode.ECMABoundary:                  case RegexCode.NonECMABoundary:                      //: if (!IsECMABoundary(Textpos()' _textbeg' _textend))                      //:     break Backward;                      Ldthis();                      Ldloc(_textposV);                      Ldloc(_textbegV);                      Ldloc(_textendV);                      Callvirt(s_isECMABoundaryM);                      if (Code() == RegexCode.ECMABoundary)                          BrfalseFar(_backtrack);                      else                          BrtrueFar(_backtrack);                      break;                    case RegexCode.Beginning:                      //: if (Leftchars() > 0)                      //:    break Backward;                      Ldloc(_textposV);                      Ldloc(_textbegV);                      BgtFar(_backtrack);                      break;                    case RegexCode.Start:                      //: if (Textpos() != Textstart())                      //:    break Backward;                      Ldloc(_textposV);                      Ldthisfld(s_textstartF);                      BneFar(_backtrack);                      break;                    case RegexCode.EndZ:                      //: if (Rightchars() > 1 || Rightchars() == 1 && CharAt(Textpos()) != '\n')                      //:    break Backward;                      Ldloc(_textposV);                      Ldloc(_textendV);                      Ldc(1);                      Sub();                      BltFar(_backtrack);                      Ldloc(_textposV);                      Ldloc(_textendV);                      Bge(_labels[NextCodepos()]);                      Rightchar();                      Ldc((int)'\n');                      BneFar(_backtrack);                      break;                    case RegexCode.End:                      //: if (Rightchars() > 0)                      //:    break Backward;                      Ldloc(_textposV);                      Ldloc(_textendV);                      BltFar(_backtrack);                      break;                    case RegexCode.One:                  case RegexCode.Notone:                  case RegexCode.Set:                  case RegexCode.One | RegexCode.Rtl:                  case RegexCode.Notone | RegexCode.Rtl:                  case RegexCode.Set | RegexCode.Rtl:                  case RegexCode.One | RegexCode.Ci:                  case RegexCode.Notone | RegexCode.Ci:                  case RegexCode.Set | RegexCode.Ci:                  case RegexCode.One | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notone | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Set | RegexCode.Ci | RegexCode.Rtl:                        //: if (Rightchars() < 1 || Rightcharnext() != (char)Operand(0))                      //:    break Backward;                      Ldloc(_textposV);                        if (!IsRtl())                      {                          Ldloc(_textendV);                          BgeFar(_backtrack);                          Rightcharnext();                      }                      else                      {                          Ldloc(_textbegV);                          BleFar(_backtrack);                          Leftcharnext();                      }                        if (IsCi())                          CallToLower();                        if (Code() == RegexCode.Set)                      {                            Ldstr(_strings[Operand(0)]);                          Call(s_charInSetM);                            BrfalseFar(_backtrack);                      }                      else                      {                          Ldc(Operand(0));                          if (Code() == RegexCode.One)                              BneFar(_backtrack);                          else                              BeqFar(_backtrack);                      }                      break;                    case RegexCode.Multi:                  case RegexCode.Multi | RegexCode.Ci:                      //                      // <                      //: String Str = _strings[Operand(0)];                      //: int i' c;                      //: if (Rightchars() < (c = Str.Length))                      //:     break Backward;                      //: for (i = 0; c > 0; i++' c--)                      //:     if (Str[i] != Rightcharnext())                      //:         break Backward;                      {                          int i;                          string str;                            str = _strings[Operand(0)];                            Ldc(str.Length);                          Ldloc(_textendV);                          Ldloc(_textposV);                          Sub();                          BgtFar(_backtrack);                            // unroll the string                          for (i = 0; i < str.Length; i++)                          {                              Ldloc(_textV);                              Ldloc(_textposV);                              if (i != 0)                              {                                  Ldc(i);                                  Add();                              }                              Callvirt(s_getcharM);                              if (IsCi())                                  CallToLower();                                Ldc((int)str[i]);                              BneFar(_backtrack);                          }                            Ldloc(_textposV);                          Ldc(str.Length);                          Add();                          Stloc(_textposV);                          break;                      }                      case RegexCode.Multi | RegexCode.Rtl:                  case RegexCode.Multi | RegexCode.Ci | RegexCode.Rtl:                      //: String Str = _strings[Operand(0)];                      //: int c;                      //: if (Leftchars() < (c = Str.Length))                      //:     break Backward;                      //: while (c > 0)                      //:     if (Str[--c] != Leftcharnext())                      //:         break Backward;                      {                          int i;                          string str;                            str = _strings[Operand(0)];                            Ldc(str.Length);                          Ldloc(_textposV);                          Ldloc(_textbegV);                          Sub();                          BgtFar(_backtrack);                            // unroll the string                          for (i = str.Length; i > 0;)                          {                              i--;                              Ldloc(_textV);                              Ldloc(_textposV);                              Ldc(str.Length - i);                              Sub();                              Callvirt(s_getcharM);                              if (IsCi())                              {                                  CallToLower();                              }                              Ldc((int)str[i]);                              BneFar(_backtrack);                          }                            Ldloc(_textposV);                          Ldc(str.Length);                          Sub();                          Stloc(_textposV);                            break;                      }                    case RegexCode.Ref:                  case RegexCode.Ref | RegexCode.Rtl:                  case RegexCode.Ref | RegexCode.Ci:                  case RegexCode.Ref | RegexCode.Ci | RegexCode.Rtl:                      //: int capnum = Operand(0);                      //: int j' c;                      //: if (!_match.IsMatched(capnum)) {                      //:     if (!RegexOptions.ECMAScript)                      //:         break Backward;                      //: } else {                      //:     if (Rightchars() < (c = _match.MatchLength(capnum)))                      //:         break Backward;                      //:     for (j = _match.MatchIndex(capnum); c > 0; j++' c--)                      //:         if (CharAt(j) != Rightcharnext())                      //:             break Backward;                      //: }                      {                          LocalBuilder lenV = _tempV;                          LocalBuilder indexV = _temp2V;                          Label l1 = DefineLabel();                            Ldthis();                          Ldc(Operand(0));                          Callvirt(s_ismatchedM);                          if ((_options & RegexOptions.ECMAScript) != 0)                              Brfalse(AdvanceLabel());                          else                              BrfalseFar(_backtrack); // !IsMatched() -> back                            Ldthis();                          Ldc(Operand(0));                          Callvirt(s_matchlengthM);                          Dup();                          Stloc(lenV);                          if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          BgtFar(_backtrack);         // Matchlength() > Rightchars() -> back                            Ldthis();                          Ldc(Operand(0));                          Callvirt(s_matchindexM);                          if (!IsRtl())                          {                              Ldloc(lenV);                              Add(IsRtl());                          }                          Stloc(indexV);              // index += len                            Ldloc(_textposV);                          Ldloc(lenV);                          Add(IsRtl());                          Stloc(_textposV);           // texpos += len                            MarkLabel(l1);                          Ldloc(lenV);                          Ldc(0);                          Ble(AdvanceLabel());                          Ldloc(_textV);                          Ldloc(indexV);                          Ldloc(lenV);                          if (IsRtl())                          {                              Ldc(1);                              Sub();                              Dup();                              Stloc(lenV);                          }                          Sub(IsRtl());                          Callvirt(s_getcharM);                          if (IsCi())                              CallToLower();                            Ldloc(_textV);                          Ldloc(_textposV);                          Ldloc(lenV);                          if (!IsRtl())                          {                              Dup();                              Ldc(1);                              Sub();                              Stloc(lenV);                          }                          Sub(IsRtl());                          Callvirt(s_getcharM);                          if (IsCi())                              CallToLower();                            Beq(l1);                          Back();                          break;                      }                      case RegexCode.Onerep:                  case RegexCode.Notonerep:                  case RegexCode.Setrep:                  case RegexCode.Onerep | RegexCode.Rtl:                  case RegexCode.Notonerep | RegexCode.Rtl:                  case RegexCode.Setrep | RegexCode.Rtl:                  case RegexCode.Onerep | RegexCode.Ci:                  case RegexCode.Notonerep | RegexCode.Ci:                  case RegexCode.Setrep | RegexCode.Ci:                  case RegexCode.Onerep | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notonerep | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Setrep | RegexCode.Ci | RegexCode.Rtl:                      //: int c = Operand(1);                      //: if (Rightchars() < c)                      //:     break Backward;                      //: char ch = (char)Operand(0);                      //: while (c-- > 0)                      //:     if (Rightcharnext() != ch)                      //:         break Backward;                      {                          LocalBuilder lenV = _tempV;                          Label l1 = DefineLabel();                            int c = Operand(1);                            if (c == 0)                              break;                            Ldc(c);                          if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          BgtFar(_backtrack);         // Matchlength() > Rightchars() -> back                            Ldloc(_textposV);                          Ldc(c);                          Add(IsRtl());                          Stloc(_textposV);           // texpos += len                            Ldc(c);                          Stloc(lenV);                            MarkLabel(l1);                          Ldloc(_textV);                          Ldloc(_textposV);                          Ldloc(lenV);                          if (IsRtl())                          {                              Ldc(1);                              Sub();                              Dup();                              Stloc(lenV);                              Add();                          }                          else                          {                              Dup();                              Ldc(1);                              Sub();                              Stloc(lenV);                              Sub();                          }                          Callvirt(s_getcharM);                          if (IsCi())                              CallToLower();                            if (Code() == RegexCode.Setrep)                          {                              Ldstr(_strings[Operand(0)]);                              Call(s_charInSetM);                                BrfalseFar(_backtrack);                          }                          else                          {                              Ldc(Operand(0));                              if (Code() == RegexCode.Onerep)                                  BneFar(_backtrack);                              else                                  BeqFar(_backtrack);                          }                          Ldloc(lenV);                          Ldc(0);                          if (Code() == RegexCode.Setrep)                              BgtFar(l1);                          else                              Bgt(l1);                          break;                      }                      case RegexCode.Oneloop:                  case RegexCode.Notoneloop:                  case RegexCode.Setloop:                  case RegexCode.Oneloop | RegexCode.Rtl:                  case RegexCode.Notoneloop | RegexCode.Rtl:                  case RegexCode.Setloop | RegexCode.Rtl:                  case RegexCode.Oneloop | RegexCode.Ci:                  case RegexCode.Notoneloop | RegexCode.Ci:                  case RegexCode.Setloop | RegexCode.Ci:                  case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl:                      //: int c = Operand(1);                      //: if (c > Rightchars())                      //:     c = Rightchars();                      //: char ch = (char)Operand(0);                      //: int i;                      //: for (i = c; i > 0; i--)                      //: {                      //:     if (Rightcharnext() != ch)                      //:     {                      //:         Leftnext();                      //:         break;                      //:     }                      //: }                      //: if (c > i)                      //:     Track(c - i - 1' Textpos() - 1);                        {                          LocalBuilder cV = _tempV;                          LocalBuilder lenV = _temp2V;                          Label l1 = DefineLabel();                          Label l2 = DefineLabel();                            int c = Operand(1);                            if (c == 0)                              break;                          if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          if (c != int.MaxValue)                          {                              Label l4 = DefineLabel();                              Dup();                              Ldc(c);                              Blt(l4);                              Pop();                              Ldc(c);                              MarkLabel(l4);                          }                          Dup();                          Stloc(lenV);                          Ldc(1);                          Add();                          Stloc(cV);                            MarkLabel(l1);                          Ldloc(cV);                          Ldc(1);                          Sub();                          Dup();                          Stloc(cV);                          Ldc(0);                          if (Code() == RegexCode.Setloop)                              BleFar(l2);                          else                              Ble(l2);                            if (IsRtl())                              Leftcharnext();                          else                              Rightcharnext();                          if (IsCi())                              CallToLower();                            if (Code() == RegexCode.Setloop)                          {                              Ldstr(_strings[Operand(0)]);                              Call(s_charInSetM);                                BrtrueFar(l1);                          }                          else                          {                              Ldc(Operand(0));                              if (Code() == RegexCode.Oneloop)                                  Beq(l1);                              else                                  Bne(l1);                          }                            Ldloc(_textposV);                          Ldc(1);                          Sub(IsRtl());                          Stloc(_textposV);                            MarkLabel(l2);                          Ldloc(lenV);                          Ldloc(cV);                          Ble(AdvanceLabel());                            ReadyPushTrack();                          Ldloc(lenV);                          Ldloc(cV);                          Sub();                          Ldc(1);                          Sub();                          DoPush();                            ReadyPushTrack();                          Ldloc(_textposV);                          Ldc(1);                          Sub(IsRtl());                          DoPush();                            Track();                          break;                      }                    case RegexCode.Oneloop | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Back:                  case RegexCode.Oneloop | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Oneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notoneloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setloop | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                      //: Trackframe(2);                      //: int i   = Tracked(0);                      //: int pos = Tracked(1);                      //: Textto(pos);                      //: if (i > 0)                      //:     Track(i - 1' pos - 1);                      //: Advance(2);                      PopTrack();                      Stloc(_textposV);                      PopTrack();                      Stloc(_tempV);                      Ldloc(_tempV);                      Ldc(0);                      BleFar(AdvanceLabel());                      ReadyPushTrack();                      Ldloc(_tempV);                      Ldc(1);                      Sub();                      DoPush();                      ReadyPushTrack();                      Ldloc(_textposV);                      Ldc(1);                      Sub(IsRtl());                      DoPush();                      Trackagain();                      Advance();                      break;                    case RegexCode.Onelazy:                  case RegexCode.Notonelazy:                  case RegexCode.Setlazy:                  case RegexCode.Onelazy | RegexCode.Rtl:                  case RegexCode.Notonelazy | RegexCode.Rtl:                  case RegexCode.Setlazy | RegexCode.Rtl:                  case RegexCode.Onelazy | RegexCode.Ci:                  case RegexCode.Notonelazy | RegexCode.Ci:                  case RegexCode.Setlazy | RegexCode.Ci:                  case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl:                  case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl:                      //: int c = Operand(1);                      //: if (c > Rightchars())                      //:     c = Rightchars();                      //: if (c > 0)                      //:     Track(c - 1' Textpos());                      {                          LocalBuilder cV = _tempV;                            int c = Operand(1);                            if (c == 0)                              break;                            if (!IsRtl())                          {                              Ldloc(_textendV);                              Ldloc(_textposV);                          }                          else                          {                              Ldloc(_textposV);                              Ldloc(_textbegV);                          }                          Sub();                          if (c != int.MaxValue)                          {                              Label l4 = DefineLabel();                              Dup();                              Ldc(c);                              Blt(l4);                              Pop();                              Ldc(c);                              MarkLabel(l4);                          }                          Dup();                          Stloc(cV);                          Ldc(0);                          Ble(AdvanceLabel());                          ReadyPushTrack();                          Ldloc(cV);                          Ldc(1);                          Sub();                          DoPush();                          PushTrack(_textposV);                          Track();                          break;                      }                    case RegexCode.Onelazy | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Back:                  case RegexCode.Onelazy | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Back:                  case RegexCode.Onelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Notonelazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                  case RegexCode.Setlazy | RegexCode.Ci | RegexCode.Rtl | RegexCode.Back:                      //: Trackframe(2);                      //: int pos = Tracked(1);                      //: Textto(pos);                      //: if (Rightcharnext() != (char)Operand(0))                      //:     break Backward;                      //: int i = Tracked(0);                      //: if (i > 0)                      //:     Track(i - 1' pos + 1);                        PopTrack();                      Stloc(_textposV);                      PopTrack();                      Stloc(_temp2V);                        if (!IsRtl())                          Rightcharnext();                      else                          Leftcharnext();                        if (IsCi())                          CallToLower();                        if (Code() == RegexCode.Setlazy)                      {                          Ldstr(_strings[Operand(0)]);                          Call(s_charInSetM);                            BrfalseFar(_backtrack);                      }                      else                      {                          Ldc(Operand(0));                          if (Code() == RegexCode.Onelazy)                              BneFar(_backtrack);                          else                              BeqFar(_backtrack);                      }                        Ldloc(_temp2V);                      Ldc(0);                      BleFar(AdvanceLabel());                      ReadyPushTrack();                      Ldloc(_temp2V);                      Ldc(1);                      Sub();                      DoPush();                      PushTrack(_textposV);                      Trackagain();                      Advance();                      break;                    default:                      throw new NotImplementedException(SR.UnimplementedState);              }
Duplicate Code,System.Text.RegularExpressions,RegexCompiler,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCompiler.cs,GenerateOneCode,The method contains a code clone-set at the following line numbers (starting from the method definition): ((1193' 1214)' (1348' 1369))
Missing Default,System.Text.RegularExpressions,RegexCharClass,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCharClass.cs,AddLowercaseRange,The following switch statement is missing a default case: switch (lc._lcOp)                  {                      case LowercaseSet:                          chMinT = (char)lc._data;                          chMaxT = (char)lc._data;                          break;                      case LowercaseAdd:                          unchecked                          {                              chMinT += (char)lc._data;                              chMaxT += (char)lc._data;                          }                          break;                      case LowercaseBor:                          chMinT |= (char)1;                          chMaxT |= (char)1;                          break;                      case LowercaseBad:                          chMinT += (char)(chMinT & 1);                          chMaxT += (char)(chMaxT & 1);                          break;                  }
Missing Default,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following switch statement is missing a default case: switch (opcode)              {                  case One:                  case Notone:                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                      sb.Append("Ch = ");                      sb.Append(RegexCharClass.CharDescription((char)_codes[offset + 1]));                      break;                    case Set:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("Set = ");                      sb.Append(RegexCharClass.SetDescription(_strings[_codes[offset + 1]]));                      break;                    case Multi:                      sb.Append("String = ");                      sb.Append(_strings[_codes[offset + 1]]);                      break;                    case Ref:                  case Testref:                      sb.Append("Index = ");                      sb.Append(_codes[offset + 1]);                      break;                    case Capturemark:                      sb.Append("Index = ");                      sb.Append(_codes[offset + 1]);                      if (_codes[offset + 2] != -1)                      {                          sb.Append("' Unindex = ");                          sb.Append(_codes[offset + 2]);                      }                      break;                    case Nullcount:                  case Setcount:                      sb.Append("Value = ");                      sb.Append(_codes[offset + 1]);                      break;                    case Goto:                  case Lazybranch:                  case Branchmark:                  case Lazybranchmark:                  case Branchcount:                  case Lazybranchcount:                      sb.Append("Addr = ");                      sb.Append(_codes[offset + 1]);                      break;              }
Missing Default,System.Text.RegularExpressions,RegexCode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexCode.cs,OpcodeDescription,The following switch statement is missing a default case: switch (opcode)              {                  case Onerep:                  case Notonerep:                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setrep:                  case Setloop:                  case Setlazy:                      sb.Append("' Rep = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;                    case Branchcount:                  case Lazybranchcount:                      sb.Append("' Limit = ");                      if (_codes[offset + 2] == int.MaxValue)                          sb.Append("inf");                      else                          sb.Append(_codes[offset + 2]);                      break;              }
Missing Default,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,Description,The following switch statement is missing a default case: switch (_type)              {                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case One:                  case Notone:                      ArgSb.Append("(Ch = " + RegexCharClass.CharDescription(_ch) + ")");                      break;                  case Capture:                      ArgSb.Append("(index = " + _m.ToString(CultureInfo.InvariantCulture) + "' unindex = " + _n.ToString(CultureInfo.InvariantCulture) + ")");                      break;                  case Ref:                  case Testref:                      ArgSb.Append("(index = " + _m.ToString(CultureInfo.InvariantCulture) + ")");                      break;                  case Multi:                      ArgSb.Append("(String = " + _str + ")");                      break;                  case Set:                  case Setloop:                  case Setlazy:                      ArgSb.Append("(Set = " + RegexCharClass.SetDescription(_str) + ")");                      break;              }
Missing Default,System.Text.RegularExpressions,RegexNode,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexNode.cs,Description,The following switch statement is missing a default case: switch (_type)              {                  case Oneloop:                  case Notoneloop:                  case Onelazy:                  case Notonelazy:                  case Setloop:                  case Setlazy:                  case Loop:                  case Lazyloop:                      ArgSb.Append("(Min = " + _m.ToString(CultureInfo.InvariantCulture) + "' Max = " + (_n == int.MaxValue ? "inf" : Convert.ToString(_n' CultureInfo.InvariantCulture)) + ")");                      break;              }
Missing Default,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,Escape,The following switch statement is missing a default case: switch (ch)                          {                              case '\n':                                  ch = 'n';                                  break;                              case '\r':                                  ch = 'r';                                  break;                              case '\t':                                  ch = 't';                                  break;                              case '\f':                                  ch = 'f';                                  break;                          }
Missing Default,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,ScanDollar,The following switch statement is missing a default case: switch (ch)                  {                      case '$':                          MoveRight();                          return new RegexNode(RegexNode.One' _options' '$');                        case '&':                          capnum = 0;                          break;                        case '`':                          capnum = RegexReplacement.LeftPortion;                          break;                        case '\'':                          capnum = RegexReplacement.RightPortion;                          break;                        case '+':                          capnum = RegexReplacement.LastGroup;                          break;                        case '_':                          capnum = RegexReplacement.WholeString;                          break;                  }
Missing Default,System.Text.RegularExpressions,RegexParser,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexParser.cs,CountCaptures,The following switch statement is missing a default case: switch (ch)                  {                      case '\\':                          if (CharsRight() > 0)                              MoveRight();                          break;                        case '#':                          if (UseOptionX())                          {                              MoveLeft();                              ScanBlank();                          }                          break;                        case '[':                          ScanCharClass(false' true);                          break;                        case ')':                          if (!EmptyOptionsStack())                              PopOptions();                          break;                        case '(':                          if (CharsRight() >= 2 && RightChar(1) == '#' && RightChar() == '?')                          {                              MoveLeft();                              ScanBlank();                          }                          else                          {                              PushOptions();                              if (CharsRight() > 0 && RightChar() == '?')                              {                                  // we have (?...                                  MoveRight();                                    if (CharsRight() > 1 && (RightChar() == '<' || RightChar() == '\''))                                  {                                      // named group: (?<... or (?'...                                        MoveRight();                                      ch = RightChar();                                        if (ch != '0' && RegexCharClass.IsWordChar(ch))                                      {                                          //if (_ignoreNextParen)                                          //    throw MakeException(SR.AlternationCantCapture);                                          if (ch >= '1' && ch <= '9')                                              NoteCaptureSlot(ScanDecimal()' pos);                                          else                                              NoteCaptureName(ScanCapname()' pos);                                      }                                  }                                  else                                  {                                      // (?...                                        // get the options if it's an option construct (?cimsx-cimsx...)                                      ScanOptions();                                        if (CharsRight() > 0)                                      {                                          if (RightChar() == ')')                                          {                                              // (?cimsx-cimsx)                                              MoveRight();                                              PopKeepOptions();                                          }                                          else if (RightChar() == '(')                                          {                                              // alternation construct: (?(foo)yes|no)                                              // ignore the next paren so we don't capture the condition                                              _ignoreNextParen = true;                                                // break from here so we don't reset _ignoreNextParen                                              break;                                          }                                      }                                  }                              }                              else                              {                                  if (!UseOptionN() && !_ignoreNextParen)                                      NoteCaptureSlot(_autocap++' pos);                              }                          }                            _ignoreNextParen = false;                          break;                  }
Missing Default,System.Text.RegularExpressions,RegexReplacement,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexReplacement.cs,ReplacementImpl,The following switch statement is missing a default case: switch (-Specials - 1 - r)                      { // special insertion patterns                          case LeftPortion:                              sb.Append(match.GetLeftSubstring());                              break;                          case RightPortion:                              sb.Append(match.GetRightSubstring());                              break;                          case LastGroup:                              sb.Append(match.LastGroupToStringImpl());                              break;                          case WholeString:                              sb.Append(match.GetOriginalString());                              break;                      }
Missing Default,System.Text.RegularExpressions,RegexReplacement,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexReplacement.cs,ReplacementImplRTL,The following switch statement is missing a default case: switch (-Specials - 1 - r)                      { // special insertion patterns                          case LeftPortion:                              al.Add(match.GetLeftSubstring());                              break;                          case RightPortion:                              al.Add(match.GetRightSubstring());                              break;                          case LastGroup:                              al.Add(match.LastGroupToStringImpl());                              break;                          case WholeString:                              al.Add(match.GetOriginalString());                              break;                      }
Missing Default,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The following switch statement is missing a default case: switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              Emit(RegexCode.Testref' MapCapnum(node._m));                              Emit(RegexCode.Forejump);                              break;                      }
Missing Default,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The following switch statement is missing a default case: switch (curIndex)                      {                          case 0:                              {                                  int Branchpos = PopInt();                                  PushInt(CurPos());                                  Emit(RegexCode.Goto' 0);                                  PatchJump(Branchpos' CurPos());                                  Emit(RegexCode.Forejump);                                  if (node._children.Count > 1)                                      break;                                  // else fallthrough                                  goto case 1;                              }                          case 1:                              PatchJump(PopInt()' CurPos());                              break;                      }
Missing Default,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The following switch statement is missing a default case: switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Setjump);                              Emit(RegexCode.Setmark);                              PushInt(CurPos());                              Emit(RegexCode.Lazybranch' 0);                              break;                      }
Missing Default,System.Text.RegularExpressions,RegexWriter,C:\selectedRepos\dotnet_corefx\src\System.Text.RegularExpressions\src\System\Text\RegularExpressions\RegexWriter.cs,EmitFragment,The following switch statement is missing a default case: switch (curIndex)                      {                          case 0:                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                              break;                          case 1:                              int Branchpos = PopInt();                              PushInt(CurPos());                              Emit(RegexCode.Goto' 0);                              PatchJump(Branchpos' CurPos());                              Emit(RegexCode.Getmark);                              Emit(RegexCode.Forejump);                                if (node._children.Count > 2)                                  break;                              // else fallthrough                              goto case 2;                          case 2:                              PatchJump(PopInt()' CurPos());                              break;                      }
