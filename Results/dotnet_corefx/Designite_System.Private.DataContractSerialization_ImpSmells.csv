Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ClassDataContractCriticalHelper,The method has 105 lines of code.
Long Method,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,The method has 153 lines of code.
Long Method,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The method has 181 lines of code.
Long Method,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,TryCreateBuiltInDataContract,The method has 120 lines of code.
Long Method,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadCollection,The method has 126 lines of code.
Long Method,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The method has 155 lines of code.
Long Method,System.Runtime.Serialization,CodeTypeReference,C:\selectedRepos\dotnet_corefx\src\Common\src\System\CodeDom\CodeTypeReference.cs,Initialize,The method has 134 lines of code.
Long Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,The method has 106 lines of code.
Long Method,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadNode,The method has 301 lines of code.
Long Method,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadAttributes2,The method has 141 lines of code.
Long Method,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The method has 114 lines of code.
Long Method,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadAttributes,The method has 108 lines of code.
Long Method,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The method has 181 lines of code.
Long Method,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadCollection,The method has 112 lines of code.
Long Method,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The method has 272 lines of code.
Long Method,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteStartAttribute,The method has 102 lines of code.
Long Method,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteStartElement,The method has 107 lines of code.
Long Method,System.Runtime.Serialization.Json,ReflectionJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReadSimpleDictionary,The method has 115 lines of code.
Complex Method,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsNonAttributedTypeValidForSerialization,Cyclomatic complexity of the method is 14
Complex Method,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,RequiresMemberAccessForRead,Cyclomatic complexity of the method is 16
Complex Method,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,RequiresMemberAccessForWrite,Cyclomatic complexity of the method is 13
Complex Method,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ClassDataContractCriticalHelper,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,Cyclomatic complexity of the method is 17
Complex Method,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,SetIfMembersHaveConflict,Cyclomatic complexity of the method is 11
Complex Method,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,Cyclomatic complexity of the method is 22
Complex Method,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetCollectionMethods,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,RequiresMemberAccessForRead,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,Cyclomatic complexity of the method is 13
Complex Method,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetCollectionStableName,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDefaultStableLocalName,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDataContractNameForGenericName,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ExpandGenericParameters,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalReadObject,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadValue,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadCollection,Cyclomatic complexity of the method is 12
Complex Method,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteMembers,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,EnumDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,WriteEnumValue,Cyclomatic complexity of the method is 11
Complex Method,System.Runtime.Serialization,EnumDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,ReadEnumValue,Cyclomatic complexity of the method is 12
Complex Method,System.Runtime.Serialization,EnumDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,ImportDataMembers,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportClassDataContract,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportGenericInfo,Cyclomatic complexity of the method is 13
Complex Method,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportXmlDataContract,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownCollectionData,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownXmlData,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadAndResolveUnknownXmlData,Cyclomatic complexity of the method is 13
Complex Method,System.Runtime.Serialization,CodeTypeReference,C:\selectedRepos\dotnet_corefx\src\Common\src\System\CodeDom\CodeTypeReference.cs,Initialize,Cyclomatic complexity of the method is 18
Complex Method,System.Runtime.Serialization,CodeTypeReference,C:\selectedRepos\dotnet_corefx\src\Common\src\System\CodeDom\CodeTypeReference.cs,RipOffAssemblyInformationFromTypeName,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization,ReflectionXmlClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteMembers,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UniqueId,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToInt,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToLong,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToSingle,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToDouble,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,MoveToDeclaration,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetAttributeNode,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ProcessAttributes,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IndexOfLocalName,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IndexOfLocalName,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueChunk,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,Cyclomatic complexity of the method is 12
Complex Method,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,Cyclomatic complexity of the method is 15
Complex Method,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,Cyclomatic complexity of the method is 14
Complex Method,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,LookupPrefix,Cyclomatic complexity of the method is 18
Complex Method,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,LookupAttributePrefix,Cyclomatic complexity of the method is 15
Complex Method,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,LookupNamespace,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartElement,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteChars,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteRaw,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,Cyclomatic complexity of the method is 15
Complex Method,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64AsyncImpl,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,XmlBinaryReaderSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReaderSession.cs,TryLookup,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,PriorityDictionary<K;V>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriterSession.cs,TryGetValue,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt32,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,Cyclomatic complexity of the method is 16
Complex Method,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadString,Cyclomatic complexity of the method is 12
Complex Method,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadQualifiedName,Cyclomatic complexity of the method is 12
Complex Method,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadAttributes,Cyclomatic complexity of the method is 15
Complex Method,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadComment,Cyclomatic complexity of the method is 9
Complex Method,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CheckUTF8DeclarationEncoding,Cyclomatic complexity of the method is 17
Complex Method,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,SetOutput,Cyclomatic complexity of the method is 10
Complex Method,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,Cyclomatic complexity of the method is 14
Complex Method,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEndStartElement,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,Cyclomatic complexity of the method is 12
Complex Method,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,Cyclomatic complexity of the method is 11
Complex Method,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEscapedText,Cyclomatic complexity of the method is 8
Complex Method,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,Cyclomatic complexity of the method is 8
Complex Method,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,Cyclomatic complexity of the method is 11
Complex Method,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,Cyclomatic complexity of the method is 11
Complex Method,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,Cyclomatic complexity of the method is 11
Complex Method,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,Cyclomatic complexity of the method is 11
Complex Method,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,Cyclomatic complexity of the method is 11
Complex Method,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetChars,Cyclomatic complexity of the method is 11
Complex Method,System.Runtime.Serialization.Json,DataContractJsonSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,GetKnownTypesFromContext,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization.Json,JsonDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonDataContract.cs,AddCollectionItemContractsToKnownDataContracts,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteMembers,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadValue,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadCollection,Cyclomatic complexity of the method is 12
Complex Method,System.Runtime.Serialization.Json,JsonObjectDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonObjectDataContract.cs,ParseJsonNumber,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization.Json,JsonXmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonXmlDataContract.cs,GetKnownTypesFromContext,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,Cyclomatic complexity of the method is 13
Complex Method,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadValueChunk,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,Cyclomatic complexity of the method is 8
Complex Method,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,UnescapeJsonString,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteEndElement,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteStartAttribute,Cyclomatic complexity of the method is 12
Complex Method,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteStartElement,Cyclomatic complexity of the method is 11
Complex Method,System.Runtime.Serialization.Json,ReflectionJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReadSimpleDictionary,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Serialization.Json,ReflectionJsonClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteMembers,Cyclomatic complexity of the method is 11
Long Parameter List,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,BeginMethod,The method has 5 parameters. Parameters: dynamicMethod' delegateType' methodName' argTypes' allowPrivateMemberAccess
Long Parameter List,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,ForEach,The method has 5 parameters. Parameters: local' elementType' enumeratorType' enumerator' getCurrentMethod
Long Parameter List,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The method has 5 parameters. Parameters: thisObj' methodInfo' param1' param2' param3
Long Parameter List,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The method has 6 parameters. Parameters: thisObj' methodInfo' param1' param2' param3' param4
Long Parameter List,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The method has 7 parameters. Parameters: thisObj' methodInfo' param1' param2' param3' param4' param5
Long Parameter List,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The method has 8 parameters. Parameters: thisObj' methodInfo' param1' param2' param3' param4' param5' param6
Long Parameter List,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidCallback,The method has 5 parameters. Parameters: method' parameters' attributeType' currentCallback' prevAttributeType
Long Parameter List,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CollectionDataContract,The method has 6 parameters. Parameters: type' kind' itemType' getEnumeratorMethod' addMethod' constructor
Long Parameter List,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CollectionDataContract,The method has 7 parameters. Parameters: type' kind' itemType' getEnumeratorMethod' addMethod' constructor' isConstructorCheckRequired
Long Parameter List,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The method has 5 parameters. Parameters: type' tryCreate' dataContract' itemType' constructorRequired
Long Parameter List,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,HandleIfInvalidCollection,The method has 7 parameters. Parameters: type' tryCreate' hasCollectionDataContract' createContractWithException' message' param' dataContract
Long Parameter List,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetCollectionMethods,The method has 6 parameters. Parameters: type' interfaceType' addMethodTypeArray' addMethodOnInterface' getEnumeratorMethod' addMethod
Long Parameter List,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CollectionDataContractCriticalHelper,The method has 6 parameters. Parameters: type' kind' itemType' getEnumeratorMethod' addMethod' constructor
Long Parameter List,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CollectionDataContractCriticalHelper,The method has 7 parameters. Parameters: type' kind' itemType' getEnumeratorMethod' addMethod' constructor' isConstructorCheckRequired
Long Parameter List,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,DataContractResolver,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractResolver.cs,TryResolveType,The method has 5 parameters. Parameters: type' declaredType' knownTypeResolver' typeName' typeNamespace
Long Parameter List,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,DataContractSerializer,The method has 5 parameters. Parameters: type' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' preserveObjectReferences
Long Parameter List,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,DataContractSerializer,The method has 8 parameters. Parameters: type' rootName' rootNamespace' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' preserveObjectReferences' dataContractResolver
Long Parameter List,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,Initialize,The method has 7 parameters. Parameters: type' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' preserveObjectReferences' dataContractResolver' serializeReadOnlyTypes
Long Parameter List,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,Initialize,The method has 9 parameters. Parameters: type' rootName' rootNamespace' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' preserveObjectReferences' dataContractResolver' serializeReadOnlyTypes
Long Parameter List,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadMembers,The method has 5 parameters. Parameters: classContract' requiredMembers' memberLabels' memberIndexLocal' requiredIndexLocal
Long Parameter List,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,TryWritePrimitive,The method has 7 parameters. Parameters: type' value' memberInfo' arrayItemIndex' ns' name' nameIndex
Long Parameter List,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,TryWritePrimitiveArray,The method has 5 parameters. Parameters: type' itemType' value' itemName' itemNamespace
Long Parameter List,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteStartElement,The method has 5 parameters. Parameters: type' ns' namespaceLocal' nameLocal' nameIndex
Long Parameter List,System.Runtime.Serialization,DataNode<T>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataObject.cs,AddQualifiedNameAttribute,The method has 6 parameters. Parameters: element' elementPrefix' elementName' elementNs' valueName' valueNs
Long Parameter List,System.Runtime.Serialization,CharDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,BooleanDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,SignedByteDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,UnsignedByteDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,ShortDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,UnsignedShortDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,NullPrimitiveDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,IntDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,UnsignedIntDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,LongDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,UnsignedLongDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,FloatDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,DoubleDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,DecimalDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,DateTimeDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,StringDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,ByteArrayDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,TimeSpanDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: writer' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,GuidDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: xmlWriter' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,UriDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: writer' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,QNameDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,WriteXmlElement,The method has 5 parameters. Parameters: writer' obj' context' name' ns
Long Parameter List,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The method has 5 parameters. Parameters: clrType' schemas' stableName' xsdType' hasRoot
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteRootElement,The method has 5 parameters. Parameters: writer' contract' name' ns' needsContractNsAtRoot
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs,XmlObjectSerializerContext,The method has 5 parameters. Parameters: serializer' maxItemsInObjectGraph' streamingContext' ignoreExtensionDataObject' dataContractResolver
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,InternalSerializeReference,The method has 6 parameters. Parameters: xmlWriter' obj' isDeclaredType' writeXsiType' declaredTypeID' declaredTypeHandle
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,InternalSerialize,The method has 6 parameters. Parameters: xmlWriter' obj' isDeclaredType' writeXsiType' declaredTypeID' declaredTypeHandle
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,SerializeWithXsiTypeAtTopLevel,The method has 5 parameters. Parameters: dataContract' xmlWriter' obj' originalDeclaredTypeHandle' graphType
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,SerializeWithXsiType,The method has 7 parameters. Parameters: xmlWriter' obj' objectTypeHandle' objectType' declaredTypeID' declaredTypeHandle' declaredType
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,SerializeAndVerifyType,The method has 6 parameters. Parameters: dataContract' xmlWriter' obj' verifyKnownType' declaredTypeHandle' declaredType
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteNull,The method has 5 parameters. Parameters: xmlWriter' memberType' isMemberTypeSerializable' name' ns
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The method has 5 parameters. Parameters: xmlReader' id' declaredTypeHandle' name' ns
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The method has 5 parameters. Parameters: xmlReader' declaredType' dataContract' name' ns
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,TryHandleNullOrRef,The method has 5 parameters. Parameters: reader' declaredType' name' ns' retObj
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,GetMemberIndex,The method has 5 parameters. Parameters: xmlReader' memberNames' memberNamespaces' memberIndex' extensionData
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,GetMemberIndexWithRequiredMembers,The method has 6 parameters. Parameters: xmlReader' memberNames' memberNamespaces' memberIndex' requiredIndex' extensionData
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ParseQualifiedName,The method has 5 parameters. Parameters: qname' xmlReader' name' ns' prefix
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,CreateWrapperXmlElement,The method has 6 parameters. Parameters: document' xmlAttributes' xmlChildNodes' prefix' localName' ns
Long Parameter List,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,TryReadBooleanArray,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,TryReadDateTimeArray,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,TryReadDecimalArray,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,TryReadInt32Array,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,TryReadInt64Array,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,TryReadSingleArray,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,TryReadDoubleArray,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization,XmlWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlWriterDelegator.cs,WriteAttributeQualifiedName,The method has 5 parameters. Parameters: attrPrefix' attrName' attrNs' name' ns
Long Parameter List,System.Runtime.Serialization,XmlWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlWriterDelegator.cs,WriteAttributeQualifiedName,The method has 5 parameters. Parameters: attrPrefix' attrName' attrNs' name' ns
Long Parameter List,System.Runtime.Serialization,KnownTypeDataContractResolver,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\KnownTypeDataContractResolver.cs,TryResolveType,The method has 5 parameters. Parameters: type' declaredType' knownTypeResolver' typeName' typeNamespace
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserialize,The method has 5 parameters. Parameters: xmlReader' declaredTypeID' declaredTypeHandle' name' ns
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserialize,The method has 5 parameters. Parameters: xmlReader' declaredType' dataContract' name' ns
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeInSharedTypeMode,The method has 5 parameters. Parameters: xmlReader' declaredTypeID' declaredType' name' ns
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeWithSurrogate,The method has 5 parameters. Parameters: xmlReader' declaredType' surrogateDataContract' name' ns
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,InternalSerialize,The method has 6 parameters. Parameters: xmlWriter' obj' isDeclaredType' writeXsiType' declaredTypeID' declaredTypeHandle
Long Parameter List,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,InternalSerializeWithSurrogate,The method has 6 parameters. Parameters: xmlWriter' obj' isDeclaredType' writeXsiType' declaredTypeID' declaredTypeHandle
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadClass,The method has 5 parameters. Parameters: xmlReader' context' memberNames' memberNamespaces' classContract
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadGetOnlyCollection,The method has 5 parameters. Parameters: xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadCollection,The method has 5 parameters. Parameters: xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadCollectionCore,The method has 5 parameters. Parameters: xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReadCollectionItems,The method has 7 parameters. Parameters: xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract' resultCollection' isReadOnlyCollection
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadMembers,The method has 6 parameters. Parameters: xmlReader' context' memberNames' memberNamespaces' classContract' obj
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadMember,The method has 6 parameters. Parameters: xmlReader' context' classContract' obj' memberIndex' members
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadValue,The method has 6 parameters. Parameters: xmlReader' context' type' name' ns' primitiveContractForOriginalType
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReadItemOfPrimitiveType,The method has 7 parameters. Parameters: xmlReader' context' type' name' ns' primitiveContract' nullables
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionInternalDeserialize,The method has 6 parameters. Parameters: xmlReader' context' collectionContract' type' name' ns
Long Parameter List,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionTryReadPrimitiveArray,The method has 8 parameters. Parameters: xmlReader' context' collectionItemName' collectionItemNamespace' type' itemType' arraySize' resultArray
Long Parameter List,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteClass,The method has 5 parameters. Parameters: xmlWriter' obj' context' classContract' memberNames
Long Parameter List,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteValue,The method has 6 parameters. Parameters: xmlWriter' context' type' value' writeXsiType' primitiveContractForParamType
Long Parameter List,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteMembers,The method has 7 parameters. Parameters: xmlWriter' obj' context' classContract' derivedMostClassContract' childElementIndex' memberNames
Long Parameter List,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionTryWritePrimitive,The method has 7 parameters. Parameters: xmlWriter' context' type' value' name' ns' primitiveContract
Long Parameter List,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionInternalSerialize,The method has 7 parameters. Parameters: xmlWriter' context' obj' isDeclaredType' writeXsiType' memberType' isNullableOfT
Long Parameter List,System.Runtime.Serialization,ReflectionXmlCollectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatReader.cs,ReflectionReadCollection,The method has 5 parameters. Parameters: xmlReader' context' itemName' itemNamespace' collectionContract
Long Parameter List,System.Runtime.Serialization,ReflectionXmlCollectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatReader.cs,ReflectionReadGetOnlyCollection,The method has 5 parameters. Parameters: xmlReader' context' itemName' itemNs' collectionContract
Long Parameter List,System.Runtime.Serialization,ReflectionXmlReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatReader.cs,ReflectionReadMembers,The method has 6 parameters. Parameters: xmlReader' context' memberNames' memberNamespaces' classContract' obj
Long Parameter List,System.Runtime.Serialization,ReflectionXmlFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionTryWritePrimitiveArray,The method has 6 parameters. Parameters: xmlWriter' obj' type' itemType' collectionItemName' itemNamespace
Long Parameter List,System.Runtime.Serialization,ReflectionXmlClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteMembers,The method has 7 parameters. Parameters: xmlWriter' obj' context' classContract' derivedMostClassContract' childElementIndex' emptyStringArray
Long Parameter List,System.Runtime.Serialization,ReflectionXmlClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteStartElement,The method has 6 parameters. Parameters: xmlWriter' type' ns' namespaceLocal' nameLocal' nameIndex
Long Parameter List,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 5 parameters. Parameters: writer' prefix' localName' namespaceUri' reader
Long Parameter List,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,BooleanArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,BooleanArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,BooleanArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,BooleanArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int16ArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int16ArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int16ArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int16ArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int32ArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int32ArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int32ArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int32ArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int64ArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int64ArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int64ArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,Int64ArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,SingleArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,SingleArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,SingleArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,SingleArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DoubleArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DoubleArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DoubleArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DoubleArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DecimalArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DecimalArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DecimalArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DecimalArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DateTimeArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DateTimeArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DateTimeArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,DateTimeArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,GuidArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,GuidArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,GuidArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,GuidArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,TimeSpanArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,TimeSpanArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,TimeSpanArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,TimeSpanArrayHelperWithDictionaryString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryAsyncCheckWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryAsyncCheckWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,CheckDeclAttribute,The method has 5 parameters. Parameters: index' localName' value' checkLower' valueSR
Long Parameter List,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,The method has 7 parameters. Parameters: encoding' byteBlock' charBlock' buffer' offset' byteCount' readContent
Long Parameter List,System.Xml,XmlNode,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,XmlNode,The method has 8 parameters. Parameters: nodeType' prefix' localName' value' nodeFlags' readState' attributeTextNode' depthDelta
Long Parameter List,System.Xml,XmlTextNode,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,XmlTextNode,The method has 8 parameters. Parameters: nodeType' prefix' localName' value' nodeFlags' readState' attributeTextNode' depthDelta
Long Parameter List,System.Xml,IXmlBinaryReaderInitializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The method has 7 parameters. Parameters: buffer' offset' count' dictionary' quotas' session' onClose
Long Parameter List,System.Xml,IXmlBinaryReaderInitializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The method has 5 parameters. Parameters: stream' dictionary' quotas' session' onClose
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The method has 7 parameters. Parameters: buffer' offset' count' dictionary' quotas' session' onClose
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The method has 5 parameters. Parameters: stream' dictionary' quotas' session' onClose
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteBase64Text,The method has 5 parameters. Parameters: trailBytes' trailByteCount' base64Buffer' base64Offset' base64Count
Long Parameter List,System.Xml,AttributeValue,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteBase64Text,The method has 5 parameters. Parameters: trailBytes' trailByteCount' buffer' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteArray,The method has 7 parameters. Parameters: prefix' localName' namespaceUri' nodeType' count' array' arrayMax
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteArray,The method has 7 parameters. Parameters: prefix' localName' namespaceUri' nodeType' count' array' arrayMax
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,SetBuffer,The method has 5 parameters. Parameters: buffer' offset' count' dictionary' session
Long Parameter List,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,SetBuffer,The method has 6 parameters. Parameters: stream' buffer' offset' count' dictionary' session
Long Parameter List,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,Equals2,The method has 5 parameters. Parameters: offset1' length1' bufferReader2' offset2' length2
Long Parameter List,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The method has 5 parameters. Parameters: buffer' offset' count' chars' charOffset
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,CreateMtomWriter,The method has 8 parameters. Parameters: stream' encoding' maxSizeInBytes' startInfo' boundary' startUri' writeMessageHeaders' ownsStream
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArrayNode,The method has 5 parameters. Parameters: reader' prefix' localName' namespaceUri' type
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArrayNode,The method has 5 parameters. Parameters: reader' prefix' localName' namespaceUri' type
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateBinaryReader,The method has 5 parameters. Parameters: buffer' offset' count' dictionary' quotas
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateBinaryReader,The method has 6 parameters. Parameters: buffer' offset' count' dictionary' quotas' session
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateBinaryReader,The method has 7 parameters. Parameters: buffer' offset' count' dictionary' quotas' session' onClose
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateBinaryReader,The method has 5 parameters. Parameters: stream' dictionary' quotas' session' onClose
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateTextReader,The method has 6 parameters. Parameters: buffer' offset' count' encoding' quotas' onClose
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateMtomReader,The method has 6 parameters. Parameters: stream' encodings' contentType' quotas' maxBufferSize' onClose
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateMtomReader,The method has 5 parameters. Parameters: buffer' offset' count' encoding' quotas
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateMtomReader,The method has 5 parameters. Parameters: buffer' offset' count' encodings' quotas
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateMtomReader,The method has 6 parameters. Parameters: buffer' offset' count' encodings' contentType' quotas
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CreateMtomReader,The method has 8 parameters. Parameters: buffer' offset' count' encodings' contentType' quotas' maxBufferSize' onClose
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The method has 5 parameters. Parameters: localName' namespaceUri' array' offset' count
Long Parameter List,System.Xml,XmlDictionaryReaderQuotas,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReaderQuotas.cs,XmlDictionaryReaderQuotas,The method has 6 parameters. Parameters: maxDepth' maxStringContentLength' maxArrayLength' maxBytesPerRead' maxNameTableCharCount' modifiedQuotas
Long Parameter List,System.Xml,XmlExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlExceptionHelper.cs,ThrowXmlException,The method has 5 parameters. Parameters: reader' res' arg1' arg2' arg3
Long Parameter List,System.Xml,XmlExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlExceptionHelper.cs,ThrowTagMismatch,The method has 5 parameters. Parameters: reader' expectedPrefix' expectedLocalName' foundPrefix' foundLocalName
Long Parameter List,System.Xml,XmlExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlExceptionHelper.cs,ThrowDuplicateAttribute,The method has 5 parameters. Parameters: reader' prefix1' prefix2' localName' ns
Long Parameter List,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteStartElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteEndElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteXmlnsAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' nsBuffer' nsOffset' nsLength
Long Parameter List,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteStartAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteBase64Text,The method has 5 parameters. Parameters: trailBuffer' trailCount' buffer' offset' count
Long Parameter List,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteBase64TextAsync,The method has 5 parameters. Parameters: trailBuffer' trailCount' buffer' offset' count
Long Parameter List,System.Xml,XmlNullNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteStartElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlNullNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteEndElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlNullNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteXmlnsAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' nsBuffer' nsOffset' nsLength
Long Parameter List,System.Xml,XmlNullNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteStartAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlNullNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteBase64Text,The method has 5 parameters. Parameters: trailBuffer' trailCount' buffer' offset' count
Long Parameter List,System.Xml,IXmlTextReaderInitializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,SetInput,The method has 6 parameters. Parameters: buffer' offset' count' encoding' quotas' onClose
Long Parameter List,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,SetInput,The method has 6 parameters. Parameters: buffer' offset' count' encoding' quotas' onClose
Long Parameter List,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEndElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteXmlnsAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' nsBuffer' nsOffset' nsLength
Long Parameter List,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteBase64Text,The method has 5 parameters. Parameters: trailBytes' trailByteCount' buffer' offset' count
Long Parameter List,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteBase64TextAsync,The method has 5 parameters. Parameters: trailBytes' trailByteCount' buffer' offset' count
Long Parameter List,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The method has 6 parameters. Parameters: b1' b2' b3' b4' notOutOfBand' preserve
Long Parameter List,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CheckUTF8DeclarationEncoding,The method has 5 parameters. Parameters: buffer' offset' count' e' expectedEnc
Long Parameter List,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' nsBuffer' nsOffset' nsLength
Long Parameter List,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Compare,The method has 5 parameters. Parameters: buffer' offset1' length1' offset2' length2
Long Parameter List,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Compare,The method has 6 parameters. Parameters: buffer1' offset1' length1' buffer2' offset2' length2
Long Parameter List,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Equals,The method has 6 parameters. Parameters: buffer1' offset1' length1' buffer2' offset2' length2
Long Parameter List,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteStartElement,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteXmlnsAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' nsBuffer' nsOffset' nsLength
Long Parameter List,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteStartAttribute,The method has 6 parameters. Parameters: prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength
Long Parameter List,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The method has 5 parameters. Parameters: trailBytes' trailByteCount' buffer' offset' count
Long Parameter List,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The method has 5 parameters. Parameters: chars' charIndex' charCount' bytes' byteIndex
Long Parameter List,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The method has 5 parameters. Parameters: chars' charIndex' charCount' bytes' byteIndex
Long Parameter List,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The method has 5 parameters. Parameters: chars' charIndex' charCount' bytes' byteIndex
Long Parameter List,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetChars,The method has 5 parameters. Parameters: bytes' byteIndex' byteCount' chars' charIndex
Long Parameter List,System.Runtime.Serialization.Json,DataContractJsonSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,WriteJsonValue,The method has 5 parameters. Parameters: contract' writer' graph' context' declaredTypeHandle
Long Parameter List,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,DataContractJsonSerializerImpl,The method has 6 parameters. Parameters: type' rootName' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' alwaysEmitTypeInformation
Long Parameter List,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,WriteJsonValue,The method has 5 parameters. Parameters: contract' writer' graph' context' declaredTypeHandle
Long Parameter List,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,Initialize,The method has 8 parameters. Parameters: type' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' emitTypeInformation' serializeReadOnlyTypes' dateTimeFormat' useSimpleDictionaryFormat
Long Parameter List,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,Initialize,The method has 9 parameters. Parameters: type' rootName' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' emitTypeInformation' serializeReadOnlyTypes' dateTimeFormat' useSimpleDictionaryFormat
Long Parameter List,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,TryWritePrimitive,The method has 6 parameters. Parameters: type' value' memberInfo' arrayItemIndex' name' nameIndex
Long Parameter List,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadMembers,The method has 5 parameters. Parameters: classContract' expectedElements' memberLabels' throwDuplicateMemberLabel' memberIndexLocal
Long Parameter List,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,TryReadDateTimeArray,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,TryReadJsonDateTimeArray,The method has 5 parameters. Parameters: context' itemName' itemNamespace' arrayLength' array
Long Parameter List,System.Runtime.Serialization.Json,DateTimeArrayJsonHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,DateTimeArrayJsonHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,SerializeWithXsiType,The method has 7 parameters. Parameters: xmlWriter' obj' objectTypeHandle' objectType' declaredTypeID' declaredTypeHandle' declaredType
Long Parameter List,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,SerializeWithXsiTypeAtTopLevel,The method has 5 parameters. Parameters: dataContract' xmlWriter' obj' originalDeclaredTypeHandle' graphType
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,SetInput,The method has 6 parameters. Parameters: buffer' offset' count' encoding' quotas' onClose
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteArray,The method has 6 parameters. Parameters: prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,JsonReaderWriterFactory,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderWriterFactory.cs,CreateJsonReader,The method has 6 parameters. Parameters: buffer' offset' count' encoding' quotas' onClose
Long Parameter List,System.Runtime.Serialization.Json,JsonReaderWriterFactory,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderWriterFactory.cs,CreateJsonWriter,The method has 5 parameters. Parameters: stream' encoding' ownsStream' indent' indentChars
Long Parameter List,System.Runtime.Serialization.Json,IXmlJsonReaderInitializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\IXmlJsonReaderInitializer.cs,SetInput,The method has 6 parameters. Parameters: buffer' offset' count' encoding' quotas' onClose
Long Parameter List,System.Runtime.Serialization.Json,ByteArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ByteArrayHelperWithString.cs,ReadArray,The method has 6 parameters. Parameters: reader' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,ByteArrayHelperWithString,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ByteArrayHelperWithString.cs,WriteArray,The method has 7 parameters. Parameters: writer' prefix' localName' namespaceUri' array' offset' count
Long Parameter List,System.Runtime.Serialization.Json,ReflectionJsonCollectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReflectionReadCollection,The method has 5 parameters. Parameters: xmlReader' context' emptyDictionaryString' itemName' collectionContract
Long Parameter List,System.Runtime.Serialization.Json,ReflectionJsonCollectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReflectionReadGetOnlyCollection,The method has 5 parameters. Parameters: xmlReader' context' emptyDictionaryString' itemName' collectionContract
Long Parameter List,System.Runtime.Serialization.Json,ReflectionJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReflectionReadMembers,The method has 6 parameters. Parameters: xmlReader' context' memberNames' memberNamespaces' classContract' obj
Long Parameter List,System.Runtime.Serialization.Json,ReflectionJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReadSimpleDictionary,The method has 5 parameters. Parameters: xmlReader' context' collectionContract' keyValueType' dictionary
Long Parameter List,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteClass,The method has 5 parameters. Parameters: xmlWriter' obj' context' classContract' memberNames
Long Parameter List,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionTryWritePrimitiveArray,The method has 5 parameters. Parameters: jsonWriter' obj' underlyingType' itemType' collectionItemName
Long Parameter List,System.Runtime.Serialization.Json,ReflectionJsonClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteMembers,The method has 7 parameters. Parameters: xmlWriter' obj' context' classContract' derivedMostClassContract' childElementIndex' memberNames
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH is 39.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW is 35.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT is 39.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_INSUFFICIENTEXECUTIONSTACK is 32.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_LOADING_REFERENCE_ASSEMBLY is 32.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_MISSINGSATELLITEASSEMBLY is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_MODULE_HASH_CHECK_FAILED is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_WAITHANDLECANNOTBEOPENED is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_CODE_DOWNLOAD_DISABLED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_HOST_GAC_ASM_MISMATCH is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_INVALID_PRIVATE_ASM_LOCATION is 37.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_PRIVATE_ASM_DISALLOWED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_SIGNATURE_CHECK_FAILED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter SECURITY_E_INCOMPATIBLE_EVIDENCE is 32.
Long Identifier,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,CreateChildElementNamespaces,The length of the parameter baseChildElementNamespaceCount is 30.
Long Identifier,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CollectionDataContract,The length of the parameter invalidCollectionInSharedContractMessage is 40.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CollectionDataContractCriticalHelper,The length of the parameter invalidCollectionInSharedContractMessage is 40.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IncrementCollectionCount,The length of the parameter buildIncrementCollectionCountDelegate is 37.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IncrementCollectionCount,The length of the parameter buildIncrementCollectionCountDelegate is 37.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetEnumeratorForCollection,The length of the parameter buildCreateGenericDictionaryEnumerator is 38.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,,The length of the parameter _invalidCollectionInSharedContractMessage is 41.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,,The length of the parameter _xmlFormatGetOnlyCollectionReaderDelegate is 41.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,,The length of the parameter _incrementCollectionCountDelegate is 33.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,,The length of the parameter s_buildIncrementCollectionCountDelegateMethod is 45.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,,The length of the parameter _createGenericDictionaryEnumeratorDelegate is 42.
Long Identifier,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,,The length of the parameter s_buildCreateGenericDictionaryEnumerator is 40.
Long Identifier,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDefaultStableLocalName,The length of the parameter parametersFromBuiltInNamespaces is 31.
Long Identifier,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDefaultStableName,The length of the parameter parametersFromBuiltInNamespaces is 31.
Long Identifier,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,IsAssemblyFriendOfSerialization,The length of the parameter internalsVisibleAttributeAssemblyName is 37.
Long Identifier,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,,The length of the parameter ISerializableFactoryTypeLocalName is 33.
Long Identifier,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,SurrogateToDataContractType,The length of the parameter serializationSurrogateProvider is 30.
Long Identifier,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,GetSurrogatedType,The length of the parameter serializationSurrogateProvider is 30.
Long Identifier,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,,The length of the parameter _serializationSurrogateProvider is 31.
Long Identifier,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the parameter incrementCollectionCountMethod is 30.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfIDeserializationCallback is 32.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfXmlFormatClassWriterDelegate is 36.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfXmlFormatCollectionWriterDelegate is 41.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfXmlFormatClassReaderDelegate is 36.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfXmlFormatCollectionReaderDelegate is 41.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfXmlFormatGetOnlyCollectionReaderDelegate is 48.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfCollectionDataContractAttribute is 39.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfOptionalFieldAttribute is 30.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfOnSerializingAttribute is 30.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfOnDeserializingAttribute is 32.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfOnDeserializedAttribute is 31.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfXmlSchemaProviderAttribute is 34.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_typeOfGenericDictionaryEnumerator is 35.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter s_dataContractXsdBaseNamespaceUri is 33.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter FullSRSInternalsVisiblePattern is 30.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter ExtensionDataSetExplicitMethod is 30.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter ExtensionDataObjectPropertyName is 31.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter GenericParameterNestedLevelAttribute is 36.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter SafeSerializationManagerNamespace is 33.
Long Identifier,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,,The length of the parameter ISerializableFactoryTypeLocalName is 33.
Long Identifier,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportISerializableDataContract,The length of the parameter iSerializableFactoryTypeAttribute is 33.
Long Identifier,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,,The length of the parameter s_enumerationValueAnnotationName is 32.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_getUninitializedObjectMethod is 30.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_storeCollectionMemberInfoMethod is 33.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_resetCollectionMemberInfoMethod is 33.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_storeIsGetOnlyCollectionMethod is 32.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_throwNullValueReturnedForGetOnlyCollectionExceptionMethod is 59.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_throwArrayExceededSizeExceptionMethod is 39.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_getMemberIndexWithRequiredMembersMethod is 41.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_throwRequiredMemberMissingExceptionMethod is 43.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_createSerializationExceptionMethod is 36.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_createUnexpectedStateExceptionMethod is 38.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_internalSerializeReferenceMethod is 34.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_incrementCollectionCountMethod is 32.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_incrementCollectionCountGenericMethod is 39.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_throwRequiredMemberMustBeEmittedMethod is 40.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_isMemberTypeSameAsMemberValue is 31.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_extensionDataSetExplicitMethodInfo is 36.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_childElementNamespacesProperty is 32.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_childElementNamespaceProperty is 31.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_getDateTimeOffsetAdapterMethod is 32.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_throwInvalidDataContractExceptionMethod is 41.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_serializeReadOnlyTypesProperty is 32.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_classSerializationExceptionMessageProperty is 44.
Long Identifier,System.Runtime.Serialization,XmlFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlFormatGeneratorStatics.cs,,The length of the parameter s_collectionSerializationExceptionMessageProperty is 49.
Long Identifier,System.Runtime.Serialization,XmlObjectSerializerContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs,,The length of the parameter _isSerializerKnownDataContractsSetExplicit is 42.
Long Identifier,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,,The length of the parameter _serializationSurrogateProvider is 31.
Long Identifier,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,,The length of the parameter _serializationSurrogateProvider is 31.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_getRevisedItemContractMethod is 30.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_getUninitializedObjectMethod is 30.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_throwDuplicateMemberExceptionMethod is 37.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_throwMissingRequiredMembersMethod is 35.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_useSimpleDictionaryFormatReadProperty is 39.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_useSimpleDictionaryFormatWriteProperty is 40.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_writeJsonISerializableMethod is 30.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_writeJsonNameWithMappingMethod is 32.
Long Identifier,System.Runtime.Serialization,JsonFormatGeneratorStatics,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatGeneratorStatics.cs,,The length of the parameter s_writeStartElementStringMethod is 31.
Long Identifier,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReadCollectionItems,The length of the parameter getCollectionSetItemDelegateMethod is 34.
Long Identifier,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadValue,The length of the parameter primitiveContractForOriginalType is 32.
Long Identifier,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,,The length of the parameter s_getCollectionSetItemDelegateMethod is 36.
Long Identifier,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,,The length of the parameter s_objectToKeyValuePairGetValue is 30.
Long Identifier,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,,The length of the parameter s_defaultIsEscapedAttributeChar is 31.
Long Identifier,System.Xml,IFragmentCapableXmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\IFragmentCapableXmlDictionaryWriter.cs,StartFragment,The length of the parameter generateSelfContainedTextFragment is 33.
Long Identifier,System.Runtime.Serialization.Json,JsonByteArrayDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonByteArrayDataContract.cs,JsonByteArrayDataContract,The length of the parameter traditionalByteArrayDataContract is 32.
Long Identifier,System.Runtime.Serialization.Json,JsonCollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonCollectionDataContract.cs,,The length of the parameter _jsonFormatGetOnlyReaderDelegate is 32.
Long Identifier,System.Runtime.Serialization.Json,JsonCollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonCollectionDataContract.cs,,The length of the parameter _traditionalCollectionDataContract is 34.
Long Identifier,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the parameter incrementCollectionCountMethod is 30.
Long Identifier,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the parameter genericDictionaryValueProperty is 30.
Long Identifier,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadMembers,The length of the parameter throwMissingRequiredMembersLabel is 32.
Long Identifier,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,CheckRequiredElements,The length of the parameter throwMissingRequiredMembersLabel is 32.
Long Identifier,System.Runtime.Serialization.Json,JsonGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonGlobals.cs,,The length of the parameter DataContractXsdBaseNamespaceLength is 34.
Long Identifier,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,,The length of the parameter _expectingFirstElementInNonPrimitiveChild is 41.
Long Identifier,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,,The length of the parameter _isWritingXmlnsAttributeDefaultNs is 33.
Long Statement,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,ReadId,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.InvalidXsIdDefinition' Id))); " is 178.
Long Statement,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,ReadRef,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.InvalidXsRefDefinition' Ref))); " is 180.
Long Statement,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,ReadArraySize,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.InvalidSizeDefinition' ArraySZSize))); " is 187.
Long Statement,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,ReadXsiType,The length of the statement  "                XmlObjectSerializerReadContext.ParseQualifiedName(xsiTypeString' reader' out XsiTypeName' out XsiTypeNamespace' out XsiTypePrefix); " is 131.
Long Statement,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,ReadFactoryType,The length of the statement  "                XmlObjectSerializerReadContext.ParseQualifiedName(factoryTypeString' reader' out FactoryTypeName' out FactoryTypeNamespace' out FactoryTypePrefix); " is 147.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,BeginMethod,The length of the statement  "            this.methodBuilder = typeBuilder.DefineMethod(methodName' MethodAttributes.Public|MethodAttributes.Static' returnType' argTypes); " is 129.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,VerifyParameterCount,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ParameterCountMismatch' methodInfo.Name' methodInfo.GetParameters().Length' expectedCount))); " is 213.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,LoadMember,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.NoGetMethodForProperty' property.DeclaringType' property))); " is 209.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,LoadMember,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.CannotLoadMemberType' "Unknown"' memberInfo.DeclaringType' memberInfo.Name))); " is 227.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,StoreMember,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.NoSetMethodForProperty' property.DeclaringType' property))); " is 209.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,StoreMember,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.CannotLoadMemberType' "Unknown"))); " is 184.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Store,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.CanOnlyStoreIntoArgOrLocGot0' DataContract.GetClrTypeFullName(var.GetType())))); " is 229.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.CharIsInvalidPrimitive))); " is 152.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.UnknownConstantType' DataContract.GetClrTypeFullName(valueType)))); " is 216.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldelem,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ArrayTypeIsNotSupported' DataContract.GetClrTypeFullName(arrayElementType)))); " is 227.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Stelem,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ArrayTypeIsNotSupported' DataContract.GetClrTypeFullName(arrayElementType)))); " is 227.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,InternalConvert,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.NoConversionPossibleTo' DataContract.GetClrTypeFullName(target)))); " is 216.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,InternalConvert,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IsNotAssignableFrom' DataContract.GetClrTypeFullName(target)' DataContract.GetClrTypeFullName(source)))); " is 254.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,InternalConvert,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IsNotAssignableFrom' DataContract.GetClrTypeFullName(target)' DataContract.GetClrTypeFullName(source)))); " is 254.
Long Statement,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,ThrowMismatchException,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ExpectingEnd' expected.ToString()))); " is 186.
Long Statement,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsNonAttributedTypeValidForSerialization,The length of the statement  "                    type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public' Array.Empty<Type>()) != null); " is 120.
Long Statement,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,CreateChildElementNamespaces,The length of the statement  "                childElementNamespaces[i + baseChildElementNamespaceCount] = GetChildNamespaceToDeclare(this' this.Members[i].MemberType' dictionary); " is 134.
Long Statement,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,WriteXmlValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.UnexpectedContractType' DataContract.GetClrTypeFullName(this.GetType())' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 257.
Long Statement,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ReadXmlValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.UnexpectedContractType' DataContract.GetClrTypeFullName(this.GetType())' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 257.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,The length of the statement  "                    memberInfos = type.GetMembers(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 128.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,The length of the statement  "                                ThrowInvalidDataContractException(SR.Format(SR.TooManyDataMembers' DataContract.GetClrTypeFullName(member.DeclaringType)' member.Name)); " is 136.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,The length of the statement  "                                    ThrowInvalidDataContractException(SR.Format(SR.IndexedPropertyCannotBeSerialized' property.DeclaringType' property.Name)); " is 122.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,The length of the statement  "                                    ThrowInvalidDataContractException(SR.Format(SR.InvalidDataMemberName' member.Name' DataContract.GetClrTypeFullName(type))); " is 123.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,The length of the statement  "                                ThrowInvalidDataContractException(SR.Format(SR.TooManyIgnoreDataMemberAttributes' DataContract.GetClrTypeFullName(member.DeclaringType)' member.Name)); " is 151.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,SetIfGetOnlyCollection,The length of the statement  "                if (CollectionDataContract.IsCollection(memberContract.MemberType' false /*isConstructorRequired*/) && !memberContract.MemberType.IsValueType) " is 142.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,SetIfMembersHaveConflict,The length of the statement  "                                hasConflictingType = (membersInHierarchy[endIndex].member.MemberType != membersInHierarchy[endIndex + 1].member.MemberType); " is 124.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,EnsureMethodsImported,The length of the statement  "                            MethodInfo[] methods = type.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic); " is 137.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,EnsureMethodsImported,The length of the statement  "                                if (IsValidCallback(method' parameters' Globals.TypeOfOnDeserializingAttribute' _onDeserializing' ref prevAttributeType)) " is 121.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidExtensionDataSetMethod,The length of the statement  "                        ThrowInvalidDataContractException(SR.Format(SR.DuplicateExtensionDataSetMethod' method' _extensionDataSetMethod' DataContract.GetClrTypeFullName(method.DeclaringType))); " is 169.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidExtensionDataSetMethod,The length of the statement  "                        DataContract.ThrowInvalidDataContractException(SR.Format(SR.ExtensionDataSetMustReturnVoid' DataContract.GetClrTypeFullName(method.DeclaringType)' method)' method.DeclaringType); " is 178.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidExtensionDataSetMethod,The length of the statement  "                        DataContract.ThrowInvalidDataContractException(SR.Format(SR.ExtensionDataSetParameterInvalid' DataContract.GetClrTypeFullName(method.DeclaringType)' method' Globals.TypeOfExtensionDataObject)' method.DeclaringType); " is 215.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidCallback,The length of the statement  "                        DataContract.ThrowInvalidDataContractException(SR.Format(SR.DuplicateCallback' method' currentCallback' DataContract.GetClrTypeFullName(method.DeclaringType)' attributeType)' method.DeclaringType); " is 197.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidCallback,The length of the statement  "                        DataContract.ThrowInvalidDataContractException(SR.Format(SR.DuplicateAttribute' prevAttributeType' attributeType' DataContract.GetClrTypeFullName(method.DeclaringType)' method)' method.DeclaringType); " is 200.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidCallback,The length of the statement  "                        DataContract.ThrowInvalidDataContractException(SR.Format(SR.CallbacksCannotBeVirtualMethods' method' DataContract.GetClrTypeFullName(method.DeclaringType)' attributeType)' method.DeclaringType); " is 194.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidCallback,The length of the statement  "                            DataContract.ThrowInvalidDataContractException(SR.Format(SR.CallbackMustReturnVoid' DataContract.GetClrTypeFullName(method.DeclaringType)' method)' method.DeclaringType); " is 170.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,IsValidCallback,The length of the statement  "                            DataContract.ThrowInvalidDataContractException(SR.Format(SR.CallbackParameterInvalid' DataContract.GetClrTypeFullName(method.DeclaringType)' method' Globals.TypeOfStreamingContext)' method.DeclaringType); " is 204.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,SetKeyValuePairAdapterFlags,The length of the statement  "                    _keyValuePairCtorInfo = type.GetConstructor(Globals.ScanAllMembers' new Type[] { Globals.TypeOfKeyValuePair.MakeGenericType(_keyValuePairGenericArguments) }); " is 158.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,GetISerializableConstructor,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.SerializationInfo_ConstructorNotFound' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 210.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,GetNonAttributedTypeConstructor,The length of the statement  "                ConstructorInfo ctor = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public' Array.Empty<Type>()); " is 134.
Long Statement,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,GetNonAttributedTypeConstructor,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.NonAttributedSerializableTypesMustHaveDefaultConstructor' DataContract.GetClrTypeFullName(type)))); " is 232.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CreateGetOnlyCollectionDataContract,The length of the statement  "                return IsCollectionOrTryCreate(type' true /*tryCreate*/' out dataContract' out itemType' false /*constructorRequired*/); " is 120.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,TryCreateGetOnlyCollectionDataContract,The length of the statement  "                    return IsCollectionOrTryCreate(type' true /*tryCreate*/' out dataContract' out itemType' false /*constructorRequired*/); " is 120.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                                getEnumeratorMethod = Globals.TypeOfIEnumerableGeneric.MakeGenericType(Globals.TypeOfKeyValuePair.MakeGenericType(genericArgs)).GetMethod(Globals.GetEnumeratorMethodName); " is 171.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                                getEnumeratorMethod = Globals.TypeOfIEnumerableGeneric.MakeGenericType(itemType).GetMethod(Globals.GetEnumeratorMethodName); " is 124.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                            dataContract = new CollectionDataContract(type' (CollectionKind)(i + 1)' itemType' getEnumeratorMethod' addMethod' null/*defaultCtor*/); " is 136.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                defaultCtor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' Array.Empty<Type>()); " is 125.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                    return HandleIfInvalidCollection(type' tryCreate' hasCollectionDataContract' isBaseTypeCollection/*createContractWithException*/' " is 129.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                    return HandleIfInvalidCollection(type' tryCreate' hasCollectionDataContract' isBaseTypeCollection/*createContractWithException*/' " is 129.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                    dataContract = new CollectionDataContract(type' kind' itemType' getEnumeratorMethod' addMethod' defaultCtor' !constructorRequired); " is 131.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                    return HandleIfInvalidCollection(type' tryCreate' hasCollectionDataContract' isBaseTypeCollection/*createContractWithException*/' " is 129.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The length of the statement  "                        dataContract = new CollectionDataContract(type' kind' itemType' getEnumeratorMethod' addMethod' defaultCtor' !constructorRequired); " is 131.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,HandleIfInvalidCollection,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(GetInvalidCollectionMessage(message' SR.Format(SR.InvalidCollectionDataContract' DataContract.GetClrTypeFullName(type))' param))); " is 250.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,HandleIfInvalidCollection,The length of the statement  "                    dataContract = new CollectionDataContract(type' GetInvalidCollectionMessage(message' SR.Format(SR.InvalidCollectionType' DataContract.GetClrTypeFullName(type))' param)); " is 169.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetCollectionMethods,The length of the statement  "                addMethod = type.GetMethod(Globals.AddMethodName' BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' addMethodTypeArray); " is 140.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetCollectionMethods,The length of the statement  "                getEnumeratorMethod = type.GetMethod(Globals.GetEnumeratorMethodName' BindingFlags.Instance | BindingFlags.Public' Array.Empty<Type>()); " is 136.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetCollectionMethods,The length of the statement  "                    Type ienumerableInterface = interfaceType.GetInterfaces().Where(t => t.FullName.StartsWith("System.Collections.Generic.IEnumerable")).FirstOrDefault(); " is 151.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetValidContract,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(InvalidCollectionInSharedContractMessage)); " is 163.
Long Statement,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,CheckConstructor,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.CollectionTypeDoesNotHaveDefaultCtor' DataContract.GetClrTypeFullName(this.UnderlyingType)))); " is 227.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,The length of the statement  "                                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractItemName' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 190.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,The length of the statement  "                                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractKeyName' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 189.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,The length of the statement  "                                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractKeyNoDictionary' DataContract.GetClrTypeFullName(UnderlyingType)' collectionContractAttribute.KeyName))); " is 234.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,The length of the statement  "                                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractValueName' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 191.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,The length of the statement  "                                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractValueNoDictionary' DataContract.GetClrTypeFullName(UnderlyingType)' collectionContractAttribute.ValueName))); " is 238.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IncrementCollectionCount,The length of the statement  "                                _incrementCollectionCountDelegate = (IncrementCollectionCountDelegate)buildIncrementCollectionCountDelegate.Invoke(null' Array.Empty<object>()); " is 144.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IncrementCollectionCount,The length of the statement  "                                var buildIncrementCollectionCountDelegate = BuildIncrementCollectionCountDelegateMethod.MakeGenericMethod(Globals.TypeOfKeyValuePair.MakeGenericType(ItemType.GetGenericArguments())); " is 182.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IncrementCollectionCount,The length of the statement  "                                _incrementCollectionCountDelegate = (IncrementCollectionCountDelegate)buildIncrementCollectionCountDelegate.Invoke(null' Array.Empty<object>()); " is 144.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetEnumeratorForCollection,The length of the statement  "                        var buildCreateGenericDictionaryEnumerator = BuildCreateGenericDictionaryEnumerato.MakeGenericMethod(keyValueTypes[0]' keyValueTypes[1]); " is 137.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetEnumeratorForCollection,The length of the statement  "                        _createGenericDictionaryEnumeratorDelegate = (CreateGenericDictionaryEnumeratorDelegate)buildCreateGenericDictionaryEnumerator.Invoke(null' Array.Empty<object>()); " is 163.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetCollectionElementType,The length of the statement  "                MethodInfo getCurrentMethod = enumeratorType.GetMethod(Globals.GetCurrentMethodName' BindingFlags.Instance | BindingFlags.Public' Array.Empty<Type>()); " is 151.
Long Statement,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,GetCollectionElementType,The length of the statement  "                        if (Kind == CollectionKind.GenericDictionary || Kind == CollectionKind.GenericCollection || Kind == CollectionKind.GenericEnumerable) " is 133.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetGetOnlyCollectionDataContract,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SerializationException(SR.Format(SR.ErrorDeserializing' SR.Format(SR.ErrorTypeInfo' DataContract.GetClrTypeFullName(dataContract.UnderlyingType))' SR.Format(SR.NoSetMethodForProperty' string.Empty' string.Empty)))); " is 306.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,WriteXmlValue,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.UnexpectedContractType' DataContract.GetClrTypeFullName(this.GetType())' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 257.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ReadXmlValue,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.UnexpectedContractType' DataContract.GetClrTypeFullName(this.GetType())' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 257.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,WriteXmlElement,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.UnexpectedContractType' DataContract.GetClrTypeFullName(this.GetType())' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 257.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ReadXmlElement,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.UnexpectedContractType' DataContract.GetClrTypeFullName(this.GetType())' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 257.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ValidatePreviousCollectionTypes,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.RecursiveCollectionType' GetClrTypeFullName(itemType)))); " is 161.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDCTypeStableName,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidDataContractName' DataContract.GetClrTypeFullName(type)))); " is 199.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDCTypeStableName,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidDataContractNamespace' DataContract.GetClrTypeFullName(type)))); " is 204.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,TryGetDCAttribute,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.TooManyDataContracts' DataContract.GetClrTypeFullName(type)))); " is 196.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetCollectionStableName,The length of the statement  "            object[] collectionContractAttributes = type.GetCustomAttributes(Globals.TypeOfCollectionDataContractAttribute' false).ToArray(); " is 129.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetCollectionStableName,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.TooManyCollectionContracts' DataContract.GetClrTypeFullName(type)))); " is 202.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetCollectionStableName,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractName' DataContract.GetClrTypeFullName(type)))); " is 205.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetCollectionStableName,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractNamespace' DataContract.GetClrTypeFullName(type)))); " is 210.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDefaultDataContractNamespace,The length of the statement  "            string ns = GetGlobalDataContractNamespace(clrNs' type.Module.GetCustomAttributes(typeof(ContractNamespaceAttribute)).ToArray()); " is 129.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDefaultDataContractNamespace,The length of the statement  "                ns = GetGlobalDataContractNamespace(clrNs' type.Assembly.GetCustomAttributes(typeof(ContractNamespaceAttribute)).ToArray()); " is 124.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDataContractNameForGenericName,The length of the statement  "                    nestedParamCounts.Add(Int32.Parse(typeName.Substring(endIndex + 1' startIndex - endIndex - 1)' CultureInfo.InvariantCulture)); " is 126.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetClrTypeFullName,The length of the statement  "            return !type.IsGenericTypeDefinition && type.ContainsGenericParameters ? String.Format(CultureInfo.InvariantCulture' "{0}.{1}"' type.Namespace' type.Name) : type.FullName; " is 171.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDataContractNamespaceFromUri,The length of the statement  "            return uriString.StartsWith(Globals.DataContractXsdBaseNamespace' StringComparison.Ordinal) ? uriString.Substring(Globals.DataContractXsdBaseNamespace.Length) : uriString; " is 171.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetGlobalDataContractNamespace,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidGlobalDataContractNamespace' clrNs))); " is 178.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetGlobalDataContractNamespace,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.DataContractNamespaceAlreadySet' dataContractNs' nsAttribute.ContractNamespace' clrNs))); " is 222.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ExpandGenericParameters,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.GenericNameBraceMismatch' format' genericNameProvider.GetGenericTypeName()))); " is 211.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ExpandGenericParameters,The length of the statement  "                        if (!Int32.TryParse(format.Substring(start' i - start)' out paramIndex) || paramIndex < 0 || paramIndex >= genericNameProvider.GetParameterCount()) " is 147.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ExpandGenericParameters,The length of the statement  "                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.GenericParameterNotValid' format.Substring(start' i - start)' genericNameProvider.GetGenericTypeName()' genericNameProvider.GetParameterCount() - 1))); " is 255.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeOneScheme' DataContract.GetClrTypeFullName(type))' type); " is 135.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeOneScheme' DataContract.GetClrTypeFullName(type))' type); " is 135.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeNoData' DataContract.GetClrTypeFullName(type))' type); " is 132.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeEmptyString' DataContract.GetClrTypeFullName(type))' type); " is 137.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                            MethodInfo method = type.GetMethod(methodName' BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public' Array.Empty<Type>()); " is 136.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeUnknownMethod' methodName' DataContract.GetClrTypeFullName(type))' type); " is 151.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeReturnType' DataContract.GetClrTypeFullName(type)' methodName)' type); " is 148.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeMethodNull' DataContract.GetClrTypeFullName(type))' type); " is 136.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                                    DataContract.ThrowInvalidDataContractException(SR.Format(SR.KnownTypeAttributeValidMethodTypes' DataContract.GetClrTypeFullName(type))' type); " is 142.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The length of the statement  "                        DataContract itemDataContract = DataContract.GetDataContract(Globals.TypeOfKeyValuePair.MakeGenericType(collectionDataContract.ItemType.GetGenericArguments())); " is 160.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,CheckAndAdd,The length of the statement  "                if (DataContractCriticalHelper.GetDataContractAdapterType(alreadyExistingContract.UnderlyingType) != DataContractCriticalHelper.GetDataContractAdapterType(type) && " is 163.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,CheckAndAdd,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.DupContractInKnownTypes' type' alreadyExistingContract.UnderlyingType' dataContract.StableName.Namespace' dataContract.StableName.Name))); " is 268.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,IsTypeVisibleInSerializationModule,The length of the statement  "            return (type.Module.Equals(typeof(DataContract).Module) || IsAssemblyFriendOfSerialization(type.Assembly)) && !type.IsNestedPrivate; " is 132.
Long Statement,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,IsAssemblyFriendOfSerialization,The length of the statement  "            InternalsVisibleToAttribute[] internalsVisibleAttributes = (InternalsVisibleToAttribute[])assembly.GetCustomAttributes(typeof(InternalsVisibleToAttribute)); " is 156.
Long Statement,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetDataContractForInitialization,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SerializationException(SR.Format(SR.DataContractCacheOverflow))); " is 127.
Long Statement,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetIdForInitialization,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SerializationException(SR.Format(SR.DataContractCacheOverflow))); " is 127.
Long Statement,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetId,The length of the statement  "                                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SerializationException(SR.Format(SR.DataContractCacheOverflow))); " is 127.
Long Statement,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,CreateDataContract,The length of the statement  "                            if (!type.IsSerializable && !type.IsDefined(Globals.TypeOfDataContractAttribute' false) && !ClassDataContract.IsNonAttributedTypeValidForSerialization(type) && !ClassDataContract.IsKnownSerializableType(type)) " is 209.
Long Statement,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetClrTypeString,The length of the statement  "                            s_clrTypeStrings.Add(Globals.TypeOfInt.Assembly.FullName' s_clrTypeStringsDictionary.Add(Globals.MscorlibAssemblyName)); " is 120.
Long Statement,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ThrowInvalidDataContractException,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(message)); " is 130.
Long Statement,System.Runtime.Serialization,DateTimeOffsetAdapter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DateTimeOffsetAdapter.cs,GetDateTimeOffset,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value.ToString(CultureInfo.InvariantCulture)' "DateTimeOffset"' exception)); " is 179.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,Initialize,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(maxItemsInObjectGraph)' SR.Format(SR.ValueMustBeNonNegative))); " is 160.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,Initialize,The length of the statement  "            Initialize(type' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' preserveObjectReferences' dataContractResolver' serializeReadOnlyTypes); " is 151.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalWriteObjectContent,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ExceededMaxItemsQuota' MaxItemsInObjectGraph))); " is 168.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalWriteObjectContent,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IsAnyCannotBeNull' declaredType))); " is 155.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalWriteObjectContent,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IsAnyCannotBeSerializedAsDerivedType' graphType' contract.UnderlyingType))); " is 196.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalReadObject,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ExceededMaxItemsQuota' MaxItemsInObjectGraph))); " is 168.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalReadObject,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationExceptionWithReaderDetails(SR.Format(SR.ExpectingElement' expectedNs' expectedName)' xmlReader)); " is 194.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalReadObject,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationExceptionWithReaderDetails(SR.Format(SR.ExpectingElementAtDeserialize' XmlNodeType.Element)' xmlReader)); " is 202.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalReadObject,The length of the statement  "            if (contract.IsPrimitive && object.ReferenceEquals(contract.UnderlyingType' _rootType) /*handle Nullable<T> differently*/) " is 122.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalReadObject,The length of the statement  "                return XmlObjectSerializerReadContext.ReadRootIXmlSerializable(xmlReader' contract as XmlDataContract' false /*isMemberType*/); " is 127.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,InternalReadObject,The length of the statement  "            XmlObjectSerializerReadContext context = XmlObjectSerializerReadContext.CreateContext(this' contract' dataContractResolver); " is 124.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,SurrogateToDataContractType,The length of the statement  "            object obj = DataContractSurrogateCaller.GetObjectToSerialize(serializationSurrogateProvider' oldObj' objType' surrogatedDeclaredType); " is 135.
Long Statement,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,GetSurrogatedType,The length of the statement  "            return DataContractSurrogateCaller.GetDataContractType(serializationSurrogateProvider' DataContract.UnwrapNullableType(type)); " is 126.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,GenerateClassReader,The length of the statement  "                        _ilg.BeginMethod("Read" + classContract.StableName.Name + "FromXml"' Globals.TypeOfXmlFormatClassReaderDelegate' memberAccessFlag); " is 131.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,GenerateClassReader,The length of the statement  "                            _ilg.ConvertValue(Globals.TypeOfKeyValuePair.MakeGenericType(classContract.KeyValuePairGenericArguments)' _ilg.CurrentMethod.ReturnType); " is 137.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,GenerateCollectionReaderHelper,The length of the statement  "                        _ilg.BeginMethod("Read" + collectionContract.StableName.Name + "FromXml" + "IsGetOnly"' Globals.TypeOfXmlFormatGetOnlyCollectionReaderDelegate' memberAccessFlag); " is 162.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,GenerateCollectionReaderHelper,The length of the statement  "                        _ilg.BeginMethod("Read" + collectionContract.StableName.Name + "FromXml" + string.Empty' Globals.TypeOfXmlFormatCollectionReaderDelegate' memberAccessFlag); " is 156.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,CreateObject,The length of the statement  "                    _ilg.Call(null' XmlFormatGeneratorStatics.GetUninitializedObjectMethod' DataContract.GetIdForInitialization(classContract)); " is 124.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadMembers,The length of the statement  "                LocalBuilder requiredIndexLocal = hasRequiredMembers ? _ilg.DeclareLocal(Globals.TypeOfInt' "requiredIndex"' firstRequiredMember) : null; " is 137.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadMembers,The length of the statement  "                    _ilg.Call(_contextArg' XmlFormatGeneratorStatics.GetMemberIndexWithRequiredMembersMethod' _xmlReaderArg' _memberNamesArg' _memberNamespacesArg' memberIndexLocal' requiredIndexLocal' extensionDataLocal); " is 202.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadMembers,The length of the statement  "                    _ilg.Call(_contextArg' XmlFormatGeneratorStatics.GetMemberIndexMethod' _xmlReaderArg' _memberNamesArg' _memberNamespacesArg' memberIndexLocal' extensionDataLocal); " is 163.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadMembers,The length of the statement  "                    _ilg.Call(null' XmlFormatGeneratorStatics.ThrowRequiredMemberMissingExceptionMethod' _xmlReaderArg' memberIndexLocal' requiredIndexLocal' _memberNamesArg); " is 155.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadISerializable,The length of the statement  "                _ilg.Call(_contextArg' XmlFormatGeneratorStatics.ReadSerializationInfoMethod' _xmlReaderArg' classContract.UnderlyingType); " is 123.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadValue,The length of the statement  "                if ((primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType) " is 130.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadValue,The length of the statement  "                    _ilg.Call(_contextArg' XmlFormatGeneratorStatics.ReadIfNullOrRefMethod' _xmlReaderArg' type' DataContract.IsTypeSerializable(type)); " is 132.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadCollection,The length of the statement  "                _ilg.Call(_contextArg' XmlFormatGeneratorStatics.CheckEndOfArrayMethod' _xmlReaderArg' size' _memberNamesArg' _memberNamespacesArg); " is 132.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadGetOnlyCollection,The length of the statement  "                _ilg.Call(_contextArg' XmlFormatGeneratorStatics.CheckEndOfArrayMethod' _xmlReaderArg' size' _memberNamesArg' _memberNamespacesArg); " is 132.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadCollectionItem,The length of the statement  "                if (collectionContract.Kind == CollectionKind.Dictionary || collectionContract.Kind == CollectionKind.GenericDictionary) " is 120.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,StoreCollectionValue,The length of the statement  "                if (collectionContract.Kind == CollectionKind.GenericDictionary || collectionContract.Kind == CollectionKind.Dictionary) " is 120.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,GenerateClassWriter,The length of the statement  "                        _ilg.BeginMethod("Write" + classContract.StableName.Name + "ToXml"' Globals.TypeOfXmlFormatClassWriterDelegate' memberAccessFlag); " is 130.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,GenerateCollectionWriter,The length of the statement  "                        _ilg.BeginMethod("Write" + collectionContract.StableName.Name + "ToXml"' Globals.TypeOfXmlFormatCollectionWriterDelegate' memberAccessFlag); " is 140.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteMembers,The length of the statement  "                    if (writeXsiType || !TryWritePrimitive(memberType' memberValue' member.MemberInfo' arrayItemIndex: null' ns: namespaceLocal' name: null' nameIndex: i + _childElementIndex)) " is 172.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteMembers,The length of the statement  "                        WriteStartElement(memberType' classContract.Namespace' namespaceLocal' nameLocal: null' nameIndex: i + _childElementIndex); " is 123.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteMembers,The length of the statement  "                        _ilg.Call(thisObj: _contextArg' XmlFormatGeneratorStatics.WriteExtensionDataMethod' _xmlWriterArg' extensionDataLocal' memberCount); " is 132.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteMembers,The length of the statement  "                            _ilg.Call(thisObj: null' XmlFormatGeneratorStatics.ThrowRequiredMemberMustBeEmittedMethod' member.Name' classContract.UnderlyingType); " is 134.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                        if (!TryWritePrimitive(itemType' null /*value*/' null /*memberInfo*/' i /*arrayItemIndex*/' itemNamespace' itemName' 0 /*nameIndex*/)) " is 134.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                            incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(collectionContract.ItemType); " is 144.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                            incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(Globals.TypeOfKeyValuePair.MakeGenericType(collectionContract.ItemType.GetGenericArguments())); " is 210.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                    MethodInfo moveNextMethod = enumeratorType.GetMethod(Globals.MoveNextMethodName' BindingFlags.Instance | BindingFlags.Public' Array.Empty<Type>()); " is 147.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                    MethodInfo getCurrentMethod = enumeratorType.GetMethod(Globals.GetCurrentMethodName' BindingFlags.Instance | BindingFlags.Public' Array.Empty<Type>()); " is 151.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                            if (kind == CollectionKind.GenericDictionary || kind == CollectionKind.GenericCollection || kind == CollectionKind.GenericEnumerable) " is 133.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                                moveNextMethod = CollectionDataContract.GetTargetMethodWithName(Globals.MoveNextMethodName' enumeratorType' ienumeratorInterface); " is 130.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                                getCurrentMethod = CollectionDataContract.GetTargetMethodWithName(Globals.GetCurrentMethodName' enumeratorType' ienumeratorInterface); " is 134.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                        Type ctorParam = Globals.TypeOfIEnumeratorGeneric.MakeGenericType(Globals.TypeOfKeyValuePair.MakeGenericType(keyValueTypes)); " is 125.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The length of the statement  "                    if (!TryWritePrimitive(elementType' currentValue' null /*memberInfo*/' null /*arrayItemIndex*/' itemNamespace' itemName' 0 /*nameIndex*/)) " is 138.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,TryWritePrimitiveArray,The length of the statement  "                    _ilg.Call(typeof(XmlWriterDelegator).GetMethod(writeArrayMethod' Globals.ScanAllMembers' new Type[] { type' typeof(XmlDictionaryString)' typeof(XmlDictionaryString) })); " is 169.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteValue,The length of the statement  "                    _ilg.Call(_contextArg' XmlFormatGeneratorStatics.WriteNullMethod' _xmlWriterArg' memberType' DataContract.IsTypeSerializable(memberType)); " is 138.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteValue,The length of the statement  "                            _ilg.Call(_contextArg' XmlFormatGeneratorStatics.WriteNullMethod' _xmlWriterArg' memberType' DataContract.IsTypeSerializable(memberType)); " is 138.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteValue,The length of the statement  "                        InternalSerialize((isNullableOfT ? XmlFormatGeneratorStatics.InternalSerializeMethod : XmlFormatGeneratorStatics.InternalSerializeReferenceMethod)' " is 147.
Long Statement,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteStartElement,The length of the statement  "                _ilg.Call(needsPrefix ? XmlFormatGeneratorStatics.WriteStartElementMethod3 : XmlFormatGeneratorStatics.WriteStartElementMethod2); " is 129.
Long Statement,System.Runtime.Serialization,EnumDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,WriteEnumValue,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.InvalidEnumValueOnWrite' value' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 203.
Long Statement,System.Runtime.Serialization,EnumDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,WriteEnumValue,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.InvalidEnumValueOnWrite' value' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 203.
Long Statement,System.Runtime.Serialization,EnumDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,ReadEnumValue,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.InvalidEnumValueOnRead' stringValue' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 208.
Long Statement,System.Runtime.Serialization,EnumDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,ReadEnumValue,The length of the statement  "            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.InvalidEnumValueOnRead' value.Substring(index' count)' DataContract.GetClrTypeFullName(UnderlyingType)))); " is 226.
Long Statement,System.Runtime.Serialization,EnumDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,ImportDataMembers,The length of the statement  "                                ThrowInvalidDataContractException(SR.Format(SR.TooManyEnumMembers' DataContract.GetClrTypeFullName(field.DeclaringType)' field.Name)); " is 134.
Long Statement,System.Runtime.Serialization,EnumDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,ImportDataMembers,The length of the statement  "                                    ThrowInvalidDataContractException(SR.Format(SR.InvalidEnumMemberValue' field.Name' DataContract.GetClrTypeFullName(type))); " is 123.
Long Statement,System.Runtime.Serialization,EnumDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,ImportDataMembers,The length of the statement  "                            ThrowInvalidDataContractException(SR.Format(SR.DataMemberOnEnumField' DataContract.GetClrTypeFullName(field.DeclaringType)' field.Name)); " is 137.
Long Statement,System.Runtime.Serialization,DataNode<T>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataObject.cs,GetData,The length of the statement  "                AddQualifiedNameAttribute(element' Globals.XsiPrefix' Globals.XsiTypeLocalName' Globals.SchemaInstanceNamespace' DataContractName' DataContractNamespace); " is 154.
Long Statement,System.Runtime.Serialization,DataNode<T>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataObject.cs,AddQualifiedNameAttribute,The length of the statement  "            element.AddAttribute(elementPrefix' elementNs' elementName' String.Format(CultureInfo.InvariantCulture' "{0}:{1}"' prefix' valueName)); " is 135.
Long Statement,System.Runtime.Serialization,CollectionDataNode,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataObject.cs,GetData,The length of the statement  "            element.AddAttribute(Globals.SerPrefix' Globals.SerializationNamespace' Globals.ArraySizeLocalName' Size.ToString(NumberFormatInfo.InvariantInfo)); " is 147.
Long Statement,System.Runtime.Serialization,ISerializableDataNode,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataObject.cs,GetData,The length of the statement  "                AddQualifiedNameAttribute(element' Globals.SerPrefix' Globals.ISerializableFactoryTypeLocalName' Globals.SerializationNamespace' FactoryTypeName' FactoryTypeNamespace); " is 168.
Long Statement,System.Runtime.Serialization,Globals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Globals.cs,FilterMethodBases,The length of the statement  "            matchedMethods = matchedMethods.Where(method => TypeSequenceEqual(method.GetParameters().Select(param => param.ParameterType).ToArray()' parameterTypes)); " is 154.
Long Statement,System.Runtime.Serialization,HybridObjectCache,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\HybridObjectCache.cs,Add,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.MultipleIdDefinition' id))); " is 177.
Long Statement,System.Runtime.Serialization,ObjectToIdCache,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ObjectToIdCache.cs,FindElement,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ObjectTableOverflow))); " is 172.
Long Statement,System.Runtime.Serialization,ObjectToIdCache,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ObjectToIdCache.cs,RemoveAt,The length of the statement  "                // We want to avoid moving objects in the cache if the next bucket position is wrapped' but the last vacant position isn't " is 122.
Long Statement,System.Runtime.Serialization,ObjectToIdCache,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ObjectToIdCache.cs,RemoveAt,The length of the statement  "                // and we want to make sure to move objects in the cache when the last vacant position is wrapped but the next bucket position isn't " is 132.
Long Statement,System.Runtime.Serialization,ObjectToIdCache,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ObjectToIdCache.cs,RemoveAt,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ObjectTableOverflow))); " is 172.
Long Statement,System.Runtime.Serialization,PrimitiveDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,TryReadNullAtTopLevel,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.CannotDeserializeRefAtTopLevel' attributes.Ref))); " is 170.
Long Statement,System.Runtime.Serialization,ObjectDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\PrimitiveDataContract.cs,ReadXmlValue,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.XmlForObjectCannotHaveContent' localName' ns)' xes)); " is 173.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportSerializationSchema,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.CouldNotReadSerializationSchema' Globals.SerializationNamespace))); " is 197.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportClassDataContract,The length of the statement  "                genericInfoElement = ExportGenericInfo(classDataContract.UnderlyingType' Globals.GenericTypeLocalName' Globals.SerializationNamespace); " is 135.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportClassDataContract,The length of the statement  "                element.Annotation = GetSchemaAnnotation(actualTypeElement' ExportSurrogateData(dataMember)' ExportEmitDefaultValue(dataMember)); " is 129.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportClassDataContract,The length of the statement  "                XmlSchemaComplexContentExtension extension = CreateTypeContent(type' classDataContract.BaseContract.StableName' schema); " is 120.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportGenericInfo,The length of the statement  "                        XmlElement argumentElement = ExportGenericInfo(genericArguments[argIndex]' Globals.GenericParameterLocalName' Globals.SerializationNamespace); " is 142.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportCollectionDataContract,The length of the statement  "            if (collectionDataContract.UnderlyingType.IsGenericType && CollectionDataContract.IsCollectionDataContract(collectionDataContract.UnderlyingType)) " is 146.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportCollectionDataContract,The length of the statement  "                genericInfoElement = ExportGenericInfo(collectionDataContract.UnderlyingType' Globals.GenericTypeLocalName' Globals.SerializationNamespace); " is 140.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportCollectionDataContract,The length of the statement  "            type.Annotation = GetSchemaAnnotation(isDictionaryElement' genericInfoElement' ExportSurrogateData(collectionDataContract)); " is 124.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportIsDictionary,The length of the statement  "            XmlElement isDictionaryElement = XmlDoc.CreateElement(IsDictionaryAnnotationName.Name' IsDictionaryAnnotationName.Namespace); " is 125.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportEnumDataContract,The length of the statement  "            XmlElement actualTypeElement = (enumDataContract.BaseContractName == DefaultEnumBaseTypeName) ? null : ExportActualType(enumDataContract.BaseContractName); " is 155.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportEnumDataContract,The length of the statement  "                        facet.Annotation = GetSchemaAnnotation(EnumerationValueAnnotationName' enumDataContract.GetStringFromEnumValue(enumDataContract.Values[i])' schema); " is 148.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportISerializableDataContract,The length of the statement  "                genericInfoElement = ExportGenericInfo(dataContract.UnderlyingType' Globals.GenericTypeLocalName' Globals.SerializationNamespace); " is 130.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,ExportXmlDataContract,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.MissingSchemaType' typeQName' DataContract.GetClrTypeFullName(clrType)))); " is 207.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,GetXmlTypeInfo,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidXmlDataContractName' DataContract.GetClrTypeFullName(type)))); " is 202.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidGetSchemaMethod' DataContract.GetClrTypeFullName(clrType)))); " is 201.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The length of the statement  "                MethodInfo getMethod = clrType.GetMethod(methodName'  /*BindingFlags.DeclaredOnly |*/ BindingFlags.Static | BindingFlags.NonPublic | BindingFlags.Public' null' new Type[] { typeof(XmlSchemaSet) }' null); " is 203.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.MissingGetSchemaMethod' DataContract.GetClrTypeFullName(clrType)' methodName))); " is 213.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The length of the statement  "                if (!(Globals.TypeOfXmlQualifiedName.IsAssignableFrom(getMethod.ReturnType)) && !(Globals.TypeOfXmlSchemaType.IsAssignableFrom(getMethod.ReturnType))) " is 150.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidReturnTypeOnGetSchemaMethod' DataContract.GetClrTypeFullName(clrType)' methodName' DataContract.GetClrTypeFullName(getMethod.ReturnType)' DataContract.GetClrTypeFullName(Globals.TypeOfXmlQualifiedName)' typeof(XmlSchemaType)))); " is 368.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidNonNullReturnValueByIsAny' DataContract.GetClrTypeFullName(clrType)' methodName))); " is 223.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeSchemaProviderMethod,The length of the statement  "                                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.MissingSchemaType' typeName' DataContract.GetClrTypeFullName(clrType)))); " is 206.
Long Statement,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,InvokeGetSchemaMethod,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidReturnSchemaOnGetSchemaMethod' DataContract.GetClrTypeFullName(clrType)))); " is 215.
Long Statement,System.Runtime.Serialization,XmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlDataContract.cs,GetConstructor,The length of the statement  "            ConstructorInfo ctor = type.GetConstructor(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public' Array.Empty<Type>()); " is 134.
Long Statement,System.Runtime.Serialization,XmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlDataContract.cs,GetConstructor,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.IXmlSerializableMustHaveDefaultConstructor' DataContract.GetClrTypeFullName(type)))); " is 218.
Long Statement,System.Runtime.Serialization,XmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlDataContract.cs,GenerateCreateXmlSerializableDelegate,The length of the statement  "                ilg.BeginMethod("Create" + DataContract.GetClrTypeFullName(type)' typeof(CreateXmlSerializableDelegate)' memberAccessFlag); " is 123.
Long Statement,System.Runtime.Serialization,XmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlDataContract.cs,RequiresMemberAccessForCreate,The length of the statement  "                        new SecurityException(SR.Format(SR.PartialTrustIXmlSerializableTypeNotPublic' DataContract.GetClrTypeFullName(UnderlyingType))' " is 127.
Long Statement,System.Runtime.Serialization,XmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlDataContract.cs,RequiresMemberAccessForCreate,The length of the statement  "                        new SecurityException(SR.Format(SR.PartialTrustIXmlSerialzableNoPublicConstructor' DataContract.GetClrTypeFullName(UnderlyingType))' " is 132.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorSerializing' GetSerializeType(graph)' ex)' ex)); " is 180.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorSerializing' GetSerializeType(graph)' ex)' ex)); " is 180.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteStartObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorWriteStartObject' GetSerializeType(graph)' ex)' ex)); " is 185.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteStartObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorWriteStartObject' GetSerializeType(graph)' ex)' ex)); " is 185.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteObjectContentHandleExceptions,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.XmlWriterMustBeInElement' writer.WriteState))); " is 167.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteObjectContentHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorSerializing' GetSerializeType(graph)' ex)' ex)); " is 180.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteObjectContentHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorSerializing' GetSerializeType(graph)' ex)' ex)); " is 180.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteEndObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorWriteEndObject' null' ex)' ex)); " is 164.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteEndObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorWriteEndObject' null' ex)' ex)); " is 164.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,WriteNull,The length of the statement  "            writer.WriteAttributeBool(Globals.XsiPrefix' DictionaryGlobals.XsiNilLocalName' DictionaryGlobals.SchemaInstanceNamespace' true); " is 129.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,IsContractDeclared,The length of the statement  "            return (object.ReferenceEquals(contract.Name' declaredContract.Name) && object.ReferenceEquals(contract.Namespace' declaredContract.Namespace)) " is 143.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,IsContractDeclared,The length of the statement  "                || (contract.Name.Value == declaredContract.Name.Value && contract.Namespace.Value == declaredContract.Namespace.Value); " is 120.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,ReadObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorDeserializing' GetDeserializeType()' ex)' ex)); " is 179.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,ReadObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorDeserializing' GetDeserializeType()' ex)' ex)); " is 179.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,IsStartObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorIsStartObject' GetDeserializeType()' ex)' ex)); " is 179.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,IsStartObjectHandleExceptions,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(GetTypeInfoError(SR.ErrorIsStartObject' GetDeserializeType()' ex)' ex)); " is 179.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,TryAddLineInfo,The length of the statement  "                return String.Format(CultureInfo.InvariantCulture' "{0} {1}"' SR.Format(SR.ErrorInLine' reader.LineNumber' reader.LinePosition)' errorMessage); " is 143.
Long Statement,System.Runtime.Serialization,XmlObjectSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializer.cs,CreateSerializationExceptionWithReaderDetails,The length of the statement  "            return XmlObjectSerializer.CreateSerializationException(TryAddLineInfo(reader' SR.Format(SR.EncounteredWithNameNamespace' errorMessage' reader.NodeType' reader.LocalName' reader.NamespaceURI))); " is 194.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs,IncrementItemCount,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ExceededMaxItemsQuota' _maxItemsInObjectGraph))); " is 169.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs,CheckIfTypeSerializable,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.TypeNotSerializable' memberType))); " is 168.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs,GetDataContractsForKnownTypes,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.NullKnownType' "knownTypes"))); " is 124.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs,IsKnownType,The length of the statement  "            DataContract knownContract = ResolveDataContractFromKnownTypes(dataContract.StableName.Name' dataContract.StableName.Namespace' null /*memberTypeContract*/ /*' declaredType */); " is 177.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerContext.cs,ResolveDataContractFromKnownTypes,The length of the statement  "                if (typeName.Name == Globals.SafeSerializationManagerName && typeName.Namespace == Globals.SafeSerializationManagerNamespace && Globals.TypeOfSafeSerializationManager != null) " is 175.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,InternalSerialize,The length of the statement  "                SerializeWithXsiType(xmlWriter' obj' obj.GetType().TypeHandle' null/*type*/' -1' declaredType.TypeHandle' declaredType); " is 120.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,InternalSerialize,The length of the statement  "                if (declaredTypeHandle.GetHashCode() == objTypeHandle.GetHashCode()) // semantically the same as Value == Value; Value is not available in SL " is 141.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,InternalSerialize,The length of the statement  "                    SerializeWithXsiType(xmlWriter' obj' objTypeHandle' null /*type*/' declaredTypeID' declaredTypeHandle' Type.GetTypeFromHandle(declaredTypeHandle)); " is 147.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,SerializeWithXsiTypeAtTopLevel,The length of the statement  "            else if (!declaredType.IsArray) //Array covariance is not supported in XSD. If declared type is array do not write xsi:type. Instead write xsi:type for each item " is 161.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,SerializeWithXsiType,The length of the statement  "            else if (declaredType.IsArray)//Array covariance is not supported in XSD. If declared type is array do not write xsi:type. Instead write xsi:type for each item " is 159.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,OnHandleIsReference,The length of the statement  "                xmlWriter.WriteAttributeString(Globals.SerPrefix' DictionaryGlobals.RefLocalName' DictionaryGlobals.SerializationNamespace' string.Format(CultureInfo.InvariantCulture' "{0}{1}"' "i"' objectId)); " is 194.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,SerializeAndVerifyType,The length of the statement  "                    DataContract knownContract = ResolveDataContractFromKnownTypes(dataContract.StableName.Name' dataContract.StableName.Namespace' null /*memberTypeContract*/); " is 157.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,SerializeAndVerifyType,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.DcTypeNotFoundOnSerialize' DataContract.GetClrTypeFullName(dataContract.UnderlyingType)' dataContract.StableName.Name' dataContract.StableName.Namespace))); " is 276.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,OnHandleReference,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.CannotSerializeObjectWithCycles' DataContract.GetClrTypeFullName(obj.GetType())))); " is 203.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,ThrowRequiredMemberMustBeEmitted,The length of the statement  "            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SerializationException(SR.Format(SR.RequiredMemberMustBeEmitted' memberName' type.FullName))); " is 156.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteIXmlSerializable,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.UnknownXmlType' DataContract.GetClrTypeFullName(obj.GetType())))); " is 186.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteISerializable,The length of the statement  "            var serInfo = new SerializationInfo(objType' XmlObjectSerializer.FormatterConverter /*!UnsafeTypeForwardingEnabled is always false*/); " is 134.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteISerializable,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ISerializableAssemblyNameSetToZero' DataContract.GetClrTypeFullName(obj.GetType())))); " is 206.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteSerializationInfo,The length of the statement  "                        xmlWriter.WriteAttributeQualifiedName(Globals.SerPrefix' DictionaryGlobals.ISerializableFactoryTypeLocalName' DictionaryGlobals.SerializationNamespace' typeName' typeNs); " is 170.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteSerializationInfo,The length of the statement  "                    xmlWriter.WriteAttributeQualifiedName(Globals.SerPrefix' DictionaryGlobals.ISerializableFactoryTypeLocalName' DictionaryGlobals.SerializationNamespace' DataContract.GetClrTypeString(typeName)' DataContract.GetClrTypeString(typeNs)); " is 232.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteSerializationInfo,The length of the statement  "                    InternalSerializeReference(xmlWriter' obj' false /*isDeclaredType*/' false /*writeXsiType*/' -1' Globals.TypeOfObject.TypeHandle); " is 130.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,ResolveType,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ResolveTypeReturnedFalse' DataContract.GetClrTypeFullName(DataContractResolver.GetType())' DataContract.GetClrTypeFullName(objectType)))); " is 258.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,ResolveType,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ResolveTypeReturnedNull' DataContract.GetClrTypeFullName(DataContractResolver.GetType())' DataContract.GetClrTypeFullName(objectType)))); " is 257.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,ResolveType,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ResolveTypeReturnedNull' DataContract.GetClrTypeFullName(DataContractResolver.GetType())' DataContract.GetClrTypeFullName(objectType)))); " is 257.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteTypeInfo,The length of the statement  "            writer.WriteAttributeQualifiedName(Globals.XsiPrefix' DictionaryGlobals.XsiTypeLocalName' DictionaryGlobals.SchemaInstanceNamespace' dataContractName' dataContractNamespace); " is 174.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteTypeInfo,The length of the statement  "            writer.WriteAttributeQualifiedName(Globals.XsiPrefix' DictionaryGlobals.XsiTypeLocalName' DictionaryGlobals.SchemaInstanceNamespace' dataContractName' dataContractNamespace); " is 174.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteExtensionDataValue,The length of the statement  "                && OnHandleReference(xmlWriter' (dataNode.Value == null ? dataNode : dataNode.Value)' true /*canContainCyclicReference*/)) " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteExtensionDataValue,The length of the statement  "                OnEndHandleReference(xmlWriter' (dataNode.Value == null ? dataNode : dataNode.Value)' true  /*canContainCyclicReference*/); " is 123.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContext.cs,WriteExtensionISerializableData,The length of the statement  "                    xmlWriter.WriteAttributeQualifiedName(Globals.SerPrefix' DictionaryGlobals.ISerializableFactoryTypeLocalName' DictionaryGlobals.SerializationNamespace' dataNode.FactoryTypeName' dataNode.FactoryTypeNamespace); " is 209.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ThrowNullValueReturnedForGetOnlyCollectionException,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.NullValueReturnedForGetOnlyCollection' DataContract.GetClrTypeFullName(type)))); " is 229.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ThrowArrayExceededSizeException,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ArrayExceededSize' arraySize' DataContract.GetClrTypeFullName(type)))); " is 220.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,TryHandleNullOrRef,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ErrorDeserializing' SR.Format(SR.ErrorTypeInfo' DataContract.GetClrTypeFullName(declaredType))' SR.Format(SR.XmlStartElementExpected' Globals.RefLocalName)))); " is 308.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(XmlObjectSerializer.TryAddLineInfo(reader' SR.Format(SR.DcTypeNotFoundOnDeserialize' attributes.XsiTypeNamespace' attributes.XsiTypeName' reader.NamespaceURI' reader.LocalName)))); " is 287.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(XmlObjectSerializer.TryAddLineInfo(reader' SR.Format(SR.DcTypeNotResolvedOnDeserialize' attributes.XsiTypeNamespace' attributes.XsiTypeName' reader.NamespaceURI' reader.LocalName)))); " is 290.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The length of the statement  "                knownTypesAddedInCurrentScope = ReplaceScopedKnownTypesTop(dataContract.KnownDataContracts' knownTypesAddedInCurrentScope); " is 123.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The length of the statement  "                DataContract factoryDataContract = ResolveDataContractFromKnownTypes(attributes.FactoryTypeName' attributes.FactoryTypeNamespace' dataContract); " is 144.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The length of the statement  "                        knownTypesAddedInCurrentScope = ReplaceScopedKnownTypesTop(dataContract.KnownDataContracts' knownTypesAddedInCurrentScope); " is 123.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,InternalDeserialize,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.FactoryTypeNotISerializable' DataContract.GetClrTypeFullName(factoryDataContract.UnderlyingType)' DataContract.GetClrTypeFullName(dataContract.UnderlyingType)))); " is 282.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ThrowRequiredMemberMissingException,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(XmlObjectSerializer.TryAddLineInfo(xmlReader' SR.Format(SR.UnexpectedElementExpectingElements' xmlReader.NodeType' xmlReader.LocalName' xmlReader.NamespaceURI' stringBuilder.ToString())))); " is 325.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,HandleMemberNotFound,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReplaceDeserializedObject,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.FactoryObjectContainsSelfReference' DataContract.GetClrTypeFullName(oldObj.GetType())' DataContract.GetClrTypeFullName(newObj.GetType())' id))); " is 264.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,GetExistingObject,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.DeserializedObjectWithIdNotFound' id))); " is 160.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,Read,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.UnexpectedEndOfFile))); " is 143.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,CheckEndOfArray,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ArrayExceededSizeAttribute' arraySize' itemName.Value' itemNamespace.Value))); " is 198.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,CheckEndOfArray,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.EndElement' xmlReader)); " is 125.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadIXmlSerializable,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadSerializationInfo,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ResolveDataContractFromTypeName,The length of the statement  "            return (attributes.XsiTypeName == null) ? null : ResolveDataContractFromKnownTypes(attributes.XsiTypeName' attributes.XsiTypeNamespace' null /*memberTypeContract*/); " is 165.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadExtensionDataMember,The length of the statement  "            member.Value = xmlReader.UnderlyingExtensionDataReader != null ? xmlReader.UnderlyingExtensionDataReader.GetCurrentNode() : ReadExtensionDataValue(xmlReader); " is 158.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadExtensionDataValue,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownClassData,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownCollectionData,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownCollectionData,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ArraySizeAttributeIncorrect' arraySize' 0))); " is 165.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownCollectionData,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ArraySizeAttributeIncorrect' arraySize' dataNode.Items.Count))); " is 184.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownISerializableData,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadUnknownXmlData,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.UnexpectedEndOfFile))); " is 143.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadAndResolveUnknownXmlData,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.UnexpectedEndOfFile))); " is 143.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadAndResolveUnknownXmlData,The length of the statement  "                        childNode.Attributes.Append(AddNamespaceDeclaration(_attributesInXmlData.XsiTypePrefix' _attributesInXmlData.XsiTypeNamespace)); " is 128.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadAndResolveUnknownXmlData,The length of the statement  "                        childNode.Attributes.Append(AddNamespaceDeclaration(_attributesInXmlData.FactoryTypePrefix' _attributesInXmlData.FactoryTypeNamespace)); " is 136.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadAndResolveUnknownXmlData,The length of the statement  "                return ReadUnknownCollectionData(CreateReaderOverChildNodes(xmlAttributes' xmlChildNodes)' dataContractName' dataContractNamespace); " is 132.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadAndResolveUnknownXmlData,The length of the statement  "                return ReadUnknownISerializableData(CreateReaderOverChildNodes(xmlAttributes' xmlChildNodes)' dataContractName' dataContractNamespace); " is 135.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,ReadAndResolveUnknownXmlData,The length of the statement  "                return ReadUnknownClassData(CreateReaderOverChildNodes(xmlAttributes' xmlChildNodes)' dataContractName' dataContractNamespace); " is 127.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,CreateUnexpectedStateException,The length of the statement  "            return XmlObjectSerializer.CreateSerializationExceptionWithReaderDetails(SR.Format(SR.ExpectingState' expectedState)' xmlReader); " is 129.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,GetAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(i)' SR.Format(SR.XmlElementAttributes))); " is 167.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,MoveToAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(i)' SR.Format(SR.XmlElementAttributes))); " is 167.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsAnyType,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidPrimitiveTypeException(valueType)); " is 135.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadExtensionData,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidPrimitiveTypeException(valueType)); " is 135.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ThrowConversionException,The length of the statement  "            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(XmlObjectSerializer.TryAddLineInfo(this' SR.Format(SR.XmlInvalidConversion' value' type)))); " is 167.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ThrowNotAtElement,The length of the statement  "            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.XmlStartElementExpected' "EndElement"))); " is 129.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsBase64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "byte[]"' exception)); " is 130.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsBase64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "byte[]"' exception)); " is 130.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadElementContentAsGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Guid"' exception)); " is 128.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadElementContentAsGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Guid"' exception)); " is 128.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadElementContentAsGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Guid"' exception)); " is 128.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Guid"' exception)); " is 128.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Guid"' exception)); " is 128.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Guid"' exception)); " is 128.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadElementContentAsUri,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Uri"' exception)); " is 127.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadElementContentAsUri,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Uri"' exception)); " is 127.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsUri,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Uri"' exception)); " is 127.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,ReadContentAsUri,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(str' "Uri"' exception)); " is 127.
Long Statement,System.Runtime.Serialization,XmlReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlReaderDelegator.cs,CheckActualArrayLength,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ArrayExceededSizeAttribute' expectedLength' itemName.Value' itemNamespace.Value))); " is 203.
Long Statement,System.Runtime.Serialization,XmlSerializableReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableReader.cs,BeginRead,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializerReadContext.CreateUnexpectedStateException(XmlNodeType.Element' xmlReader)); " is 153.
Long Statement,System.Runtime.Serialization,XmlSerializableReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableReader.cs,EndRead,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializerReadContext.CreateUnexpectedStateException(XmlNodeType.EndElement' _xmlReader)); " is 157.
Long Statement,System.Runtime.Serialization,XmlSerializableReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableReader.cs,Close,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IXmlSerializableIllegalOperation))); " is 185.
Long Statement,System.Runtime.Serialization,XmlSerializableWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableWriter.cs,EndWrite,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IXmlSerializableMissingEndElements' (_obj == null ? string.Empty : DataContract.GetClrTypeFullName(_obj.GetType()))))); " is 268.
Long Statement,System.Runtime.Serialization,XmlSerializableWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableWriter.cs,WriteEndElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IXmlSerializableWritePastSubTree' (_obj == null ? string.Empty : DataContract.GetClrTypeFullName(_obj.GetType()))))); " is 266.
Long Statement,System.Runtime.Serialization,XmlSerializableWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableWriter.cs,WriteFullEndElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IXmlSerializableWritePastSubTree' (_obj == null ? string.Empty : DataContract.GetClrTypeFullName(_obj.GetType()))))); " is 266.
Long Statement,System.Runtime.Serialization,XmlSerializableWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableWriter.cs,Close,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.IXmlSerializableIllegalOperation))); " is 185.
Long Statement,System.Runtime.Serialization,XmlWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlWriterDelegator.cs,WriteStartElement,The length of the statement  "                writer.WriteStartElement(prefix' (localName == null ? null : localName.Value)' (namespaceUri == null ? null : namespaceUri.Value)); " is 131.
Long Statement,System.Runtime.Serialization,XmlWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlWriterDelegator.cs,WriteStartElementPrimitive,The length of the statement  "                writer.WriteStartElement(null' (localName == null ? null : localName.Value)' (namespaceUri == null ? null : namespaceUri.Value)); " is 129.
Long Statement,System.Runtime.Serialization,XmlWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlWriterDelegator.cs,WriteAnyType,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidPrimitiveTypeException(valueType)); " is 135.
Long Statement,System.Runtime.Serialization,XmlWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlWriterDelegator.cs,WriteExtensionData,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(CreateInvalidPrimitiveTypeException(valueType)); " is 135.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserialize,The length of the statement  "                    return InternalDeserializeWithSurrogate(xmlReader' Type.GetTypeFromHandle(declaredTypeHandle)' null /*surrogateDataContract*/' name' ns); " is 137.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserialize,The length of the statement  "                return InternalDeserializeInSharedTypeMode(xmlReader' declaredTypeID' Type.GetTypeFromHandle(declaredTypeHandle)' name' ns); " is 124.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeInSharedTypeMode,The length of the statement  "                    dataContract = (declaredTypeID < 0) ? GetDataContract(declaredType) : GetDataContract(declaredTypeID' declaredType.TypeHandle); " is 127.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeInSharedTypeMode,The length of the statement  "                    throw XmlObjectSerializer.CreateSerializationException(XmlObjectSerializer.TryAddLineInfo(xmlReader' SR.Format(SR.AttributeNotFound' Globals.SerializationNamespace' Globals.ClrTypeLocalName' xmlReader.NodeType' xmlReader.NamespaceURI' xmlReader.LocalName))); " is 258.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeInSharedTypeMode,The length of the statement  "                    throw XmlObjectSerializer.CreateSerializationException(XmlObjectSerializer.TryAddLineInfo(xmlReader' SR.Format(SR.AttributeNotFound' Globals.SerializationNamespace' Globals.ClrAssemblyLocalName' xmlReader.NodeType' xmlReader.NamespaceURI' xmlReader.LocalName))); " is 262.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeInSharedTypeMode,The length of the statement  "                    throw XmlObjectSerializer.CreateSerializationException(XmlObjectSerializer.TryAddLineInfo(xmlReader' SR.Format(SR.AttributeNotFound' Globals.SerializationNamespace' Globals.ClrTypeLocalName' xmlReader.NodeType' xmlReader.NamespaceURI' xmlReader.LocalName))); " is 258.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeInSharedTypeMode,The length of the statement  "                dataContract = (declaredTypeID < 0) ? GetDataContract(declaredType) : GetDataContract(declaredTypeID' declaredType.TypeHandle); " is 127.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeWithSurrogate,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser' DataContract.GetClrTypeFullName(declaredType)))); " is 236.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,InternalDeserializeWithSurrogate,The length of the statement  "            object obj = DataContractSurrogateCaller.GetDeserializedObject(_serializationSurrogateProvider' oldObj' dataContract.UnderlyingType' declaredType); " is 147.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,CheckIfTypeSerializable,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.TypeNotSerializable' memberType))); " is 168.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerReadContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContextComplex.cs,GetSurrogatedType,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser' " is 186.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,OnHandleReference,The length of the statement  "                    xmlWriter.WriteAttributeInt(Globals.SerPrefix' DictionaryGlobals.IdLocalName' DictionaryGlobals.SerializationNamespace' objectId); " is 130.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,OnHandleReference,The length of the statement  "                    xmlWriter.WriteAttributeInt(Globals.SerPrefix' DictionaryGlobals.RefLocalName' DictionaryGlobals.SerializationNamespace' objectId); " is 131.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,OnHandleReference,The length of the statement  "                    xmlWriter.WriteAttributeBool(Globals.XsiPrefix' DictionaryGlobals.XsiNilLocalName' DictionaryGlobals.SchemaInstanceNamespace' true); " is 132.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,CheckIfTypeSerializable,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.TypeNotSerializable' memberType))); " is 168.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,GetSurrogatedType,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.SurrogatesWithGetOnlyCollectionsNotSupportedSerDeser' " is 186.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,InternalSerializeWithSurrogate,The length of the statement  "            obj = DataContractSerializer.SurrogateToDataContractType(_serializationSurrogateProvider' obj' declaredType' ref objType); " is 122.
Long Statement,System.Runtime.Serialization,XmlObjectSerializerWriteContextComplex,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerWriteContextComplex.cs,WriteArraySize,The length of the statement  "                xmlWriter.WriteAttributeInt(Globals.SerPrefix' DictionaryGlobals.ArraySizeLocalName' DictionaryGlobals.SerializationNamespace' size); " is 133.
Long Statement,System.Runtime.Serialization,XmlSerializableServices,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableServices.cs,ReadNodes,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.UnexpectedEndOfFile)); " is 161.
Long Statement,System.Runtime.Serialization,XmlSerializableServices,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlSerializableServices.cs,ReadNodes,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.UnexpectedEndOfFile)); " is 161.
Long Statement,System.Runtime.Serialization,FastInvokerBuilder,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\AccessorBuilder.cs,CreateGetter,The length of the statement  "                var createGetterGeneric = s_createGetterInternal.MakeGenericMethod(propInfo.DeclaringType' propInfo.PropertyType).CreateDelegate<Func<PropertyInfo' Getter>>(); " is 159.
Long Statement,System.Runtime.Serialization,FastInvokerBuilder,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\AccessorBuilder.cs,CreateGetter,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.InvalidMember' DataContract.GetClrTypeFullName(memberInfo.DeclaringType)' memberInfo.Name))); " is 194.
Long Statement,System.Runtime.Serialization,FastInvokerBuilder,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\AccessorBuilder.cs,CreateSetter,The length of the statement  "                    var buildSetAccessorGeneric = s_createSetterInternal.MakeGenericMethod(propInfo.DeclaringType' propInfo.PropertyType).CreateDelegate<Func<PropertyInfo' Setter>>(); " is 163.
Long Statement,System.Runtime.Serialization,FastInvokerBuilder,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\AccessorBuilder.cs,CreateSetter,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.NoSetMethodForProperty' propInfo.DeclaringType' propInfo.Name))); " is 166.
Long Statement,System.Runtime.Serialization,FastInvokerBuilder,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\AccessorBuilder.cs,CreateSetter,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.InvalidMember' DataContract.GetClrTypeFullName(memberInfo.DeclaringType)' memberInfo.Name))); " is 194.
Long Statement,System.Runtime.Serialization,CreateDelegateExtension,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\AccessorBuilder.cs,CreateDelegate,The length of the statement  "                throw new InvalidOperationException(SR.Format(SR.FailedToCreateMethodDelegate' method.Name' method.DeclaringType.FullName)' e); " is 127.
Long Statement,System.Runtime.Serialization,CodeTypeReference,C:\selectedRepos\dotnet_corefx\src\Common\src\System\CodeDom\CodeTypeReference.cs,Initialize,The length of the statement  "                        // System.Collections.Generic.Dictionary`2[[System.string' mscorlib' Version=2.0.0.0' Culture=neutral' PublicKeyToken=b77a5c561934e089]'  " is 136.
Long Statement,System.Runtime.Serialization,CodeTypeReference,C:\selectedRepos\dotnet_corefx\src\Common\src\System\CodeDom\CodeTypeReference.cs,Initialize,The length of the statement  "                        //          [System.Collections.Generic.List`1[[System.Int32' mscorlib' Version=2.0.0.0' Culture=neutral' PublicKeyToken=b77a5c561934e089]]'  " is 140.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,EnsureTypeNotGeneric,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.GenericTypeNotExportable' type))); " is 138.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,InternalAdd,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.DupContractInDataContractSet' dataContract.StableName.Name' dataContract.StableName.Namespace))); " is 198.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,InternalAdd,The length of the statement  "                        bool typeNamesEqual = (DataContract.GetClrTypeFullName(dataContract.UnderlyingType) == DataContract.GetClrTypeFullName(dataContractInSet.UnderlyingType)); " is 154.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,InternalAdd,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.DupTypeContractInDataContractSet' (typeNamesEqual ? dataContract.UnderlyingType.AssemblyQualifiedName : DataContract.GetClrTypeFullName(dataContract.UnderlyingType))' (typeNamesEqual ? dataContractInSet.UnderlyingType.AssemblyQualifiedName : DataContract.GetClrTypeFullName(dataContractInSet.UnderlyingType))' dataContract.StableName.Name' dataContract.StableName.Namespace))); " is 478.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,GetStableName,The length of the statement  "                //    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.GetString(SR.ValueTypeMismatchInSurrogatedType' dcType' clrType))); " is 167.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,GetDataContract,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.GetString(SR.ValueTypeMismatchInSurrogatedType' dcType' clrType))); " is 161.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,GetMemberTypeDataContract,The length of the statement  "                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.GetString(SR.SurrogatesWithGetOnlyCollectionsNotSupported' " is 152.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,GetMemberTypeDataContract,The length of the statement  "                                DataContract.GetClrTypeFullName(dataMemberType)' DataContract.GetClrTypeFullName(dataMember.MemberInfo.DeclaringType)' dataMember.MemberInfo.Name))); " is 149.
Long Statement,System.Runtime.Serialization,DataContractSet,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSet.cs,GetMemberTypeDataContract,The length of the statement  "                    return DataContract.GetGetOnlyCollectionDataContract(DataContract.GetId(dataMemberType.TypeHandle)' dataMemberType.TypeHandle' dataMemberType' SerializationMode.SharedContract); " is 177.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadGetOnlyCollection,The length of the statement  "                resultCollection = ReadCollectionItems(xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract' resultCollection' isReadOnlyCollection); " is 164.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadCollection,The length of the statement  "            return ReflectionReadCollectionCore(xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract); " is 121.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadCollectionCore,The length of the statement  "            if (isArray && ReflectionTryReadPrimitiveArray(xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract.UnderlyingType' collectionContract.ItemType' arraySize' out resultArray)) " is 204.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadCollectionCore,The length of the statement  "                resultCollection = ReadCollectionItems(xmlReader' context' collectionItemName' collectionItemNamespace' collectionContract' resultCollection' isReadOnlyCollection); " is 164.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,GetCollectionReadItemDelegate,The length of the statement  "            if (collectionContract.Kind == CollectionKind.Dictionary || collectionContract.Kind == CollectionKind.GenericDictionary) " is 120.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReadCollectionItems,The length of the statement  "            CollectionSetItemDelegate collectionSetItemDelegate = (CollectionSetItemDelegate)getCollectionSetItemDelegateMethod.Invoke(this' new object[] { collectionContract' resultCollection' isReadOnlyCollection }); " is 206.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadValue,The length of the statement  "            if ((primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType) " is 130.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,GetReflectionReadValueDelegate,The length of the statement  "            if ((primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType) " is 130.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,GetCollectionSetItemDelegate,The length of the statement  "            else if (collectionContract.Kind == CollectionKind.GenericDictionary || collectionContract.Kind == CollectionKind.Dictionary) " is 125.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,GetCollectionSetItemDelegate,The length of the statement  "                Func<object' object> objectToKeyValuePairGetKey = (Func<object' object>)s_objectToKeyValuePairGetKey.MakeGenericMethod(keyType' valueType).CreateDelegate(typeof(Func<object' object>)); " is 184.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,GetCollectionSetItemDelegate,The length of the statement  "                Func<object' object> objectToKeyValuePairGetValue = (Func<object' object>)s_objectToKeyValuePairGetValue.MakeGenericMethod(keyType' valueType).CreateDelegate(typeof(Func<object' object>)); " is 188.
Long Statement,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,GetCollectionSetItemDelegate,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.CollectionMustHaveAddMethod' DataContract.GetClrTypeFullName(collectionContract.UnderlyingType)))); " is 203.
Long Statement,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteValue,The length of the statement  "            bool originValueIsNullableOfT = (memberType.IsGenericType && memberType.GetGenericTypeDefinition() == Globals.TypeOfNullable); " is 126.
Long Statement,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteValue,The length of the statement  "                    ReflectionInternalSerialize(xmlWriter' context' memberValue' memberValue.GetType().TypeHandle.Equals(memberType.TypeHandle)' writeXsiType' memberType); " is 151.
Long Statement,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteValue,The length of the statement  "                    PrimitiveDataContract primitiveContract = originValueIsNullableOfT ? PrimitiveDataContract.GetPrimitiveDataContract(memberType) : primitiveContractForParamType; " is 160.
Long Statement,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteValue,The length of the statement  "                            ReflectionInternalSerialize(xmlWriter' context' memberValue' memberValue.GetType().TypeHandle.Equals(memberType.TypeHandle)' writeXsiType' memberType' originValueIsNullableOfT); " is 177.
Long Statement,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionInternalSerialize,The length of the statement  "                context.InternalSerialize(xmlWriter' obj' isDeclaredType' writeXsiType' DataContract.GetId(memberType.TypeHandle)' memberType.TypeHandle); " is 138.
Long Statement,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionInternalSerialize,The length of the statement  "                context.InternalSerializeReference(xmlWriter' obj' isDeclaredType' writeXsiType' DataContract.GetId(memberType.TypeHandle)' memberType.TypeHandle); " is 147.
Long Statement,System.Runtime.Serialization,ReflectionXmlCollectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatReader.cs,ReflectionReadCollection,The length of the statement  "            return _reflectionReader.ReflectionReadCollection(xmlReader' context' itemName' itemNamespace/*itemNamespace*/' collectionContract); " is 132.
Long Statement,System.Runtime.Serialization,ReflectionXmlReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatReader.cs,ReflectionReadMembers,The length of the statement  "            Debug.Assert(reflectedMemberCount == memberCount' "The value returned by ReflectionGetMembers() should equal to memberCount."); " is 127.
Long Statement,System.Runtime.Serialization,ReflectionXmlReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatReader.cs,ReflectionReadMembers,The length of the statement  "                    memberIndex = context.GetMemberIndexWithRequiredMembers(xmlReader' memberNames' memberNamespaces' memberIndex' requiredIndex' extensionData); " is 141.
Long Statement,System.Runtime.Serialization,ReflectionXmlReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatReader.cs,ReflectionReadDictionaryItem,The length of the statement  "            Debug.Assert(collectionContract.Kind == CollectionKind.Dictionary || collectionContract.Kind == CollectionKind.GenericDictionary); " is 130.
Long Statement,System.Runtime.Serialization,ReflectionXmlFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                PrimitiveDataContract primitiveContractForType = PrimitiveDataContract.GetPrimitiveDataContract(collectionDataContract.UnderlyingType); " is 135.
Long Statement,System.Runtime.Serialization,ReflectionXmlFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                    bool isDictionary = collectionDataContract.Kind == CollectionKind.Dictionary || collectionDataContract.Kind == CollectionKind.GenericDictionary; " is 144.
Long Statement,System.Runtime.Serialization,ReflectionXmlFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                            _reflectionClassWriter.ReflectionWriteValue(xmlWriter' context' elementType' current' false' primitiveContractForParamType: null); " is 130.
Long Statement,System.Runtime.Serialization,ReflectionXmlClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteMembers,The length of the statement  "                ReflectionWriteMembers(xmlWriter' obj' context' classContract.BaseContract' derivedMostClassContract' childElementIndex' emptyStringArray); " is 139.
Long Statement,System.Runtime.Serialization,ReflectionXmlClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteMembers,The length of the statement  "                    if (writeXsiType || !ReflectionTryWritePrimitive(xmlWriter' context' memberType' memberValue' memberNames[i + childElementIndex] /*name*/' ns' primitiveContract)) " is 162.
Long Statement,System.Runtime.Serialization,SchemaHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaHelper.cs,AddSchemaImport,The length of the statement  "            if (SchemaHelper.NamespacesEqual(ns' schema.TargetNamespace) || SchemaHelper.NamespacesEqual(ns' Globals.SchemaNamespace) || SchemaHelper.NamespacesEqual(ns' Globals.SchemaInstanceNamespace)) " is 191.
Long Statement,System.Runtime.Serialization,XPathQueryGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XPathQueryGenerator.cs,ProcessDataContract,The length of the statement  "            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.QueryGeneratorPathToMemberNotFound))); " is 158.
Long Statement,System.Runtime.Serialization,XPathQueryGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XPathQueryGenerator.cs,ProcessClassDataContract,The length of the statement  "                if (member.MemberInfo.Name == memberNode.Name && member.MemberInfo.DeclaringType.IsAssignableFrom(memberNode.DeclaringType)) " is 124.
Long Statement,System.Runtime.Serialization,XPathQueryGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XPathQueryGenerator.cs,ProcessClassDataContract,The length of the statement  "            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.QueryGeneratorPathToMemberNotFound))); " is 158.
Long Statement,System.Runtime.Serialization,ExportContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XPathQueryGenerator.cs,WriteChildToContext,The length of the statement  "                _xPathBuilder.Append(XPathQueryGenerator.XPathSeparator + prefix + XPathQueryGenerator.NsSeparator + contextMember.Name); " is 121.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,Export,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(assemblies))); " is 134.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,Export,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.CannotExportNullAssembly' nameof(assemblies)))); " is 170.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,Export,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(types))); " is 129.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,Export,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.CannotExportNullType' nameof(types)))); " is 161.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,Export,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(type))); " is 128.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,GetSchemaTypeName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(type))); " is 128.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,GetSchemaType,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(type))); " is 128.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,GetRootElementName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(type))); " is 128.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,AddKnownTypes,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.CannotExportNullKnownType))); " is 151.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,CanExport,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(assemblies))); " is 134.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,CanExport,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.CannotExportNullAssembly' nameof(assemblies)))); " is 170.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,CanExport,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(types))); " is 129.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,CanExport,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.CannotExportNullType' nameof(types)))); " is 161.
Long Statement,System.Runtime.Serialization,XsdDataContractExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XsdDataContractExporter.cs,CanExport,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(type))); " is 128.
Long Statement,System.Runtime.Serialization,SurrogateDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SurrogateDataContract.cs,WriteXmlValue,The length of the statement  "            SerializationInfo serInfo = new SerializationInfo(UnderlyingType' XmlObjectSerializer.FormatterConverter' !context.UnsafeTypeForwardingEnabled); " is 144.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 189.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(chars)' SR.Format(SR.XmlArrayTooSmallOutput' count))); " is 180.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,TryGetGuid,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(buffer))); " is 130.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,TryGetGuid,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,TryGetGuid,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' buffer.Length))); " is 190.
Long Statement,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,TryGetGuid,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(buffer)' SR.Format(SR.XmlArrayTooSmallOutput' guidLength))); " is 186.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToType,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException()); " is 120.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToByteArray,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(exception.Message' exception.InnerException)); " is 121.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,GetString,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException()); " is 120.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToObject,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException()); " is 120.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The length of the statement  "            DiagnosticUtility.DebugAssert(offset + count <= chars.Length' string.Format("offset '{0}' + count '{1}' MUST BE <= chars.Length '{2}'"' offset' count' chars.Length)); " is 166.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The length of the statement  "                    // If we're asking for more than are possibly available' or more than are truly available then we can return the entire thing " is 125.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The length of the statement  "                    if (charCount >= encoding.GetMaxCharCount(byteCount) || charCount >= encoding.GetCharCount(bytes' byteOffset' byteCount)) " is 121.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The length of the statement  "                        // codepoints from U+10000 - U+10FFFF (last Unicode codepoint representable in UTF-8) are represented by up to 4 bytes in UTF-8  " is 127.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The length of the statement  "                            // Note the by the time we arrive here' if actualByteCount == 3' the next decoder.GetChars() call will read the 4th byte " is 120.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The length of the statement  "                                    string.Format("byteOffset {0} + actualByteCount {1} MUST BE < bytes.Length {2}"' byteOffset' actualByteCount' bytes.Length)); " is 125.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateEncodingException(bytes' byteOffset' byteCount' exception)); " is 143.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,GetInt64,The length of the statement  "            DiagnosticUtility.DebugAssert(_type == ValueHandleType.Int64 || _type == ValueHandleType.TimeSpan || _type == ValueHandleType.DateTime' ""); " is 140.
Long Statement,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,GetQNameDictionaryText,The length of the statement  "            return string.Concat(PrefixHandle.GetString(PrefixHandle.GetAlphaPrefix(_length))' ":"' _bufferReader.GetDictionaryString(_offset)); " is 132.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddXmlnsAttribute,The length of the statement  "                XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlSpecificBindingPrefix' "xml"' xmlNamespace))); " is 122.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddXmlnsAttribute,The length of the statement  "                XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlSpecificBindingPrefix' "xmlns"' xmlnsNamespace))); " is 126.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetAttributeNode,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(index)' SR.Format(SR.XmlElementAttributes))); " is 171.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetAttributeNode,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(index)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetAttributeNode,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(index)' SR.Format(SR.OffsetExceedsBufferSize' _attributeCount))); " is 191.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetAttributeNode,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(name))); " is 128.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetAttributeNode,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetAttributeNode,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ProcessAttributes,The length of the statement  "                                if (attributeNode2.QNameType == QNameType.Normal && attributeNode1.LocalName == attributeNode2.LocalName && attributeNode1.Namespace.Uri == attributeNode2.Namespace.Uri) " is 169.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ProcessAttributes,The length of the statement  "                                    XmlExceptionHelper.ThrowDuplicateAttribute(this' attributeNode1.Prefix.GetString()' attributeNode2.Prefix.GetString()' attributeNode1.LocalName.GetString()' attributeNode1.Namespace.Uri.GetString()); " is 199.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ProcessAttributes,The length of the statement  "                                    XmlExceptionHelper.ThrowDuplicateAttribute(this' xmlns' xmlns' attributeNode1.Namespace.Prefix.GetString()' xmlnsNamespace); " is 124.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,CheckAttributes,The length of the statement  "                    XmlExceptionHelper.ThrowDuplicateXmlnsAttribute(this' attributeNodes[attribute1].Namespace.Prefix.GetString()' xmlnsNamespace); " is 127.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,CheckAttributes,The length of the statement  "                    XmlExceptionHelper.ThrowDuplicateAttribute(this' attributeNodes[attribute1].Prefix.GetString()' attributeNodes[attribute2].Prefix.GetString()' attributeNodes[attribute1].LocalName.GetString()' attributeNodes[attribute1].Namespace.Uri.GetString()); " is 247.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IsLocalName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IsLocalName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IsStartElement,The length of the statement  "            return (_node.NodeType == XmlNodeType.Element || IsStartElement()) && _node.Prefix == prefix && _node.LocalName == localName; " is 125.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IsStartElement,The length of the statement  "            return (_node.NodeType == XmlNodeType.Element || IsStartElement()) && _node.LocalName == localName && _node.IsNamespaceUri(namespaceUri); " is 137.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IsStartElement,The length of the statement  "            return (_node.NodeType == XmlNodeType.Element || IsStartElement()) && _node.LocalName == localName && _node.IsNamespaceUri(namespaceUri); " is 137.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IndexOfLocalName,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "localNames[{0}]"' i)); " is 161.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IndexOfLocalName,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "localNames[{0}]"' i)); " is 161.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IndexOfLocalName,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "localNames[{0}]"' i)); " is 161.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,IndexOfLocalName,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "localNames[{0}]"' i)); " is 161.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueChunk,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueChunk,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueChunk,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 189.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueChunk,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueChunk,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - offset))); " is 205.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(buffer))); " is 130.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' buffer.Length))); " is 190.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' buffer.Length - offset))); " is 206.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadEndElement,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlEndElementNoOpenNodes))); " is 158.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadEndElement,The length of the statement  "                XmlExceptionHelper.ThrowEndElementExpected(this' elementNode.LocalName.GetString()' elementNode.Namespace.Uri.GetString()); " is 123.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The length of the statement  "            return ReadContentAsBase64(_quotas.MaxArrayLength' XmlDictionaryReader.MaxInitialArrayLength);  // Initial count will get ignored " is 129.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(buffer))); " is 130.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' buffer.Length))); " is 190.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' buffer.Length - offset))); " is 206.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,The length of the statement  "                        // When deserializing base64 content which contains new line chars (CR' LF) chars from ReadObject' the reader reads in chunks of base64 content' LF char' base64 content' LF char and so on " is 187.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,The length of the statement  "                        // Relying on encoding.GetBytes' exception to handle LF char would result in performance degradation so skipping LF char here " is 125.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,The length of the statement  "                        throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(exception.Message' exception.InnerException)); " is 121.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ResolveEntity,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidOperation))); " is 153.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadDecimalArray,The length of the statement  "            return DecimalArrayHelperWithDictionaryString.Instance.ReadArray(this' localName' namespaceUri' _quotas.MaxArrayLength); " is 120.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadDateTimeArray,The length of the statement  "            return DateTimeArrayHelperWithDictionaryString.Instance.ReadArray(this' localName' namespaceUri' _quotas.MaxArrayLength); " is 121.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadTimeSpanArray,The length of the statement  "            return TimeSpanArrayHelperWithDictionaryString.Instance.ReadArray(this' localName' namespaceUri' _quotas.MaxArrayLength); " is 121.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,SignAttribute,The length of the statement  "                writer.WriteStartAttribute(prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength); " is 120.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,StartCanonicalization,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlCanonicalizationStarted))); " is 131.
Long Statement,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,EndCanonicalization,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlCanonicalizationNotStarted))); " is 134.
Long Statement,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlReservedPrefix)' nameof(prefix))); " is 159.
Long Statement,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlPrefixBoundToNamespace' prefix' nameSpace.Uri' uri)' nameof(prefix))); " is 195.
Long Statement,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlEmptyNamespaceRequiresNullPrefix)' nameof(prefix))); " is 177.
Long Statement,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlSpecificBindingNamespace' "xmlns"' uri))); " is 167.
Long Statement,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlSpecificBindingNamespace' "xml"' uri))); " is 165.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,ThrowClosed,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlWriterClosed))); " is 149.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteXmlnsAttribute"' WriteState.ToString()))); " is 200.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteXmlnsAttribute"' WriteState.ToString()))); " is 200.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteStartAttribute"' WriteState.ToString()))); " is 200.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlPrefixBoundToNamespace' "xml"' xmlNamespace' ns)' nameof(ns))); " is 188.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlPrefixBoundToNamespace' "xmlns"' xmlnsNamespace' ns)' nameof(ns))); " is 192.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlUndefinedPrefix' prefix)' nameof(prefix))); " is 168.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlEmptyNamespaceRequiresNullPrefix)' nameof(prefix))); " is 177.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlSpecificBindingNamespace' "xmlns"' ns))); " is 166.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartAttribute,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlSpecificBindingNamespace' "xml"' ns))); " is 164.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteStartAttribute,The length of the statement  "            StartAttribute(ref prefix' (localName != null ? localName.Value : null)' (namespaceUri != null ? namespaceUri.Value : null)' namespaceUri); " is 139.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEndAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteEndAttribute"' WriteState.ToString()))); " is 198.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEndAttribute,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlInvalidXmlSpace' _attributeValue))); " is 161.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEndAttributeAsync,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteEndAttribute"' WriteState.ToString()))); " is 169.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEndAttributeAsyncImpl,The length of the statement  "                            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlInvalidXmlSpace' _attributeValue))); " is 132.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteComment,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteComment"' WriteState.ToString()))); " is 193.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteComment,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlInvalidCommentChars)' nameof(text))); " is 162.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteFullEndElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteFullEndElement"' WriteState.ToString()))); " is 200.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteCData,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteCData"' WriteState.ToString()))); " is 191.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteDocType,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.XmlMethodNotSupported' "WriteDocType"))); " is 167.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlOnlyOneRoot))); " is 148.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.InvalidLocalNameEmpty)' nameof(localName))); " is 166.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteStartElement"' WriteState.ToString()))); " is 198.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartElement,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlUndefinedPrefix' prefix)' nameof(prefix))); " is 168.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,PreStartElementAsyncCheck,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.InvalidLocalNameEmpty)' nameof(localName))); " is 137.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,PreStartElementAsyncCheck,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteStartElement"' WriteState.ToString()))); " is 169.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartElementAsync,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlUndefinedPrefix' prefix)' nameof(prefix))); " is 139.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteStartElement,The length of the statement  "            StartElement(ref prefix' (localName != null ? localName.Value : null)' (namespaceUri != null ? namespaceUri.Value : null)' namespaceUri); " is 137.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEndElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidDepth' "WriteEndElement"' _depth.ToString(CultureInfo.InvariantCulture)))); " is 215.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEndElementAsync,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidDepth' "WriteEndElement"' _depth.ToString(CultureInfo.InvariantCulture)))); " is 186.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartContent,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlIllegalOutsideRoot))); " is 155.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartContentAsync,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlIllegalOutsideRoot))); " is 126.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,VerifyWhitespace,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlIllegalOutsideRoot))); " is 155.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,VerifyWhitespace,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlIllegalOutsideRoot))); " is 155.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,VerifyWhitespace,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlIllegalOutsideRoot))); " is 155.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,LookupPrefix,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(ns))); " is 126.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,GetQualifiedNamePrefix,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlNamespaceNotFound' namespaceUri)' nameof(namespaceUri))); " is 182.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteQualifiedName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteQualifiedName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.InvalidLocalNameEmpty)' nameof(localName))); " is 166.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteQualifiedName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteQualifiedName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.InvalidLocalNameEmpty)' nameof(localName))); " is 166.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteStartDocument,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteStartDocument"' WriteState.ToString()))); " is 199.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteProcessingInstruction,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlProcessingInstructionNotSupported)' nameof(name))); " is 176.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteProcessingInstruction,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidDeclaration))); " is 155.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEndDocument,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlNoRootElement))); " is 150.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteEntityRef,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.XmlMethodNotSupported' "WriteEntityRef"))); " is 169.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteNmToken,The length of the statement  "            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.XmlMethodNotSupported' "WriteNmToken"))); " is 167.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteWhitespace,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlOnlyWhitespace)' nameof(whitespace))); " is 163.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - offset))); " is 205.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteRaw,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteRaw,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteRaw,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteRaw,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - offset))); " is 205.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteCharEntity,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlMissingLowSurrogate)' nameof(ch))); " is 160.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value))); " is 129.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WritePrimitiveValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value))); " is 129.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WritePrimitiveValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlNestedArraysNotSupported)' nameof(value))); " is 168.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(buffer))); " is 130.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' buffer.Length - offset))); " is 206.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64Async,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 145.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64Async,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 144.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64Async,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' buffer.Length - offset))); " is 177.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64AsyncImpl,The length of the statement  "                        await _writer.WriteBase64TextAsync(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount).ConfigureAwait(false); " is 138.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartCanonicalization,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlCanonicalizationStarted))); " is 131.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,EndCanonicalization,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlCanonicalizationNotStarted))); " is 134.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlOnlyOneRoot))); " is 148.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlOnlyOneRoot))); " is 148.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,StartArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidWriteState' "WriteStartElement"' WriteState.ToString()))); " is 198.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,GeneratePrefix,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidPrefixState' WriteState.ToString()))); " is 178.
Long Statement,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,GeneratePrefix,The length of the statement  "                prefix = string.Concat("d"' _depth.ToString(CultureInfo.InvariantCulture)' "p"' prefixId.ToString(CultureInfo.InvariantCulture)); " is 129.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' buffer.Length))); " is 190.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' buffer.Length - offset))); " is 206.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialUTF8Text,The length of the statement  "                XmlBinaryNodeType nodeType = (withEndElement ? XmlBinaryNodeType.Chars32TextWithEndElement : XmlBinaryNodeType.Chars32Text); " is 124.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialUnicodeText,The length of the statement  "                XmlBinaryNodeType nodeType = (withEndElement ? XmlBinaryNodeType.UnicodeChars32TextWithEndElement : XmlBinaryNodeType.UnicodeChars32Text); " is 138.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialBinaryText,The length of the statement  "                XmlBinaryNodeType nodeType = (withEndElement ? XmlBinaryNodeType.Bytes32TextWithEndElement : XmlBinaryNodeType.Bytes32Text); " is 124.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,IsStartArray,The length of the statement  "            return IsStartElement(localName' namespaceUri) && _arrayState == ArrayState.Element && _arrayNodeType == nodeType && !Signing; " is 126.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,IsStartArray,The length of the statement  "            return IsStartElement(localName' namespaceUri) && _arrayState == ArrayState.Element && _arrayNodeType == nodeType && !Signing; " is 126.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(array))); " is 129.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' array.Length))); " is 189.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' array.Length - offset))); " is 205.
Long Statement,System.Xml,XmlBinaryReaderSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReaderSession.cs,Add,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(id)' SR.Format(SR.XmlInvalidID))); " is 160.
Long Statement,System.Xml,XmlBinaryReaderSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReaderSession.cs,Add,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlIDDefined))); " is 146.
Long Statement,System.Xml,XmlBinaryReaderSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReaderSession.cs,Add,The length of the statement  "                    XmlDictionaryString[] newStrings = new XmlDictionaryString[Math.Min(Math.Max(id + 1' _strings.Length * 2)' MaxArrayEntries)]; " is 125.
Long Statement,System.Xml,XmlBinaryReaderSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReaderSession.cs,TryLookup,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value))); " is 129.
Long Statement,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WroteAttributeValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlOnlySingleValue))); " is 152.
Long Statement,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNode,The length of the statement  "            DiagnosticUtility.DebugAssert(nodeType >= XmlBinaryNodeType.MinText && nodeType <= XmlBinaryNodeType.MaxText && ((byte)nodeType & 1) == 0' "Invalid nodeType"); " is 159.
Long Statement,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The length of the statement  "            DiagnosticUtility.DebugAssert(nodeType == XmlBinaryNodeType.Chars8Text || nodeType == XmlBinaryNodeType.Bytes8Text || nodeType == XmlBinaryNodeType.UnicodeChars8Text' ""); " is 171.
Long Statement,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteEndElement,The length of the statement  "                DiagnosticUtility.DebugAssert(nodeType >= XmlBinaryNodeType.MinText && nodeType <= XmlBinaryNodeType.MaxText && ((byte)nodeType & 1) == 0' ""); " is 143.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,SetOutput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(stream))); " is 130.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(array))); " is 129.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' array.Length))); " is 189.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' array.Length - offset))); " is 205.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.BoolTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 135.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.BoolTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 135.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.Int16TextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.Int16TextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.Int32TextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.Int32TextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.Int64TextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.Int64TextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.FloatTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.FloatTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 136.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.DoubleTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 137.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.DoubleTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 137.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.DecimalTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 138.
Long Statement,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteArray,The length of the statement  "                        UnsafeWriteArray(prefix' localName' namespaceUri' XmlBinaryNodeType.DecimalTextWithEndElement' count' (byte*)items' (byte*)&items[count]); " is 138.
Long Statement,System.Xml,XmlBinaryWriterSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriterSession.cs,TryAdd,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlKeyAlreadyExists))); " is 153.
Long Statement,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDateTime,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value.ToString(CultureInfo.InvariantCulture)' "DateTime"' exception)); " is 173.
Long Statement,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDateTime,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value.ToString(CultureInfo.InvariantCulture)' "DateTime"' exception)); " is 173.
Long Statement,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDateTime,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value.ToString(CultureInfo.InvariantCulture)' "DateTime"' exception)); " is 173.
Long Statement,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadTimeSpan,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value.ToString(CultureInfo.InvariantCulture)' "TimeSpan"' exception)); " is 173.
Long Statement,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadTimeSpan,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value.ToString(CultureInfo.InvariantCulture)' "TimeSpan"' exception)); " is 173.
Long Statement,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadTimeSpan,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value.ToString(CultureInfo.InvariantCulture)' "TimeSpan"' exception)); " is 173.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToBoolean,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Boolean"' exception)); " is 133.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToBoolean,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Boolean"' exception)); " is 133.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Int32"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Int32"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Int32"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Int64"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Int64"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Int64"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToSingle,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "float"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToSingle,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "float"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToSingle,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "float"' exception)); " is 131.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDouble,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "double"' exception)); " is 132.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDouble,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "double"' exception)); " is 132.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDouble,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "double"' exception)); " is 132.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDecimal,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "decimal"' exception)); " is 133.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDecimal,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "decimal"' exception)); " is 133.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDecimal,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "decimal"' exception)); " is 133.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDateTime,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(ToString(value)' "DateTime"' exception)); " is 144.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDateTime,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "DateTime"' exception)); " is 134.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToDateTime,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "DateTime"' exception)); " is 134.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToUniqueId,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "UniqueId"' exception)); " is 134.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToUniqueId,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "UniqueId"' exception)); " is 134.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToTimeSpan,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "TimeSpan"' exception)); " is 134.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToTimeSpan,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "TimeSpan"' exception)); " is 134.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToTimeSpan,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "TimeSpan"' exception)); " is 134.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Guid"' exception)); " is 130.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Guid"' exception)); " is 130.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToGuid,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "Guid"' exception)); " is 130.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToUInt64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "UInt64"' exception)); " is 132.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToUInt64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "UInt64"' exception)); " is 132.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToUInt64,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(value' "UInt64"' exception)); " is 132.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToString,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateEncodingException(buffer' offset' count' exception)); " is 136.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToStringUnicode,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateEncodingException(buffer' offset' count' exception)); " is 136.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToBytes,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateEncodingException(value' exception)); " is 120.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateEncodingException(buffer' offset' count' exception)); " is 136.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToQualifiedName,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.XmlInvalidQualifiedName' qname))); " is 122.
Long Statement,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException()); " is 120.
Long Statement,System.Xml,XmlDictionary,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionary.cs,TryLookup,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value))); " is 129.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteXmlnsAttribute,The length of the statement  "                prefix = namespaceUri.Length == 0 ? string.Empty : string.Concat("d"' namespaceUri.Length.ToString(System.Globalization.NumberFormatInfo.InvariantInfo)); " is 153.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteQualifiedName,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(localName))); " is 133.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value))); " is 129.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteValue,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(SR.Format(SR.XmlInvalidStream))); " is 137.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteElementNode,The length of the statement  "            if (reader.TryGetLocalNameAsDictionaryString(out localName) && reader.TryGetNamespaceUriAsDictionaryString(out namespaceUri)) " is 125.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteElementNode,The length of the statement  "                        if (reader.TryGetLocalNameAsDictionaryString(out localName) && reader.TryGetNamespaceUriAsDictionaryString(out namespaceUri)) " is 125.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArrayNode,The length of the statement  "            if (reader.TryGetLocalNameAsDictionaryString(out localName) && reader.TryGetNamespaceUriAsDictionaryString(out namespaceUri)) " is 125.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteNode,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(reader))); " is 130.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteNode,The length of the statement  "                if (nodeType == XmlNodeType.Text || nodeType == XmlNodeType.Whitespace || nodeType == XmlNodeType.SignificantWhitespace) " is 120.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(array))); " is 129.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' array.Length))); " is 189.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' array.Length - offset))); " is 205.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteArray,The length of the statement  "            WriteArray(prefix' XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 128.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,IndexOfLocalName,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "localNames[{0}]"' i)); " is 161.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,IndexOfLocalName,The length of the statement  "                        throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "localNames[{0}]"' i)); " is 161.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadString,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidOperation))); " is 153.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadString,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.XmlInvalidOperation))); " is 153.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsString,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "strings[{0}]"' i)); " is 158.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsString,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperArgumentNull(string.Format(CultureInfo.InvariantCulture' "strings[{0}]"' i)); " is 158.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadElementContentAsDateTime,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(string.Empty' "DateTime"' exception)); " is 141.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadElementContentAsDateTime,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(string.Empty' "DateTime"' exception)); " is 141.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadElementContentAsUniqueId,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(string.Empty' "UniqueId"' exception)); " is 141.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadElementContentAsUniqueId,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(string.Empty' "UniqueId"' exception)); " is 141.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadElementContentAsGuid,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(string.Empty' "Guid"' exception)); " is 137.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadElementContentAsGuid,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(string.Empty' "Guid"' exception)); " is 137.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadElementContentAsGuid,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException(string.Empty' "Guid"' exception)); " is 137.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(array))); " is 129.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' array.Length))); " is 189.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,CheckArray,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' array.Length - offset))); " is 205.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadDateTimeArray,The length of the statement  "            return DateTimeArrayHelperWithDictionaryString.Instance.ReadArray(this' localName' namespaceUri' Quotas.MaxArrayLength); " is 120.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadTimeSpanArray,The length of the statement  "            return TimeSpanArrayHelperWithDictionaryString.Instance.ReadArray(this' localName' namespaceUri' Quotas.MaxArrayLength); " is 120.
Long Statement,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadArray,The length of the statement  "            return ReadArray(XmlDictionaryString.GetString(localName)' XmlDictionaryString.GetString(namespaceUri)' array' offset' count); " is 126.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsBoolean,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Boolean"' exception)); " is 126.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsBoolean,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Boolean"' exception)); " is 126.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsDecimal,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Decimal"' exception)); " is 126.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsDecimal,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Decimal"' exception)); " is 126.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsDecimal,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Decimal"' exception)); " is 126.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsDouble,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Double"' exception)); " is 125.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsDouble,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Double"' exception)); " is 125.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsDouble,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Double"' exception)); " is 125.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsInt,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Int32"' exception)); " is 124.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsInt,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Int32"' exception)); " is 124.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsInt,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Int32"' exception)); " is 124.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsLong,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Int64"' exception)); " is 124.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsLong,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Int64"' exception)); " is 124.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsLong,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Int64"' exception)); " is 124.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsFloat,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Single"' exception)); " is 125.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsFloat,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Single"' exception)); " is 125.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsFloat,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("Single"' exception)); " is 125.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsString,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("String"' exception)); " is 125.
Long Statement,System.Xml,XmlWrappedReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsString,The length of the statement  "                    throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateConversionException("String"' exception)); " is 125.
Long Statement,System.Xml,XmlDictionaryReaderQuotas,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReaderQuotas.cs,CopyTo,The length of the statement  "                throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidOperationException(SR.Format(SR.QuotaCopyReadOnly))); " is 122.
Long Statement,System.Xml,EmptyStringDictionary,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryString.cs,TryLookup,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(value))); " is 129.
Long Statement,System.Xml,XmlExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlExceptionHelper.cs,ThrowMaxStringContentLengthExceeded,The length of the statement  "            ThrowXmlException(reader' SR.XmlMaxStringContentLengthExceeded' maxStringContentLength.ToString(NumberFormatInfo.CurrentInfo)); " is 127.
Long Statement,System.Xml,XmlExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlExceptionHelper.cs,ThrowTagMismatch,The length of the statement  "            ThrowXmlException(reader' SR.XmlTagMismatch' GetName(expectedPrefix' expectedLocalName)' GetName(foundPrefix' foundLocalName)); " is 127.
Long Statement,System.Xml,XmlExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlExceptionHelper.cs,ThrowXmlDictionaryStringIDOutOfRange,The length of the statement  "            ThrowXmlException(reader' SR.XmlDictionaryStringIDRange' XmlDictionaryString.MinKey.ToString(NumberFormatInfo.CurrentInfo)' XmlDictionaryString.MaxKey.ToString(NumberFormatInfo.CurrentInfo)); " is 191.
Long Statement,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteStartElement,The length of the statement  "            WriteStartElement(Encoding.UTF8.GetString(prefixBuffer' prefixOffset' prefixLength)' Encoding.UTF8.GetString(localNameBuffer' localNameOffset' localNameLength)); " is 161.
Long Statement,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteEndElement,The length of the statement  "            WriteEndElement(Encoding.UTF8.GetString(prefixBuffer' prefixOffset' prefixLength)' Encoding.UTF8.GetString(localNameBuffer' localNameOffset' localNameLength)); " is 159.
Long Statement,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteXmlnsAttribute,The length of the statement  "            WriteXmlnsAttribute(Encoding.UTF8.GetString(prefixBuffer' prefixOffset' prefixLength)' Encoding.UTF8.GetString(nsBuffer' nsOffset' nsLength)); " is 142.
Long Statement,System.Xml,XmlNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlNodeWriter.cs,WriteStartAttribute,The length of the statement  "            WriteStartAttribute(Encoding.UTF8.GetString(prefixBuffer' prefixOffset' prefixLength)' Encoding.UTF8.GetString(localNameBuffer' localNameOffset' localNameLength)); " is 163.
Long Statement,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(buffer))); " is 130.
Long Statement,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(offset)' SR.Format(SR.OffsetExceedsBufferSize' buffer.Length))); " is 190.
Long Statement,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,SetInput,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' buffer.Length - offset))); " is 206.
Long Statement,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadEndElement,The length of the statement  "                    XmlExceptionHelper.ThrowTagMismatch(this' elementNode.Prefix.GetString()' elementNode.LocalName.GetString()' _prefix.GetString()' _localName.GetString()); " is 154.
Long Statement,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadText,The length of the statement  "            if (offset < offsetMax - 1 - length && (buffer[offset + length] == (byte)'<' && buffer[offset + length + 1] != (byte)'!')) " is 122.
Long Statement,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CheckUTF8DeclarationEncoding,The length of the statement  "                    ThrowEncodingMismatch(s_safeUTF8.GetString(buffer' encStart' encCount)' s_safeUTF8.GetString(s_encodingUTF8' 0' s_encodingUTF8.Length)); " is 136.
Long Statement,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ProcessBuffer,The length of the statement  "                SupportedEncoding declEnc = ReadBOMEncoding(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]' encoding == null' out preserve); " is 152.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("prefixBuffer")); " is 130.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixOffset"' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixOffset"' SR.Format(SR.OffsetExceedsBufferSize' prefixBuffer.Length))); " is 196.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixLength"' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixLength"' SR.Format(SR.SizeExceedsRemainingBufferSpace' prefixBuffer.Length - prefixOffset))); " is 219.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("localNameBuffer")); " is 133.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameOffset"' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameOffset"' SR.Format(SR.OffsetExceedsBufferSize' localNameBuffer.Length))); " is 202.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameLength"' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameLength"' SR.Format(SR.SizeExceedsRemainingBufferSpace' localNameBuffer.Length - localNameOffset))); " is 228.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartElement,The length of the statement  "            _elementWriter.WriteStartElement(prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength); " is 126.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,IsInclusivePrefix,The length of the statement  "                    if (String.Compare(Encoding.UTF8.GetString(_xmlnsBuffer' xmlnsAttribute.prefixOffset' xmlnsAttribute.prefixLength)' _inclusivePrefixes[i]' StringComparison.Ordinal) == 0) " is 170.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEndStartElement,The length of the statement  "            _writer.WriteStartElement(_elementBuffer' _element.prefixOffset' _element.prefixLength' _elementBuffer' _element.localNameOffset' _element.localNameLength); " is 156.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEndStartElement,The length of the statement  "                    if (Equals(_xmlnsBuffer' _xmlnsAttributes[i].prefixOffset' _xmlnsAttributes[i].prefixLength' _xmlnsBuffer' _xmlnsAttributes[j].prefixOffset' _xmlnsAttributes[j].prefixLength)) " is 175.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEndStartElement,The length of the statement  "                        if (Equals(_xmlnsBuffer' _xmlnsAttributes[i].nsOffset' _xmlnsAttributes[i].nsLength' _xmlnsBuffer' _xmlnsAttributes[j].nsOffset' _xmlnsAttributes[j].nsLength)) " is 159.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEndStartElement,The length of the statement  "                _writer.WriteEndElement(_elementBuffer' _element.prefixOffset' _element.prefixLength' _elementBuffer' _element.localNameOffset' _element.localNameLength); " is 154.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("ns"' SR.Format(SR.CombinedPrefixNSLength' int.MaxValue / maxBytesPerChar))); " is 196.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("ns"' SR.Format(SR.CombinedPrefixNSLength' int.MaxValue / maxBytesPerChar))); " is 196.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("prefixBuffer")); " is 130.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixOffset"' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixOffset"' SR.Format(SR.OffsetExceedsBufferSize' prefixBuffer.Length))); " is 196.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixLength"' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixLength"' SR.Format(SR.SizeExceedsRemainingBufferSpace' prefixBuffer.Length - prefixOffset))); " is 219.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("nsBuffer")); " is 126.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("nsOffset"' SR.Format(SR.ValueMustBeNonNegative))); " is 170.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("nsOffset"' SR.Format(SR.OffsetExceedsBufferSize' nsBuffer.Length))); " is 188.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("nsLength"' SR.Format(SR.ValueMustBeNonNegative))); " is 170.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("nsLength"' SR.Format(SR.SizeExceedsRemainingBufferSpace' nsBuffer.Length - nsOffset))); " is 207.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("nsLength"' SR.Format(SR.CombinedPrefixNSLength' int.MaxValue))); " is 184.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "            _attribute.localNameOffset = _attribute.prefixOffset + _attribute.prefixLength + (_attribute.prefixLength != 0 ? 1 : 0); " is 120.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("prefixBuffer")); " is 130.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixOffset"' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixOffset"' SR.Format(SR.OffsetExceedsBufferSize' prefixBuffer.Length))); " is 196.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixLength"' SR.Format(SR.ValueMustBeNonNegative))); " is 174.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("prefixLength"' SR.Format(SR.SizeExceedsRemainingBufferSpace' prefixBuffer.Length - prefixOffset))); " is 219.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("localNameBuffer")); " is 133.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameOffset"' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameOffset"' SR.Format(SR.OffsetExceedsBufferSize' localNameBuffer.Length))); " is 202.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameLength"' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("localNameLength"' SR.Format(SR.SizeExceedsRemainingBufferSpace' localNameBuffer.Length - localNameOffset))); " is 228.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteStartAttribute,The length of the statement  "            _elementWriter.WriteStartAttribute(prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength); " is 128.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEscapedText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("chars")); " is 123.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEscapedText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset"' SR.Format(SR.ValueMustBeNonNegative))); " is 168.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEscapedText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset"' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 183.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEscapedText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count"' SR.Format(SR.ValueMustBeNonNegative))); " is 167.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteEscapedText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count"' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - offset))); " is 199.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("chars")); " is 123.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset"' SR.Format(SR.ValueMustBeNonNegative))); " is 168.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset"' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 183.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count"' SR.Format(SR.ValueMustBeNonNegative))); " is 167.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count"' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - offset))); " is 199.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("value")); " is 123.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException("chars")); " is 123.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset"' SR.Format(SR.ValueMustBeNonNegative))); " is 168.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("offset"' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 183.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count"' SR.Format(SR.ValueMustBeNonNegative))); " is 167.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteText,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException("count"' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - offset))); " is 199.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,WriteXmlnsAttribute,The length of the statement  "                _writer.WriteXmlnsAttribute(_xmlnsBuffer' xmlnsAttribute.prefixOffset' xmlnsAttribute.prefixLength' _xmlnsBuffer' xmlnsAttribute.nsOffset' xmlnsAttribute.nsLength); " is 164.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,AddXmlnsAttribute,The length of the statement  "            //            Console.WriteLine("{0}={1}"' Encoding.UTF8.GetString(xmlnsBuffer' xmlnsAttribute.prefixOffset' xmlnsAttribute.prefixLength)'  " is 138.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,AddXmlnsAttribute,The length of the statement  "            //                                Encoding.UTF8.GetString(xmlnsBuffer' xmlnsAttribute.nsOffset' xmlnsAttribute.nsLength)); " is 122.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,AddXmlnsAttribute,The length of the statement  "                    Array.Copy(_xmlnsAttributes' xmlnsAttributeIndex' _xmlnsAttributes' xmlnsAttributeIndex + 1' _xmlnsAttributeCount - xmlnsAttributeIndex); " is 137.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Compare,The length of the statement  "            //            Console.WriteLine("Compare: \"{0}\"' \"{1}\""' Encoding.UTF8.GetString(sourceBuffer' offset1' length1)' Encoding.UTF8.GetString(sourceBuffer' offset2' length2)); " is 175.
Long Statement,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Equals,The length of the statement  "            //            Console.WriteLine("Equals: \"{0}\"' \"{1}\""' Encoding.UTF8.GetString(buffer1' offset1' length1)' Encoding.UTF8.GetString(buffer2' offset2' length2)); " is 164.
Long Statement,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteStartElement,The length of the statement  "            _signingWriter.WriteStartElement(prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength); " is 126.
Long Statement,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteStartAttribute,The length of the statement  "            _writer.WriteStartAttribute(prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength); " is 121.
Long Statement,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteStartAttribute,The length of the statement  "            _signingWriter.WriteStartAttribute(prefixBuffer' prefixOffset' prefixLength' localNameBuffer' localNameOffset' localNameLength); " is 128.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charCount)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' charCount.ToString(NumberFormatInfo.CurrentInfo)))); " is 196.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(index)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(index)' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 188.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.ValueMustBeNonNegative))); " is 173.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - index))); " is 204.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' count.ToString(NumberFormatInfo.CurrentInfo)))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars)))); " is 200.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The length of the statement  "                            throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars)))); " is 200.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charCount)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charCount)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - charIndex))); " is 212.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(bytes))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.OffsetExceedsBufferSize' bytes.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' charCount.ToString(NumberFormatInfo.CurrentInfo)))); " is 196.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars)))); " is 204.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars)))); " is 204.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes))); " is 157.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charCount)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charCount)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - charIndex))); " is 212.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(bytes))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.OffsetExceedsBufferSize' bytes.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' charCount.ToString(NumberFormatInfo.CurrentInfo)))); " is 196.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars)))); " is 186.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars)))); " is 186.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The length of the statement  "                                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes))); " is 157.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 4 * 3 - 2))); " is 202.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(bytes))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.OffsetExceedsBufferSize' bytes.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.SizeExceedsRemainingBufferSpace' bytes.Length - byteIndex))); " is 212.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(chars))); " is 157.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(bytes))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteIndex)' SR.Format(SR.OffsetExceedsBufferSize' bytes.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.SizeExceedsRemainingBufferSpace' bytes.Length - byteIndex))); " is 212.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentNullException(nameof(chars))); " is 129.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.ValueMustBeNonNegative))); " is 177.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(charIndex)' SR.Format(SR.OffsetExceedsBufferSize' chars.Length))); " is 192.
Long Statement,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(chars))); " is 157.
Long Statement,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(charCount)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - charIndex)); " is 130.
Long Statement,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The length of the statement  "                                    throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars))); " is 122.
Long Statement,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The length of the statement  "                                    throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars))); " is 122.
Long Statement,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetChars,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.SizeExceedsRemainingBufferSpace' bytes.Length - byteIndex)); " is 130.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalReadObject,The length of the statement  "                    throw XmlObjectSerializer.CreateSerializationExceptionWithReaderDetails(SR.Format(SR.ExpectingElement' XmlDictionaryString.Empty' RootName)' xmlReader); " is 152.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalReadObject,The length of the statement  "                throw XmlObjectSerializer.CreateSerializationExceptionWithReaderDetails(SR.Format(SR.ExpectingElementAtDeserialize' XmlNodeType.Element)' xmlReader); " is 149.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalReadObject,The length of the statement  "            if (contract.IsPrimitive && object.ReferenceEquals(contract.UnderlyingType' _rootType))// handle Nullable<T> differently " is 120.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalReadObject,The length of the statement  "            XmlObjectSerializerReadContextComplexJson context = XmlObjectSerializerReadContextComplexJson.CreateContext(this' contract); " is 124.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalWriteObjectContent,The length of the statement  "            //    graph = DataContractSerializer.SurrogateToDataContractType(dataContractSurrogate' graph' declaredType' ref graphType); " is 124.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalWriteObjectContent,The length of the statement  "                        XmlObjectSerializerWriteContextComplexJson context = XmlObjectSerializerWriteContextComplexJson.CreateContext(this' contract); " is 126.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalWriteObjectContent,The length of the statement  "                        DataContractJsonSerializerImpl.WriteJsonValue(JsonDataContract.GetJsonDataContract(contract)' writer' graph' null' declaredType.TypeHandle); //  XmlObjectSerializerWriteContextComplexJson " is 187.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,InternalWriteObjectContent,The length of the statement  "                    XmlObjectSerializerWriteContextComplexJson context = XmlObjectSerializerWriteContextComplexJson.CreateContext(this' RootContract); " is 130.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,Initialize,The length of the statement  "            Initialize(type' knownTypes' maxItemsInObjectGraph' ignoreExtensionDataObject' emitTypeInformation' serializeReadOnlyTypes' dateTimeFormat' useSimpleDictionaryFormat); " is 167.
Long Statement,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,CheckIfTypeIsReference,The length of the statement  "                throw XmlObjectSerializer.CreateSerializationException(SR.Format(SR.JsonUnsupportedForIsReference' DataContract.GetClrTypeFullName(dataContract.UnderlyingType)' dataContract.IsReference)); " is 188.
Long Statement,System.Runtime.Serialization.Json,JsonClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonClassDataContract.cs,CopyMembersAndCheckDuplicateNames,The length of the statement  "                            throw new SerializationException(SR.Format(SR.JsonDuplicateMemberNames' DataContract.GetClrTypeFullName(_traditionalClassDataContract.UnderlyingType)' _traditionalClassDataContract.MemberNames[i].Value)); " is 204.
Long Statement,System.Runtime.Serialization.Json,JsonClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonClassDataContract.cs,CopyMembersAndCheckDuplicateNames,The length of the statement  "                            decodedMemberNames[i] = DataContractJsonSerializerImpl.ConvertXmlNameToJsonName(_traditionalClassDataContract.MemberNames[i]); " is 126.
Long Statement,System.Runtime.Serialization.Json,JsonCollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonCollectionDataContract.cs,ReadJsonValueCore,The length of the statement  "                JsonFormatGetOnlyReaderDelegate(jsonReader' context' XmlDictionaryString.Empty' JsonGlobals.itemDictionaryString' TraditionalCollectionDataContract); " is 149.
Long Statement,System.Runtime.Serialization.Json,JsonCollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonCollectionDataContract.cs,ReadJsonValueCore,The length of the statement  "                o = JsonFormatReaderDelegate(jsonReader' context' XmlDictionaryString.Empty' JsonGlobals.itemDictionaryString' TraditionalCollectionDataContract); " is 146.
Long Statement,System.Runtime.Serialization.Json,JsonDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonDataContract.cs,CreateJsonDataContract,The length of the statement  "                            throw new ArgumentException(SR.Format(SR.JsonTypeNotSupportedByDataContractJsonSerializer' traditionalDataContract.UnderlyingType)' nameof(traditionalDataContract)); " is 165.
Long Statement,System.Runtime.Serialization.Json,JsonDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonDataContract.cs,AddCollectionItemContractsToKnownDataContracts,The length of the statement  "                                    DataContract itemDataContract = DataContract.GetDataContract(Globals.TypeOfKeyValuePair.MakeGenericType(collectionDataContract.ItemType.GenericTypeArguments)); " is 159.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateClassWriter,The length of the statement  "                    BeginMethod(_ilg' "Write" + DataContract.SanitizeTypeName(classContract.StableName.Name) + "ToJson"' typeof(JsonFormatClassWriterDelegate)' memberAccessFlag); " is 158.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateCollectionWriter,The length of the statement  "                    BeginMethod(_ilg' "Write" + DataContract.SanitizeTypeName(collectionContract.StableName.Name) + "ToJson"' typeof(JsonFormatCollectionWriterDelegate)' memberAccessFlag); " is 168.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,BeginMethod,The length of the statement  "                DynamicMethod dynamicMethod = new DynamicMethod(methodName' signature.ReturnType' paramTypes' typeof(JsonFormatWriterGenerator).Module' allowPrivateMemberAccess); " is 162.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteMembers,The length of the statement  "                    bool requiresNameAttribute = DataContractJsonSerializerImpl.CheckIfXmlNameRequiresMapping(classContract.MemberNames[i]); " is 120.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteMembers,The length of the statement  "                    if (requiresNameAttribute || !TryWritePrimitive(memberType' memberValue' member.MemberInfo' arrayItemIndex: null' name: null' nameIndex: i + _childElementIndex)) " is 161.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteMembers,The length of the statement  "                            _ilg.Call(thisObj: null' JsonFormatGeneratorStatics.WriteJsonNameWithMappingMethod' _xmlWriterArg' _memberNamesArg' i + _childElementIndex); " is 140.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteMembers,The length of the statement  "                        _ilg.Call(thisObj: _contextArg' XmlFormatGeneratorStatics.WriteExtensionDataMethod' _xmlWriterArg' extensionDataLocal' memberCount); " is 132.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteMembers,The length of the statement  "                            _ilg.Call(thisObj: null' XmlFormatGeneratorStatics.ThrowRequiredMemberMustBeEmittedMethod' member.Name' classContract.UnderlyingType); " is 134.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                            incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(collectionContract.ItemType); " is 144.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                            incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(Globals.TypeOfKeyValuePair.MakeGenericType(collectionContract.ItemType.GetGenericArguments())); " is 210.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                    MethodInfo moveNextMethod = enumeratorType.GetMethod(Globals.MoveNextMethodName' BindingFlags.Instance | BindingFlags.Public' Array.Empty<Type>()); " is 147.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                    MethodInfo getCurrentMethod = enumeratorType.GetMethod(Globals.GetCurrentMethodName' BindingFlags.Instance | BindingFlags.Public' Array.Empty<Type>()); " is 151.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                            if (kind == CollectionKind.GenericDictionary || kind == CollectionKind.GenericCollection || kind == CollectionKind.GenericEnumerable) " is 133.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                                moveNextMethod = CollectionDataContract.GetTargetMethodWithName(Globals.MoveNextMethodName' enumeratorType' ienumeratorInterface); " is 130.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                                getCurrentMethod = CollectionDataContract.GetTargetMethodWithName(Globals.GetCurrentMethodName' enumeratorType' ienumeratorInterface); " is 134.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                        ConstructorInfo dictEnumCtor = enumeratorType.GetConstructor(Globals.ScanAllMembers' new Type[] { Globals.TypeOfIDictionaryEnumerator }); " is 137.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                        Type ctorParam = Globals.TypeOfIEnumeratorGeneric.MakeGenericType(Globals.TypeOfKeyValuePair.MakeGenericType(keyValueTypes)); " is 125.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The length of the statement  "                    if (!TryWritePrimitive(elementType' currentValue' null /*memberInfo*/' null /*arrayItemIndex*/' itemName' 0 /*nameIndex*/)) " is 123.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteValue,The length of the statement  "                        InternalSerialize(XmlFormatGeneratorStatics.InternalSerializeMethod' memberValue' memberType' false /* writeXsiType */); " is 120.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteValue,The length of the statement  "                    _ilg.Call(_contextArg' XmlFormatGeneratorStatics.WriteNullMethod' _xmlWriterArg' memberType' DataContract.IsTypeSerializable(memberType)); " is 138.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteValue,The length of the statement  "                            _ilg.Call(_contextArg' XmlFormatGeneratorStatics.WriteNullMethod' _xmlWriterArg' memberType' DataContract.IsTypeSerializable(memberType)); " is 138.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteValue,The length of the statement  "                        InternalSerialize((isNullableOfT ? XmlFormatGeneratorStatics.InternalSerializeMethod : XmlFormatGeneratorStatics.InternalSerializeReferenceMethod)' " is 147.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateClassReader,The length of the statement  "                    BeginMethod(_ilg' "Read" + DataContract.SanitizeTypeName(classContract.StableName.Name) + "FromJson"' typeof(JsonFormatClassReaderDelegate)' memberAccessFlag); " is 159.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateClassReader,The length of the statement  "                        _ilg.ConvertValue(Globals.TypeOfKeyValuePair.MakeGenericType(classContract.KeyValuePairGenericArguments)' _ilg.CurrentMethod.ReturnType); " is 137.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateCollectionReaderHelper,The length of the statement  "                        BeginMethod(_ilg' "Read" + DataContract.SanitizeTypeName(collectionContract.StableName.Name) + "FromJson" + "IsGetOnly"' typeof(JsonFormatGetOnlyCollectionReaderDelegate)' memberAccessFlag); " is 190.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateCollectionReaderHelper,The length of the statement  "                        BeginMethod(_ilg' "Read" + DataContract.SanitizeTypeName(collectionContract.StableName.Name) + "FromJson"' typeof(JsonFormatCollectionReaderDelegate)' memberAccessFlag); " is 169.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,BeginMethod,The length of the statement  "                DynamicMethod dynamicMethod = new DynamicMethod(methodName' signature.ReturnType' paramTypes' typeof(JsonFormatReaderGenerator).Module' allowPrivateMemberAccess); " is 162.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadMembers,The length of the statement  "                BitFlagsGenerator expectedElements = new BitFlagsGenerator(memberCount' _ilg' classContract.UnderlyingType.Name + "_ExpectedElements"); " is 135.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadMembers,The length of the statement  "                _ilg.Call(_contextArg' JsonFormatGeneratorStatics.GetJsonMemberIndexMethod' _xmlReaderArg' _memberNamesArg' memberIndexLocal' extensionDataLocal); " is 146.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadMembers,The length of the statement  "                _ilg.Call(null' JsonFormatGeneratorStatics.ThrowDuplicateMemberExceptionMethod' _objectLocal' _memberNamesArg' memberIndexLocal); " is 129.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadISerializable,The length of the statement  "                ConstructorInfo ctor = classContract.UnderlyingType.GetConstructor(Globals.ScanAllMembers' null' JsonFormatGeneratorStatics.SerInfoCtorArgs' null); " is 147.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadISerializable,The length of the statement  "                    throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.SerializationInfo_ConstructorNotFound' DataContract.GetClrTypeFullName(classContract.UnderlyingType)))); " is 253.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadISerializable,The length of the statement  "                _ilg.Call(_contextArg' XmlFormatGeneratorStatics.ReadSerializationInfoMethod' _xmlReaderArg' classContract.UnderlyingType); " is 123.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadValue,The length of the statement  "                if ((primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType) " is 130.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadValue,The length of the statement  "                    _ilg.Call(_contextArg' XmlFormatGeneratorStatics.ReadIfNullOrRefMethod' _xmlReaderArg' type' DataContract.IsTypeSerializable(type)); " is 132.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadCollection,The length of the statement  "                            constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' Array.Empty<Type>()); " is 125.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadCollection,The length of the statement  "                            constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' Array.Empty<Type>()); " is 125.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadGetOnlyCollection,The length of the statement  "                    _ilg.Call(_contextArg' XmlFormatGeneratorStatics.CheckEndOfArrayMethod' _xmlReaderArg' size' _memberNamesArg' _emptyDictionaryStringArg); " is 137.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadGetOnlyCollection,The length of the statement  "                _ilg.Call(_contextArg' XmlFormatGeneratorStatics.CheckEndOfArrayMethod' _xmlReaderArg' size' _memberNamesArg' _emptyDictionaryStringArg); " is 137.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadCollectionItem,The length of the statement  "                if (collectionContract.Kind == CollectionKind.Dictionary || collectionContract.Kind == CollectionKind.GenericDictionary) " is 120.
Long Statement,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,StoreCollectionValue,The length of the statement  "                if (collectionContract.Kind == CollectionKind.GenericDictionary || collectionContract.Kind == CollectionKind.Dictionary) " is 120.
Long Statement,System.Runtime.Serialization.Json,JsonObjectDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonObjectDataContract.cs,ReadJsonValueCore,The length of the statement  "                    return DataContractJsonSerializerImpl.ReadJsonValue(DataContract.GetDataContract(Globals.TypeOfObjectArray)' jsonReader' context); " is 130.
Long Statement,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ReadContentAsBase64,The length of the statement  "                buffer = ByteArrayHelperWithString.Instance.ReadArray(tempDictionaryReader' JsonGlobals.itemString' string.Empty' tempDictionaryReader.Quotas.MaxArrayLength); " is 158.
Long Statement,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ReadContentAsBase64,The length of the statement  "                buffer = ByteArrayHelperWithString.Instance.ReadArray(dictionaryReader' JsonGlobals.itemString' string.Empty' dictionaryReader.Quotas.MaxArrayLength); " is 150.
Long Statement,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ParseJsonDate,The length of the statement  "                return DateTime.ParseExact(originalDateTimeValue' dateTimeFormat.FormatString' dateTimeFormat.FormatProvider' dateTimeFormat.DateTimeStyles); " is 141.
Long Statement,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ParseJsonDateInDefaultFormat,The length of the statement  "                throw new FormatException(SR.Format(SR.JsonInvalidDateTimeString' originalDateTimeValue' JsonGlobals.DateTimeStartGuardWriter' JsonGlobals.DateTimeEndGuardWriter)); " is 164.
Long Statement,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,TryReadJsonDateTimeArray,The length of the statement  "            array = this.DateTimeArrayHelper.ReadArray(dictionaryReader' XmlDictionaryString.GetString(itemName)' XmlDictionaryString.GetString(itemNamespace)' GetArrayLengthQuota(context)); " is 178.
Long Statement,System.Runtime.Serialization.Json,JsonWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonWriterDelegator.cs,WriteDateTimeInDefaultFormat,The length of the statement  "                        throw XmlObjectSerializer.CreateSerializationException(SR.JsonDateTimeOutOfRange' new ArgumentOutOfRangeException(nameof(value))); " is 130.
Long Statement,System.Runtime.Serialization.Json,JsonXmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonXmlDataContract.cs,ReadJsonValueCore,The length of the statement  "                GetKnownTypesFromContext(context' (context == null) ? null : context.SerializerKnownTypeList)' 1' false' false); //  maxItemsInObjectGraph //  ignoreExtensionDataObject //  preserveObjectReferences " is 197.
Long Statement,System.Runtime.Serialization.Json,JsonXmlDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonXmlDataContract.cs,WriteJsonValueCore,The length of the statement  "                GetKnownTypesFromContext(context' (context == null) ? null : context.SerializerKnownTypeList)' 1' false' false); //  maxItemsInObjectGraph //  ignoreExtensionDataObject //  preserveObjectReferences " is 197.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerReadContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerReadContextComplexJson.cs,ResolveDataContractFromType,The length of the statement  "            DataContract contract = ResolveDataContractFromKnownTypes(qname.Name' TrimNamespace(qname.Namespace)' memberTypeContract); " is 122.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerReadContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerReadContextComplexJson.cs,VerifyType,The length of the statement  "            DataContract knownContract = ResolveDataContractFromKnownTypes(dataContract.StableName.Name' dataContract.StableName.Namespace' null /*memberTypeContract*/); " is 157.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerReadContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerReadContextComplexJson.cs,VerifyType,The length of the statement  "                throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.DcTypeNotFoundOnSerialize' DataContract.GetClrTypeFullName(dataContract.UnderlyingType)' dataContract.StableName.Name' dataContract.StableName.Namespace))); " is 296.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,WriteTypeInfo,The length of the statement  "                    WriteTypeInfo(writer' string.Concat(dataContractName' JsonGlobals.NameValueSeparatorString' TruncateDefaultDataContractNamespace(dataContractNamespace))); " is 154.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,WriteTypeInfo,The length of the statement  "                        throw new SerializationException(SR.Format(SR.EnumTypeNotSupportedByDataContractJsonSerializer' declaredContract.UnderlyingType)); " is 130.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,SerializeWithXsiType,The length of the statement  "            else if (declaredType.IsArray) // If declared type is array do not write __serverType. Instead write__serverType for each item " is 126.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,SerializeWithXsiTypeAtTopLevel,The length of the statement  "                && !declaredType.IsArray)//Array covariance is not supported in XSD. If declared type is array do not write xsi:type. Instead write xsi:type for each item " is 154.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,VerifyType,The length of the statement  "                throw XmlObjectSerializer.CreateSerializationException(SR.Format(SR.DcTypeNotFoundOnSerialize' DataContract.GetClrTypeFullName(dataContract.UnderlyingType)' dataContract.StableName.Name' dataContract.StableName.Namespace)); " is 223.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,VerifyObjectCompatibilityWithInterface,The length of the statement  "                throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.XmlObjectAssignedToIncompatibleInterface' graph.GetType()' declaredType))); " is 215.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,VerifyObjectCompatibilityWithInterface,The length of the statement  "                throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.CollectionAssignedToIncompatibleInterface' graph.GetType()' declaredType))); " is 216.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,VerifyType,The length of the statement  "            DataContract knownContract = ResolveDataContractFromKnownTypes(dataContract.StableName.Name' dataContract.StableName.Namespace' null /*memberTypeContract*/); " is 157.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,VerifyType,The length of the statement  "                throw System.ServiceModel.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.DcTypeNotFoundOnSerialize' DataContract.GetClrTypeFullName(dataContract.UnderlyingType)' dataContract.StableName.Name' dataContract.StableName.Namespace))); " is 296.
Long Statement,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,WriteJsonISerializable,The length of the statement  "                throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlObjectSerializer.CreateSerializationException(SR.Format(SR.ChangingFullTypeNameNotSupported' serInfo.FullTypeName' DataContract.GetClrTypeFullName(objType)))); " is 249.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The length of the statement  "                    if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte) " is 137.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The length of the statement  "                    if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte) " is 137.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadValueAsBase64,The length of the statement  "                    throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' buffer.Length - offset)); " is 124.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadValueChunk,The length of the statement  "                    throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' chars.Length - offset)); " is 123.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,SetInput,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.JsonSizeExceedsRemainingBufferSpace' buffer.Length - offset)); " is 128.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,CheckArray,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.SizeExceedsRemainingBufferSpace' array.Length - offset)); " is 123.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,UnescapeJsonString,The length of the statement  "                    Fx.Assert(i < val.Length' "Found that an '\' was the last character in a string. ReadServerTypeAttriute validates that the escape sequence is valid when it calls ReadQuotedText and ReadEscapedCharacter"); " is 204.
Long Statement,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,CreateSigningNodeWriter,The length of the statement  "            throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new NotSupportedException(SR.Format(SR.JsonMethodNotSupported' "CreateSigningNodeWriter"))); " is 150.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteBase64,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.JsonSizeExceedsRemainingBufferSpace' buffer.Length - index)); " is 127.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteBinHex,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.JsonSizeExceedsRemainingBufferSpace' buffer.Length - index)); " is 127.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteChars,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.JsonSizeExceedsRemainingBufferSpace' buffer.Length - index)); " is 127.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteEndElement,The length of the statement  "                    throw new XmlException(SR.Format(SR.JsonMustSpecifyDataType' JsonGlobals.typeString' JsonGlobals.objectString' JsonGlobals.serverTypeString)); " is 142.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteEndElement,The length of the statement  "                    throw new XmlException(SR.Format(SR.JsonMustSpecifyDataType' JsonGlobals.itemString' string.Empty' JsonGlobals.itemString)); " is 124.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteRaw,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(count)' SR.Format(SR.JsonSizeExceedsRemainingBufferSpace' buffer.Length - index)); " is 127.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteStartAttribute,The length of the statement  "                        JsonGlobals.serverTypeString' JsonGlobals.typeString' _dataType.ToString().ToLowerInvariant()' JsonGlobals.objectString)); " is 122.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteString,The length of the statement  "                if (!((_dataType == JsonDataType.Array || _dataType == JsonDataType.Object || _nodeType == JsonNodeType.EndElement) && XmlConverter.IsWhitespace(text))) " is 152.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,StartText,The length of the statement  "                throw new XmlException(SR.Format(SR.JsonMustSpecifyDataType' JsonGlobals.typeString' JsonGlobals.objectString' JsonGlobals.serverTypeString)); " is 142.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,StartText,The length of the statement  "                throw new XmlException(SR.Format(SR.JsonMustSpecifyDataType' JsonGlobals.itemString' string.Empty' JsonGlobals.itemString)); " is 124.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,ThrowIfServerTypeWritten,The length of the statement  "                throw new XmlException(SR.Format(SR.JsonInvalidDataTypeSpecifiedForServerType' JsonGlobals.typeString' dataTypeSpecified' JsonGlobals.serverTypeString' JsonGlobals.objectString)); " is 179.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,ThrowInvalidAttributeContent,The length of the statement  "                throw new XmlException(SR.Format(SR.JsonCannotWriteTextAfterNonTextAttribute' _dataType.ToString().ToLowerInvariant())); " is 120.
Long Statement,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteValue,The length of the statement  "            //  Calls to methods that write numbers can't be mixed with calls that write quoted text unless the attribute mode is explicitly string.             " is 136.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonClassReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReflectionReadClass,The length of the statement  "            return _reflectionReader.ReflectionReadClass(xmlReader' context' memberNames' null /*memberNamespaces*/' _classContract); " is 121.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonCollectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReflectionReadCollection,The length of the statement  "            return _reflectionReader.ReflectionReadCollection(xmlReader' context' itemName' emptyDictionaryString/*itemNamespace*/' collectionContract); " is 140.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonCollectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReflectionReadGetOnlyCollection,The length of the statement  "            _reflectionReader.ReflectionReadGetOnlyCollection(xmlReader' context' itemName' emptyDictionaryString/*itemNamespace*/' collectionContract); " is 140.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatReader.cs,ReflectionReadDictionaryItem,The length of the statement  "            Debug.Assert(collectionContract.Kind == CollectionKind.Dictionary || collectionContract.Kind == CollectionKind.GenericDictionary); " is 130.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                        _reflectionClassWriter.ReflectionWriteValue(jsonWriter' context' itemType' array.GetValue(i)' false' primitiveContract); " is 120.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                        _reflectionClassWriter.ReflectionWriteValue(jsonWriter' context' dictionaryValueType ?? value.GetType()' value' false' primitiveContractForParamType: null); " is 156.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                    PrimitiveDataContract primitiveContractForType = PrimitiveDataContract.GetPrimitiveDataContract(collectionContract.UnderlyingType); " is 131.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                        bool isDictionary = collectionContract.Kind == CollectionKind.Dictionary || collectionContract.Kind == CollectionKind.GenericDictionary; " is 136.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteCollection,The length of the statement  "                                _reflectionClassWriter.ReflectionWriteValue(jsonWriter' context' elementType' current' false' primitiveContractForParamType: null); " is 131.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteMembers,The length of the statement  "                ReflectionWriteMembers(xmlWriter' obj' context' classContract.BaseContract' derivedMostClassContract' childElementIndex' memberNames); " is 134.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteMembers,The length of the statement  "                    bool requiresNameAttribute = DataContractJsonSerializerImpl.CheckIfXmlNameRequiresMapping(classContract.MemberNames[i]); " is 120.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteMembers,The length of the statement  "                    if (requiresNameAttribute || !ReflectionTryWritePrimitive(xmlWriter' context' memberType' memberValue' memberNames[i + childElementIndex] /*name*/' null/*ns*/' primitiveContract)) " is 179.
Long Statement,System.Runtime.Serialization.Json,ReflectionJsonClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteMembers,The length of the statement  "                        ReflectionWriteValue(xmlWriter' context' memberType' memberValue' false/*writeXsiType*/' primitiveContractForParamType: null); " is 126.
Complex Conditional,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,IfNotDefaultValue,The conditional expression  "(typeCode == TypeCode.Object && type.IsValueType) ||                  typeCode == TypeCode.DateTime || typeCode == TypeCode.Decimal"  is complex.
Complex Conditional,System.Runtime.Serialization,ClassDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,GetChildNamespaceToDeclare,The conditional expression  "!childType.IsEnum && !Globals.TypeOfIXmlSerializable.IsAssignableFrom(childType)                  && DataContract.GetBuiltInDataContract(childType) == null && childType != Globals.TypeOfDBNull"  is complex.
Complex Conditional,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ClassDataContractCriticalHelper,The conditional expression  "baseType != null && baseType != Globals.TypeOfObject && baseType != Globals.TypeOfValueType && baseType != Globals.TypeOfUri"  is complex.
Complex Conditional,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,EnsureIsReferenceImported,The conditional expression  "(baseIsReference && !dataContractAttribute.IsReference) ||                              (!baseIsReference && dataContractAttribute.IsReference)"  is complex.
Complex Conditional,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ImportDataMembers,The conditional expression  "(field == null && property == null) || (field != null && field.IsInitOnly)"  is complex.
Complex Conditional,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,IsTypeSerializable,The conditional expression  "type.IsSerializable ||                  type.IsEnum ||                  type.IsDefined(Globals.TypeOfDataContractAttribute' false) ||                  type.IsInterface ||                  type.IsPointer ||                  //Special casing DBNull as its considered a Primitive but is no longer Serializable                  type == Globals.TypeOfDBNull ||                  Globals.TypeOfIXmlSerializable.IsAssignableFrom(type)"  is complex.
Complex Conditional,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,CreateDataContract,The conditional expression  "!type.IsSerializable && !type.IsDefined(Globals.TypeOfDataContractAttribute' false) && !ClassDataContract.IsNonAttributedTypeValidForSerialization(type) && !ClassDataContract.IsKnownSerializableType(type)"  is complex.
Complex Conditional,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadValue,The conditional expression  "(primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType"  is complex.
Complex Conditional,System.Runtime.Serialization,ObjectToIdCache,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ObjectToIdCache.cs,RemoveAt,The conditional expression  "(nextStartPosition <= lastVacantPosition && !(isNextStartPositionWrapped && !isLastVacantPositionWrapped)) ||                      (isLastVacantPositionWrapped && !isNextStartPositionWrapped)"  is complex.
Complex Conditional,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,ReflectionReadValue,The conditional expression  "(primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType"  is complex.
Complex Conditional,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,GetReflectionReadValueDelegate,The conditional expression  "(primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType"  is complex.
Complex Conditional,System.Runtime.Serialization,ReflectionClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionClassWriter.cs,ReflectionWriteValue,The conditional expression  "memberValue == null &&                              (memberType == Globals.TypeOfObject                              || (originValueIsNullableOfT && memberType.IsValueType))"  is complex.
Complex Conditional,System.Runtime.Serialization,ReflectionXmlClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionXmlFormatWriter.cs,ReflectionWriteMembers,The conditional expression  "(memberValue == null && defaultValue == null)                          || (memberValue != null && memberValue.Equals(defaultValue))"  is complex.
Complex Conditional,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The conditional expression  "charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-'"  is complex.
Complex Conditional,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteWhitespace,The conditional expression  "c != ' ' &&                      c != '\t' &&                      c != '\n' &&                      c != '\r'"  is complex.
Complex Conditional,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteQualifiedName,The conditional expression  "prefix.Length == 1 && (ch >= 'a' && ch <= 'z') && TryGetKey(localName' out key)"  is complex.
Complex Conditional,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetQuoteCharEntity,The conditional expression  "length != 6 ||                  buffer[offset + 1] != (byte)'q' ||                  buffer[offset + 2] != (byte)'u' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'t'"  is complex.
Complex Conditional,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetAmpersandCharEntity,The conditional expression  "length != 5 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'p'"  is complex.
Complex Conditional,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetApostropheCharEntity,The conditional expression  "length != 6 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'p' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'s'"  is complex.
Complex Conditional,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The conditional expression  "chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':'"  is complex.
Complex Conditional,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The conditional expression  "hourDelta >= 0 && (value < DateTime.MaxValue - ts) ||                          hourDelta < 0 && (value > DateTime.MinValue - ts)"  is complex.
Complex Conditional,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The conditional expression  "buffer[offset + 0] != (byte)'?' ||                  buffer[offset + 1] != (byte)'x' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'l' ||                  (s_charType[buffer[offset + 4]] & CharType.Whitespace) == 0"  is complex.
Complex Conditional,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The conditional expression  "buffer[offset + 0] != (byte)'[' ||                  buffer[offset + 1] != (byte)'C' ||                  buffer[offset + 2] != (byte)'D' ||                  buffer[offset + 3] != (byte)'A' ||                  buffer[offset + 4] != (byte)'T' ||                  buffer[offset + 5] != (byte)'A' ||                  buffer[offset + 6] != (byte)'['"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadValue,The conditional expression  "(primitiveContract != null && primitiveContract.UnderlyingType != Globals.TypeOfObject) || nullables != 0 || type.IsValueType"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlObjectSerializerWriteContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerWriteContextComplexJson.cs,WriteTypeInfo,The conditional expression  "!((object.ReferenceEquals(contract.Name' declaredContract.Name) &&                     object.ReferenceEquals(contract.Namespace' declaredContract.Namespace)) ||                   (contract.Name.Value == declaredContract.Name.Value &&                   contract.Namespace.Value == declaredContract.Namespace.Value)) &&                   (contract.UnderlyingType != Globals.TypeOfObjectArray) &&                   (_emitXsiType != EmitTypeInformation.Never)"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The conditional expression  "buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e'"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The conditional expression  "!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The conditional expression  "!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The conditional expression  "(ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N')"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ComputeNumericalTextLength,The conditional expression  "ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectByte || ch == JsonGlobals.EndCollectionByte                      || IsWhitespace(ch)"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadAttributes,The conditional expression  "nextByte == '-' ||                          (nextByte <= '9' && nextByte >= '0') ||                          nextByte == 'N' ||                          nextByte == 'I'"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The conditional expression  "buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"'"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteString,The conditional expression  "!((_dataType == JsonDataType.Array || _dataType == JsonDataType.Object || _nodeType == JsonNodeType.EndElement) && XmlConverter.IsWhitespace(text))"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteWhitespace,The conditional expression  "c != ' ' &&                      c != '\t' &&                      c != '\n' &&                      c != '\r'"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteEscapedJsonString,The conditional expression  "(ch >= HIGH_SURROGATE_START && (ch <= LOW_SURROGATE_END || ch >= MAX_CHAR)) || IsUnicodeNewlineCharacter(ch)"  is complex.
Complex Conditional,System.Runtime.Serialization.Json,ReflectionJsonClassWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteMembers,The conditional expression  "(memberValue == null && defaultValue == null)                          || (memberValue != null && memberValue.Equals(defaultValue))"  is complex.
Virtual Method Call from Constructor,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ClassDataContractCriticalHelper,The constructor "ClassDataContractCriticalHelper" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ClassDataContractCriticalHelper,The constructor "ClassDataContractCriticalHelper" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The constructor "DictionaryGlobals" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,DataContractSerializer,The constructor "DataContractSerializer" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,DataContractSerializer,The constructor "DataContractSerializer" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,EnumDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,EnumDataContractCriticalHelper,The constructor "EnumDataContractCriticalHelper" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,XmlDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlDataContract.cs,XmlDataContractCriticalHelper,The constructor "XmlDataContractCriticalHelper" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization,XmlDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlDataContract.cs,XmlDataContractCriticalHelper,The constructor "XmlDataContractCriticalHelper" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Runtime.Serialization.Json,DataContractJsonSerializerImpl,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\DataContractJsonSerializer.cs,DataContractJsonSerializerImpl,The constructor "DataContractJsonSerializerImpl" calls a virtual method "Add".
Empty Catch Block,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ImportKnownTypeAttributes,The method has an empty catch block.
Empty Catch Block,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToByteArray,The method has an empty catch block.
Empty Catch Block,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadBase64,The method has an empty catch block.
Magic Number,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,Read,The following statement contains a magic number: while (reader.MoveToNextAttribute())              {                  switch (reader.IndexOfLocalName(s_serializationLocalNames' DictionaryGlobals.SerializationNamespace))                  {                      case 0:                          ReadId(reader);                          break;                      case 1:                          ReadArraySize(reader);                          break;                      case 2:                          ReadRef(reader);                          break;                      case 3:                          ClrType = reader.Value;                          break;                      case 4:                          ClrAssembly = reader.Value;                          break;                      case 5:                          ReadFactoryType(reader);                          break;                      default:                          switch (reader.IndexOfLocalName(s_schemaInstanceLocalNames' DictionaryGlobals.SchemaInstanceNamespace))                          {                              case 0:                                  ReadXsiNil(reader);                                  break;                              case 1:                                  ReadXsiType(reader);                                  break;                              default:                                  if (!reader.IsNamespaceUri(DictionaryGlobals.XmlnsNamespace))                                      UnrecognizedAttributesFound = true;                                  break;                          }                          break;                  }              }
Magic Number,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,Read,The following statement contains a magic number: while (reader.MoveToNextAttribute())              {                  switch (reader.IndexOfLocalName(s_serializationLocalNames' DictionaryGlobals.SerializationNamespace))                  {                      case 0:                          ReadId(reader);                          break;                      case 1:                          ReadArraySize(reader);                          break;                      case 2:                          ReadRef(reader);                          break;                      case 3:                          ClrType = reader.Value;                          break;                      case 4:                          ClrAssembly = reader.Value;                          break;                      case 5:                          ReadFactoryType(reader);                          break;                      default:                          switch (reader.IndexOfLocalName(s_schemaInstanceLocalNames' DictionaryGlobals.SchemaInstanceNamespace))                          {                              case 0:                                  ReadXsiNil(reader);                                  break;                              case 1:                                  ReadXsiType(reader);                                  break;                              default:                                  if (!reader.IsNamespaceUri(DictionaryGlobals.XmlnsNamespace))                                      UnrecognizedAttributesFound = true;                                  break;                          }                          break;                  }              }
Magic Number,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,Read,The following statement contains a magic number: while (reader.MoveToNextAttribute())              {                  switch (reader.IndexOfLocalName(s_serializationLocalNames' DictionaryGlobals.SerializationNamespace))                  {                      case 0:                          ReadId(reader);                          break;                      case 1:                          ReadArraySize(reader);                          break;                      case 2:                          ReadRef(reader);                          break;                      case 3:                          ClrType = reader.Value;                          break;                      case 4:                          ClrAssembly = reader.Value;                          break;                      case 5:                          ReadFactoryType(reader);                          break;                      default:                          switch (reader.IndexOfLocalName(s_schemaInstanceLocalNames' DictionaryGlobals.SchemaInstanceNamespace))                          {                              case 0:                                  ReadXsiNil(reader);                                  break;                              case 1:                                  ReadXsiType(reader);                                  break;                              default:                                  if (!reader.IsNamespaceUri(DictionaryGlobals.XmlnsNamespace))                                      UnrecognizedAttributesFound = true;                                  break;                          }                          break;                  }              }
Magic Number,System.Runtime.Serialization,Attributes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Attributes.cs,Read,The following statement contains a magic number: while (reader.MoveToNextAttribute())              {                  switch (reader.IndexOfLocalName(s_serializationLocalNames' DictionaryGlobals.SerializationNamespace))                  {                      case 0:                          ReadId(reader);                          break;                      case 1:                          ReadArraySize(reader);                          break;                      case 2:                          ReadRef(reader);                          break;                      case 3:                          ClrType = reader.Value;                          break;                      case 4:                          ClrAssembly = reader.Value;                          break;                      case 5:                          ReadFactoryType(reader);                          break;                      default:                          switch (reader.IndexOfLocalName(s_schemaInstanceLocalNames' DictionaryGlobals.SchemaInstanceNamespace))                          {                              case 0:                                  ReadXsiNil(reader);                                  break;                              case 1:                                  ReadXsiType(reader);                                  break;                              default:                                  if (!reader.IsNamespaceUri(DictionaryGlobals.XmlnsNamespace))                                      UnrecognizedAttributesFound = true;                                  break;                          }                          break;                  }              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: VerifyParameterCount(methodInfo' 2);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param2' 2' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: VerifyParameterCount(methodInfo' 3);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param2' 2' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param3' 3' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: VerifyParameterCount(methodInfo' 4);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param2' 2' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param3' 3' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param4' 4' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: VerifyParameterCount(methodInfo' 5);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param2' 2' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param3' 3' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param4' 4' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param5' 5' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: VerifyParameterCount(methodInfo' 6);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param2' 2' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param3' 3' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param4' 4' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param5' 5' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Call,The following statement contains a magic number: LoadParam(param6' 6' methodInfo);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The following statement contains a magic number: switch (intVar)              {                  case -1:                      _ilGen.Emit(OpCodes.Ldc_I4_M1);                      break;                  case 0:                      _ilGen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      _ilGen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      _ilGen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      _ilGen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      _ilGen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      _ilGen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      _ilGen.Emit(OpCodes.Ldc_I4' intVar);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The following statement contains a magic number: switch (intVar)              {                  case -1:                      _ilGen.Emit(OpCodes.Ldc_I4_M1);                      break;                  case 0:                      _ilGen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      _ilGen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      _ilGen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      _ilGen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      _ilGen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      _ilGen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      _ilGen.Emit(OpCodes.Ldc_I4' intVar);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The following statement contains a magic number: switch (intVar)              {                  case -1:                      _ilGen.Emit(OpCodes.Ldc_I4_M1);                      break;                  case 0:                      _ilGen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      _ilGen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      _ilGen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      _ilGen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      _ilGen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      _ilGen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      _ilGen.Emit(OpCodes.Ldc_I4' intVar);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The following statement contains a magic number: switch (intVar)              {                  case -1:                      _ilGen.Emit(OpCodes.Ldc_I4_M1);                      break;                  case 0:                      _ilGen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      _ilGen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      _ilGen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      _ilGen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      _ilGen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      _ilGen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      _ilGen.Emit(OpCodes.Ldc_I4' intVar);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The following statement contains a magic number: switch (intVar)              {                  case -1:                      _ilGen.Emit(OpCodes.Ldc_I4_M1);                      break;                  case 0:                      _ilGen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      _ilGen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      _ilGen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      _ilGen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      _ilGen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      _ilGen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      _ilGen.Emit(OpCodes.Ldc_I4' intVar);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The following statement contains a magic number: switch (intVar)              {                  case -1:                      _ilGen.Emit(OpCodes.Ldc_I4_M1);                      break;                  case 0:                      _ilGen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      _ilGen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      _ilGen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      _ilGen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      _ilGen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      _ilGen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      _ilGen.Emit(OpCodes.Ldc_I4' intVar);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldc,The following statement contains a magic number: switch (intVar)              {                  case -1:                      _ilGen.Emit(OpCodes.Ldc_I4_M1);                      break;                  case 0:                      _ilGen.Emit(OpCodes.Ldc_I4_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldc_I4_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldc_I4_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldc_I4_3);                      break;                  case 4:                      _ilGen.Emit(OpCodes.Ldc_I4_4);                      break;                  case 5:                      _ilGen.Emit(OpCodes.Ldc_I4_5);                      break;                  case 6:                      _ilGen.Emit(OpCodes.Ldc_I4_6);                      break;                  case 7:                      _ilGen.Emit(OpCodes.Ldc_I4_7);                      break;                  case 8:                      _ilGen.Emit(OpCodes.Ldc_I4_8);                      break;                  default:                      _ilGen.Emit(OpCodes.Ldc_I4' intVar);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldarg,The following statement contains a magic number: switch (slot)              {                  case 0:                      _ilGen.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldarg_3);                      break;                  default:                      if (slot <= 255)                          _ilGen.Emit(OpCodes.Ldarg_S' slot);                      else                          _ilGen.Emit(OpCodes.Ldarg' slot);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldarg,The following statement contains a magic number: switch (slot)              {                  case 0:                      _ilGen.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldarg_3);                      break;                  default:                      if (slot <= 255)                          _ilGen.Emit(OpCodes.Ldarg_S' slot);                      else                          _ilGen.Emit(OpCodes.Ldarg' slot);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldarg,The following statement contains a magic number: switch (slot)              {                  case 0:                      _ilGen.Emit(OpCodes.Ldarg_0);                      break;                  case 1:                      _ilGen.Emit(OpCodes.Ldarg_1);                      break;                  case 2:                      _ilGen.Emit(OpCodes.Ldarg_2);                      break;                  case 3:                      _ilGen.Emit(OpCodes.Ldarg_3);                      break;                  default:                      if (slot <= 255)                          _ilGen.Emit(OpCodes.Ldarg_S' slot);                      else                          _ilGen.Emit(OpCodes.Ldarg' slot);                      break;              }
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Starg,The following statement contains a magic number: if (slot <= 255)                  _ilGen.Emit(OpCodes.Starg_S' slot);              else                  _ilGen.Emit(OpCodes.Starg' slot);
Magic Number,System.Runtime.Serialization,CodeGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CodeGenerator.cs,Ldarga,The following statement contains a magic number: if (slot <= 255)                  _ilGen.Emit(OpCodes.Ldarga_S' slot);              else                  _ilGen.Emit(OpCodes.Ldarga' slot);
Magic Number,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ClassDataContractCriticalHelper,The following statement contains a magic number: if (type == Globals.TypeOfDBNull)                  {                      this.StableName = stableName;                      _members = new List<DataMember>();                      XmlDictionary dictionary = new XmlDictionary(2);                      this.Name = dictionary.Add(StableName.Name);                      this.Namespace = dictionary.Add(StableName.Namespace);                      this.ContractNamespaces = this.MemberNames = this.MemberNamespaces = Array.Empty<XmlDictionaryString>();                      EnsureMethodsImported();                      return;                  }
Magic Number,System.Runtime.Serialization,ClassDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ClassDataContract.cs,ClassDataContractCriticalHelper,The following statement contains a magic number: if (_isISerializable)                  {                      SetDataContractName(stableName);                  }                  else                  {                      this.StableName = stableName;                      ImportDataMembers();                      XmlDictionary dictionary = new XmlDictionary(2 + Members.Count);                      Name = dictionary.Add(StableName.Name);                      Namespace = dictionary.Add(StableName.Namespace);                        int baseMemberCount = 0;                      int baseContractCount = 0;                      if (BaseContract == null)                      {                          MemberNames = new XmlDictionaryString[Members.Count];                          MemberNamespaces = new XmlDictionaryString[Members.Count];                          ContractNamespaces = new XmlDictionaryString[1];                      }                      else                      {                          baseMemberCount = BaseContract.MemberNames.Length;                          MemberNames = new XmlDictionaryString[Members.Count + baseMemberCount];                          Array.Copy(BaseContract.MemberNames' 0' MemberNames' 0' baseMemberCount);                          MemberNamespaces = new XmlDictionaryString[Members.Count + baseMemberCount];                          Array.Copy(BaseContract.MemberNamespaces' 0' MemberNamespaces' 0' baseMemberCount);                          baseContractCount = BaseContract.ContractNamespaces.Length;                          ContractNamespaces = new XmlDictionaryString[1 + baseContractCount];                          Array.Copy(BaseContract.ContractNamespaces' 0' ContractNamespaces' 0' baseContractCount);                      }                      ContractNamespaces[baseContractCount] = Namespace;                      for (int i = 0; i < Members.Count; i++)                      {                          MemberNames[i + baseMemberCount] = dictionary.Add(Members[i].Name);                          MemberNamespaces[i + baseMemberCount] = Namespace;                      }                  }
Magic Number,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,The following statement contains a magic number: if (itemType != null)                  {                      _itemType = itemType;                      _isItemTypeNullable = DataContract.IsTypeNullable(itemType);                        bool isDictionary = (kind == CollectionKind.Dictionary || kind == CollectionKind.GenericDictionary);                      string itemName = null' keyName = null' valueName = null;                      if (collectionContractAttribute != null)                      {                          if (collectionContractAttribute.IsItemNameSetExplicitly)                          {                              if (collectionContractAttribute.ItemName == null || collectionContractAttribute.ItemName.Length == 0)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractItemName' DataContract.GetClrTypeFullName(UnderlyingType))));                              itemName = DataContract.EncodeLocalName(collectionContractAttribute.ItemName);                              _itemNameSetExplicit = true;                          }                          if (collectionContractAttribute.IsKeyNameSetExplicitly)                          {                              if (collectionContractAttribute.KeyName == null || collectionContractAttribute.KeyName.Length == 0)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractKeyName' DataContract.GetClrTypeFullName(UnderlyingType))));                              if (!isDictionary)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractKeyNoDictionary' DataContract.GetClrTypeFullName(UnderlyingType)' collectionContractAttribute.KeyName)));                              keyName = DataContract.EncodeLocalName(collectionContractAttribute.KeyName);                          }                          if (collectionContractAttribute.IsValueNameSetExplicitly)                          {                              if (collectionContractAttribute.ValueName == null || collectionContractAttribute.ValueName.Length == 0)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractValueName' DataContract.GetClrTypeFullName(UnderlyingType))));                              if (!isDictionary)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractValueNoDictionary' DataContract.GetClrTypeFullName(UnderlyingType)' collectionContractAttribute.ValueName)));                              valueName = DataContract.EncodeLocalName(collectionContractAttribute.ValueName);                          }                      }                        XmlDictionary dictionary = isDictionary ? new XmlDictionary(5) : new XmlDictionary(3);                      this.Name = dictionary.Add(this.StableName.Name);                      this.Namespace = dictionary.Add(this.StableName.Namespace);                      _itemName = itemName ?? DataContract.GetStableName(DataContract.UnwrapNullableType(itemType)).Name;                      _collectionItemName = dictionary.Add(_itemName);                      if (isDictionary)                      {                          _keyName = keyName ?? Globals.KeyLocalName;                          _valueName = valueName ?? Globals.ValueLocalName;                      }                  }
Magic Number,System.Runtime.Serialization,CollectionDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,Init,The following statement contains a magic number: if (itemType != null)                  {                      _itemType = itemType;                      _isItemTypeNullable = DataContract.IsTypeNullable(itemType);                        bool isDictionary = (kind == CollectionKind.Dictionary || kind == CollectionKind.GenericDictionary);                      string itemName = null' keyName = null' valueName = null;                      if (collectionContractAttribute != null)                      {                          if (collectionContractAttribute.IsItemNameSetExplicitly)                          {                              if (collectionContractAttribute.ItemName == null || collectionContractAttribute.ItemName.Length == 0)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractItemName' DataContract.GetClrTypeFullName(UnderlyingType))));                              itemName = DataContract.EncodeLocalName(collectionContractAttribute.ItemName);                              _itemNameSetExplicit = true;                          }                          if (collectionContractAttribute.IsKeyNameSetExplicitly)                          {                              if (collectionContractAttribute.KeyName == null || collectionContractAttribute.KeyName.Length == 0)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractKeyName' DataContract.GetClrTypeFullName(UnderlyingType))));                              if (!isDictionary)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractKeyNoDictionary' DataContract.GetClrTypeFullName(UnderlyingType)' collectionContractAttribute.KeyName)));                              keyName = DataContract.EncodeLocalName(collectionContractAttribute.KeyName);                          }                          if (collectionContractAttribute.IsValueNameSetExplicitly)                          {                              if (collectionContractAttribute.ValueName == null || collectionContractAttribute.ValueName.Length == 0)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractValueName' DataContract.GetClrTypeFullName(UnderlyingType))));                              if (!isDictionary)                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new InvalidDataContractException(SR.Format(SR.InvalidCollectionContractValueNoDictionary' DataContract.GetClrTypeFullName(UnderlyingType)' collectionContractAttribute.ValueName)));                              valueName = DataContract.EncodeLocalName(collectionContractAttribute.ValueName);                          }                      }                        XmlDictionary dictionary = isDictionary ? new XmlDictionary(5) : new XmlDictionary(3);                      this.Name = dictionary.Add(this.StableName.Name);                      this.Namespace = dictionary.Add(this.StableName.Namespace);                      _itemName = itemName ?? DataContract.GetStableName(DataContract.UnwrapNullableType(itemType)).Name;                      _collectionItemName = dictionary.Add(_itemName);                      if (isDictionary)                      {                          _keyName = keyName ?? Globals.KeyLocalName;                          _valueName = valueName ?? Globals.ValueLocalName;                      }                  }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetNamespacesDigest,The following statement contains a magic number: char[] digestChars = new char[24];
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetNamespacesDigest,The following statement contains a magic number: const int digestLen = 6;
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int[] shifts = new int[] { 7' 12' 17' 22' 5' 9' 14' 20' 4' 11' 16' 23' 6' 10' 15' 21 };
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int blocks = (namespaces.Length + 8) / 64 + 1;
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: int blocks = (namespaces.Length + 8) / 64 + 1;
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: for (int i = 0; i < blocks; i++)              {                  byte[] block = namespaces;                  int offset = i * 64;                    if (offset + 64 > namespaces.Length)                  {                      block = new byte[64];                        for (int j = offset; j < namespaces.Length; j++)                      {                          block[j - offset] = namespaces[j];                      }                      if (offset <= namespaces.Length)                      {                          block[namespaces.Length - offset] = 0x80;                      }                      if (i == blocks - 1)                      {                          unchecked                          {                              block[56] = (byte)(namespaces.Length << 3);                              block[57] = (byte)(namespaces.Length >> 5);                              block[58] = (byte)(namespaces.Length >> 13);                              block[59] = (byte)(namespaces.Length >> 21);                          }                      }                        offset = 0;                  }                    uint a = aa;                  uint b = bb;                  uint c = cc;                  uint d = dd;                    uint f;                  int g;                    for (int j = 0; j < 64; j++)                  {                      if (j < 16)                      {                          f = b & c | ~b & d;                          g = j;                      }                      else if (j < 32)                      {                          f = b & d | c & ~d;                          g = 5 * j + 1;                      }                      else if (j < 48)                      {                          f = b ^ c ^ d;                          g = 3 * j + 5;                      }                      else                      {                          f = c ^ (b | ~d);                          g = 7 * j;                      }                        g = (g & 0x0f) * 4 + offset;                        uint hold = d;                      d = c;                      c = b;                        b = unchecked(a + f + sines[j] + (uint)(block[g] + (block[g + 1] << 8) + (block[g + 2] << 16) + (block[g + 3] << 24)));                      b = b << shifts[j & 3 | j >> 2 & ~3] | b >> 32 - shifts[j & 3 | j >> 2 & ~3];                      b = unchecked(b + c);                        a = hold;                  }                    unchecked                  {                      aa += a;                      bb += b;                        if (i < blocks - 1)                      {                          cc += c;                          dd += d;                      }                  }              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: unchecked              {                  return new byte[] { (byte)aa' (byte)(aa >> 8)' (byte)(aa >> 16)' (byte)(aa >> 24)' (byte)bb' (byte)(bb >> 8) };              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: unchecked              {                  return new byte[] { (byte)aa' (byte)(aa >> 8)' (byte)(aa >> 16)' (byte)(aa >> 24)' (byte)bb' (byte)(bb >> 8) };              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: unchecked              {                  return new byte[] { (byte)aa' (byte)(aa >> 8)' (byte)(aa >> 16)' (byte)(aa >> 24)' (byte)bb' (byte)(bb >> 8) };              }
Magic Number,System.Runtime.Serialization,DataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,ComputeHash,The following statement contains a magic number: unchecked              {                  return new byte[] { (byte)aa' (byte)(aa >> 8)' (byte)(aa >> 16)' (byte)(aa >> 24)' (byte)bb' (byte)(bb >> 8) };              }
Magic Number,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetId,The following statement contains a magic number: lock (s_cacheLock)                  {                      IntRef id;                      typeHandle = GetDataContractAdapterTypeHandle(typeHandle);                      s_typeHandleRef.Value = typeHandle;                      if (!s_typeToIDCache.TryGetValue(s_typeHandleRef' out id))                      {                          int value = s_dataContractID++;                          if (value >= s_dataContractCache.Length)                          {                              int newSize = (value < Int32.MaxValue / 2) ? value * 2 : Int32.MaxValue;                              if (newSize <= value)                              {                                  DiagnosticUtility.DebugAssert("DataContract cache overflow");                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SerializationException(SR.Format(SR.DataContractCacheOverflow)));                              }                              Array.Resize<DataContract>(ref s_dataContractCache' newSize);                          }                          id = new IntRef(value);                          try                          {                              s_typeToIDCache.Add(new TypeHandleRef(typeHandle)' id);                          }                          catch (Exception ex)                          {                              if (DiagnosticUtility.IsFatal(ex))                              {                                  throw;                              }                              throw DiagnosticUtility.ExceptionUtility.ThrowHelperFatal(ex.Message' ex);                          }                      }                      return id.Value;                  }
Magic Number,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetId,The following statement contains a magic number: lock (s_cacheLock)                  {                      IntRef id;                      typeHandle = GetDataContractAdapterTypeHandle(typeHandle);                      s_typeHandleRef.Value = typeHandle;                      if (!s_typeToIDCache.TryGetValue(s_typeHandleRef' out id))                      {                          int value = s_dataContractID++;                          if (value >= s_dataContractCache.Length)                          {                              int newSize = (value < Int32.MaxValue / 2) ? value * 2 : Int32.MaxValue;                              if (newSize <= value)                              {                                  DiagnosticUtility.DebugAssert("DataContract cache overflow");                                  throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new SerializationException(SR.Format(SR.DataContractCacheOverflow)));                              }                              Array.Resize<DataContract>(ref s_dataContractCache' newSize);                          }                          id = new IntRef(value);                          try                          {                              s_typeToIDCache.Add(new TypeHandleRef(typeHandle)' id);                          }                          catch (Exception ex)                          {                              if (DiagnosticUtility.IsFatal(ex))                              {                                  throw;                              }                              throw DiagnosticUtility.ExceptionUtility.ThrowHelperFatal(ex.Message' ex);                          }                      }                      return id.Value;                  }
Magic Number,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,GetBuiltInDataContract,The following statement contains a magic number: lock (s_initBuiltInContractsLock)                  {                      if (s_nameToBuiltInContract == null)                          s_nameToBuiltInContract = new Dictionary<XmlQualifiedName' DataContract>();                        DataContract dataContract = null;                      XmlQualifiedName qname = new XmlQualifiedName(typeName);                      if (!s_nameToBuiltInContract.TryGetValue(qname' out dataContract))                      {                          Type type = null;                          string name = typeName.Substring(7);                          if (name == "Char")                              type = typeof(Char);                          else if (name == "Boolean")                              type = typeof(Boolean);                          else if (name == "SByte")                              type = typeof(SByte);                          else if (name == "Byte")                              type = typeof(Byte);                          else if (name == "Int16")                              type = typeof(Int16);                          else if (name == "UInt16")                              type = typeof(UInt16);                          else if (name == "Int32")                              type = typeof(Int32);                          else if (name == "UInt32")                              type = typeof(UInt32);                          else if (name == "Int64")                              type = typeof(Int64);                          else if (name == "UInt64")                              type = typeof(UInt64);                          else if (name == "Single")                              type = typeof(Single);                          else if (name == "Double")                              type = typeof(Double);                          else if (name == "Decimal")                              type = typeof(Decimal);                          else if (name == "DateTime")                              type = typeof(DateTime);                          else if (name == "String")                              type = typeof(String);                          else if (name == "Byte[]")                              type = typeof(byte[]);                          else if (name == "Object")                              type = typeof(Object);                          else if (name == "TimeSpan")                              type = typeof(TimeSpan);                          else if (name == "Guid")                              type = typeof(Guid);                          else if (name == "Uri")                              type = typeof(Uri);                          else if (name == "Xml.XmlQualifiedName")                              type = typeof(XmlQualifiedName);                          else if (name == "Enum")                              type = typeof(Enum);                          else if (name == "ValueType")                              type = typeof(ValueType);                          else if (name == "Array")                              type = typeof(Array);                          else if (name == "Xml.XmlElement")                              type = typeof(XmlElement);                          else if (name == "Xml.XmlNode[]")                              type = typeof(XmlNode[]);                            if (type != null)                              TryCreateBuiltInDataContract(type' out dataContract);                            s_nameToBuiltInContract.Add(qname' dataContract);                      }                      return dataContract;                  }
Magic Number,System.Runtime.Serialization,DataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContract.cs,SetDataContractName,The following statement contains a magic number: XmlDictionary dictionary = new XmlDictionary(2);
Magic Number,System.Runtime.Serialization,DictionaryGlobals,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DictionaryGlobals.cs,DictionaryGlobals,The following statement contains a magic number: XmlDictionary dictionary = new XmlDictionary(61);
Magic Number,System.Runtime.Serialization,DataContractSerializer,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataContractSerializer.cs,DataContractSerializer,The following statement contains a magic number: XmlDictionary dictionary = new XmlDictionary(2);
Magic Number,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,GenerateCollectionReaderHelper,The following statement contains a magic number: _collectionContractArg = _ilg.GetArg(4);
Magic Number,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,InitArgs,The following statement contains a magic number: _memberNamesArg = _ilg.GetArg(2);
Magic Number,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,InitArgs,The following statement contains a magic number: _memberNamespacesArg = _ilg.GetArg(3);
Magic Number,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadCollection,The following statement contains a magic number: if (isArray)                  {                      growingCollection = _ilg.DeclareLocal(type' "growingCollection");                      _ilg.NewArray(itemType' 32);                      _ilg.Stloc(growingCollection);                  }
Magic Number,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,InitArgs,The following statement contains a magic number: _contextArg = _ilg.GetArg(2);
Magic Number,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,InitArgs,The following statement contains a magic number: _dataContractArg = _ilg.GetArg(3);
Magic Number,System.Runtime.Serialization,EnumDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\EnumDataContract.cs,EnumDataContractCriticalHelper,The following statement contains a magic number: XmlDictionary dictionary = new XmlDictionary(2 + Members.Count);
Magic Number,System.Runtime.Serialization,ExtensionDataReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataReader.cs,GrowElementsIfNeeded,The following statement contains a magic number: if (_elements == null)                  _elements = new ElementData[8];              else if (_elements.Length == _depth)              {                  ElementData[] newElements = new ElementData[_elements.Length * 2];                  Array.Copy(_elements' 0' newElements' 0' _elements.Length);                  _elements = newElements;              }
Magic Number,System.Runtime.Serialization,ExtensionDataReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataReader.cs,GrowElementsIfNeeded,The following statement contains a magic number: if (_elements == null)                  _elements = new ElementData[8];              else if (_elements.Length == _depth)              {                  ElementData[] newElements = new ElementData[_elements.Length * 2];                  Array.Copy(_elements' 0' newElements' 0' _elements.Length);                  _elements = newElements;              }
Magic Number,System.Runtime.Serialization,ElementData,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataReader.cs,GrowAttributesIfNeeded,The following statement contains a magic number: if (attributes == null)                  attributes = new AttributeData[4];              else if (attributes.Length == attributeCount)              {                  AttributeData[] newAttributes = new AttributeData[attributes.Length * 2];                  Array.Copy(attributes' 0' newAttributes' 0' attributes.Length);                  attributes = newAttributes;              }
Magic Number,System.Runtime.Serialization,ElementData,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ExtensionDataReader.cs,GrowAttributesIfNeeded,The following statement contains a magic number: if (attributes == null)                  attributes = new AttributeData[4];              else if (attributes.Length == attributeCount)              {                  AttributeData[] newAttributes = new AttributeData[attributes.Length * 2];                  Array.Copy(attributes' 0' newAttributes' 0' attributes.Length);                  attributes = newAttributes;              }
Magic Number,System.Runtime.Serialization,ObjectReferenceStack,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ObjectReferenceStack.cs,Push,The following statement contains a magic number: if (_objectArray == null)              {                  _objectArray = new object[InitialArraySize];                  _objectArray[_count++] = obj;              }              else if (_count < MaximumArraySize)              {                  if (_count == _objectArray.Length)                      Array.Resize<object>(ref _objectArray' _objectArray.Length * 2);                  _objectArray[_count++] = obj;              }              else              {                  if (_objectDictionary == null)                      _objectDictionary = new Dictionary<object' object>();                    _objectDictionary.Add(obj' null);                  _count++;              }
Magic Number,System.Runtime.Serialization,ObjectReferenceStack,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ObjectReferenceStack.cs,EnsureSetAsIsReference,The following statement contains a magic number: if (_count > MaximumArraySize)              {                  if (_objectDictionary == null)                  {                      DiagnosticUtility.DebugAssert("Object reference stack in invalid state");                  }                  _objectDictionary.Remove(obj);              }              else              {                  if ((_objectArray != null) && _objectArray[_count - 1] == obj)                  {                      if (_isReferenceArray == null)                      {                          _isReferenceArray = new bool[InitialArraySize];                      }                      else if (_count == _isReferenceArray.Length)                      {                          Array.Resize<bool>(ref _isReferenceArray' _isReferenceArray.Length * 2);                      }                      _isReferenceArray[_count - 1] = true;                  }              }
Magic Number,System.Runtime.Serialization,SchemaExporter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\SchemaExporter.cs,GetDefaultEnumValue,The following statement contains a magic number: return isFlags ? (long)Math.Pow(2' index) : index;
Magic Number,System.Runtime.Serialization,ScopedKnownTypes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ScopedKnownTypes.cs,Push,The following statement contains a magic number: if (dataContractDictionaries == null)                  dataContractDictionaries = new DataContractDictionary[4];              else if (_count == dataContractDictionaries.Length)                  Array.Resize<DataContractDictionary>(ref dataContractDictionaries' dataContractDictionaries.Length * 2);
Magic Number,System.Runtime.Serialization,ScopedKnownTypes,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ScopedKnownTypes.cs,Push,The following statement contains a magic number: if (dataContractDictionaries == null)                  dataContractDictionaries = new DataContractDictionary[4];              else if (_count == dataContractDictionaries.Length)                  Array.Resize<DataContractDictionary>(ref dataContractDictionaries' dataContractDictionaries.Length * 2);
Magic Number,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,EnsureArraySize,The following statement contains a magic number: if (array.Length <= index)              {                  if (index == Int32.MaxValue)                  {                      throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(                          XmlObjectSerializer.CreateSerializationException(                          SR.Format(SR.MaxArrayLengthExceeded' Int32.MaxValue'                          DataContract.GetClrTypeFullName(typeof(T)))));                  }                  int newSize = (index < Int32.MaxValue / 2) ? index * 2 : Int32.MaxValue;                  T[] newArray = new T[newSize];                  Array.Copy(array' 0' newArray' 0' array.Length);                  array = newArray;              }
Magic Number,System.Runtime.Serialization,XmlObjectSerializerReadContext,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\XmlObjectSerializerReadContext.cs,EnsureArraySize,The following statement contains a magic number: if (array.Length <= index)              {                  if (index == Int32.MaxValue)                  {                      throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(                          XmlObjectSerializer.CreateSerializationException(                          SR.Format(SR.MaxArrayLengthExceeded' Int32.MaxValue'                          DataContract.GetClrTypeFullName(typeof(T)))));                  }                  int newSize = (index < Int32.MaxValue / 2) ? index * 2 : Int32.MaxValue;                  T[] newArray = new T[newSize];                  Array.Copy(array' 0' newArray' 0' array.Length);                  array = newArray;              }
Magic Number,System.Runtime.Serialization,BitFlagsGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\BitFlagsGenerator.cs,BitFlagsGenerator,The following statement contains a magic number: int localCount = (bitCount + 7) / 8;
Magic Number,System.Runtime.Serialization,BitFlagsGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\BitFlagsGenerator.cs,BitFlagsGenerator,The following statement contains a magic number: int localCount = (bitCount + 7) / 8;
Magic Number,System.Runtime.Serialization,BitFlagsGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\BitFlagsGenerator.cs,GetBitValue,The following statement contains a magic number: return (byte)(1 << (bitIndex & 7));
Magic Number,System.Runtime.Serialization,BitFlagsGenerator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\BitFlagsGenerator.cs,GetByteIndex,The following statement contains a magic number: return bitIndex >> 3;
Magic Number,System.Runtime.Serialization,CodeTypeReference,C:\selectedRepos\dotnet_corefx\src\Common\src\System\CodeDom\CodeTypeReference.cs,RipOffAssemblyInformationFromTypeName,The following statement contains a magic number: if (start < end)              {                  if (typeName[start] == '[' && typeName[end] == ']')                  {                      start++;                      end--;                  }                    // if we still have a ] at the end' there's no assembly info.                   if (typeName[end] != ']')                  {                      int commaCount = 0;                      for (int index = end; index >= start; index--)                      {                          if (typeName[index] == ''')                          {                              commaCount++;                              if (commaCount == 4)                              {                                  result = typeName.Substring(start' index - start);                                  break;                              }                          }                      }                  }              }
Magic Number,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The following statement contains a magic number: if (reader.TryGetArrayLength(out count))              {                  if (count > XmlDictionaryReader.MaxInitialArrayLength)                      count = XmlDictionaryReader.MaxInitialArrayLength;              }              else              {                  count = 32;              }
Magic Number,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The following statement contains a magic number: while (true)              {                  array = new TArray[count];                  int read = 0;                  while (read < array.Length)                  {                      int actual = ReadArray(reader' localName' namespaceUri' array' read' array.Length - read);                      if (actual == 0)                          break;                      read += actual;                  }                  totalRead += read;                  if (read < array.Length || reader.NodeType == XmlNodeType.EndElement)                      break;                  if (arrays == null)                      arrays = new TArray[32][];                  arrays[arrayCount++] = array;                  count = count * 2;              }
Magic Number,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,ReadArray,The following statement contains a magic number: while (true)              {                  array = new TArray[count];                  int read = 0;                  while (read < array.Length)                  {                      int actual = ReadArray(reader' localName' namespaceUri' array' read' array.Length - read);                      if (actual == 0)                          break;                      read += actual;                  }                  totalRead += read;                  if (read < array.Length || reader.NodeType == XmlNodeType.EndElement)                      break;                  if (arrays == null)                      arrays = new TArray[32][];                  arrays[arrayCount++] = array;                  count = count * 2;              }
Magic Number,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The following statement contains a magic number: if (reader.TryGetArrayLength(out count))                  count = Math.Min(count' 256);              else                  count = 256;
Magic Number,System.Xml,ArrayHelper<TArgument;TArray>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ArrayHelper.cs,WriteArray,The following statement contains a magic number: if (reader.TryGetArrayLength(out count))                  count = Math.Min(count' 256);              else                  count = 256;
Magic Number,System.Xml,PrefixHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\PrefixHandle.cs,GetAlphaPrefix,The following statement contains a magic number: DiagnosticUtility.DebugAssert(index >= 0 && index < 26' "");
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UniqueId,The following statement contains a magic number: fixed (byte* pb = &guid[offset])              {                  _idLow = UnsafeGetInt64(pb);                  _idHigh = UnsafeGetInt64(&pb[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeEncode,The following statement contains a magic number: pch[0] = val2char[b >> 4];
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: if (charCount != uuidLength ||                  chars[0] != 'u' || chars[1] != 'r' || chars[2] != 'n' || chars[3] != ':' ||                  chars[4] != 'u' || chars[5] != 'u' || chars[6] != 'i' || chars[7] != 'd' || chars[8] != ':' ||                  chars[17] != '-' || chars[22] != '-' || chars[27] != '-' || chars[32] != '-')              {                  return;              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeParse,The following statement contains a magic number: fixed (short* ps = &s_char2val[0])              {                  short* _char2val = ps;                    //   0         1         2         3         4                  //   012345678901234567890123456789012345678901234                  //   urn:uuid:aabbccdd-eeff-gghh-0011-223344556677                  //                   //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5                  //   ddccbbaaffeehhgg0011223344556677                    i = UnsafeDecode(_char2val' chars[15]' chars[16]); bytes[0] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[13]' chars[14]); bytes[1] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[11]' chars[12]); bytes[2] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[9]' chars[10]); bytes[3] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[20]' chars[21]); bytes[4] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[18]' chars[19]); bytes[5] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[25]' chars[26]); bytes[6] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[23]' chars[24]); bytes[7] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[28]' chars[29]); bytes[8] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[30]' chars[31]); bytes[9] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[33]' chars[34]); bytes[10] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[35]' chars[36]); bytes[11] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[37]' chars[38]); bytes[12] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[39]' chars[40]); bytes[13] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[41]' chars[42]); bytes[14] = (byte)i; j |= i;                  i = UnsafeDecode(_char2val' chars[43]' chars[44]); bytes[15] = (byte)i; j |= i;                    if (j >= 0x100)                      return;                    _idLow = UnsafeGetInt64(bytes);                  _idHigh = UnsafeGetInt64(&bytes[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,ToCharArray,The following statement contains a magic number: if (_s != null)              {                  _s.CopyTo(0' chars' offset' count);              }              else              {                  byte* bytes = stackalloc byte[guidLength];                  UnsafeSetInt64(_idLow' bytes);                  UnsafeSetInt64(_idHigh' &bytes[8]);                    fixed (char* _pch = &chars[offset])                  {                      char* pch = _pch;                      pch[0] = 'u';                      pch[1] = 'r';                      pch[2] = 'n';                      pch[3] = ':';                      pch[4] = 'u';                      pch[5] = 'u';                      pch[6] = 'i';                      pch[7] = 'd';                      pch[8] = ':';                      pch[17] = '-';                      pch[22] = '-';                      pch[27] = '-';                      pch[32] = '-';                        fixed (char* ps = val2char)                      {                          char* _val2char = ps;                          UnsafeEncode(_val2char' bytes[0]' &pch[15]);                          UnsafeEncode(_val2char' bytes[1]' &pch[13]);                          UnsafeEncode(_val2char' bytes[2]' &pch[11]);                          UnsafeEncode(_val2char' bytes[3]' &pch[9]);                          UnsafeEncode(_val2char' bytes[4]' &pch[20]);                          UnsafeEncode(_val2char' bytes[5]' &pch[18]);                          UnsafeEncode(_val2char' bytes[6]' &pch[25]);                          UnsafeEncode(_val2char' bytes[7]' &pch[23]);                          UnsafeEncode(_val2char' bytes[8]' &pch[28]);                          UnsafeEncode(_val2char' bytes[9]' &pch[30]);                          UnsafeEncode(_val2char' bytes[10]' &pch[33]);                          UnsafeEncode(_val2char' bytes[11]' &pch[35]);                          UnsafeEncode(_val2char' bytes[12]' &pch[37]);                          UnsafeEncode(_val2char' bytes[13]' &pch[39]);                          UnsafeEncode(_val2char' bytes[14]' &pch[41]);                          UnsafeEncode(_val2char' bytes[15]' &pch[43]);                      }                  }              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,TryGetGuid,The following statement contains a magic number: fixed (byte* pb = &buffer[offset])              {                  UnsafeSetInt64(_idLow' pb);                  UnsafeSetInt64(_idHigh' &pb[8]);              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,GetHashCode,The following statement contains a magic number: if (IsGuid)              {                  Int64 hash = (_idLow ^ _idHigh);                  return ((int)(hash >> 32)) ^ ((int)hash);              }              else              {                  return ToString().GetHashCode();              }
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeGetInt64,The following statement contains a magic number: Int32 idHigh = UnsafeGetInt32(&pb[4]);
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeGetInt64,The following statement contains a magic number: return (((Int64)idHigh) << 32) | ((UInt32)idLow);
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeGetInt32,The following statement contains a magic number: int value = pb[3];
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeGetInt32,The following statement contains a magic number: value <<= 8;
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeGetInt32,The following statement contains a magic number: value |= pb[2];
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeGetInt32,The following statement contains a magic number: value <<= 8;
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeGetInt32,The following statement contains a magic number: value <<= 8;
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeSetInt64,The following statement contains a magic number: UnsafeSetInt32((int)(value >> 32)' &pb[4]);
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeSetInt64,The following statement contains a magic number: UnsafeSetInt32((int)(value >> 32)' &pb[4]);
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeSetInt32,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeSetInt32,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeSetInt32,The following statement contains a magic number: pb[2] = (byte)value;
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeSetInt32,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,UniqueId,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\UniqueId.cs,UnsafeSetInt32,The following statement contains a magic number: pb[3] = (byte)value;
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToByteArray,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && (_length % 4) == 0)              {                  try                  {                      int expectedLength = _length / 4 * 3;                      if (_length > 0)                      {                          if (_bufferReader.Buffer[_offset + _length - 1] == '=')                          {                              expectedLength--;                              if (_bufferReader.Buffer[_offset + _length - 2] == '=')                                  expectedLength--;                          }                      }                      byte[] buffer = new byte[expectedLength];                      int actualLength = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' _length' buffer' 0);                      if (actualLength != buffer.Length)                      {                          byte[] newBuffer = new byte[actualLength];                          Buffer.BlockCopy(buffer' 0' newBuffer' 0' actualLength);                          buffer = newBuffer;                      }                      return buffer;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToByteArray,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && (_length % 4) == 0)              {                  try                  {                      int expectedLength = _length / 4 * 3;                      if (_length > 0)                      {                          if (_bufferReader.Buffer[_offset + _length - 1] == '=')                          {                              expectedLength--;                              if (_bufferReader.Buffer[_offset + _length - 2] == '=')                                  expectedLength--;                          }                      }                      byte[] buffer = new byte[expectedLength];                      int actualLength = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' _length' buffer' 0);                      if (actualLength != buffer.Length)                      {                          byte[] newBuffer = new byte[actualLength];                          Buffer.BlockCopy(buffer' 0' newBuffer' 0' actualLength);                          buffer = newBuffer;                      }                      return buffer;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToByteArray,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && (_length % 4) == 0)              {                  try                  {                      int expectedLength = _length / 4 * 3;                      if (_length > 0)                      {                          if (_bufferReader.Buffer[_offset + _length - 1] == '=')                          {                              expectedLength--;                              if (_bufferReader.Buffer[_offset + _length - 2] == '=')                                  expectedLength--;                          }                      }                      byte[] buffer = new byte[expectedLength];                      int actualLength = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' _length' buffer' 0);                      if (actualLength != buffer.Length)                      {                          byte[] newBuffer = new byte[actualLength];                          Buffer.BlockCopy(buffer' 0' newBuffer' 0' actualLength);                          buffer = newBuffer;                      }                      return buffer;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,ToByteArray,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && (_length % 4) == 0)              {                  try                  {                      int expectedLength = _length / 4 * 3;                      if (_length > 0)                      {                          if (_bufferReader.Buffer[_offset + _length - 1] == '=')                          {                              expectedLength--;                              if (_bufferReader.Buffer[_offset + _length - 2] == '=')                                  expectedLength--;                          }                      }                      byte[] buffer = new byte[expectedLength];                      int actualLength = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' _length' buffer' 0);                      if (actualLength != buffer.Length)                      {                          byte[] newBuffer = new byte[actualLength];                          Buffer.BlockCopy(buffer' 0' newBuffer' 0' actualLength);                          buffer = newBuffer;                      }                      return buffer;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,Equals2,The following statement contains a magic number: for (int i = 0; i < _length; ++i)              {                  DiagnosticUtility.DebugAssert(str[i] < 128' "");                  byte ch = buffer[i + _offset];                  if (ch == str[i])                      continue;                    if (checkLower && char.ToLowerInvariant((char)ch) == str[i])                      continue;                    return false;              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadBase64,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && count >= 3 && (_length % 4) == 0)              {                  try                  {                      int charCount = Math.Min(count / 3 * 4' _length);                      actual = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' charCount' buffer' offset);                      _offset += charCount;                      _length -= charCount;                      return true;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadBase64,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && count >= 3 && (_length % 4) == 0)              {                  try                  {                      int charCount = Math.Min(count / 3 * 4' _length);                      actual = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' charCount' buffer' offset);                      _offset += charCount;                      _length -= charCount;                      return true;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadBase64,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && count >= 3 && (_length % 4) == 0)              {                  try                  {                      int charCount = Math.Min(count / 3 * 4' _length);                      actual = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' charCount' buffer' offset);                      _offset += charCount;                      _length -= charCount;                      return true;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadBase64,The following statement contains a magic number: if (_type == ValueHandleType.UTF8 && count >= 3 && (_length % 4) == 0)              {                  try                  {                      int charCount = Math.Min(count / 3 * 4' _length);                      actual = Base64Encoding.GetBytes(_bufferReader.Buffer' _offset' charCount' buffer' offset);                      _offset += charCount;                      _length -= charCount;                      return true;                  }                  catch (FormatException)                  {                      // Something unhappy with the characters' fall back to the hard way                  }              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The following statement contains a magic number: while (true)              {                  while (charCount > 0 && byteCount > 0)                  {                      // fast path for codepoints U+0000 - U+007F                      byte b = bytes[byteOffset];                      if (b >= 0x80)                          break;                      chars[charOffset] = (char)b;                      byteOffset++;                      byteCount--;                      charOffset++;                      charCount--;                  }                    if (charCount == 0 || byteCount == 0 || insufficientSpaceInCharsArray)                      break;                    int actualByteCount;                  int actualCharCount;                    try                  {                      // If we're asking for more than are possibly available' or more than are truly available then we can return the entire thing                      if (charCount >= encoding.GetMaxCharCount(byteCount) || charCount >= encoding.GetCharCount(bytes' byteOffset' byteCount))                      {                          actualCharCount = encoding.GetChars(bytes' byteOffset' byteCount' chars' charOffset);                          actualByteCount = byteCount;                      }                      else                      {                          Decoder decoder = encoding.GetDecoder();                            // Since x bytes can never generate more than x characters this is a safe estimate as to what will fit                          actualByteCount = Math.Min(charCount' byteCount);                            // We use a decoder so we don't error if we fall across a character boundary                          actualCharCount = decoder.GetChars(bytes' byteOffset' actualByteCount' chars' charOffset);                            // We might have gotten zero characters though if < 4 bytes were requested because                          // codepoints from U+0000 - U+FFFF can be up to 3 bytes in UTF-8' and represented as ONE char                          // codepoints from U+10000 - U+10FFFF (last Unicode codepoint representable in UTF-8) are represented by up to 4 bytes in UTF-8                           //                                    and represented as TWO chars (high+low surrogate)                          // (e.g. 1 char requested' 1 char in the buffer represented in 3 bytes)                          while (actualCharCount == 0)                          {                              // Note the by the time we arrive here' if actualByteCount == 3' the next decoder.GetChars() call will read the 4th byte                              // if we don't bail out since the while loop will advance actualByteCount only after reading the byte.                               if (actualByteCount >= 3 && charCount < 2)                              {                                  // If we reach here' it means that we're:                                   // - trying to decode more than 3 bytes and'                                   // - there is only one char left of charCount where we're stuffing decoded characters.                                   // In this case' we need to back off since decoding > 3 bytes in UTF-8 means that we will get 2 16-bit chars                                   // (a high surrogate and a low surrogate) - the Decoder will attempt to provide both at once                                   // and an ArgumentException will be thrown complaining that there's not enough space in the output char array.                                      // actualByteCount = 0 when the while loop is broken out of; decoder goes out of scope so its state no longer matters                                    insufficientSpaceInCharsArray = true;                                  break;                              }                              else                              {                                  DiagnosticUtility.DebugAssert(byteOffset + actualByteCount < bytes.Length'                                      string.Format("byteOffset {0} + actualByteCount {1} MUST BE < bytes.Length {2}"' byteOffset' actualByteCount' bytes.Length));                                    // Request a few more bytes to get at least one character                                  actualCharCount = decoder.GetChars(bytes' byteOffset + actualByteCount' 1' chars' charOffset);                                  actualByteCount++;                              }                          }                            // Now that we actually retrieved some characters' figure out how many bytes it actually was                          actualByteCount = encoding.GetByteCount(chars' charOffset' actualCharCount);                      }                  }                  catch (FormatException exception)                  {                      throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateEncodingException(bytes' byteOffset' byteCount' exception));                  }                    // Advance                  byteOffset += actualByteCount;                  byteCount -= actualByteCount;                    charOffset += actualCharCount;                  charCount -= actualCharCount;              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,TryReadChars,The following statement contains a magic number: while (true)              {                  while (charCount > 0 && byteCount > 0)                  {                      // fast path for codepoints U+0000 - U+007F                      byte b = bytes[byteOffset];                      if (b >= 0x80)                          break;                      chars[charOffset] = (char)b;                      byteOffset++;                      byteCount--;                      charOffset++;                      charCount--;                  }                    if (charCount == 0 || byteCount == 0 || insufficientSpaceInCharsArray)                      break;                    int actualByteCount;                  int actualCharCount;                    try                  {                      // If we're asking for more than are possibly available' or more than are truly available then we can return the entire thing                      if (charCount >= encoding.GetMaxCharCount(byteCount) || charCount >= encoding.GetCharCount(bytes' byteOffset' byteCount))                      {                          actualCharCount = encoding.GetChars(bytes' byteOffset' byteCount' chars' charOffset);                          actualByteCount = byteCount;                      }                      else                      {                          Decoder decoder = encoding.GetDecoder();                            // Since x bytes can never generate more than x characters this is a safe estimate as to what will fit                          actualByteCount = Math.Min(charCount' byteCount);                            // We use a decoder so we don't error if we fall across a character boundary                          actualCharCount = decoder.GetChars(bytes' byteOffset' actualByteCount' chars' charOffset);                            // We might have gotten zero characters though if < 4 bytes were requested because                          // codepoints from U+0000 - U+FFFF can be up to 3 bytes in UTF-8' and represented as ONE char                          // codepoints from U+10000 - U+10FFFF (last Unicode codepoint representable in UTF-8) are represented by up to 4 bytes in UTF-8                           //                                    and represented as TWO chars (high+low surrogate)                          // (e.g. 1 char requested' 1 char in the buffer represented in 3 bytes)                          while (actualCharCount == 0)                          {                              // Note the by the time we arrive here' if actualByteCount == 3' the next decoder.GetChars() call will read the 4th byte                              // if we don't bail out since the while loop will advance actualByteCount only after reading the byte.                               if (actualByteCount >= 3 && charCount < 2)                              {                                  // If we reach here' it means that we're:                                   // - trying to decode more than 3 bytes and'                                   // - there is only one char left of charCount where we're stuffing decoded characters.                                   // In this case' we need to back off since decoding > 3 bytes in UTF-8 means that we will get 2 16-bit chars                                   // (a high surrogate and a low surrogate) - the Decoder will attempt to provide both at once                                   // and an ArgumentException will be thrown complaining that there's not enough space in the output char array.                                      // actualByteCount = 0 when the while loop is broken out of; decoder goes out of scope so its state no longer matters                                    insufficientSpaceInCharsArray = true;                                  break;                              }                              else                              {                                  DiagnosticUtility.DebugAssert(byteOffset + actualByteCount < bytes.Length'                                      string.Format("byteOffset {0} + actualByteCount {1} MUST BE < bytes.Length {2}"' byteOffset' actualByteCount' bytes.Length));                                    // Request a few more bytes to get at least one character                                  actualCharCount = decoder.GetChars(bytes' byteOffset + actualByteCount' 1' chars' charOffset);                                  actualByteCount++;                              }                          }                            // Now that we actually retrieved some characters' figure out how many bytes it actually was                          actualByteCount = encoding.GetByteCount(chars' charOffset' actualCharCount);                      }                  }                  catch (FormatException exception)                  {                      throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(XmlExceptionHelper.CreateEncodingException(bytes' byteOffset' byteCount' exception));                  }                    // Advance                  byteOffset += actualByteCount;                  byteCount -= actualByteCount;                    charOffset += actualCharCount;                  charCount -= actualCharCount;              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,GetCharText,The following statement contains a magic number: if (ch > char.MaxValue)              {                  SurrogateChar surrogate = new SurrogateChar(ch);                  char[] chars = new char[2];                  chars[0] = surrogate.HighChar;                  chars[1] = surrogate.LowChar;                  return new string(chars' 0' 2);              }              else              {                  return ((char)ch).ToString();              }
Magic Number,System.Xml,ValueHandle,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\ValueHandle.cs,GetCharText,The following statement contains a magic number: if (ch > char.MaxValue)              {                  SurrogateChar surrogate = new SurrogateChar(ch);                  char[] chars = new char[2];                  chars[0] = surrogate.HighChar;                  chars[1] = surrogate.LowChar;                  return new string(chars' 0' 2);              }              else              {                  return ((char)ch).ToString();              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,MoveToDeclaration,The following statement contains a magic number: if (_attributeCount > 3)                  XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlMalformedDecl)));
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,MoveToDeclaration,The following statement contains a magic number: if (_attributeCount > 1)              {                  if (CheckDeclAttribute(1' "encoding"' null' true' SR.XmlInvalidEncoding))                  {                      if (_attributeCount == 3 && !CheckStandalone(2))                          XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlMalformedDecl)));                  }                  else if (!CheckStandalone(1) || _attributeCount > 2)                  {                      XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlMalformedDecl)));                  }              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,MoveToDeclaration,The following statement contains a magic number: if (_attributeCount > 1)              {                  if (CheckDeclAttribute(1' "encoding"' null' true' SR.XmlInvalidEncoding))                  {                      if (_attributeCount == 3 && !CheckStandalone(2))                          XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlMalformedDecl)));                  }                  else if (!CheckStandalone(1) || _attributeCount > 2)                  {                      XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlMalformedDecl)));                  }              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,MoveToDeclaration,The following statement contains a magic number: if (_attributeCount > 1)              {                  if (CheckDeclAttribute(1' "encoding"' null' true' SR.XmlInvalidEncoding))                  {                      if (_attributeCount == 3 && !CheckStandalone(2))                          XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlMalformedDecl)));                  }                  else if (!CheckStandalone(1) || _attributeCount > 2)                  {                      XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlMalformedDecl)));                  }              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,EnterScope,The following statement contains a magic number: if (_elementNodes == null)              {                  _elementNodes = new XmlElementNode[4];              }              else if (_elementNodes.Length == _depth)              {                  XmlElementNode[] newElementNodes = new XmlElementNode[_depth * 2];                  Array.Copy(_elementNodes' 0' newElementNodes' 0' _depth);                  _elementNodes = newElementNodes;              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,EnterScope,The following statement contains a magic number: if (_elementNodes == null)              {                  _elementNodes = new XmlElementNode[4];              }              else if (_elementNodes.Length == _depth)              {                  XmlElementNode[] newElementNodes = new XmlElementNode[_depth * 2];                  Array.Copy(_elementNodes' 0' newElementNodes' 0' _depth);                  _elementNodes = newElementNodes;              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddAttribute,The following statement contains a magic number: if (_attributeNodes == null)              {                  _attributeNodes = new XmlAttributeNode[4];              }              else if (_attributeNodes.Length == attributeIndex)              {                  XmlAttributeNode[] newAttributeNodes = new XmlAttributeNode[attributeIndex * 2];                  Array.Copy(_attributeNodes' 0' newAttributeNodes' 0' attributeIndex);                  _attributeNodes = newAttributeNodes;              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddAttribute,The following statement contains a magic number: if (_attributeNodes == null)              {                  _attributeNodes = new XmlAttributeNode[4];              }              else if (_attributeNodes.Length == attributeIndex)              {                  XmlAttributeNode[] newAttributeNodes = new XmlAttributeNode[attributeIndex * 2];                  Array.Copy(_attributeNodes' 0' newAttributeNodes' 0' attributeIndex);                  _attributeNodes = newAttributeNodes;              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Close,The following statement contains a magic number: if (_attributeNodes != null && _attributeNodes.Length > 16)                  _attributeNodes = null;
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Close,The following statement contains a magic number: if (_elementNodes != null && _elementNodes.Length > 16)                  _elementNodes = null;
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ProcessAttributes,The following statement contains a magic number: if (attributeCount > 1)              {                  if (attributeCount < 12)                  {                      // For small numbers of attributes' a naive n * (n - 1) / 2 comparisons to check for uniqueness is faster                      for (int i = 0; i < attributeCount - 1; i++)                      {                          XmlAttributeNode attributeNode1 = attributeNodes[i];                          QNameType qnameType = attributeNode1.QNameType;                          if (qnameType == QNameType.Normal)                          {                              for (int j = i + 1; j < attributeCount; j++)                              {                                  XmlAttributeNode attributeNode2 = attributeNodes[j];                                  if (attributeNode2.QNameType == QNameType.Normal && attributeNode1.LocalName == attributeNode2.LocalName && attributeNode1.Namespace.Uri == attributeNode2.Namespace.Uri)                                  {                                      XmlExceptionHelper.ThrowDuplicateAttribute(this' attributeNode1.Prefix.GetString()' attributeNode2.Prefix.GetString()' attributeNode1.LocalName.GetString()' attributeNode1.Namespace.Uri.GetString());                                  }                              }                          }                          else                          {                              DiagnosticUtility.DebugAssert(qnameType == QNameType.Xmlns' "");                              for (int j = i + 1; j < attributeCount; j++)                              {                                  XmlAttributeNode attributeNode2 = attributeNodes[j];                                  if (attributeNode2.QNameType == QNameType.Xmlns && attributeNode1.Namespace.Prefix == attributeNode2.Namespace.Prefix)                                      XmlExceptionHelper.ThrowDuplicateAttribute(this' xmlns' xmlns' attributeNode1.Namespace.Prefix.GetString()' xmlnsNamespace);                              }                          }                      }                  }                  else                  {                      CheckAttributes(attributeNodes' attributeCount);                  }              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The following statement contains a magic number: return ReadBytes(Base64Encoding' 3' 4' buffer' offset' Math.Min(count' 512)' false);
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The following statement contains a magic number: return ReadBytes(Base64Encoding' 3' 4' buffer' offset' Math.Min(count' 512)' false);
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadValueAsBase64,The following statement contains a magic number: return ReadBytes(Base64Encoding' 3' 4' buffer' offset' Math.Min(count' 512)' false);
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The following statement contains a magic number: return ReadBytes(Base64Encoding' 3' 4' buffer' offset' Math.Min(count' 512)' true);
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The following statement contains a magic number: return ReadBytes(Base64Encoding' 3' 4' buffer' offset' Math.Min(count' 512)' true);
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadContentAsBase64,The following statement contains a magic number: return ReadBytes(Base64Encoding' 3' 4' buffer' offset' Math.Min(count' 512)' true);
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,The following statement contains a magic number: while (true)              {                  // If we didn't align on the boundary' then we might have some remaining characters                  if (_trailCharCount > 0)                  {                      Array.Copy(_trailChars' 0' chars' charCount' _trailCharCount);                      charCount += _trailCharCount;                      _trailCharCount = 0;                  }                  // Read until we at least get a charBlock                  while (charCount < charBlock)                  {                      int actualCharCount;                      if (readContent)                      {                          actualCharCount = ReadContentAsChars(chars' charCount' maxCharCount - charCount);                          // When deserializing base64 content which contains new line chars (CR' LF) chars from ReadObject' the reader reads in chunks of base64 content' LF char' base64 content' LF char and so on                          // Relying on encoding.GetBytes' exception to handle LF char would result in performance degradation so skipping LF char here                          if (actualCharCount == 1 && chars[charCount] == '\n')                              continue;                      }                      else                      {                          actualCharCount = ReadValueChunk(chars' charCount' maxCharCount - charCount);                      }                      if (actualCharCount == 0)                          break;                      charCount += actualCharCount;                  }                  // Trim so its a multiple of charBlock                  if (charCount >= charBlock)                  {                      _trailCharCount = (charCount % charBlock);                      if (_trailCharCount > 0)                      {                          if (_trailChars == null)                              _trailChars = new char[4];                          charCount = charCount - _trailCharCount;                          Array.Copy(chars' charCount' _trailChars' 0' _trailCharCount);                      }                  }                  try                  {                      if (byteCount < byteBlock)                      {                          if (_trailBytes == null)                              _trailBytes = new byte[3];                          _trailByteCount = encoding.GetBytes(chars' 0' charCount' _trailBytes' 0);                          int actual = Math.Min(_trailByteCount' byteCount);                          Buffer.BlockCopy(_trailBytes' 0' buffer' offset' actual);                          _trailByteCount -= actual;                          Buffer.BlockCopy(_trailBytes' actual' _trailBytes' 0' _trailByteCount);                          return actual;                      }                      else                      {                          // charCount is a multiple of charBlock and we have enough room to convert everything                          return encoding.GetBytes(chars' 0' charCount' buffer' offset);                      }                  }                  catch (FormatException exception)                  {                      // Something was wrong with the format' see if we can strip the spaces                      int i = 0;                      int j = 0;                      while (true)                      {                          while (j < charCount && XmlConverter.IsWhitespace(chars[j]))                              j++;                          if (j == charCount)                              break;                          chars[i++] = chars[j++];                      }                      // No spaces' so don't try again                      if (i == charCount)                          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(exception.Message' exception.InnerException));                      charCount = i;                  }              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,ReadBytes,The following statement contains a magic number: while (true)              {                  // If we didn't align on the boundary' then we might have some remaining characters                  if (_trailCharCount > 0)                  {                      Array.Copy(_trailChars' 0' chars' charCount' _trailCharCount);                      charCount += _trailCharCount;                      _trailCharCount = 0;                  }                  // Read until we at least get a charBlock                  while (charCount < charBlock)                  {                      int actualCharCount;                      if (readContent)                      {                          actualCharCount = ReadContentAsChars(chars' charCount' maxCharCount - charCount);                          // When deserializing base64 content which contains new line chars (CR' LF) chars from ReadObject' the reader reads in chunks of base64 content' LF char' base64 content' LF char and so on                          // Relying on encoding.GetBytes' exception to handle LF char would result in performance degradation so skipping LF char here                          if (actualCharCount == 1 && chars[charCount] == '\n')                              continue;                      }                      else                      {                          actualCharCount = ReadValueChunk(chars' charCount' maxCharCount - charCount);                      }                      if (actualCharCount == 0)                          break;                      charCount += actualCharCount;                  }                  // Trim so its a multiple of charBlock                  if (charCount >= charBlock)                  {                      _trailCharCount = (charCount % charBlock);                      if (_trailCharCount > 0)                      {                          if (_trailChars == null)                              _trailChars = new char[4];                          charCount = charCount - _trailCharCount;                          Array.Copy(chars' charCount' _trailChars' 0' _trailCharCount);                      }                  }                  try                  {                      if (byteCount < byteBlock)                      {                          if (_trailBytes == null)                              _trailBytes = new byte[3];                          _trailByteCount = encoding.GetBytes(chars' 0' charCount' _trailBytes' 0);                          int actual = Math.Min(_trailByteCount' byteCount);                          Buffer.BlockCopy(_trailBytes' 0' buffer' offset' actual);                          _trailByteCount -= actual;                          Buffer.BlockCopy(_trailBytes' actual' _trailBytes' 0' _trailByteCount);                          return actual;                      }                      else                      {                          // charCount is a multiple of charBlock and we have enough room to convert everything                          return encoding.GetBytes(chars' 0' charCount' buffer' offset);                      }                  }                  catch (FormatException exception)                  {                      // Something was wrong with the format' see if we can strip the spaces                      int i = 0;                      int j = 0;                      while (true)                      {                          while (j < charCount && XmlConverter.IsWhitespace(chars[j]))                              j++;                          if (j == charCount)                              break;                          chars[i++] = chars[j++];                      }                      // No spaces' so don't try again                      if (i == charCount)                          throw DiagnosticUtility.ExceptionUtility.ThrowHelperError(new XmlException(exception.Message' exception.InnerException));                      charCount = i;                  }              }
Magic Number,System.Xml,XmlBaseReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,GetCharBuffer,The following statement contains a magic number: if (count > 1024)                  return new char[count];
Magic Number,System.Xml,AttributeSorter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Close,The following statement contains a magic number: if (_indeces != null && _indeces.Length > 32)                  {                      _indeces = null;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Close,The following statement contains a magic number: if (_namespaces != null && _namespaces.Length > 32)                      _namespaces = null;
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Close,The following statement contains a magic number: if (_attributes != null && _attributes.Length > 4)                      _attributes = null;
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddAttribute,The following statement contains a magic number: if (_attributes == null)                  {                      _attributes = new XmlAttribute[1];                  }                  else if (_attributes.Length == _attributeCount)                  {                      XmlAttribute[] newAttributes = new XmlAttribute[_attributeCount * 2];                      Array.Copy(_attributes' 0' newAttributes' 0' _attributeCount);                      _attributes = newAttributes;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (_namespaces == null)                  {                      _namespaces = new Namespace[4];                  }                  else if (_namespaces.Length == _nsCount)                  {                      Namespace[] newNamespaces = new Namespace[_nsCount * 2];                      Array.Copy(_namespaces' 0' newNamespaces' 0' _nsCount);                      _namespaces = newNamespaces;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (_namespaces == null)                  {                      _namespaces = new Namespace[4];                  }                  else if (_namespaces.Length == _nsCount)                  {                      Namespace[] newNamespaces = new Namespace[_nsCount * 2];                      Array.Copy(_namespaces' 0' newNamespaces' 0' _nsCount);                      _namespaces = newNamespaces;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Clear,The following statement contains a magic number: if (_namespaces == null)                  {                      _namespaces = new Namespace[4];                      _namespaces[0] = _defaultNamespace;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Close,The following statement contains a magic number: if (_depth == 0)                  {                      if (_namespaces != null && _namespaces.Length > 32)                          _namespaces = null;                      if (_attributes != null && _attributes.Length > 4)                          _attributes = null;                  }                  else                  {                      _namespaces = null;                      _attributes = null;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,Close,The following statement contains a magic number: if (_depth == 0)                  {                      if (_namespaces != null && _namespaces.Length > 32)                          _namespaces = null;                      if (_attributes != null && _attributes.Length > 4)                          _attributes = null;                  }                  else                  {                      _namespaces = null;                      _attributes = null;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddAttribute,The following statement contains a magic number: if (_attributes == null)                  {                      _attributes = new XmlAttribute[1];                  }                  else if (_attributes.Length == _attributeCount)                  {                      XmlAttribute[] newAttributes = new XmlAttribute[_attributeCount * 2];                      Array.Copy(_attributes' 0' newAttributes' 0' _attributeCount);                      _attributes = newAttributes;                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (prefix.Length >= 3)                  {                      // Upper and lower case letter differ by a bit.                      if ((prefix[0] & ~32) == 'X' && (prefix[1] & ~32) == 'M' && (prefix[2] & ~32) == 'L')                      {                          if (prefix == "xml" && uri == xmlNamespace)                              return;                          if (prefix == "xmlns" && uri == xmlnsNamespace)                              return;                          throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlReservedPrefix)' nameof(prefix)));                      }                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (prefix.Length >= 3)                  {                      // Upper and lower case letter differ by a bit.                      if ((prefix[0] & ~32) == 'X' && (prefix[1] & ~32) == 'M' && (prefix[2] & ~32) == 'L')                      {                          if (prefix == "xml" && uri == xmlNamespace)                              return;                          if (prefix == "xmlns" && uri == xmlnsNamespace)                              return;                          throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlReservedPrefix)' nameof(prefix)));                      }                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (prefix.Length >= 3)                  {                      // Upper and lower case letter differ by a bit.                      if ((prefix[0] & ~32) == 'X' && (prefix[1] & ~32) == 'M' && (prefix[2] & ~32) == 'L')                      {                          if (prefix == "xml" && uri == xmlNamespace)                              return;                          if (prefix == "xmlns" && uri == xmlnsNamespace)                              return;                          throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlReservedPrefix)' nameof(prefix)));                      }                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (prefix.Length >= 3)                  {                      // Upper and lower case letter differ by a bit.                      if ((prefix[0] & ~32) == 'X' && (prefix[1] & ~32) == 'M' && (prefix[2] & ~32) == 'L')                      {                          if (prefix == "xml" && uri == xmlNamespace)                              return;                          if (prefix == "xmlns" && uri == xmlnsNamespace)                              return;                          throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlReservedPrefix)' nameof(prefix)));                      }                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (prefix.Length >= 3)                  {                      // Upper and lower case letter differ by a bit.                      if ((prefix[0] & ~32) == 'X' && (prefix[1] & ~32) == 'M' && (prefix[2] & ~32) == 'L')                      {                          if (prefix == "xml" && uri == xmlNamespace)                              return;                          if (prefix == "xmlns" && uri == xmlnsNamespace)                              return;                          throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlReservedPrefix)' nameof(prefix)));                      }                  }
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (uri.Length == xmlNamespace.Length && uri[18] == 'X' && uri == xmlNamespace)                      throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlSpecificBindingNamespace' "xml"' uri)));
Magic Number,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,AddNamespace,The following statement contains a magic number: if (_namespaces.Length == _nsCount)                  {                      Namespace[] newNamespaces = new Namespace[_nsCount * 2];                      Array.Copy(_namespaces' 0' newNamespaces' 0' _nsCount);                      _namespaces = newNamespaces;                  }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,EnterScope,The following statement contains a magic number: if (_elements == null)              {                  _elements = new Element[4];              }              else if (_elements.Length == _depth)              {                  Element[] newElementNodes = new Element[_depth * 2];                  Array.Copy(_elements' 0' newElementNodes' 0' _depth);                  _elements = newElementNodes;              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,EnterScope,The following statement contains a magic number: if (_elements == null)              {                  _elements = new Element[4];              }              else if (_elements.Length == _depth)              {                  Element[] newElementNodes = new Element[_depth * 2];                  Array.Copy(_elements' 0' newElementNodes' 0' _depth);                  _elements = newElementNodes;              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteSurrogateCharEntity,The following statement contains a magic number: if (_attributeValue != null)              {                  char[] chars = new char[2] { highChar' lowChar };                  WriteAttributeText(new string(chars));              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          StartContent();                          _writer.WriteBase64Text(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          StartContent();                          _writer.WriteBase64Text(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          StartContent();                          _writer.WriteBase64Text(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          StartContent();                          _writer.WriteBase64Text(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64AsyncImpl,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          await StartContentAsync().ConfigureAwait(false);                          await _writer.WriteBase64TextAsync(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount).ConfigureAwait(false);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64AsyncImpl,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          await StartContentAsync().ConfigureAwait(false);                          await _writer.WriteBase64TextAsync(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount).ConfigureAwait(false);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64AsyncImpl,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          await StartContentAsync().ConfigureAwait(false);                          await _writer.WriteBase64TextAsync(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount).ConfigureAwait(false);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBaseWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseWriter.cs,WriteBase64AsyncImpl,The following statement contains a magic number: if (count > 0)              {                  if (_trailByteCount > 0)                  {                      while (_trailByteCount < 3 && count > 0)                      {                          _trailBytes[_trailByteCount++] = buffer[offset++];                          count--;                      }                  }                    int totalByteCount = _trailByteCount + count;                  int actualByteCount = totalByteCount - (totalByteCount % 3);                    if (_trailBytes == null)                  {                      _trailBytes = new byte[3];                  }                    if (actualByteCount >= 3)                  {                      if (_attributeValue != null)                      {                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(_trailBytes' 0' _trailByteCount));                          WriteAttributeText(XmlConverter.Base64Encoding.GetString(buffer' offset' actualByteCount - _trailByteCount));                      }                      if (!_isXmlnsAttribute)                      {                          await StartContentAsync().ConfigureAwait(false);                          await _writer.WriteBase64TextAsync(_trailBytes' _trailByteCount' buffer' offset' actualByteCount - _trailByteCount).ConfigureAwait(false);                          EndContent();                      }                      _trailByteCount = (totalByteCount - actualByteCount);                      if (_trailByteCount > 0)                      {                          int trailOffset = offset + count - _trailByteCount;                          for (int i = 0; i < _trailByteCount; i++)                              _trailBytes[i] = buffer[trailOffset++];                      }                  }                  else                  {                      Buffer.BlockCopy(buffer' offset' _trailBytes' _trailByteCount' count);                      _trailByteCount += count;                  }              }
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialUTF8Text,The following statement contains a magic number: const int maxTextNodeLength = 5;
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialUnicodeText,The following statement contains a magic number: const int maxTextNodeLength = 5;
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialBinaryText,The following statement contains a magic number: const int nodeLength = 5;
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialBinaryText,The following statement contains a magic number: if (length <= maxBytesPerRead)              {                  if (withEndElement)                      ReadText(MoveToAtomicTextWithEndElement()' ValueHandleType.Base64' length);                  else                      ReadText(MoveToComplexText()' ValueHandleType.Base64' length);              }              else              {                  int actual = maxBytesPerRead;                  if (actual > 3)                      actual -= (actual % 3);                  ReadText(MoveToComplexText()' ValueHandleType.Base64' actual);                  XmlBinaryNodeType nodeType = (withEndElement ? XmlBinaryNodeType.Bytes32TextWithEndElement : XmlBinaryNodeType.Bytes32Text);                  InsertNode(nodeType' length - actual);              }
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,ReadPartialBinaryText,The following statement contains a magic number: if (length <= maxBytesPerRead)              {                  if (withEndElement)                      ReadText(MoveToAtomicTextWithEndElement()' ValueHandleType.Base64' length);                  else                      ReadText(MoveToComplexText()' ValueHandleType.Base64' length);              }              else              {                  int actual = maxBytesPerRead;                  if (actual > 3)                      actual -= (actual % 3);                  ReadText(MoveToComplexText()' ValueHandleType.Base64' actual);                  XmlBinaryNodeType nodeType = (withEndElement ? XmlBinaryNodeType.Bytes32TextWithEndElement : XmlBinaryNodeType.Bytes32Text);                  InsertNode(nodeType' length - actual);              }
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,InsertNode,The following statement contains a magic number: byte[] buffer = new byte[5];
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,InsertNode,The following statement contains a magic number: unchecked              {                  buffer[1] = (byte)length;                  length >>= 8;                  buffer[2] = (byte)length;                  length >>= 8;                  buffer[3] = (byte)length;              }
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,InsertNode,The following statement contains a magic number: unchecked              {                  buffer[1] = (byte)length;                  length >>= 8;                  buffer[2] = (byte)length;                  length >>= 8;                  buffer[3] = (byte)length;              }
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,InsertNode,The following statement contains a magic number: unchecked              {                  buffer[1] = (byte)length;                  length >>= 8;                  buffer[2] = (byte)length;                  length >>= 8;                  buffer[3] = (byte)length;              }
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,InsertNode,The following statement contains a magic number: unchecked              {                  buffer[1] = (byte)length;                  length >>= 8;                  buffer[2] = (byte)length;                  length >>= 8;                  buffer[3] = (byte)length;              }
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,InsertNode,The following statement contains a magic number: length >>= 8;
Magic Number,System.Xml,XmlBinaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReader.cs,InsertNode,The following statement contains a magic number: buffer[4] = (byte)length;
Magic Number,System.Xml,XmlBinaryReaderSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReaderSession.cs,Add,The following statement contains a magic number: if (id >= MaxArrayEntries)              {                  if (_stringDict == null)                      _stringDict = new Dictionary<int' XmlDictionaryString>();                    _stringDict.Add(id' xmlString);              }              else              {                  if (_strings == null)                  {                      _strings = new XmlDictionaryString[Math.Max(id + 1' 16)];                  }                  else if (id >= _strings.Length)                  {                      XmlDictionaryString[] newStrings = new XmlDictionaryString[Math.Min(Math.Max(id + 1' _strings.Length * 2)' MaxArrayEntries)];                      Array.Copy(_strings' 0' newStrings' 0' _strings.Length);                      _strings = newStrings;                  }                  _strings[id] = xmlString;              }
Magic Number,System.Xml,XmlBinaryReaderSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryReaderSession.cs,Add,The following statement contains a magic number: if (id >= MaxArrayEntries)              {                  if (_stringDict == null)                      _stringDict = new Dictionary<int' XmlDictionaryString>();                    _stringDict.Add(id' xmlString);              }              else              {                  if (_strings == null)                  {                      _strings = new XmlDictionaryString[Math.Max(id + 1' 16)];                  }                  else if (id >= _strings.Length)                  {                      XmlDictionaryString[] newStrings = new XmlDictionaryString[Math.Min(Math.Max(id + 1' _strings.Length * 2)' MaxArrayEntries)];                      Array.Copy(_strings' 0' newStrings' 0' _strings.Length);                      _strings = newStrings;                  }                  _strings[id] = xmlString;              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,XmlBinaryNodeWriter,The following statement contains a magic number: DiagnosticUtility.DebugAssert(XmlBinaryNodeType.MaxAttribute < XmlBinaryNodeType.MinElement &&                                            XmlBinaryNodeType.MaxElement < XmlBinaryNodeType.MinText &&                                            (int)XmlBinaryNodeType.MaxText < 256' "NodeTypes enumeration messed up");
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: byte[] buffer = GetTextNodeBuffer(5' out offset);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithLength,The following statement contains a magic number: if (length < 256)              {                  buffer[offset + 0] = (byte)nodeType;                  buffer[offset + 1] = (byte)length;                  Advance(2);              }              else if (length < 65536)              {                  buffer[offset + 0] = (byte)(nodeType + 1 * 2); // WithEndElements interleave                  buffer[offset + 1] = unchecked((byte)length);                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  Advance(3);              }              else              {                  buffer[offset + 0] = (byte)(nodeType + 2 * 2); // WithEndElements interleave                  buffer[offset + 1] = (byte)length;                  length >>= 8;                  buffer[offset + 2] = (byte)length;                  length >>= 8;                  buffer[offset + 3] = (byte)length;                  length >>= 8;                  buffer[offset + 4] = (byte)length;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: byte[] buffer = GetTextNodeBuffer(9' out offset);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: buffer[offset + 2] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: buffer[offset + 3] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: buffer[offset + 4] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: buffer[offset + 5] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: buffer[offset + 6] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: buffer[offset + 7] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: buffer[offset + 8] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNodeWithInt64,The following statement contains a magic number: Advance(9);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,TryGetKey,The following statement contains a magic number: if (s.Dictionary == _dictionary)              {                  key = s.Key * 2;                  return true;              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,TryGetKey,The following statement contains a magic number: if (_dictionary != null && _dictionary.TryLookup(s' out t))              {                  DiagnosticUtility.DebugAssert(t.Dictionary == _dictionary' "");                  key = t.Key * 2;                  return true;              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,TryGetKey,The following statement contains a magic number: key = sessionKey * 2 + 1;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteName,The following statement contains a magic number: if (charCount < 128 / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    // 1 byte for the length                  int offset;                  byte[] buffer = GetBuffer(1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 1);                  DiagnosticUtility.DebugAssert(length < 128' "");                  buffer[offset] = (byte)length;                  Advance(1 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  WriteMultiByteInt32(byteCount);                  UnsafeWriteUTF8Chars(chars' charCount);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteName,The following statement contains a magic number: if (charCount < 128 / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    // 1 byte for the length                  int offset;                  byte[] buffer = GetBuffer(1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 1);                  DiagnosticUtility.DebugAssert(length < 128' "");                  buffer[offset] = (byte)length;                  Advance(1 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  WriteMultiByteInt32(byteCount);                  UnsafeWriteUTF8Chars(chars' charCount);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteMultiByteInt32,The following statement contains a magic number: byte[] buffer = GetBuffer(5' out offset);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteMultiByteInt32,The following statement contains a magic number: while ((i & 0xFFFFFF80) != 0)              {                  buffer[offset++] = (byte)((i & 0x7F) | 0x80);                  i >>= 7;              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt32Text,The following statement contains a magic number: if (value >= -128 && value < 128)              {                  if (value == 0)                  {                      WriteTextNode(XmlBinaryNodeType.ZeroText);                  }                  else if (value == 1)                  {                      WriteTextNode(XmlBinaryNodeType.OneText);                  }                  else                  {                      int offset;                      byte[] buffer = GetTextNodeBuffer(2' out offset);                      buffer[offset + 0] = (byte)XmlBinaryNodeType.Int8Text;                      buffer[offset + 1] = (byte)value;                      Advance(2);                  }              }              else if (value >= -32768 && value < 32768)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(3' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int16Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  Advance(3);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(5' out offset);                  buffer[offset + 0] = (byte)XmlBinaryNodeType.Int32Text;                  buffer[offset + 1] = (byte)value;                  value >>= 8;                  buffer[offset + 2] = (byte)value;                  value >>= 8;                  buffer[offset + 3] = (byte)value;                  value >>= 8;                  buffer[offset + 4] = (byte)value;                  Advance(5);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: byte[] buffer = GetBuffer(8' out offset);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: buffer[offset + 2] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: buffer[offset + 3] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: buffer[offset + 4] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: buffer[offset + 5] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: buffer[offset + 6] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: value >>= 8;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: buffer[offset + 7] = (byte)value;
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteInt64,The following statement contains a magic number: Advance(8);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteText,The following statement contains a magic number: if (charCount <= byte.MaxValue / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    int offset;                  byte[] buffer = GetBuffer(1 + 1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 2);                    if (length / 2 <= charCount)                  {                      buffer[offset] = (byte)XmlBinaryNodeType.Chars8Text;                  }                  else                  {                      buffer[offset] = (byte)XmlBinaryNodeType.UnicodeChars8Text;                      length = UnsafeGetUnicodeChars(chars' charCount' buffer' offset + 2);                  }                  _textNodeOffset = offset;                  DiagnosticUtility.DebugAssert(length <= byte.MaxValue' "");                  buffer[offset + 1] = (byte)length;                  Advance(2 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  if (byteCount / 2 > charCount)                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.UnicodeChars8Text' charCount * 2);                      UnsafeWriteUnicodeChars(chars' charCount);                  }                  else                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.Chars8Text' byteCount);                      UnsafeWriteUTF8Chars(chars' charCount);                  }              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteText,The following statement contains a magic number: if (charCount <= byte.MaxValue / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    int offset;                  byte[] buffer = GetBuffer(1 + 1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 2);                    if (length / 2 <= charCount)                  {                      buffer[offset] = (byte)XmlBinaryNodeType.Chars8Text;                  }                  else                  {                      buffer[offset] = (byte)XmlBinaryNodeType.UnicodeChars8Text;                      length = UnsafeGetUnicodeChars(chars' charCount' buffer' offset + 2);                  }                  _textNodeOffset = offset;                  DiagnosticUtility.DebugAssert(length <= byte.MaxValue' "");                  buffer[offset + 1] = (byte)length;                  Advance(2 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  if (byteCount / 2 > charCount)                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.UnicodeChars8Text' charCount * 2);                      UnsafeWriteUnicodeChars(chars' charCount);                  }                  else                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.Chars8Text' byteCount);                      UnsafeWriteUTF8Chars(chars' charCount);                  }              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteText,The following statement contains a magic number: if (charCount <= byte.MaxValue / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    int offset;                  byte[] buffer = GetBuffer(1 + 1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 2);                    if (length / 2 <= charCount)                  {                      buffer[offset] = (byte)XmlBinaryNodeType.Chars8Text;                  }                  else                  {                      buffer[offset] = (byte)XmlBinaryNodeType.UnicodeChars8Text;                      length = UnsafeGetUnicodeChars(chars' charCount' buffer' offset + 2);                  }                  _textNodeOffset = offset;                  DiagnosticUtility.DebugAssert(length <= byte.MaxValue' "");                  buffer[offset + 1] = (byte)length;                  Advance(2 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  if (byteCount / 2 > charCount)                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.UnicodeChars8Text' charCount * 2);                      UnsafeWriteUnicodeChars(chars' charCount);                  }                  else                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.Chars8Text' byteCount);                      UnsafeWriteUTF8Chars(chars' charCount);                  }              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteText,The following statement contains a magic number: if (charCount <= byte.MaxValue / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    int offset;                  byte[] buffer = GetBuffer(1 + 1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 2);                    if (length / 2 <= charCount)                  {                      buffer[offset] = (byte)XmlBinaryNodeType.Chars8Text;                  }                  else                  {                      buffer[offset] = (byte)XmlBinaryNodeType.UnicodeChars8Text;                      length = UnsafeGetUnicodeChars(chars' charCount' buffer' offset + 2);                  }                  _textNodeOffset = offset;                  DiagnosticUtility.DebugAssert(length <= byte.MaxValue' "");                  buffer[offset + 1] = (byte)length;                  Advance(2 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  if (byteCount / 2 > charCount)                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.UnicodeChars8Text' charCount * 2);                      UnsafeWriteUnicodeChars(chars' charCount);                  }                  else                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.Chars8Text' byteCount);                      UnsafeWriteUTF8Chars(chars' charCount);                  }              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteText,The following statement contains a magic number: if (charCount <= byte.MaxValue / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    int offset;                  byte[] buffer = GetBuffer(1 + 1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 2);                    if (length / 2 <= charCount)                  {                      buffer[offset] = (byte)XmlBinaryNodeType.Chars8Text;                  }                  else                  {                      buffer[offset] = (byte)XmlBinaryNodeType.UnicodeChars8Text;                      length = UnsafeGetUnicodeChars(chars' charCount' buffer' offset + 2);                  }                  _textNodeOffset = offset;                  DiagnosticUtility.DebugAssert(length <= byte.MaxValue' "");                  buffer[offset + 1] = (byte)length;                  Advance(2 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  if (byteCount / 2 > charCount)                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.UnicodeChars8Text' charCount * 2);                      UnsafeWriteUnicodeChars(chars' charCount);                  }                  else                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.Chars8Text' byteCount);                      UnsafeWriteUTF8Chars(chars' charCount);                  }              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,UnsafeWriteText,The following statement contains a magic number: if (charCount <= byte.MaxValue / maxBytesPerChar)              {                  // Optimize if we know we can fit the converted string in the buffer                  // so we don't have to make a pass to count the bytes                    int offset;                  byte[] buffer = GetBuffer(1 + 1 + charCount * maxBytesPerChar' out offset);                  int length = UnsafeGetUTF8Chars(chars' charCount' buffer' offset + 2);                    if (length / 2 <= charCount)                  {                      buffer[offset] = (byte)XmlBinaryNodeType.Chars8Text;                  }                  else                  {                      buffer[offset] = (byte)XmlBinaryNodeType.UnicodeChars8Text;                      length = UnsafeGetUnicodeChars(chars' charCount' buffer' offset + 2);                  }                  _textNodeOffset = offset;                  DiagnosticUtility.DebugAssert(length <= byte.MaxValue' "");                  buffer[offset + 1] = (byte)length;                  Advance(2 + length);              }              else              {                  int byteCount = UnsafeGetUTF8Length(chars' charCount);                  if (byteCount / 2 > charCount)                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.UnicodeChars8Text' charCount * 2);                      UnsafeWriteUnicodeChars(chars' charCount);                  }                  else                  {                      WriteTextNodeWithLength(XmlBinaryNodeType.Chars8Text' byteCount);                      UnsafeWriteUTF8Chars(chars' charCount);                  }              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteCharEntity,The following statement contains a magic number: if (ch > char.MaxValue)              {                  SurrogateChar sch = new SurrogateChar(ch);                  char[] chars = new char[2] { sch.HighChar' sch.LowChar' };                  WriteText(chars' 0' 2);              }              else              {                  char[] chars = new char[1] { (char)ch };                  WriteText(chars' 0' 1);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteCharEntity,The following statement contains a magic number: if (ch > char.MaxValue)              {                  SurrogateChar sch = new SurrogateChar(ch);                  char[] chars = new char[2] { sch.HighChar' sch.LowChar' };                  WriteText(chars' 0' 2);              }              else              {                  char[] chars = new char[1] { (char)ch };                  WriteText(chars' 0' 1);              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteFloatText,The following statement contains a magic number: if (f >= long.MinValue && f <= long.MaxValue && (l = (long)f) == f)              {                  WriteInt64Text(l);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(float)' out offset);                  byte* bytes = (byte*)&f;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.FloatText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  Advance(1 + sizeof(float));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteFloatText,The following statement contains a magic number: if (f >= long.MinValue && f <= long.MaxValue && (l = (long)f) == f)              {                  WriteInt64Text(l);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(float)' out offset);                  byte* bytes = (byte*)&f;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.FloatText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  Advance(1 + sizeof(float));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteFloatText,The following statement contains a magic number: if (f >= long.MinValue && f <= long.MaxValue && (l = (long)f) == f)              {                  WriteInt64Text(l);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(float)' out offset);                  byte* bytes = (byte*)&f;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.FloatText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  Advance(1 + sizeof(float));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteFloatText,The following statement contains a magic number: if (f >= long.MinValue && f <= long.MaxValue && (l = (long)f) == f)              {                  WriteInt64Text(l);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(float)' out offset);                  byte* bytes = (byte*)&f;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.FloatText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  Advance(1 + sizeof(float));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteFloatText,The following statement contains a magic number: if (f >= long.MinValue && f <= long.MaxValue && (l = (long)f) == f)              {                  WriteInt64Text(l);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(float)' out offset);                  byte* bytes = (byte*)&f;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.FloatText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  Advance(1 + sizeof(float));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteDoubleText,The following statement contains a magic number: if (d >= float.MinValue && d <= float.MaxValue && (f = (float)d) == d)              {                  WriteFloatText(f);              }              else              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(1 + sizeof(double)' out offset);                  byte* bytes = (byte*)&d;                  buffer[offset + 0] = (byte)XmlBinaryNodeType.DoubleText;                  buffer[offset + 1] = bytes[0];                  buffer[offset + 2] = bytes[1];                  buffer[offset + 3] = bytes[2];                  buffer[offset + 4] = bytes[3];                  buffer[offset + 5] = bytes[4];                  buffer[offset + 6] = bytes[5];                  buffer[offset + 7] = bytes[6];                  buffer[offset + 8] = bytes[7];                  Advance(1 + sizeof(double));              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteUniqueIdText,The following statement contains a magic number: if (value.IsGuid)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(17' out offset);                  buffer[offset] = (byte)XmlBinaryNodeType.UniqueIdText;                  value.TryGetGuid(buffer' offset + 1);                  Advance(17);              }              else              {                  WriteText(value.ToString());              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteUniqueIdText,The following statement contains a magic number: if (value.IsGuid)              {                  int offset;                  byte[] buffer = GetTextNodeBuffer(17' out offset);                  buffer[offset] = (byte)XmlBinaryNodeType.UniqueIdText;                  value.TryGetGuid(buffer' offset + 1);                  Advance(17);              }              else              {                  WriteText(value.ToString());              }
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteGuidText,The following statement contains a magic number: byte[] buffer = GetTextNodeBuffer(17' out offset);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteGuidText,The following statement contains a magic number: Buffer.BlockCopy(guid.ToByteArray()' 0' buffer' offset + 1' 16);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteGuidText,The following statement contains a magic number: Advance(17);
Magic Number,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteGuidArray,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  byte[] buffer = array[offset + i].ToByteArray();                  WriteBytes(buffer' 0' 16);              }
Magic Number,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNode,The following statement contains a magic number: if (type == typeof(string))              {                  XmlDictionaryString value;                  if (reader.TryGetValueAsDictionaryString(out value))                  {                      WriteString(value);                  }                  else                  {                      if (reader.CanReadValueChunk)                      {                          if (_chars == null)                          {                              _chars = new char[256];                          }                          int count;                          while ((count = reader.ReadValueChunk(_chars' 0' _chars.Length)) > 0)                          {                              this.WriteChars(_chars' 0' count);                          }                      }                      else                      {                          WriteString(reader.Value);                      }                  }                  if (!attribute)                  {                      reader.Read();                  }              }              else if (type == typeof(byte[]))              {                  if (reader.CanReadBinaryContent)                  {                      // Its best to read in buffers that are a multiple of 3 so we don't break base64 boundaries when converting text                      if (_bytes == null)                      {                          _bytes = new byte[384];                      }                      int count;                      while ((count = reader.ReadValueAsBase64(_bytes' 0' _bytes.Length)) > 0)                      {                          this.WriteBase64(_bytes' 0' count);                      }                  }                  else                  {                      WriteString(reader.Value);                  }                  if (!attribute)                  {                      reader.Read();                  }              }              else if (type == typeof(int))                  WriteValue(reader.ReadContentAsInt());              else if (type == typeof(long))                  WriteValue(reader.ReadContentAsLong());              else if (type == typeof(bool))                  WriteValue(reader.ReadContentAsBoolean());              else if (type == typeof(double))                  WriteValue(reader.ReadContentAsDouble());              else if (type == typeof(DateTime))                  WriteValue(reader.ReadContentAsDateTimeOffset().DateTime);              else if (type == typeof(float))                  WriteValue(reader.ReadContentAsFloat());              else if (type == typeof(decimal))                  WriteValue(reader.ReadContentAsDecimal());              else if (type == typeof(UniqueId))                  WriteValue(reader.ReadContentAsUniqueId());              else if (type == typeof(Guid))                  WriteValue(reader.ReadContentAsGuid());              else if (type == typeof(TimeSpan))                  WriteValue(reader.ReadContentAsTimeSpan());              else                  WriteValue(reader.ReadContentAsObject());
Magic Number,System.Xml,XmlBinaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,WriteTextNode,The following statement contains a magic number: if (type == typeof(string))              {                  XmlDictionaryString value;                  if (reader.TryGetValueAsDictionaryString(out value))                  {                      WriteString(value);                  }                  else                  {                      if (reader.CanReadValueChunk)                      {                          if (_chars == null)                          {                              _chars = new char[256];                          }                          int count;                          while ((count = reader.ReadValueChunk(_chars' 0' _chars.Length)) > 0)                          {                              this.WriteChars(_chars' 0' count);                          }                      }                      else                      {                          WriteString(reader.Value);                      }                  }                  if (!attribute)                  {                      reader.Read();                  }              }              else if (type == typeof(byte[]))              {                  if (reader.CanReadBinaryContent)                  {                      // Its best to read in buffers that are a multiple of 3 so we don't break base64 boundaries when converting text                      if (_bytes == null)                      {                          _bytes = new byte[384];                      }                      int count;                      while ((count = reader.ReadValueAsBase64(_bytes' 0' _bytes.Length)) > 0)                      {                          this.WriteBase64(_bytes' 0' count);                      }                  }                  else                  {                      WriteString(reader.Value);                  }                  if (!attribute)                  {                      reader.Read();                  }              }              else if (type == typeof(int))                  WriteValue(reader.ReadContentAsInt());              else if (type == typeof(long))                  WriteValue(reader.ReadContentAsLong());              else if (type == typeof(bool))                  WriteValue(reader.ReadContentAsBoolean());              else if (type == typeof(double))                  WriteValue(reader.ReadContentAsDouble());              else if (type == typeof(DateTime))                  WriteValue(reader.ReadContentAsDateTimeOffset().DateTime);              else if (type == typeof(float))                  WriteValue(reader.ReadContentAsFloat());              else if (type == typeof(decimal))                  WriteValue(reader.ReadContentAsDecimal());              else if (type == typeof(UniqueId))                  WriteValue(reader.ReadContentAsUniqueId());              else if (type == typeof(Guid))                  WriteValue(reader.ReadContentAsGuid());              else if (type == typeof(TimeSpan))                  WriteValue(reader.ReadContentAsTimeSpan());              else                  WriteValue(reader.ReadContentAsObject());
Magic Number,System.Xml,XmlBinaryWriterSession,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriterSession.cs,AddKeys,The following statement contains a magic number: IntArray keys = new IntArray(Math.Max(minCount' 16));
Magic Number,System.Xml,PriorityDictionary<K;V>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriterSession.cs,PriorityDictionary,The following statement contains a magic number: _list = new Entry[16];
Magic Number,System.Xml,PriorityDictionary<K;V>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriterSession.cs,DecreaseAll,The following statement contains a magic number: for (int i = 0; i < _listCount; i++)                  {                      _list[i].Time /= 2;                  }
Magic Number,System.Xml,PriorityDictionary<K;V>,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriterSession.cs,DecreaseAll,The following statement contains a magic number: _now /= 2;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,SetBuffer,The following statement contains a magic number: if (_streamBuffer == null)              {                  _streamBuffer = new byte[128];              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,Close,The following statement contains a magic number: if (_streamBuffer != null && _streamBuffer.Length > 4096)              {                  _streamBuffer = null;              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,TryEnsureBytes,The following statement contains a magic number: if (newOffsetMax > _buffer.Length)              {                  byte[] newBuffer = new byte[Math.Max(newOffsetMax' _buffer.Length * 2)];                  System.Buffer.BlockCopy(_buffer' 0' newBuffer' 0' _offsetMax);                  _buffer = newBuffer;                  _streamBuffer = newBuffer;              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: i |= ((j & 0x7F) << 7);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: i |= ((k & 0x7F) << 14);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: i |= ((l & 0x7F) << 21);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadMultiByteUInt31,The following statement contains a magic number: i |= (m << 28);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadUInt16,The following statement contains a magic number: byte[] buffer = GetBuffer(2' out offset);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadUInt16,The following statement contains a magic number: int i = buffer[offset + 0] + (buffer[offset + 1] << 8);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadUInt16,The following statement contains a magic number: Advance(2);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: byte[] buffer = GetBuffer(4' out offset);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: byte b3 = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: byte b4 = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: Advance(4);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt32,The following statement contains a magic number: return (((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadInt64,The following statement contains a magic number: return (hi << 32) + lo;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadSingle,The following statement contains a magic number: DiagnosticUtility.DebugAssert(sizeof(float) == 4' "");
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadSingle,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadSingle,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadSingle,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadSingle,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: DiagnosticUtility.DebugAssert(sizeof(double) == 8' "");
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[4] = buffer[offset + 4];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[4] = buffer[offset + 4];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[5] = buffer[offset + 5];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[5] = buffer[offset + 5];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[6] = buffer[offset + 6];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[6] = buffer[offset + 6];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[7] = buffer[offset + 7];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadDouble,The following statement contains a magic number: pb[7] = buffer[offset + 7];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,UnsafeReadArray,The following statement contains a magic number: if (_stream != null)              {                  const int chunk = 256;                  while (length >= chunk)                  {                      byte[] _buffer = GetBuffer(chunk' out _offset);                      for (int i = 0; i < chunk; i++)                      {                          *dst++ = _buffer[_offset + i];                      }                      Advance(chunk);                      length -= chunk;                  }              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetCharBuffer,The following statement contains a magic number: if (count > 1024)                  return new char[count];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetLessThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  buffer[offset + 1] != (byte)'l' ||                  buffer[offset + 2] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetLessThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  buffer[offset + 1] != (byte)'l' ||                  buffer[offset + 2] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetGreaterThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  buffer[offset + 1] != (byte)'g' ||                  buffer[offset + 2] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetGreaterThanCharEntity,The following statement contains a magic number: if (length != 4 ||                  buffer[offset + 1] != (byte)'g' ||                  buffer[offset + 2] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'q' ||                  buffer[offset + 2] != (byte)'u' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'q' ||                  buffer[offset + 2] != (byte)'u' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'q' ||                  buffer[offset + 2] != (byte)'u' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetQuoteCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'q' ||                  buffer[offset + 2] != (byte)'u' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'t')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'p')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'p')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetAmpersandCharEntity,The following statement contains a magic number: if (length != 5 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'p')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'p' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'s')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'p' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'s')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'p' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'s')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetApostropheCharEntity,The following statement contains a magic number: if (length != 6 ||                  buffer[offset + 1] != (byte)'a' ||                  buffer[offset + 2] != (byte)'p' ||                  buffer[offset + 3] != (byte)'o' ||                  buffer[offset + 4] != (byte)'s')              {                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++)              {                  byte ch = buffer[offset + i];                  if (ch < (byte)'0' || ch > (byte)'9')                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                  value = value * 10 + (ch - '0');                  if (value > SurrogateChar.MaxValue)                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDecimalCharEntity,The following statement contains a magic number: for (int i = 2; i < length - 1; i++)              {                  byte ch = buffer[offset + i];                  if (ch < (byte)'0' || ch > (byte)'9')                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                  value = value * 10 + (ch - '0');                  if (value > SurrogateChar.MaxValue)                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: DiagnosticUtility.DebugAssert(buffer[offset + 2] == 'x'' "");
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = buffer[offset + i];                  int digit = 0;                  if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                  DiagnosticUtility.DebugAssert(digit >= 0 && digit < 16' "");                  value = value * 16 + digit;                  if (value > SurrogateChar.MaxValue)                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = buffer[offset + i];                  int digit = 0;                  if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                  DiagnosticUtility.DebugAssert(digit >= 0 && digit < 16' "");                  value = value * 16 + digit;                  if (value > SurrogateChar.MaxValue)                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = buffer[offset + i];                  int digit = 0;                  if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                  DiagnosticUtility.DebugAssert(digit >= 0 && digit < 16' "");                  value = value * 16 + digit;                  if (value > SurrogateChar.MaxValue)                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = buffer[offset + i];                  int digit = 0;                  if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                  DiagnosticUtility.DebugAssert(digit >= 0 && digit < 16' "");                  value = value * 16 + digit;                  if (value > SurrogateChar.MaxValue)                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetHexCharEntity,The following statement contains a magic number: for (int i = 3; i < length - 1; i++)              {                  byte ch = buffer[offset + i];                  int digit = 0;                  if (ch >= '0' && ch <= '9')                      digit = (ch - '0');                  else if (ch >= 'a' && ch <= 'f')                      digit = 10 + (ch - 'a');                  else if (ch >= 'A' && ch <= 'F')                      digit = 10 + (ch - 'A');                  else                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                  DiagnosticUtility.DebugAssert(digit >= 0 && digit < 16' "");                  value = value * 16 + digit;                  if (value > SurrogateChar.MaxValue)                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: if (length < 3)                  XmlExceptionHelper.ThrowInvalidCharRef(_reader);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: switch (buffer[offset + 1])              {                  case (byte)'l':                      return GetLessThanCharEntity(offset' length);                  case (byte)'g':                      return GetGreaterThanCharEntity(offset' length);                  case (byte)'a':                      if (buffer[offset + 2] == (byte)'m')                          return GetAmpersandCharEntity(offset' length);                      else                          return GetApostropheCharEntity(offset' length);                  case (byte)'q':                      return GetQuoteCharEntity(offset' length);                  case (byte)'#':                      if (buffer[offset + 2] == (byte)'x')                          return GetHexCharEntity(offset' length);                      else                          return GetDecimalCharEntity(offset' length);                  default:                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                      return 0;              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetCharEntity,The following statement contains a magic number: switch (buffer[offset + 1])              {                  case (byte)'l':                      return GetLessThanCharEntity(offset' length);                  case (byte)'g':                      return GetGreaterThanCharEntity(offset' length);                  case (byte)'a':                      if (buffer[offset + 2] == (byte)'m')                          return GetAmpersandCharEntity(offset' length);                      else                          return GetApostropheCharEntity(offset' length);                  case (byte)'q':                      return GetQuoteCharEntity(offset' length);                  case (byte)'#':                      if (buffer[offset + 2] == (byte)'x')                          return GetHexCharEntity(offset' length);                      else                          return GetDecimalCharEntity(offset' length);                  default:                      XmlExceptionHelper.ThrowInvalidCharRef(_reader);                      return 0;              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,Equals2,The following statement contains a magic number: if (length1 < 8)              {                  int length = Math.Min(byteLength' charLength);                  int offset = offset1;                  for (int i = 0; i < length; i++)                  {                      byte b = buffer[offset + i];                      if (b >= 0x80)                          return XmlConverter.ToString(buffer' offset1' length1) == s2;                      if (s2[i] != (char)b)                          return false;                  }                  return byteLength == charLength;              }              else              {                  int length = Math.Min(byteLength' charLength);                  fixed (byte* _pb = &buffer[offset1])                  {                      byte* pb = _pb;                      byte* pbMax = pb + length;                      fixed (char* _pch = s2)                      {                          char* pch = _pch;                          // Try to do the fast comparison in ASCII space                          int t = 0;                          while (pb < pbMax && *pb < 0x80)                          {                              t = *pb - (byte)*pch;                              // The code generated is better if we break out then return                              if (t != 0)                                  break;                              pb++;                              pch++;                          }                          if (t != 0)                              return false;                          if (pb == pbMax)                              return (byteLength == charLength);                      }                  }                  return XmlConverter.ToString(buffer' offset1' length1) == s2;              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt16,The following statement contains a magic number: return (Int16)(buffer[offset] + (buffer[offset + 1] << 8));
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt32,The following statement contains a magic number: byte b3 = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt32,The following statement contains a magic number: byte b4 = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt32,The following statement contains a magic number: return (((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt32,The following statement contains a magic number: return (((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt32,The following statement contains a magic number: return (((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: b3 = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: b4 = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: Int64 lo = (UInt32)(((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: Int64 lo = (UInt32)(((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: Int64 lo = (UInt32)(((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: b1 = buffer[offset + 4];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: b2 = buffer[offset + 5];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: b3 = buffer[offset + 6];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: b4 = buffer[offset + 7];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: Int64 hi = (UInt32)(((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: Int64 hi = (UInt32)(((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: Int64 hi = (UInt32)(((((b4 << 8) + b3) << 8) + b2) << 8) + b1;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetInt64,The following statement contains a magic number: return (hi << 32) + lo;
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetSingle,The following statement contains a magic number: DiagnosticUtility.DebugAssert(sizeof(float) == 4' "");
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetSingle,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetSingle,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetSingle,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetSingle,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: DiagnosticUtility.DebugAssert(sizeof(double) == 8' "");
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[2] = buffer[offset + 2];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[3] = buffer[offset + 3];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[4] = buffer[offset + 4];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[4] = buffer[offset + 4];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[5] = buffer[offset + 5];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[5] = buffer[offset + 5];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[6] = buffer[offset + 6];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[6] = buffer[offset + 6];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[7] = buffer[offset + 7];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetDouble,The following statement contains a magic number: pb[7] = buffer[offset + 7];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetGuid,The following statement contains a magic number: if (_guid == null)                  _guid = new byte[16];
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,ReadQName,The following statement contains a magic number: if (prefix >= 26)                  XmlExceptionHelper.ThrowInvalidBinaryFormat(_reader);
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetRows,The following statement contains a magic number: for (int i = _offsetMin; i < _offsetMax; i++)              {                  if (_buffer[i] == (byte)13 || _buffer[i] == (byte)10)                  {                      if (i + 1 < _offsetMax && _buffer[i + 1] == (byte)10)                          i++;                      list.Add(i + 1);                  }              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetRows,The following statement contains a magic number: for (int i = _offsetMin; i < _offsetMax; i++)              {                  if (_buffer[i] == (byte)13 || _buffer[i] == (byte)10)                  {                      if (i + 1 < _offsetMax && _buffer[i + 1] == (byte)10)                          i++;                      list.Add(i + 1);                  }              }
Magic Number,System.Xml,XmlBufferReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBufferReader.cs,GetRows,The following statement contains a magic number: for (int i = _offsetMin; i < _offsetMax; i++)              {                  if (_buffer[i] == (byte)13 || _buffer[i] == (byte)10)                  {                      if (i + 1 < _offsetMax && _buffer[i + 1] == (byte)10)                          i++;                      list.Add(i + 1);                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                  for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value < int.MinValue / 10)                          return false;                      value *= 10;                      if (value < int.MinValue + digit)                          return false;                      value -= digit;                  }              }              else              {                  for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value > int.MaxValue / 10)                          return false;                      value *= 10;                      if (value > int.MaxValue - digit)                          return false;                      value += digit;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                  for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value < int.MinValue / 10)                          return false;                      value *= 10;                      if (value < int.MinValue + digit)                          return false;                      value -= digit;                  }              }              else              {                  for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value > int.MaxValue / 10)                          return false;                      value *= 10;                      if (value > int.MaxValue - digit)                          return false;                      value += digit;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                  for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value < int.MinValue / 10)                          return false;                      value *= 10;                      if (value < int.MinValue + digit)                          return false;                      value -= digit;                  }              }              else              {                  for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value > int.MaxValue / 10)                          return false;                      value *= 10;                      if (value > int.MaxValue - digit)                          return false;                      value += digit;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                  for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value < int.MinValue / 10)                          return false;                      value *= 10;                      if (value < int.MinValue + digit)                          return false;                      value -= digit;                  }              }              else              {                  for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value > int.MaxValue / 10)                          return false;                      value *= 10;                      if (value > int.MaxValue - digit)                          return false;                      value += digit;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                  for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value < int.MinValue / 10)                          return false;                      value *= 10;                      if (value < int.MinValue + digit)                          return false;                      value -= digit;                  }              }              else              {                  for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value > int.MaxValue / 10)                          return false;                      value *= 10;                      if (value > int.MaxValue - digit)                          return false;                      value += digit;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt32,The following statement contains a magic number: if (chars[offset] == '-')              {                  if (count == 1)                      return false;                  for (int i = offset + 1; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value < int.MinValue / 10)                          return false;                      value *= 10;                      if (value < int.MinValue + digit)                          return false;                      value -= digit;                  }              }              else              {                  for (int i = offset; i < offsetMax; i++)                  {                      int digit = (chars[i] - '0');                      if ((uint)digit > 9)                          return false;                      if (value > int.MaxValue / 10)                          return false;                      value *= 10;                      if (value > int.MaxValue - digit)                          return false;                      value += digit;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                  if (!TryParseInt32(chars' offset' count' out value))                      return false;                  result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                  if (chars[offset] == '-')                  {                      for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value < long.MinValue / 10)                              return false;                          value *= 10;                          if (value < long.MinValue + digit)                              return false;                          value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value > long.MaxValue / 10)                              return false;                          value *= 10;                          if (value > long.MaxValue - digit)                              return false;                          value += digit;                      }                  }                  result = value;                  return true;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                  if (!TryParseInt32(chars' offset' count' out value))                      return false;                  result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                  if (chars[offset] == '-')                  {                      for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value < long.MinValue / 10)                              return false;                          value *= 10;                          if (value < long.MinValue + digit)                              return false;                          value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value > long.MaxValue / 10)                              return false;                          value *= 10;                          if (value > long.MaxValue - digit)                              return false;                          value += digit;                      }                  }                  result = value;                  return true;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                  if (!TryParseInt32(chars' offset' count' out value))                      return false;                  result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                  if (chars[offset] == '-')                  {                      for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value < long.MinValue / 10)                              return false;                          value *= 10;                          if (value < long.MinValue + digit)                              return false;                          value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value > long.MaxValue / 10)                              return false;                          value *= 10;                          if (value > long.MaxValue - digit)                              return false;                          value += digit;                      }                  }                  result = value;                  return true;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                  if (!TryParseInt32(chars' offset' count' out value))                      return false;                  result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                  if (chars[offset] == '-')                  {                      for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value < long.MinValue / 10)                              return false;                          value *= 10;                          if (value < long.MinValue + digit)                              return false;                          value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value > long.MaxValue / 10)                              return false;                          value *= 10;                          if (value > long.MaxValue - digit)                              return false;                          value += digit;                      }                  }                  result = value;                  return true;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                  if (!TryParseInt32(chars' offset' count' out value))                      return false;                  result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                  if (chars[offset] == '-')                  {                      for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value < long.MinValue / 10)                              return false;                          value *= 10;                          if (value < long.MinValue + digit)                              return false;                          value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value > long.MaxValue / 10)                              return false;                          value *= 10;                          if (value > long.MaxValue - digit)                              return false;                          value += digit;                      }                  }                  result = value;                  return true;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                  if (!TryParseInt32(chars' offset' count' out value))                      return false;                  result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                  if (chars[offset] == '-')                  {                      for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value < long.MinValue / 10)                              return false;                          value *= 10;                          if (value < long.MinValue + digit)                              return false;                          value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value > long.MaxValue / 10)                              return false;                          value *= 10;                          if (value > long.MaxValue - digit)                              return false;                          value += digit;                      }                  }                  result = value;                  return true;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseInt64,The following statement contains a magic number: if (count < 11)              {                  int value;                  if (!TryParseInt32(chars' offset' count' out value))                      return false;                  result = value;                  return true;              }              else              {                  long value = 0;                  int offsetMax = offset + count;                  if (chars[offset] == '-')                  {                      for (int i = offset + 1; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value < long.MinValue / 10)                              return false;                          value *= 10;                          if (value < long.MinValue + digit)                              return false;                          value -= digit;                      }                  }                  else                  {                      for (int i = offset; i < offsetMax; i++)                      {                          int digit = (chars[i] - '0');                          if ((uint)digit > 9)                              return false;                          if (value > long.MaxValue / 10)                              return false;                          value *= 10;                          if (value > long.MaxValue - digit)                              return false;                          value += digit;                      }                  }                  result = value;                  return true;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (count < 1 || count > 10)                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                      if (count > 8)                      {                          result = (float)((double)value / (double)pow10);                      }                      else                      {                          result = (float)value / (float)pow10;                      }                      if (negative)                          result = -result;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                      if (count > 8)                      {                          result = (float)((double)value / (double)pow10);                      }                      else                      {                          result = (float)value / (float)pow10;                      }                      if (negative)                          result = -result;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                      if (count > 8)                      {                          result = (float)((double)value / (double)pow10);                      }                      else                      {                          result = (float)value / (float)pow10;                      }                      if (negative)                          result = -result;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                      if (count > 8)                      {                          result = (float)((double)value / (double)pow10);                      }                      else                      {                          result = (float)value / (float)pow10;                      }                      if (negative)                          result = -result;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                      if (count > 8)                      {                          result = (float)((double)value / (double)pow10);                      }                      else                      {                          result = (float)value / (float)pow10;                      }                      if (negative)                          result = -result;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      // More than 8 characters (7 sig figs and a decimal) and int -> float conversion is lossy' so use double                      if (count > 8)                      {                          result = (float)((double)value / (double)pow10);                      }                      else                      {                          result = (float)value / (float)pow10;                      }                      if (negative)                          result = -result;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseSingle,The following statement contains a magic number: if (count == 10)                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (count < 1 || count > 10)                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: while (offset < offsetMax)              {                  ch = (chars[offset] - '0');                  if (ch == ('.' - '0'))                  {                      offset++;                      int pow10 = 1;                      while (offset < offsetMax)                      {                          ch = chars[offset] - '0';                          if (((uint)ch) >= 10)                              return false;                          pow10 *= 10;                          value = value * 10 + ch;                          offset++;                      }                      if (negative)                          result = -(double)value / pow10;                      else                          result = (double)value / pow10;                      return true;                  }                  else if (((uint)ch) >= 10)                      return false;                  value = value * 10 + ch;                  offset++;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDouble,The following statement contains a magic number: if (count == 10)                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value > int.MaxValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }              else              {                  while (value < int.MinValue)                  {                      long valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (int)(value - valueDiv10 * 10));                      value = valueDiv10;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'I';                  buffer[offset + 1] = (byte)'N';                  buffer[offset + 2] = (byte)'F';                  return 3;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'I';                  buffer[offset + 1] = (byte)'N';                  buffer[offset + 2] = (byte)'F';                  return 3;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'I';                  buffer[offset + 1] = (byte)'N';                  buffer[offset + 2] = (byte)'F';                  return 3;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'I';                  buffer[offset + 1] = (byte)'N';                  buffer[offset + 2] = (byte)'F';                  return 3;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInfinity,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'I';                  buffer[offset + 2] = (byte)'N';                  buffer[offset + 3] = (byte)'F';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'I';                  buffer[offset + 1] = (byte)'N';                  buffer[offset + 2] = (byte)'F';                  return 3;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToZero,The following statement contains a magic number: if (isNegative)              {                  buffer[offset + 0] = (byte)'-';                  buffer[offset + 1] = (byte)'0';                  return 2;              }              else              {                  buffer[offset] = (byte)'0';                  return 1;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToAsciiChars,The following statement contains a magic number: for (int i = 0; i < s.Length; i++)              {                  Fx.Assert(s[i] < 128' "");                  buffer[offset++] = (byte)s[i];              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'f';                  buffer[offset + 1] = (byte)'a';                  buffer[offset + 2] = (byte)'l';                  buffer[offset + 3] = (byte)'s';                  buffer[offset + 4] = (byte)'e';                  return 5;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'f';                  buffer[offset + 1] = (byte)'a';                  buffer[offset + 2] = (byte)'l';                  buffer[offset + 3] = (byte)'s';                  buffer[offset + 4] = (byte)'e';                  return 5;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'f';                  buffer[offset + 1] = (byte)'a';                  buffer[offset + 2] = (byte)'l';                  buffer[offset + 3] = (byte)'s';                  buffer[offset + 4] = (byte)'e';                  return 5;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'f';                  buffer[offset + 1] = (byte)'a';                  buffer[offset + 2] = (byte)'l';                  buffer[offset + 3] = (byte)'s';                  buffer[offset + 4] = (byte)'e';                  return 5;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'f';                  buffer[offset + 1] = (byte)'a';                  buffer[offset + 2] = (byte)'l';                  buffer[offset + 3] = (byte)'s';                  buffer[offset + 4] = (byte)'e';                  return 5;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'f';                  buffer[offset + 1] = (byte)'a';                  buffer[offset + 2] = (byte)'l';                  buffer[offset + 3] = (byte)'s';                  buffer[offset + 4] = (byte)'e';                  return 5;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: if (value)              {                  buffer[offset + 0] = (byte)'t';                  buffer[offset + 1] = (byte)'r';                  buffer[offset + 2] = (byte)'u';                  buffer[offset + 3] = (byte)'e';                  return 4;              }              else              {                  buffer[offset + 0] = (byte)'f';                  buffer[offset + 1] = (byte)'a';                  buffer[offset + 2] = (byte)'l';                  buffer[offset + 3] = (byte)'s';                  buffer[offset + 4] = (byte)'e';                  return 5;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: if (ch1 > 9 || ch2 > 9)                  return -1;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: if (ch1 > 9 || ch2 > 9)                  return -1;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32D2,The following statement contains a magic number: return 10 * ch1 + ch2;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  byte ch = (byte)(chars[offset + i] - '0');                  if (ch > 9)                      return -1;                  value = value * 10 + ch;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToInt32D7,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  byte ch = (byte)(chars[offset + i] - '0');                  if (ch > 9)                      return -1;                  value = value * 10 + ch;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (count < 19)                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (chars[offset + 4] != '-' || chars[offset + 7] != '-' || chars[offset + 10] != 'T' ||                  chars[offset + 13] != ':' || chars[offset + 16] != ':')                  return false;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int year = ToInt32D4(chars' offset + 0' 4);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int month = ToInt32D2(chars' offset + 5);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int day = ToInt32D2(chars' offset + 8);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int hour = ToInt32D2(chars' offset + 11);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int minute = ToInt32D2(chars' offset + 14);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: int second = ToInt32D2(chars' offset + 17);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: offset += 19;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars[offset] == '.')              {                  offset++;                  int digitOffset = offset;                  while (offset < offsetMax)                  {                      byte ch = chars[offset];                      if (ch < '0' || ch > '9')                          break;                      offset++;                  }                  int digitCount = offset - digitOffset;                  if (digitCount < 1 || digitCount > 7)                      return false;                  ticks = ToInt32D7(chars' digitOffset' digitCount);                  if (ticks < 0)                      return false;                  for (int i = digitCount; i < 7; ++i)                      ticks *= 10;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars[offset] == '.')              {                  offset++;                  int digitOffset = offset;                  while (offset < offsetMax)                  {                      byte ch = chars[offset];                      if (ch < '0' || ch > '9')                          break;                      offset++;                  }                  int digitCount = offset - digitOffset;                  if (digitCount < 1 || digitCount > 7)                      return false;                  ticks = ToInt32D7(chars' digitOffset' digitCount);                  if (ticks < 0)                      return false;                  for (int i = digitCount; i < 7; ++i)                      ticks *= 10;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax && chars[offset] == '.')              {                  offset++;                  int digitOffset = offset;                  while (offset < offsetMax)                  {                      byte ch = chars[offset];                      if (ch < '0' || ch > '9')                          break;                      offset++;                  }                  int digitCount = offset - digitOffset;                  if (digitCount < 1 || digitCount > 7)                      return false;                  ticks = ToInt32D7(chars' digitOffset' digitCount);                  if (ticks < 0)                      return false;                  for (int i = digitCount; i < 7; ++i)                      ticks *= 10;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                  if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                  else if (ch == '+' || ch == '-')                  {                      offset++;                      if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                      kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                      if ((hourDelta | minuteDelta) < 0)                          return false;                      if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                      offset += 5;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                  if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                  else if (ch == '+' || ch == '-')                  {                      offset++;                      if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                      kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                      if ((hourDelta | minuteDelta) < 0)                          return false;                      if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                      offset += 5;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                  if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                  else if (ch == '+' || ch == '-')                  {                      offset++;                      if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                      kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                      if ((hourDelta | minuteDelta) < 0)                          return false;                      if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                      offset += 5;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,TryParseDateTime,The following statement contains a magic number: if (offset < offsetMax)              {                  byte ch = chars[offset];                  if (ch == 'Z')                  {                      offset++;                      kind = DateTimeKind.Utc;                  }                  else if (ch == '+' || ch == '-')                  {                      offset++;                      if (offset + 5 > offsetMax || chars[offset + 2] != ':')                          return false;                      kind = DateTimeKind.Utc;                      isLocal = true;                      hourDelta = ToInt32D2(chars' offset);                      minuteDelta = ToInt32D2(chars' offset + 3);                      if ((hourDelta | minuteDelta) < 0)                          return false;                      if (ch == '+')                      {                          hourDelta = -hourDelta;                          minuteDelta = -minuteDelta;                      }                      offset += 5;                  }              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsR,The following statement contains a magic number: if (value >= 0)              {                  while (value >= 10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' + (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' + value);                  count++;              }              else              {                  while (value <= -10)                  {                      int valueDiv10 = value / 10;                      count++;                      chars[--offset] = (byte)('0' - (value - valueDiv10 * 10));                      value = valueDiv10;                  }                  chars[--offset] = (byte)('0' - value);                  chars[--offset] = (byte)'-';                  count += 2;              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: DiagnosticUtility.DebugAssert(value >= 0 && value < 100' "");
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10)              {                  chars[offset + 0] = (byte)'0';                  chars[offset + 1] = (byte)('0' + value);              }              else              {                  int valueDiv10 = value / 10;                  chars[offset + 0] = (byte)('0' + valueDiv10);                  chars[offset + 1] = (byte)('0' + value - valueDiv10 * 10);              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10)              {                  chars[offset + 0] = (byte)'0';                  chars[offset + 1] = (byte)('0' + value);              }              else              {                  int valueDiv10 = value / 10;                  chars[offset + 0] = (byte)('0' + valueDiv10);                  chars[offset + 1] = (byte)('0' + value - valueDiv10 * 10);              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: if (value < 10)              {                  chars[offset + 0] = (byte)'0';                  chars[offset + 1] = (byte)('0' + value);              }              else              {                  int valueDiv10 = value / 10;                  chars[offset + 0] = (byte)('0' + valueDiv10);                  chars[offset + 1] = (byte)('0' + value - valueDiv10 * 10);              }
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD2,The following statement contains a magic number: return 2;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: DiagnosticUtility.DebugAssert(value >= 0 && value < 10000' "");
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2(value / 100' chars' offset + 0);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2(value % 100' chars' offset + 2);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: ToCharsD2(value % 100' chars' offset + 2);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD4,The following statement contains a magic number: return 4;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD7,The following statement contains a magic number: DiagnosticUtility.DebugAssert(value >= 0 && value < 10000000' "");
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD7,The following statement contains a magic number: int zeroCount = 7 - ToCharsR(value' chars' offset + 7);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD7,The following statement contains a magic number: int zeroCount = 7 - ToCharsR(value' chars' offset + 7);
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToCharsD7,The following statement contains a magic number: int count = 7;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: const long TicksPerMillisecond = 10000;
Magic Number,System.Xml,XmlConverter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlConverter.cs,ToChars,The following statement contains a magic number: const long TicksPerSecond = TicksPerMillisecond * 1000;
Magic Number,System.Xml,XmlDictionary,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionary.cs,Add,The following statement contains a magic number: if (!_lookup.TryGetValue(value' out str))              {                  if (_strings == null)                  {                      _strings = new XmlDictionaryString[4];                  }                  else if (_nextId == _strings.Length)                  {                      int newSize = _nextId * 2;                      if (newSize == 0)                          newSize = 4;                      Array.Resize(ref _strings' newSize);                  }                  str = new XmlDictionaryString(this' value' _nextId);                  _strings[_nextId] = str;                  _lookup.Add(value' str);                  _nextId++;              }
Magic Number,System.Xml,XmlDictionary,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionary.cs,Add,The following statement contains a magic number: if (!_lookup.TryGetValue(value' out str))              {                  if (_strings == null)                  {                      _strings = new XmlDictionaryString[4];                  }                  else if (_nextId == _strings.Length)                  {                      int newSize = _nextId * 2;                      if (newSize == 0)                          newSize = 4;                      Array.Resize(ref _strings' newSize);                  }                  str = new XmlDictionaryString(this' value' _nextId);                  _strings[_nextId] = str;                  _lookup.Add(value' str);                  _nextId++;              }
Magic Number,System.Xml,XmlDictionary,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionary.cs,Add,The following statement contains a magic number: if (!_lookup.TryGetValue(value' out str))              {                  if (_strings == null)                  {                      _strings = new XmlDictionaryString[4];                  }                  else if (_nextId == _strings.Length)                  {                      int newSize = _nextId * 2;                      if (newSize == 0)                          newSize = 4;                      Array.Resize(ref _strings' newSize);                  }                  str = new XmlDictionaryString(this' value' _nextId);                  _strings[_nextId] = str;                  _lookup.Add(value' str);                  _nextId++;              }
Magic Number,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteValue,The following statement contains a magic number: int blockSize = 256;
Magic Number,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteValue,The following statement contains a magic number: while (true)              {                  bytesRead = stream.Read(block' 0' blockSize);                  if (bytesRead > 0)                      WriteBase64(block' 0' bytesRead);                  else                      break;                  if (blockSize < 65536 && bytesRead == blockSize)                  {                      blockSize = blockSize * 16;                      block = new byte[blockSize];                  }              }
Magic Number,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteValue,The following statement contains a magic number: while (true)              {                  bytesRead = stream.Read(block' 0' blockSize);                  if (bytesRead > 0)                      WriteBase64(block' 0' bytesRead);                  else                      break;                  if (blockSize < 65536 && bytesRead == blockSize)                  {                      blockSize = blockSize * 16;                      block = new byte[blockSize];                  }              }
Magic Number,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsBytes,The following statement contains a magic number: byte[][] buffers = new byte[32][];
Magic Number,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsBytes,The following statement contains a magic number: int count = 384;
Magic Number,System.Xml,XmlDictionaryReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryReader.cs,ReadContentAsBytes,The following statement contains a magic number: while (true)              {                  buffer = new byte[count];                  buffers[bufferCount++] = buffer;                  int read = 0;                  while (read < buffer.Length)                  {                      int actual;                      if (base64)                          actual = ReadContentAsBase64(buffer' read' buffer.Length - read);                      else                          actual = ReadContentAsBinHex(buffer' read' buffer.Length - read);                      if (actual == 0)                          break;                      read += actual;                  }                  totalRead += read;                  if (read < buffer.Length)                      break;                  count = count * 2;              }
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,WriteBytes,The following statement contains a magic number: _offset += 2;
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,WriteUTF8Char,The following statement contains a magic number: if (ch < 0x80)              {                  WriteByte((byte)ch);              }              else if (ch <= char.MaxValue)              {                  char* chars = stackalloc char[1];                  chars[0] = (char)ch;                  UnsafeWriteUTF8Chars(chars' 1);              }              else              {                  SurrogateChar surrogateChar = new SurrogateChar(ch);                  char* chars = stackalloc char[2];                  chars[0] = surrogateChar.HighChar;                  chars[1] = surrogateChar.LowChar;                  UnsafeWriteUTF8Chars(chars' 2);              }
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,WriteUTF8Char,The following statement contains a magic number: if (ch < 0x80)              {                  WriteByte((byte)ch);              }              else if (ch <= char.MaxValue)              {                  char* chars = stackalloc char[1];                  chars[0] = (char)ch;                  UnsafeWriteUTF8Chars(chars' 1);              }              else              {                  SurrogateChar surrogateChar = new SurrogateChar(ch);                  char* chars = stackalloc char[2];                  chars[0] = surrogateChar.HighChar;                  chars[1] = surrogateChar.LowChar;                  UnsafeWriteUTF8Chars(chars' 2);              }
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,UnsafeWriteUnicodeChars,The following statement contains a magic number: const int charChunkSize = bufferLength / 2;
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,UnsafeWriteUnicodeChars,The following statement contains a magic number: while (charCount > charChunkSize)              {                  int offset;                  int chunkSize = charChunkSize;                  if ((int)(chars[chunkSize - 1] & 0xFC00) == 0xD800) // This is a high surrogate                      chunkSize--;                  byte[] buffer = GetBuffer(chunkSize * 2' out offset);                  Advance(UnsafeGetUnicodeChars(chars' chunkSize' buffer' offset));                  charCount -= chunkSize;                  chars += chunkSize;              }
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,UnsafeWriteUnicodeChars,The following statement contains a magic number: if (charCount > 0)              {                  int offset;                  byte[] buffer = GetBuffer(charCount * 2' out offset);                  Advance(UnsafeGetUnicodeChars(chars' charCount' buffer' offset));              }
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,UnsafeGetUnicodeChars,The following statement contains a magic number: while (chars < charsMax)              {                  char value = *chars++;                  buffer[offset++] = (byte)value;                  value >>= 8;                  buffer[offset++] = (byte)value;              }
Magic Number,System.Xml,XmlStreamNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlStreamNodeWriter.cs,UnsafeGetUnicodeChars,The following statement contains a magic number: return charCount * 2;
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: byte[] buffer = BufferReader.GetBuffer(5' out offset);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'?' ||                  buffer[offset + 1] != (byte)'x' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'l' ||                  (s_charType[buffer[offset + 4]] & CharType.Whitespace) == 0)              {                  XmlExceptionHelper.ThrowProcessingInstructionNotSupported(this);              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'?' ||                  buffer[offset + 1] != (byte)'x' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'l' ||                  (s_charType[buffer[offset + 4]] & CharType.Whitespace) == 0)              {                  XmlExceptionHelper.ThrowProcessingInstructionNotSupported(this);              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'?' ||                  buffer[offset + 1] != (byte)'x' ||                  buffer[offset + 2] != (byte)'m' ||                  buffer[offset + 3] != (byte)'l' ||                  (s_charType[buffer[offset + 4]] & CharType.Whitespace) == 0)              {                  XmlExceptionHelper.ThrowProcessingInstructionNotSupported(this);              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: BufferReader.Advance(5);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: int localNameLength = 3;
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: buffer = BufferReader.GetBuffer(2' out offset);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'?' ||                  buffer[offset + 1] != (byte)'>')              {                  XmlExceptionHelper.ThrowTokenExpected(this' "?>"' Encoding.UTF8.GetString(buffer' offset' 2));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadDeclaration,The following statement contains a magic number: BufferReader.Advance(2);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,IsNextCharacterNonFFFE,The following statement contains a magic number: if (buffer[offset + 1] == 0xBF && (buffer[offset + 2] == 0xBE || buffer[offset + 2] == 0xBF))              {                  // 0xFFFE : 0xEF 0xBF 0xBE                  // 0xFFFF : 0xEF 0xBF 0xBF                  // we know that buffer[offset] is already 0xEF' don't bother checking it.                  return false;              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,IsNextCharacterNonFFFE,The following statement contains a magic number: if (buffer[offset + 1] == 0xBF && (buffer[offset + 2] == 0xBE || buffer[offset + 2] == 0xBF))              {                  // 0xFFFE : 0xEF 0xBF 0xBE                  // 0xFFFF : 0xEF 0xBF 0xBF                  // we know that buffer[offset] is already 0xEF' don't bother checking it.                  return false;              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadNonFFFE,The following statement contains a magic number: byte[] buff = BufferReader.GetBuffer(3' out off);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buff[off + 1] == 0xBF && (buff[off + 2] == 0xBE || buff[off + 2] == 0xBF))              {                  XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlInvalidFFFE)));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buff[off + 1] == 0xBF && (buff[off + 2] == 0xBE || buff[off + 2] == 0xBF))              {                  XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlInvalidFFFE)));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadNonFFFE,The following statement contains a magic number: BufferReader.Advance(3);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,BufferElement,The following statement contains a magic number: const int byteCount = 128;
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadComment,The following statement contains a magic number: while (true)              {                  while (true)                  {                      byte b = BufferReader.GetByte();                      if (b == '-')                          break;                      if ((s_charType[b] & CharType.Comment) == 0)                      {                          if (b == 0xEF)                              ReadNonFFFE();                          else                              XmlExceptionHelper.ThrowInvalidXml(this' b);                      }                      else                      {                          BufferReader.SkipByte();                      }                  }                    int offset;                  byte[] buffer = BufferReader.GetBuffer(3' out offset);                  if (buffer[offset + 0] == (byte)'-' &&                      buffer[offset + 1] == (byte)'-')                  {                      if (buffer[offset + 2] == (byte)'>')                          break;                      XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlInvalidCommentChars)));                  }                  BufferReader.SkipByte();              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadComment,The following statement contains a magic number: while (true)              {                  while (true)                  {                      byte b = BufferReader.GetByte();                      if (b == '-')                          break;                      if ((s_charType[b] & CharType.Comment) == 0)                      {                          if (b == 0xEF)                              ReadNonFFFE();                          else                              XmlExceptionHelper.ThrowInvalidXml(this' b);                      }                      else                      {                          BufferReader.SkipByte();                      }                  }                    int offset;                  byte[] buffer = BufferReader.GetBuffer(3' out offset);                  if (buffer[offset + 0] == (byte)'-' &&                      buffer[offset + 1] == (byte)'-')                  {                      if (buffer[offset + 2] == (byte)'>')                          break;                      XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlInvalidCommentChars)));                  }                  BufferReader.SkipByte();              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadComment,The following statement contains a magic number: BufferReader.Advance(3);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: byte[] buffer = BufferReader.GetBuffer(7' out offset);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'[' ||                  buffer[offset + 1] != (byte)'C' ||                  buffer[offset + 2] != (byte)'D' ||                  buffer[offset + 3] != (byte)'A' ||                  buffer[offset + 4] != (byte)'T' ||                  buffer[offset + 5] != (byte)'A' ||                  buffer[offset + 6] != (byte)'[')              {                  XmlExceptionHelper.ThrowTokenExpected(this' "[CDATA["' Encoding.UTF8.GetString(buffer' offset' 7));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'[' ||                  buffer[offset + 1] != (byte)'C' ||                  buffer[offset + 2] != (byte)'D' ||                  buffer[offset + 3] != (byte)'A' ||                  buffer[offset + 4] != (byte)'T' ||                  buffer[offset + 5] != (byte)'A' ||                  buffer[offset + 6] != (byte)'[')              {                  XmlExceptionHelper.ThrowTokenExpected(this' "[CDATA["' Encoding.UTF8.GetString(buffer' offset' 7));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'[' ||                  buffer[offset + 1] != (byte)'C' ||                  buffer[offset + 2] != (byte)'D' ||                  buffer[offset + 3] != (byte)'A' ||                  buffer[offset + 4] != (byte)'T' ||                  buffer[offset + 5] != (byte)'A' ||                  buffer[offset + 6] != (byte)'[')              {                  XmlExceptionHelper.ThrowTokenExpected(this' "[CDATA["' Encoding.UTF8.GetString(buffer' offset' 7));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'[' ||                  buffer[offset + 1] != (byte)'C' ||                  buffer[offset + 2] != (byte)'D' ||                  buffer[offset + 3] != (byte)'A' ||                  buffer[offset + 4] != (byte)'T' ||                  buffer[offset + 5] != (byte)'A' ||                  buffer[offset + 6] != (byte)'[')              {                  XmlExceptionHelper.ThrowTokenExpected(this' "[CDATA["' Encoding.UTF8.GetString(buffer' offset' 7));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'[' ||                  buffer[offset + 1] != (byte)'C' ||                  buffer[offset + 2] != (byte)'D' ||                  buffer[offset + 3] != (byte)'A' ||                  buffer[offset + 4] != (byte)'T' ||                  buffer[offset + 5] != (byte)'A' ||                  buffer[offset + 6] != (byte)'[')              {                  XmlExceptionHelper.ThrowTokenExpected(this' "[CDATA["' Encoding.UTF8.GetString(buffer' offset' 7));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: if (buffer[offset + 0] != (byte)'[' ||                  buffer[offset + 1] != (byte)'C' ||                  buffer[offset + 2] != (byte)'D' ||                  buffer[offset + 3] != (byte)'A' ||                  buffer[offset + 4] != (byte)'T' ||                  buffer[offset + 5] != (byte)'A' ||                  buffer[offset + 6] != (byte)'[')              {                  XmlExceptionHelper.ThrowTokenExpected(this' "[CDATA["' Encoding.UTF8.GetString(buffer' offset' 7));              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: BufferReader.Advance(7);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: while (true)              {                  byte b;                  while (true)                  {                      b = BufferReader.GetByte();                      if (b == ']')                          break;                        if (b == 0xEF)                          ReadNonFFFE();                      else                          BufferReader.SkipByte();                  }                  buffer = BufferReader.GetBuffer(3' out offset);                  if (buffer[offset + 0] == (byte)']' &&                      buffer[offset + 1] == (byte)']' &&                      buffer[offset + 2] == (byte)'>')                      break;                  BufferReader.SkipByte();              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: while (true)              {                  byte b;                  while (true)                  {                      b = BufferReader.GetByte();                      if (b == ']')                          break;                        if (b == 0xEF)                          ReadNonFFFE();                      else                          BufferReader.SkipByte();                  }                  buffer = BufferReader.GetBuffer(3' out offset);                  if (buffer[offset + 0] == (byte)']' &&                      buffer[offset + 1] == (byte)']' &&                      buffer[offset + 2] == (byte)'>')                      break;                  BufferReader.SkipByte();              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadCData,The following statement contains a magic number: BufferReader.Advance(3);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadTextAndWatchForInvalidCharacters,The following statement contains a magic number: while (offset < offsetMax && ((charType[buffer[offset]] & CharType.Text) != 0 || buffer[offset] == 0xEF))              {                  if (buffer[offset] != 0xEF)                  {                      offset++;                  }                  else                  {                      // Ensure that we have three bytes (buffer[offset]' buffer[offset + 1]' buffer[offset + 2])                        // available for IsNextCharacterNonFFFE to check.                       if (offset + 2 < offsetMax)                      {                          if (IsNextCharacterNonFFFE(buffer' offset))                          {                              // if first byte is 0xEF' UTF8 mandates a 3-byte character representation of this Unicode code point                              offset += 3;                          }                          else                          {                              XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlInvalidFFFE)));                          }                      }                      else                      {                          if (BufferReader.Offset < offset)                          {                              // We have read some characters already                              // Let the outer ReadText advance the bufferReader and return text node to caller                              break;                          }                          else                          {                              // Get enough bytes for us to process next character' then go back to top of while loop                              int dummy;                              BufferReader.GetBuffer(3' out dummy);                          }                      }                  }              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadTextAndWatchForInvalidCharacters,The following statement contains a magic number: while (offset < offsetMax && ((charType[buffer[offset]] & CharType.Text) != 0 || buffer[offset] == 0xEF))              {                  if (buffer[offset] != 0xEF)                  {                      offset++;                  }                  else                  {                      // Ensure that we have three bytes (buffer[offset]' buffer[offset + 1]' buffer[offset + 2])                        // available for IsNextCharacterNonFFFE to check.                       if (offset + 2 < offsetMax)                      {                          if (IsNextCharacterNonFFFE(buffer' offset))                          {                              // if first byte is 0xEF' UTF8 mandates a 3-byte character representation of this Unicode code point                              offset += 3;                          }                          else                          {                              XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlInvalidFFFE)));                          }                      }                      else                      {                          if (BufferReader.Offset < offset)                          {                              // We have read some characters already                              // Let the outer ReadText advance the bufferReader and return text node to caller                              break;                          }                          else                          {                              // Get enough bytes for us to process next character' then go back to top of while loop                              int dummy;                              BufferReader.GetBuffer(3' out dummy);                          }                      }                  }              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadTextAndWatchForInvalidCharacters,The following statement contains a magic number: while (offset < offsetMax && ((charType[buffer[offset]] & CharType.Text) != 0 || buffer[offset] == 0xEF))              {                  if (buffer[offset] != 0xEF)                  {                      offset++;                  }                  else                  {                      // Ensure that we have three bytes (buffer[offset]' buffer[offset + 1]' buffer[offset + 2])                        // available for IsNextCharacterNonFFFE to check.                       if (offset + 2 < offsetMax)                      {                          if (IsNextCharacterNonFFFE(buffer' offset))                          {                              // if first byte is 0xEF' UTF8 mandates a 3-byte character representation of this Unicode code point                              offset += 3;                          }                          else                          {                              XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlInvalidFFFE)));                          }                      }                      else                      {                          if (BufferReader.Offset < offset)                          {                              // We have read some characters already                              // Let the outer ReadText advance the bufferReader and return text node to caller                              break;                          }                          else                          {                              // Get enough bytes for us to process next character' then go back to top of while loop                              int dummy;                              BufferReader.GetBuffer(3' out dummy);                          }                      }                  }              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & 0x80) == 0x80)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                  int originalLength = length;                  do                  {                      length--;                  }                  while (length > 0 && (buffer[offset + length] & 0xC0) != 0xC0);                  // Couldn't find the lead char                  if (length == 0)                      return originalLength; // Invalid utf8 sequence - can't break                  // Count how many bytes follow the lead char                  byte b = unchecked((byte)(buffer[offset + length] << 2));                  int byteCount = 2;                  while ((b & 0x80) == 0x80)                  {                      b = unchecked((byte)(b << 1));                      byteCount++;                      // There shouldn't be more than 3 bytes following the lead char                      if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                  }                  if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & 0x80) == 0x80)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                  int originalLength = length;                  do                  {                      length--;                  }                  while (length > 0 && (buffer[offset + length] & 0xC0) != 0xC0);                  // Couldn't find the lead char                  if (length == 0)                      return originalLength; // Invalid utf8 sequence - can't break                  // Count how many bytes follow the lead char                  byte b = unchecked((byte)(buffer[offset + length] << 2));                  int byteCount = 2;                  while ((b & 0x80) == 0x80)                  {                      b = unchecked((byte)(b << 1));                      byteCount++;                      // There shouldn't be more than 3 bytes following the lead char                      if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                  }                  if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & 0x80) == 0x80)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                  int originalLength = length;                  do                  {                      length--;                  }                  while (length > 0 && (buffer[offset + length] & 0xC0) != 0xC0);                  // Couldn't find the lead char                  if (length == 0)                      return originalLength; // Invalid utf8 sequence - can't break                  // Count how many bytes follow the lead char                  byte b = unchecked((byte)(buffer[offset + length] << 2));                  int byteCount = 2;                  while ((b & 0x80) == 0x80)                  {                      b = unchecked((byte)(b << 1));                      byteCount++;                      // There shouldn't be more than 3 bytes following the lead char                      if (byteCount > 4)                          return originalLength; // Invalid utf8 sequence - can't break                  }                  if (length + byteCount == originalLength)                      return originalLength; // sequence fits exactly              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,ReadEscapedText,The following statement contains a magic number: if (ch < 256 && (s_charType[ch] & CharType.Whitespace) != 0)                  MoveToWhitespaceText().Value.SetCharValue(ch);              else                  MoveToComplexText().Value.SetCharValue(ch);
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,Read,The following statement contains a magic number: if (ch == (byte)'<')              {                  BufferReader.SkipByte();                  ch = BufferReader.GetByte();                  if (ch == (byte)'/')                      ReadEndElement();                  else if (ch == (byte)'!')                  {                      BufferReader.SkipByte();                      ch = BufferReader.GetByte();                      if (ch == '-')                      {                          ReadComment();                      }                      else                      {                          if (OutsideRootElement)                              XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlCDATAInvalidAtTopLevel)));                            ReadCData();                      }                  }                  else if (ch == (byte)'?')                      ReadDeclaration();                  else                      ReadStartElement();              }              else if ((s_charType[ch] & CharType.SpecialWhitespace) != 0)              {                  ReadWhitespace();              }              else if (OutsideRootElement && ch != '\r')              {                  XmlExceptionHelper.ThrowInvalidRootData(this);              }              else if ((s_charType[ch] & CharType.Text) != 0)              {                  ReadText(false);              }              else if (ch == '&')              {                  ReadEscapedText();              }              else if (ch == '\r')              {                  BufferReader.SkipByte();                    if (!BufferReader.EndOfFile && BufferReader.GetByte() == '\n')                      ReadWhitespace();                  else                      MoveToComplexText().Value.SetCharValue('\n');              }              else if (ch == ']')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(3' out offset);                  if (buffer[offset + 0] == (byte)']' &&                      buffer[offset + 1] == (byte)']' &&                      buffer[offset + 2] == (byte)'>')                  {                      XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlCloseCData)));                  }                    BufferReader.SkipByte();                  MoveToComplexText().Value.SetCharValue(']');  // Need to get past the ']' and keep going.              }              else if (ch == 0xEF)  // Watch for invalid characters 0xfffe and 0xffff              {                  ReadText(true);              }              else              {                  XmlExceptionHelper.ThrowInvalidXml(this' ch);              }
Magic Number,System.Xml,XmlUTF8TextReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextReader.cs,Read,The following statement contains a magic number: if (ch == (byte)'<')              {                  BufferReader.SkipByte();                  ch = BufferReader.GetByte();                  if (ch == (byte)'/')                      ReadEndElement();                  else if (ch == (byte)'!')                  {                      BufferReader.SkipByte();                      ch = BufferReader.GetByte();                      if (ch == '-')                      {                          ReadComment();                      }                      else                      {                          if (OutsideRootElement)                              XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlCDATAInvalidAtTopLevel)));                            ReadCData();                      }                  }                  else if (ch == (byte)'?')                      ReadDeclaration();                  else                      ReadStartElement();              }              else if ((s_charType[ch] & CharType.SpecialWhitespace) != 0)              {                  ReadWhitespace();              }              else if (OutsideRootElement && ch != '\r')              {                  XmlExceptionHelper.ThrowInvalidRootData(this);              }              else if ((s_charType[ch] & CharType.Text) != 0)              {                  ReadText(false);              }              else if (ch == '&')              {                  ReadEscapedText();              }              else if (ch == '\r')              {                  BufferReader.SkipByte();                    if (!BufferReader.EndOfFile && BufferReader.GetByte() == '\n')                      ReadWhitespace();                  else                      MoveToComplexText().Value.SetCharValue('\n');              }              else if (ch == ']')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(3' out offset);                  if (buffer[offset + 0] == (byte)']' &&                      buffer[offset + 1] == (byte)']' &&                      buffer[offset + 2] == (byte)'>')                  {                      XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.XmlCloseCData)));                  }                    BufferReader.SkipByte();                  MoveToComplexText().Value.SetCharValue(']');  // Need to get past the ']' and keep going.              }              else if (ch == 0xEF)  // Watch for invalid characters 0xfffe and 0xffff              {                  ReadText(true);              }              else              {                  XmlExceptionHelper.ThrowInvalidXml(this' ch);              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,GetCharBuffer,The following statement contains a magic number: if (charCount >= 256)                  return new char[charCount];
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer = GetBuffer(9' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 2] = (byte)'[';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 3] = (byte)'C';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 4] = (byte)'D';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 5] = (byte)'A';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 6] = (byte)'T';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 7] = (byte)'A';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 8] = (byte)'[';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: Advance(9);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer = GetBuffer(3' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: buffer[offset + 2] = (byte)'>';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteCData,The following statement contains a magic number: Advance(3);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartComment,The following statement contains a magic number: byte[] buffer = GetBuffer(4' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartComment,The following statement contains a magic number: buffer[offset + 2] = (byte)'-';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartComment,The following statement contains a magic number: buffer[offset + 3] = (byte)'-';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartComment,The following statement contains a magic number: Advance(4);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEndComment,The following statement contains a magic number: byte[] buffer = GetBuffer(3' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEndComment,The following statement contains a magic number: buffer[offset + 2] = (byte)'>';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEndComment,The following statement contains a magic number: Advance(3);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartXmlnsAttribute,The following statement contains a magic number: byte[] buffer = GetBuffer(6' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartXmlnsAttribute,The following statement contains a magic number: buffer[offset + 2] = (byte)'m';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartXmlnsAttribute,The following statement contains a magic number: buffer[offset + 3] = (byte)'l';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartXmlnsAttribute,The following statement contains a magic number: buffer[offset + 4] = (byte)'n';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartXmlnsAttribute,The following statement contains a magic number: buffer[offset + 5] = (byte)'s';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteStartXmlnsAttribute,The following statement contains a magic number: Advance(6);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteEscapedText,The following statement contains a magic number: for (int j = 0; j < count; j++)              {                  byte ch = chars[offset + j];                  if (ch < isEscapedCharLength && isEscapedChar[ch])                  {                      WriteUTF8Chars(chars' offset + i' j - i);                      WriteCharEntity(ch);                      i = j + 1;                  }                  else if (ch == 239 && offset + j + 2 < count)                  {                      // 0xFFFE and 0xFFFF must be written as char entities                      // UTF8(239' 191' 190) = (char) 0xFFFE                      // UTF8(239' 191' 191) = (char) 0xFFFF                      byte ch2 = chars[offset + j + 1];                      byte ch3 = chars[offset + j + 2];                      if (ch2 == 191 && (ch3 == 190 || ch3 == 191))                      {                          WriteUTF8Chars(chars' offset + i' j - i);                          WriteCharEntity(ch3 == 190 ? (char)0xFFFE : (char)0xFFFF);                          i = j + 3;                      }                  }              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteLessThanCharEntity,The following statement contains a magic number: byte[] buffer = GetBuffer(4' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteLessThanCharEntity,The following statement contains a magic number: buffer[offset + 2] = (byte)'t';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteLessThanCharEntity,The following statement contains a magic number: buffer[offset + 3] = (byte)';';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteLessThanCharEntity,The following statement contains a magic number: Advance(4);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteGreaterThanCharEntity,The following statement contains a magic number: byte[] buffer = GetBuffer(4' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteGreaterThanCharEntity,The following statement contains a magic number: buffer[offset + 2] = (byte)'t';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteGreaterThanCharEntity,The following statement contains a magic number: buffer[offset + 3] = (byte)';';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteGreaterThanCharEntity,The following statement contains a magic number: Advance(4);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteAmpersandCharEntity,The following statement contains a magic number: byte[] buffer = GetBuffer(5' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteAmpersandCharEntity,The following statement contains a magic number: buffer[offset + 2] = (byte)'m';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteAmpersandCharEntity,The following statement contains a magic number: buffer[offset + 3] = (byte)'p';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteAmpersandCharEntity,The following statement contains a magic number: buffer[offset + 4] = (byte)';';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteAmpersandCharEntity,The following statement contains a magic number: Advance(5);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteApostropheCharEntity,The following statement contains a magic number: byte[] buffer = GetBuffer(6' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteApostropheCharEntity,The following statement contains a magic number: buffer[offset + 2] = (byte)'p';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteApostropheCharEntity,The following statement contains a magic number: buffer[offset + 3] = (byte)'o';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteApostropheCharEntity,The following statement contains a magic number: buffer[offset + 4] = (byte)'s';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteApostropheCharEntity,The following statement contains a magic number: buffer[offset + 5] = (byte)';';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteApostropheCharEntity,The following statement contains a magic number: Advance(6);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteQuoteCharEntity,The following statement contains a magic number: byte[] buffer = GetBuffer(6' out offset);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteQuoteCharEntity,The following statement contains a magic number: buffer[offset + 2] = (byte)'u';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteQuoteCharEntity,The following statement contains a magic number: buffer[offset + 3] = (byte)'o';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteQuoteCharEntity,The following statement contains a magic number: buffer[offset + 4] = (byte)'t';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteQuoteCharEntity,The following statement contains a magic number: buffer[offset + 5] = (byte)';';
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,WriteQuoteCharEntity,The following statement contains a magic number: Advance(6);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,ToBase16,The following statement contains a magic number: do              {                  count++;                  chars[--offset] = s_digits[(int)(value & 0x0F)];                  value /= 16;              }              while (value != 0);
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  byte[] chars = GetBuffer(charCount' out charOffset);                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  byte[] chars = GetBuffer(charCount' out charOffset);                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  byte[] chars = GetBuffer(charCount' out charOffset);                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  byte[] chars = GetBuffer(charCount' out charOffset);                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  byte[] chars = GetBuffer(charCount' out charOffset);                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  byte[] chars = GetBuffer(charCount' out charOffset);                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64Text,The following statement contains a magic number: if (count > 0)              {                  int charOffset;                  byte[] chars = GetBuffer(4' out charOffset);                  Advance(encoding.GetChars(buffer' offset' count' chars' charOffset));              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64TextAsync,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  BytesWithOffset bufferResult = await GetBufferAsync(charCount).ConfigureAwait(false);                  byte[] chars = bufferResult.Bytes;                  charOffset = bufferResult.Offset;                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64TextAsync,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  BytesWithOffset bufferResult = await GetBufferAsync(charCount).ConfigureAwait(false);                  byte[] chars = bufferResult.Bytes;                  charOffset = bufferResult.Offset;                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64TextAsync,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  BytesWithOffset bufferResult = await GetBufferAsync(charCount).ConfigureAwait(false);                  byte[] chars = bufferResult.Bytes;                  charOffset = bufferResult.Offset;                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64TextAsync,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  BytesWithOffset bufferResult = await GetBufferAsync(charCount).ConfigureAwait(false);                  byte[] chars = bufferResult.Bytes;                  charOffset = bufferResult.Offset;                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64TextAsync,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  BytesWithOffset bufferResult = await GetBufferAsync(charCount).ConfigureAwait(false);                  byte[] chars = bufferResult.Bytes;                  charOffset = bufferResult.Offset;                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64TextAsync,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(bufferLength / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  int charOffset;                  BytesWithOffset bufferResult = await GetBufferAsync(charCount).ConfigureAwait(false);                  byte[] chars = bufferResult.Bytes;                  charOffset = bufferResult.Offset;                  Advance(encoding.GetChars(buffer' offset' byteCount' chars' charOffset));                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlUTF8NodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlUTF8TextWriter.cs,InternalWriteBase64TextAsync,The following statement contains a magic number: if (count > 0)              {                  int charOffset;                  BytesWithOffset bufferResult = await GetBufferAsync(4).ConfigureAwait(false);                  byte[] chars = bufferResult.Bytes;                  charOffset = bufferResult.Offset;                  Advance(encoding.GetChars(buffer' offset' count' chars' charOffset));              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,EncodingStreamWrapper,The following statement contains a magic number: try              {                  _isReading = true;                  _stream = stream;                    // Decode the expected encoding                  SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                    // Get the byte order mark so we can determine the encoding                  // May want to try to delay allocating everything until we know the BOM                  SupportedEncoding declEnc = ReadBOMEncoding(encoding == null);                    // Check that the expected encoding matches the decl encoding.                  if (expectedEnc != SupportedEncoding.None && expectedEnc != declEnc)                      ThrowExpectedEncodingMismatch(expectedEnc' declEnc);                    // Fastpath: UTF-8 BOM                  if (declEnc == SupportedEncoding.UTF8)                  {                      // Fastpath: UTF-8 BOM' No declaration                      FillBuffer(2);                      if (_bytes[_byteOffset + 1] != '?' || _bytes[_byteOffset] != '<')                      {                          return;                      }                        FillBuffer(BufferLength);                      CheckUTF8DeclarationEncoding(_bytes' _byteOffset' _byteCount' declEnc' expectedEnc);                  }                  else                  {                      // Convert to UTF-8                      EnsureBuffers();                      FillBuffer((BufferLength - 1) * 2);                      SetReadDocumentEncoding(declEnc);                      CleanupCharBreak();                      int count = _encoding.GetChars(_bytes' _byteOffset' _byteCount' _chars' 0);                      _byteOffset = 0;                      _byteCount = s_validatingUTF8.GetBytes(_chars' 0' count' _bytes' 0);                        // Check for declaration                      if (_bytes[1] == '?' && _bytes[0] == '<')                      {                          CheckUTF8DeclarationEncoding(_bytes' 0' _byteCount' declEnc' expectedEnc);                      }                      else                      {                          // Declaration required if no out-of-band encoding                          if (expectedEnc == SupportedEncoding.None)                              throw new XmlException(SR.XmlDeclarationRequired);                      }                  }              }              catch (DecoderFallbackException ex)              {                  throw new XmlException(SR.XmlInvalidBytes' ex);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,EncodingStreamWrapper,The following statement contains a magic number: try              {                  _isReading = true;                  _stream = stream;                    // Decode the expected encoding                  SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                    // Get the byte order mark so we can determine the encoding                  // May want to try to delay allocating everything until we know the BOM                  SupportedEncoding declEnc = ReadBOMEncoding(encoding == null);                    // Check that the expected encoding matches the decl encoding.                  if (expectedEnc != SupportedEncoding.None && expectedEnc != declEnc)                      ThrowExpectedEncodingMismatch(expectedEnc' declEnc);                    // Fastpath: UTF-8 BOM                  if (declEnc == SupportedEncoding.UTF8)                  {                      // Fastpath: UTF-8 BOM' No declaration                      FillBuffer(2);                      if (_bytes[_byteOffset + 1] != '?' || _bytes[_byteOffset] != '<')                      {                          return;                      }                        FillBuffer(BufferLength);                      CheckUTF8DeclarationEncoding(_bytes' _byteOffset' _byteCount' declEnc' expectedEnc);                  }                  else                  {                      // Convert to UTF-8                      EnsureBuffers();                      FillBuffer((BufferLength - 1) * 2);                      SetReadDocumentEncoding(declEnc);                      CleanupCharBreak();                      int count = _encoding.GetChars(_bytes' _byteOffset' _byteCount' _chars' 0);                      _byteOffset = 0;                      _byteCount = s_validatingUTF8.GetBytes(_chars' 0' count' _bytes' 0);                        // Check for declaration                      if (_bytes[1] == '?' && _bytes[0] == '<')                      {                          CheckUTF8DeclarationEncoding(_bytes' 0' _byteCount' declEnc' expectedEnc);                      }                      else                      {                          // Declaration required if no out-of-band encoding                          if (expectedEnc == SupportedEncoding.None)                              throw new XmlException(SR.XmlDeclarationRequired);                      }                  }              }              catch (DecoderFallbackException ex)              {                  throw new XmlException(SR.XmlInvalidBytes' ex);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: switch (preserve)              {                  case 1:                      _bytes[0] = (byte)b4;                      break;                    case 2:                      _bytes[0] = (byte)b3;                      _bytes[1] = (byte)b4;                      break;                    case 4:                      _bytes[0] = (byte)b1;                      _bytes[1] = (byte)b2;                      _bytes[2] = (byte)b3;                      _bytes[3] = (byte)b4;                      break;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: switch (preserve)              {                  case 1:                      _bytes[0] = (byte)b4;                      break;                    case 2:                      _bytes[0] = (byte)b3;                      _bytes[1] = (byte)b4;                      break;                    case 4:                      _bytes[0] = (byte)b1;                      _bytes[1] = (byte)b2;                      _bytes[2] = (byte)b3;                      _bytes[3] = (byte)b4;                      break;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: switch (preserve)              {                  case 1:                      _bytes[0] = (byte)b4;                      break;                    case 2:                      _bytes[0] = (byte)b3;                      _bytes[1] = (byte)b4;                      break;                    case 4:                      _bytes[0] = (byte)b1;                      _bytes[1] = (byte)b2;                      _bytes[2] = (byte)b3;                      _bytes[3] = (byte)b4;                      break;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: switch (preserve)              {                  case 1:                      _bytes[0] = (byte)b4;                      break;                    case 2:                      _bytes[0] = (byte)b3;                      _bytes[1] = (byte)b4;                      break;                    case 4:                      _bytes[0] = (byte)b1;                      _bytes[1] = (byte)b2;                      _bytes[2] = (byte)b3;                      _bytes[3] = (byte)b4;                      break;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: if (b1 == '<' && b2 != 0x00) // UTF-8' no BOM              {                  e = SupportedEncoding.UTF8;                  preserve = 4;              }              else if (b1 == 0xFF && b2 == 0xFE) // UTF-16 little endian              {                  e = SupportedEncoding.UTF16LE;                  preserve = 2;              }              else if (b1 == 0xFE && b2 == 0xFF) // UTF-16 big endian              {                  e = SupportedEncoding.UTF16BE;                  preserve = 2;              }              else if (b1 == 0x00 && b2 == '<') // UTF-16 big endian' no BOM              {                  e = SupportedEncoding.UTF16BE;                    if (notOutOfBand && (b3 != 0x00 || b4 != '?'))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == '<' && b2 == 0x00) // UTF-16 little endian' no BOM              {                  e = SupportedEncoding.UTF16LE;                    if (notOutOfBand && (b3 != '?' || b4 != 0x00))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == 0xEF && b2 == 0xBB) // UTF8 with BOM              {                  // Encoding error                  if (notOutOfBand && b3 != 0xBF)                      throw new XmlException(SR.XmlBadBOM);                  preserve = 1;              }              else  // Assume UTF8              {                  preserve = 4;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: if (b1 == '<' && b2 != 0x00) // UTF-8' no BOM              {                  e = SupportedEncoding.UTF8;                  preserve = 4;              }              else if (b1 == 0xFF && b2 == 0xFE) // UTF-16 little endian              {                  e = SupportedEncoding.UTF16LE;                  preserve = 2;              }              else if (b1 == 0xFE && b2 == 0xFF) // UTF-16 big endian              {                  e = SupportedEncoding.UTF16BE;                  preserve = 2;              }              else if (b1 == 0x00 && b2 == '<') // UTF-16 big endian' no BOM              {                  e = SupportedEncoding.UTF16BE;                    if (notOutOfBand && (b3 != 0x00 || b4 != '?'))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == '<' && b2 == 0x00) // UTF-16 little endian' no BOM              {                  e = SupportedEncoding.UTF16LE;                    if (notOutOfBand && (b3 != '?' || b4 != 0x00))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == 0xEF && b2 == 0xBB) // UTF8 with BOM              {                  // Encoding error                  if (notOutOfBand && b3 != 0xBF)                      throw new XmlException(SR.XmlBadBOM);                  preserve = 1;              }              else  // Assume UTF8              {                  preserve = 4;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: if (b1 == '<' && b2 != 0x00) // UTF-8' no BOM              {                  e = SupportedEncoding.UTF8;                  preserve = 4;              }              else if (b1 == 0xFF && b2 == 0xFE) // UTF-16 little endian              {                  e = SupportedEncoding.UTF16LE;                  preserve = 2;              }              else if (b1 == 0xFE && b2 == 0xFF) // UTF-16 big endian              {                  e = SupportedEncoding.UTF16BE;                  preserve = 2;              }              else if (b1 == 0x00 && b2 == '<') // UTF-16 big endian' no BOM              {                  e = SupportedEncoding.UTF16BE;                    if (notOutOfBand && (b3 != 0x00 || b4 != '?'))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == '<' && b2 == 0x00) // UTF-16 little endian' no BOM              {                  e = SupportedEncoding.UTF16LE;                    if (notOutOfBand && (b3 != '?' || b4 != 0x00))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == 0xEF && b2 == 0xBB) // UTF8 with BOM              {                  // Encoding error                  if (notOutOfBand && b3 != 0xBF)                      throw new XmlException(SR.XmlBadBOM);                  preserve = 1;              }              else  // Assume UTF8              {                  preserve = 4;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: if (b1 == '<' && b2 != 0x00) // UTF-8' no BOM              {                  e = SupportedEncoding.UTF8;                  preserve = 4;              }              else if (b1 == 0xFF && b2 == 0xFE) // UTF-16 little endian              {                  e = SupportedEncoding.UTF16LE;                  preserve = 2;              }              else if (b1 == 0xFE && b2 == 0xFF) // UTF-16 big endian              {                  e = SupportedEncoding.UTF16BE;                  preserve = 2;              }              else if (b1 == 0x00 && b2 == '<') // UTF-16 big endian' no BOM              {                  e = SupportedEncoding.UTF16BE;                    if (notOutOfBand && (b3 != 0x00 || b4 != '?'))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == '<' && b2 == 0x00) // UTF-16 little endian' no BOM              {                  e = SupportedEncoding.UTF16LE;                    if (notOutOfBand && (b3 != '?' || b4 != 0x00))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == 0xEF && b2 == 0xBB) // UTF8 with BOM              {                  // Encoding error                  if (notOutOfBand && b3 != 0xBF)                      throw new XmlException(SR.XmlBadBOM);                  preserve = 1;              }              else  // Assume UTF8              {                  preserve = 4;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: if (b1 == '<' && b2 != 0x00) // UTF-8' no BOM              {                  e = SupportedEncoding.UTF8;                  preserve = 4;              }              else if (b1 == 0xFF && b2 == 0xFE) // UTF-16 little endian              {                  e = SupportedEncoding.UTF16LE;                  preserve = 2;              }              else if (b1 == 0xFE && b2 == 0xFF) // UTF-16 big endian              {                  e = SupportedEncoding.UTF16BE;                  preserve = 2;              }              else if (b1 == 0x00 && b2 == '<') // UTF-16 big endian' no BOM              {                  e = SupportedEncoding.UTF16BE;                    if (notOutOfBand && (b3 != 0x00 || b4 != '?'))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == '<' && b2 == 0x00) // UTF-16 little endian' no BOM              {                  e = SupportedEncoding.UTF16LE;                    if (notOutOfBand && (b3 != '?' || b4 != 0x00))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == 0xEF && b2 == 0xBB) // UTF8 with BOM              {                  // Encoding error                  if (notOutOfBand && b3 != 0xBF)                      throw new XmlException(SR.XmlBadBOM);                  preserve = 1;              }              else  // Assume UTF8              {                  preserve = 4;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following statement contains a magic number: if (b1 == '<' && b2 != 0x00) // UTF-8' no BOM              {                  e = SupportedEncoding.UTF8;                  preserve = 4;              }              else if (b1 == 0xFF && b2 == 0xFE) // UTF-16 little endian              {                  e = SupportedEncoding.UTF16LE;                  preserve = 2;              }              else if (b1 == 0xFE && b2 == 0xFF) // UTF-16 big endian              {                  e = SupportedEncoding.UTF16BE;                  preserve = 2;              }              else if (b1 == 0x00 && b2 == '<') // UTF-16 big endian' no BOM              {                  e = SupportedEncoding.UTF16BE;                    if (notOutOfBand && (b3 != 0x00 || b4 != '?'))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == '<' && b2 == 0x00) // UTF-16 little endian' no BOM              {                  e = SupportedEncoding.UTF16LE;                    if (notOutOfBand && (b3 != '?' || b4 != 0x00))                      throw new XmlException(SR.XmlDeclMissing);                  preserve = 4;              }              else if (b1 == 0xEF && b2 == 0xBB) // UTF8 with BOM              {                  // Encoding error                  if (notOutOfBand && b3 != 0xBF)                      throw new XmlException(SR.XmlBadBOM);                  preserve = 1;              }              else  // Assume UTF8              {                  preserve = 4;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,EnsureByteBuffer,The following statement contains a magic number: _bytes = new byte[BufferLength * 4];
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CheckUTF8DeclarationEncoding,The following statement contains a magic number: for (i = offset + 2; i < max; i++)  // Skip the "<?" so we don't get caught by the first "?"              {                  if (quot != 0)                  {                      if (buffer[i] == quot)                      {                          quot = 0;                      }                      continue;                  }                    if (buffer[i] == (byte)'\'' || buffer[i] == (byte)'"')                  {                      quot = buffer[i];                  }                  else if (buffer[i] == (byte)'=')                  {                      if (eq == 1)                      {                          encEq = i;                          break;                      }                      eq++;                  }                  else if (buffer[i] == (byte)'?')  // Not legal character in a decl before second "="                  {                      break;                  }              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CheckUTF8DeclarationEncoding,The following statement contains a magic number: if (encEq < 28) // Earliest second "=" can appear                  throw new XmlException(SR.XmlMalformedDecl);
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ProcessBuffer,The following statement contains a magic number: if (count < 4)                  throw new XmlException(SR.UnexpectedEndOfFile);
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ProcessBuffer,The following statement contains a magic number: try              {                  int preserve;                  ArraySegment<byte> seg;                    SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                  SupportedEncoding declEnc = ReadBOMEncoding(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]' encoding == null' out preserve);                  if (expectedEnc != SupportedEncoding.None && expectedEnc != declEnc)                      ThrowExpectedEncodingMismatch(expectedEnc' declEnc);                    offset += 4 - preserve;                  count -= 4 - preserve;                    // Fastpath: UTF-8                  char[] chars;                  byte[] bytes;                  Encoding localEnc;                  if (declEnc == SupportedEncoding.UTF8)                  {                      // Fastpath: No declaration                      if (buffer[offset + 1] != '?' || buffer[offset] != '<')                      {                          seg = new ArraySegment<byte>(buffer' offset' count);                          return seg;                      }                        CheckUTF8DeclarationEncoding(buffer' offset' count' declEnc' expectedEnc);                      seg = new ArraySegment<byte>(buffer' offset' count);                      return seg;                  }                    // Convert to UTF-8                  localEnc = GetSafeEncoding(declEnc);                  int inputCount = Math.Min(count' BufferLength * 2);                  chars = new char[localEnc.GetMaxCharCount(inputCount)];                  int ccount = localEnc.GetChars(buffer' offset' inputCount' chars' 0);                  bytes = new byte[s_validatingUTF8.GetMaxByteCount(ccount)];                  int bcount = s_validatingUTF8.GetBytes(chars' 0' ccount' bytes' 0);                    // Check for declaration                  if (bytes[1] == '?' && bytes[0] == '<')                  {                      CheckUTF8DeclarationEncoding(bytes' 0' bcount' declEnc' expectedEnc);                  }                  else                  {                      // Declaration required if no out-of-band encoding                      if (expectedEnc == SupportedEncoding.None)                          throw new XmlException(SR.XmlDeclarationRequired);                  }                    seg = new ArraySegment<byte>(s_validatingUTF8.GetBytes(GetEncoding(declEnc).GetChars(buffer' offset' count)));                  return seg;              }              catch (DecoderFallbackException e)              {                  throw new XmlException(SR.XmlInvalidBytes' e);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ProcessBuffer,The following statement contains a magic number: try              {                  int preserve;                  ArraySegment<byte> seg;                    SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                  SupportedEncoding declEnc = ReadBOMEncoding(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]' encoding == null' out preserve);                  if (expectedEnc != SupportedEncoding.None && expectedEnc != declEnc)                      ThrowExpectedEncodingMismatch(expectedEnc' declEnc);                    offset += 4 - preserve;                  count -= 4 - preserve;                    // Fastpath: UTF-8                  char[] chars;                  byte[] bytes;                  Encoding localEnc;                  if (declEnc == SupportedEncoding.UTF8)                  {                      // Fastpath: No declaration                      if (buffer[offset + 1] != '?' || buffer[offset] != '<')                      {                          seg = new ArraySegment<byte>(buffer' offset' count);                          return seg;                      }                        CheckUTF8DeclarationEncoding(buffer' offset' count' declEnc' expectedEnc);                      seg = new ArraySegment<byte>(buffer' offset' count);                      return seg;                  }                    // Convert to UTF-8                  localEnc = GetSafeEncoding(declEnc);                  int inputCount = Math.Min(count' BufferLength * 2);                  chars = new char[localEnc.GetMaxCharCount(inputCount)];                  int ccount = localEnc.GetChars(buffer' offset' inputCount' chars' 0);                  bytes = new byte[s_validatingUTF8.GetMaxByteCount(ccount)];                  int bcount = s_validatingUTF8.GetBytes(chars' 0' ccount' bytes' 0);                    // Check for declaration                  if (bytes[1] == '?' && bytes[0] == '<')                  {                      CheckUTF8DeclarationEncoding(bytes' 0' bcount' declEnc' expectedEnc);                  }                  else                  {                      // Declaration required if no out-of-band encoding                      if (expectedEnc == SupportedEncoding.None)                          throw new XmlException(SR.XmlDeclarationRequired);                  }                    seg = new ArraySegment<byte>(s_validatingUTF8.GetBytes(GetEncoding(declEnc).GetChars(buffer' offset' count)));                  return seg;              }              catch (DecoderFallbackException e)              {                  throw new XmlException(SR.XmlInvalidBytes' e);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ProcessBuffer,The following statement contains a magic number: try              {                  int preserve;                  ArraySegment<byte> seg;                    SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                  SupportedEncoding declEnc = ReadBOMEncoding(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]' encoding == null' out preserve);                  if (expectedEnc != SupportedEncoding.None && expectedEnc != declEnc)                      ThrowExpectedEncodingMismatch(expectedEnc' declEnc);                    offset += 4 - preserve;                  count -= 4 - preserve;                    // Fastpath: UTF-8                  char[] chars;                  byte[] bytes;                  Encoding localEnc;                  if (declEnc == SupportedEncoding.UTF8)                  {                      // Fastpath: No declaration                      if (buffer[offset + 1] != '?' || buffer[offset] != '<')                      {                          seg = new ArraySegment<byte>(buffer' offset' count);                          return seg;                      }                        CheckUTF8DeclarationEncoding(buffer' offset' count' declEnc' expectedEnc);                      seg = new ArraySegment<byte>(buffer' offset' count);                      return seg;                  }                    // Convert to UTF-8                  localEnc = GetSafeEncoding(declEnc);                  int inputCount = Math.Min(count' BufferLength * 2);                  chars = new char[localEnc.GetMaxCharCount(inputCount)];                  int ccount = localEnc.GetChars(buffer' offset' inputCount' chars' 0);                  bytes = new byte[s_validatingUTF8.GetMaxByteCount(ccount)];                  int bcount = s_validatingUTF8.GetBytes(chars' 0' ccount' bytes' 0);                    // Check for declaration                  if (bytes[1] == '?' && bytes[0] == '<')                  {                      CheckUTF8DeclarationEncoding(bytes' 0' bcount' declEnc' expectedEnc);                  }                  else                  {                      // Declaration required if no out-of-band encoding                      if (expectedEnc == SupportedEncoding.None)                          throw new XmlException(SR.XmlDeclarationRequired);                  }                    seg = new ArraySegment<byte>(s_validatingUTF8.GetBytes(GetEncoding(declEnc).GetChars(buffer' offset' count)));                  return seg;              }              catch (DecoderFallbackException e)              {                  throw new XmlException(SR.XmlInvalidBytes' e);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ProcessBuffer,The following statement contains a magic number: try              {                  int preserve;                  ArraySegment<byte> seg;                    SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                  SupportedEncoding declEnc = ReadBOMEncoding(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]' encoding == null' out preserve);                  if (expectedEnc != SupportedEncoding.None && expectedEnc != declEnc)                      ThrowExpectedEncodingMismatch(expectedEnc' declEnc);                    offset += 4 - preserve;                  count -= 4 - preserve;                    // Fastpath: UTF-8                  char[] chars;                  byte[] bytes;                  Encoding localEnc;                  if (declEnc == SupportedEncoding.UTF8)                  {                      // Fastpath: No declaration                      if (buffer[offset + 1] != '?' || buffer[offset] != '<')                      {                          seg = new ArraySegment<byte>(buffer' offset' count);                          return seg;                      }                        CheckUTF8DeclarationEncoding(buffer' offset' count' declEnc' expectedEnc);                      seg = new ArraySegment<byte>(buffer' offset' count);                      return seg;                  }                    // Convert to UTF-8                  localEnc = GetSafeEncoding(declEnc);                  int inputCount = Math.Min(count' BufferLength * 2);                  chars = new char[localEnc.GetMaxCharCount(inputCount)];                  int ccount = localEnc.GetChars(buffer' offset' inputCount' chars' 0);                  bytes = new byte[s_validatingUTF8.GetMaxByteCount(ccount)];                  int bcount = s_validatingUTF8.GetBytes(chars' 0' ccount' bytes' 0);                    // Check for declaration                  if (bytes[1] == '?' && bytes[0] == '<')                  {                      CheckUTF8DeclarationEncoding(bytes' 0' bcount' declEnc' expectedEnc);                  }                  else                  {                      // Declaration required if no out-of-band encoding                      if (expectedEnc == SupportedEncoding.None)                          throw new XmlException(SR.XmlDeclarationRequired);                  }                    seg = new ArraySegment<byte>(s_validatingUTF8.GetBytes(GetEncoding(declEnc).GetChars(buffer' offset' count)));                  return seg;              }              catch (DecoderFallbackException e)              {                  throw new XmlException(SR.XmlInvalidBytes' e);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ProcessBuffer,The following statement contains a magic number: try              {                  int preserve;                  ArraySegment<byte> seg;                    SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                  SupportedEncoding declEnc = ReadBOMEncoding(buffer[offset]' buffer[offset + 1]' buffer[offset + 2]' buffer[offset + 3]' encoding == null' out preserve);                  if (expectedEnc != SupportedEncoding.None && expectedEnc != declEnc)                      ThrowExpectedEncodingMismatch(expectedEnc' declEnc);                    offset += 4 - preserve;                  count -= 4 - preserve;                    // Fastpath: UTF-8                  char[] chars;                  byte[] bytes;                  Encoding localEnc;                  if (declEnc == SupportedEncoding.UTF8)                  {                      // Fastpath: No declaration                      if (buffer[offset + 1] != '?' || buffer[offset] != '<')                      {                          seg = new ArraySegment<byte>(buffer' offset' count);                          return seg;                      }                        CheckUTF8DeclarationEncoding(buffer' offset' count' declEnc' expectedEnc);                      seg = new ArraySegment<byte>(buffer' offset' count);                      return seg;                  }                    // Convert to UTF-8                  localEnc = GetSafeEncoding(declEnc);                  int inputCount = Math.Min(count' BufferLength * 2);                  chars = new char[localEnc.GetMaxCharCount(inputCount)];                  int ccount = localEnc.GetChars(buffer' offset' inputCount' chars' 0);                  bytes = new byte[s_validatingUTF8.GetMaxByteCount(ccount)];                  int bcount = s_validatingUTF8.GetBytes(chars' 0' ccount' bytes' 0);                    // Check for declaration                  if (bytes[1] == '?' && bytes[0] == '<')                  {                      CheckUTF8DeclarationEncoding(bytes' 0' bcount' declEnc' expectedEnc);                  }                  else                  {                      // Declaration required if no out-of-band encoding                      if (expectedEnc == SupportedEncoding.None)                          throw new XmlException(SR.XmlDeclarationRequired);                  }                    seg = new ArraySegment<byte>(s_validatingUTF8.GetBytes(GetEncoding(declEnc).GetChars(buffer' offset' count)));                  return seg;              }              catch (DecoderFallbackException e)              {                  throw new XmlException(SR.XmlInvalidBytes' e);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,Read,The following statement contains a magic number: try              {                  if (_byteCount == 0)                  {                      if (_encodingCode == SupportedEncoding.UTF8)                          return _stream.Read(buffer' offset' count);                        // No more bytes than can be turned into characters                      _byteOffset = 0;                      _byteCount = _stream.Read(_bytes' _byteCount' (_chars.Length - 1) * 2);                        // Check for end of stream                      if (_byteCount == 0)                          return 0;                        // Fix up incomplete chars                      CleanupCharBreak();                        // Change encoding                      int charCount = _encoding.GetChars(_bytes' 0' _byteCount' _chars' 0);                      _byteCount = Encoding.UTF8.GetBytes(_chars' 0' charCount' _bytes' 0);                  }                    // Give them bytes                  if (_byteCount < count)                      count = _byteCount;                  Buffer.BlockCopy(_bytes' _byteOffset' buffer' offset' count);                  _byteOffset += count;                  _byteCount -= count;                  return count;              }              catch (DecoderFallbackException ex)              {                  throw new XmlException(SR.XmlInvalidBytes' ex);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if ((_byteCount % 2) != 0)              {                  int b = _stream.ReadByte();                  if (b < 0)                      throw new XmlException(SR.UnexpectedEndOfFile);                    _bytes[max++] = (byte)b;                  _byteCount++;              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if ((w & 0xDC00) != 0xDC00 && w >= 0xD800 && w <= 0xDBFF)  // First 16-bit number of surrogate pair              {                  int b1 = _stream.ReadByte();                  int b2 = _stream.ReadByte();                  if (b2 < 0)                      throw new XmlException(SR.UnexpectedEndOfFile);                  _bytes[max++] = (byte)b1;                  _bytes[max++] = (byte)b2;                  _byteCount += 2;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,SetOutput,The following statement contains a magic number: if (_xmlnsAttributes == null)              {                  _xmlnsAttributeCount = 0;                  _xmlnsOffset = 0;                  WriteXmlnsAttribute("xml"' "http://www.w3.org/XML/1998/namespace");                  WriteXmlnsAttribute("xmlns"' xmlnsNamespace);                  WriteXmlnsAttribute(string.Empty' string.Empty);                  _xmlnsStartOffset = _xmlnsOffset;                  for (int i = 0; i < 3; i++)                  {                      _xmlnsAttributes[i].referred = true;                  }              }              else              {                  _xmlnsAttributeCount = 3;                  _xmlnsOffset = _xmlnsStartOffset;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,SetOutput,The following statement contains a magic number: if (_xmlnsAttributes == null)              {                  _xmlnsAttributeCount = 0;                  _xmlnsOffset = 0;                  WriteXmlnsAttribute("xml"' "http://www.w3.org/XML/1998/namespace");                  WriteXmlnsAttribute("xmlns"' xmlnsNamespace);                  WriteXmlnsAttribute(string.Empty' string.Empty);                  _xmlnsStartOffset = _xmlnsOffset;                  for (int i = 0; i < 3; i++)                  {                      _xmlnsAttributes[i].referred = true;                  }              }              else              {                  _xmlnsAttributeCount = 3;                  _xmlnsOffset = _xmlnsStartOffset;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Close,The following statement contains a magic number: if (_elementStream != null && _elementStream.Length > 512)                  _elementStream = null;
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Close,The following statement contains a magic number: if (_scopes != null && _scopes.Length > 16)                  _scopes = null;
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Close,The following statement contains a magic number: if (_attributes != null && _attributes.Length > 16)                  _attributes = null;
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,Close,The following statement contains a magic number: if (_xmlnsBuffer != null && _xmlnsBuffer.Length > 1024)              {                  _xmlnsAttributes = null;                  _xmlnsBuffer = null;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,StartElement,The following statement contains a magic number: if (_scopes == null)              {                  _scopes = new Scope[4];              }              else if (_depth == _scopes.Length)              {                  Scope[] newScopes = new Scope[_depth * 2];                  Array.Copy(_scopes' newScopes' _depth);                  _scopes = newScopes;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,StartElement,The following statement contains a magic number: if (_scopes == null)              {                  _scopes = new Scope[4];              }              else if (_depth == _scopes.Length)              {                  Scope[] newScopes = new Scope[_depth * 2];                  Array.Copy(_scopes' newScopes' _depth);                  _scopes = newScopes;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,EnsureXmlnsBuffer,The following statement contains a magic number: if (_xmlnsBuffer == null)              {                  _xmlnsBuffer = new byte[Math.Max(byteCount' 128)];              }              else if (_xmlnsOffset + byteCount > _xmlnsBuffer.Length)              {                  byte[] newBuffer = new byte[Math.Max(_xmlnsOffset + byteCount' _xmlnsBuffer.Length * 2)];                  Buffer.BlockCopy(_xmlnsBuffer' 0' newBuffer' 0' _xmlnsOffset);                  _xmlnsBuffer = newBuffer;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,EnsureXmlnsBuffer,The following statement contains a magic number: if (_xmlnsBuffer == null)              {                  _xmlnsBuffer = new byte[Math.Max(byteCount' 128)];              }              else if (_xmlnsOffset + byteCount > _xmlnsBuffer.Length)              {                  byte[] newBuffer = new byte[Math.Max(_xmlnsOffset + byteCount' _xmlnsBuffer.Length * 2)];                  Buffer.BlockCopy(_xmlnsBuffer' 0' newBuffer' 0' _xmlnsOffset);                  _xmlnsBuffer = newBuffer;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,SortAttributes,The following statement contains a magic number: if (_attributeCount < 16)              {                  for (int i = 0; i < _attributeCount - 1; i++)                  {                      int attributeMin = i;                      for (int j = i + 1; j < _attributeCount; j++)                      {                          if (Compare(ref _attributes[j]' ref _attributes[attributeMin]) < 0)                          {                              attributeMin = j;                          }                      }                        if (attributeMin != i)                      {                          Attribute temp = _attributes[i];                          _attributes[i] = _attributes[attributeMin];                          _attributes[attributeMin] = temp;                      }                  }              }              else              {                  new AttributeSorter(this).Sort();              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,AddAttribute,The following statement contains a magic number: if (_attributes == null)              {                  _attributes = new Attribute[4];              }              else if (_attributeCount == _attributes.Length)              {                  Attribute[] newAttributes = new Attribute[_attributeCount * 2];                  Array.Copy(_attributes' newAttributes' _attributeCount);                  _attributes = newAttributes;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,AddAttribute,The following statement contains a magic number: if (_attributes == null)              {                  _attributes = new Attribute[4];              }              else if (_attributeCount == _attributes.Length)              {                  Attribute[] newAttributes = new Attribute[_attributeCount * 2];                  Array.Copy(_attributes' newAttributes' _attributeCount);                  _attributes = newAttributes;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,AddXmlnsAttribute,The following statement contains a magic number: if (_xmlnsAttributes == null)              {                  _xmlnsAttributes = new XmlnsAttribute[4];              }              else if (_xmlnsAttributes.Length == _xmlnsAttributeCount)              {                  XmlnsAttribute[] newXmlnsAttributes = new XmlnsAttribute[_xmlnsAttributeCount * 2];                  Array.Copy(_xmlnsAttributes' newXmlnsAttributes' _xmlnsAttributeCount);                  _xmlnsAttributes = newXmlnsAttributes;              }
Magic Number,System.Xml,XmlCanonicalWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlCanonicalWriter.cs,AddXmlnsAttribute,The following statement contains a magic number: if (_xmlnsAttributes == null)              {                  _xmlnsAttributes = new XmlnsAttribute[4];              }              else if (_xmlnsAttributes.Length == _xmlnsAttributeCount)              {                  XmlnsAttribute[] newXmlnsAttributes = new XmlnsAttribute[_xmlnsAttributeCount * 2];                  Array.Copy(_xmlnsAttributes' newXmlnsAttributes' _xmlnsAttributeCount);                  _xmlnsAttributes = newXmlnsAttributes;              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: if (_base64Chars == null)                  _base64Chars = new byte[512];
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(_base64Chars.Length / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  encoding.GetChars(buffer' offset' byteCount' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' charCount);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' charCount);                  }                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(_base64Chars.Length / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  encoding.GetChars(buffer' offset' byteCount' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' charCount);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' charCount);                  }                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(_base64Chars.Length / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  encoding.GetChars(buffer' offset' byteCount' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' charCount);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' charCount);                  }                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(_base64Chars.Length / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  encoding.GetChars(buffer' offset' byteCount' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' charCount);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' charCount);                  }                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(_base64Chars.Length / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  encoding.GetChars(buffer' offset' byteCount' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' charCount);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' charCount);                  }                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: while (count >= 3)              {                  int byteCount = Math.Min(_base64Chars.Length / 4 * 3' count - count % 3);                  int charCount = byteCount / 3 * 4;                  encoding.GetChars(buffer' offset' byteCount' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' charCount);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' charCount);                  }                  offset += byteCount;                  count -= byteCount;              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: if (count > 0)              {                  encoding.GetChars(buffer' offset' count' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' 4);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' 4);                  }              }
Magic Number,System.Xml,XmlSigningNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlSigningNodeWriter.cs,WriteBase64Text,The following statement contains a magic number: if (count > 0)              {                  encoding.GetChars(buffer' offset' count' _base64Chars' 0);                  _signingWriter.WriteText(_base64Chars' 0' 4);                  if (_text)                  {                      _writer.WriteText(_base64Chars' 0' 4);                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxByteCount,The following statement contains a magic number: if ((charCount % 4) != 0)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' charCount.ToString(NumberFormatInfo.CurrentInfo))));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxByteCount,The following statement contains a magic number: return charCount / 4 * 3;
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxByteCount,The following statement contains a magic number: return charCount / 4 * 3;
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,IsValidLeadBytes,The following statement contains a magic number: return ((v1 | v2) < 64) && ((v3 | v4) != 0xFF);
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,IsValidTailBytes,The following statement contains a magic number: return !(v3 == 64 && v4 != 64);
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,IsValidTailBytes,The following statement contains a magic number: return !(v3 == 64 && v4 != 64);
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: if ((count % 4) != 0)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' count.ToString(NumberFormatInfo.CurrentInfo))));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetByteCount,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[index])                  {                      int totalCount = 0;                      char* pch = _chars;                      char* pchMax = _chars + count;                      while (pch < pchMax)                      {                          DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                          char pch0 = pch[0];                          char pch1 = pch[1];                          char pch2 = pch[2];                          char pch3 = pch[3];                            if ((pch0 | pch1 | pch2 | pch3) >= 128)                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            // xx765432 xx107654 xx321076 xx543210                          // 76543210 76543210 76543210                          int v1 = _char2val[pch0];                          int v2 = _char2val[pch1];                          int v3 = _char2val[pch2];                          int v4 = _char2val[pch3];                            if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                              throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' index + (int)(pch - _chars))));                            int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                          totalCount += byteCount;                          pch += 4;                      }                      return totalCount;                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: if ((charCount % 4) != 0)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' charCount.ToString(NumberFormatInfo.CurrentInfo))));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (char* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          char* pch = _chars;                          char* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              char pch0 = pch[0];                              char pch1 = pch[1];                              char pch2 = pch[2];                              char pch3 = pch[3];                                if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' new string(pch' 0' 4)' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = (byte)((v2 << 4) | ((v3 >> 2) & 0x0F));                                  if (byteCount > 2)                                  {                                      pb[2] = (byte)((v3 << 6) | ((v4 >> 0) & 0x3F));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: if ((charCount % 4) != 0)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Length' charCount.ToString(NumberFormatInfo.CurrentInfo))));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetBytes,The following statement contains a magic number: fixed (byte* _char2val = &s_char2val[0])              {                  fixed (byte* _chars = &chars[charIndex])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          byte* pch = _chars;                          byte* pchMax = _chars + charCount;                          byte* pb = _bytes;                          byte* pbMax = _bytes + bytes.Length - byteIndex;                          while (pch < pchMax)                          {                              DiagnosticUtility.DebugAssert(pch + 4 <= pchMax' "");                              byte pch0 = pch[0];                              byte pch1 = pch[1];                              byte pch2 = pch[2];                              byte pch3 = pch[3];                              if ((pch0 | pch1 | pch2 | pch3) >= 128)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                              // xx765432 xx107654 xx321076 xx543210                              // 76543210 76543210 76543210                                int v1 = _char2val[pch0];                              int v2 = _char2val[pch1];                              int v3 = _char2val[pch2];                              int v4 = _char2val[pch3];                                if (!IsValidLeadBytes(v1' v2' v3' v4) || !IsValidTailBytes(v3' v4))                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new FormatException(SR.Format(SR.XmlInvalidBase64Sequence' "?"' charIndex + (int)(pch - _chars))));                                int byteCount = (v4 != 64 ? 3 : (v3 != 64 ? 2 : 1));                              if (pb + byteCount > pbMax)                                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentException(SR.Format(SR.XmlArrayTooSmall)' nameof(bytes)));                                pb[0] = (byte)((v1 << 2) | ((v2 >> 4) & 0x03));                              if (byteCount > 1)                              {                                  pb[1] = unchecked((byte)((v2 << 4) | ((v3 >> 2) & 0x0F)));                                  if (byteCount > 2)                                  {                                      pb[2] = unchecked((byte)((v3 << 6) | ((v4 >> 0) & 0x3F)));                                  }                              }                              pb += byteCount;                              pch += 4;                          }                          return (int)(pb - _bytes);                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 4 * 3 - 2)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 4 * 3 - 2)));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 4 * 3 - 2)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 4 * 3 - 2)));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 4 * 3 - 2)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 4 * 3 - 2)));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 4 * 3 - 2)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 4 * 3 - 2)));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 4 * 3 - 2)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 4 * 3 - 2)));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 4 * 3 - 2)                  throw System.Runtime.Serialization.DiagnosticUtility.ExceptionUtility.ThrowHelperError(new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 4 * 3 - 2)));
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: return ((byteCount + 2) / 3) * 4;
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: return ((byteCount + 2) / 3) * 4;
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetMaxCharCount,The following statement contains a magic number: return ((byteCount + 2) / 3) * 4;
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              char* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2char[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4)];                                  pch[2] = '=';                                  pch[3] = '=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2char[(pb[0] >> 2)];                                  pch[1] = _val2char[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2char[((pb[1] & 0x0F) << 2)];                                  pch[3] = '=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,Base64Encoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\Base64Encoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (byte* _val2byte = &s_val2byte[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (byte* _chars = &chars[charIndex])                          {                              byte* pb = _bytes;                              byte* pbMax = pb + byteCount - 3;                              byte* pch = _chars;                                // Convert chunks of 3 bytes to 4 chars                              while (pb <= pbMax)                              {                                  // 76543210 76543210 76543210                                  // xx765432 xx107654 xx321076 xx543210                                    // Inspect the code carefully before you change this                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2) | (pb[2] >> 6)];                                  pch[3] = _val2byte[pb[2] & 0x3F];                                    pb += 3;                                  pch += 4;                              }                                // Handle 1 or 2 trailing bytes                              if (pb - pbMax == 2)                              {                                  // 1 trailing byte                                  // 76543210 xxxxxxxx xxxxxxxx                                  // xx765432 xx10xxxx xxxxxxxx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4)];                                  pch[2] = (byte)'=';                                  pch[3] = (byte)'=';                              }                              else if (pb - pbMax == 1)                              {                                  // 2 trailing bytes                                  // 76543210 76543210 xxxxxxxx                                  // xx765432 xx107654 xx3210xx xxxxxxxx                                  pch[0] = _val2byte[(pb[0] >> 2)];                                  pch[1] = _val2byte[((pb[0] & 0x03) << 4) | (pb[1] >> 4)];                                  pch[2] = _val2byte[((pb[1] & 0x0F) << 2)];                                  pch[3] = (byte)'=';                              }                              else                              {                                  // 0 trailing bytes                                  DiagnosticUtility.DebugAssert(pb - pbMax == 3' "");                              }                          }                      }                  }              }
Magic Number,System.Text,SurrogateChar,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\SurrogateChar.cs,SurrogateChar,The following statement contains a magic number: const int mask = ((1 << 10) - 1);
Magic Number,System.Text,SurrogateChar,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\SurrogateChar.cs,SurrogateChar,The following statement contains a magic number: _highChar = (char)((((ch - MinValue) >> 10) & mask) + surHighMin);
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetMaxByteCount,The following statement contains a magic number: if ((charCount % 2) != 0)                  throw new FormatException(SR.Format(SR.XmlInvalidBinHexLength' charCount.ToString(NumberFormatInfo.CurrentInfo)));
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetMaxByteCount,The following statement contains a magic number: return charCount / 2;
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The following statement contains a magic number: if (charCount > 0)              {                  fixed (byte* _char2val = &s_char2val[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              char* pch = _chars;                              char* pchMax = _chars + charCount;                              byte* pb = _bytes;                              while (pch < pchMax)                              {                                  char pch0 = pch[0];                                  char pch1 = pch[1];                                  if ((pch0 | pch1) >= 128)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  byte d1 = _char2val[pch0];                                  byte d2 = _char2val[pch1];                                  if ((d1 | d2) == 0xFF)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  pb[0] = (byte)((d1 << 4) + d2);                                  pch += 2;                                  pb++;                              }                          }                      }                  }              }
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The following statement contains a magic number: if (charCount > 0)              {                  fixed (byte* _char2val = &s_char2val[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              char* pch = _chars;                              char* pchMax = _chars + charCount;                              byte* pb = _bytes;                              while (pch < pchMax)                              {                                  char pch0 = pch[0];                                  char pch1 = pch[1];                                  if ((pch0 | pch1) >= 128)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  byte d1 = _char2val[pch0];                                  byte d2 = _char2val[pch1];                                  if ((d1 | d2) == 0xFF)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  pb[0] = (byte)((d1 << 4) + d2);                                  pch += 2;                                  pb++;                              }                          }                      }                  }              }
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The following statement contains a magic number: if (charCount > 0)              {                  fixed (byte* _char2val = &s_char2val[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              char* pch = _chars;                              char* pchMax = _chars + charCount;                              byte* pb = _bytes;                              while (pch < pchMax)                              {                                  char pch0 = pch[0];                                  char pch1 = pch[1];                                  if ((pch0 | pch1) >= 128)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  byte d1 = _char2val[pch0];                                  byte d2 = _char2val[pch1];                                  if ((d1 | d2) == 0xFF)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  pb[0] = (byte)((d1 << 4) + d2);                                  pch += 2;                                  pb++;                              }                          }                      }                  }              }
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The following statement contains a magic number: if (charCount > 0)              {                  fixed (byte* _char2val = &s_char2val[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              char* pch = _chars;                              char* pchMax = _chars + charCount;                              byte* pb = _bytes;                              while (pch < pchMax)                              {                                  char pch0 = pch[0];                                  char pch1 = pch[1];                                  if ((pch0 | pch1) >= 128)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  byte d1 = _char2val[pch0];                                  byte d2 = _char2val[pch1];                                  if ((d1 | d2) == 0xFF)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  pb[0] = (byte)((d1 << 4) + d2);                                  pch += 2;                                  pb++;                              }                          }                      }                  }              }
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetBytes,The following statement contains a magic number: if (charCount > 0)              {                  fixed (byte* _char2val = &s_char2val[0])                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              char* pch = _chars;                              char* pchMax = _chars + charCount;                              byte* pb = _bytes;                              while (pch < pchMax)                              {                                  char pch0 = pch[0];                                  char pch1 = pch[1];                                  if ((pch0 | pch1) >= 128)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  byte d1 = _char2val[pch0];                                  byte d2 = _char2val[pch1];                                  if ((d1 | d2) == 0xFF)                                      throw new FormatException(SR.Format(SR.XmlInvalidBinHexSequence' new string(pch' 0' 2)' charIndex + (int)(pch - _chars)));                                  pb[0] = (byte)((d1 << 4) + d2);                                  pch += 2;                                  pb++;                              }                          }                      }                  }              }
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 2)                  throw new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 2));
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetMaxCharCount,The following statement contains a magic number: if (byteCount < 0 || byteCount > int.MaxValue / 2)                  throw new ArgumentOutOfRangeException(nameof(byteCount)' SR.Format(SR.ValueMustBeInRange' 0' int.MaxValue / 2));
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetMaxCharCount,The following statement contains a magic number: return byteCount * 2;
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              char* pch = _chars;                              byte* pb = _bytes;                              byte* pbMax = _bytes + byteCount;                              while (pb < pbMax)                              {                                  pch[0] = _val2char[pb[0] >> 4];                                  pch[1] = _val2char[pb[0] & 0x0F];                                  pb++;                                  pch += 2;                              }                          }                      }                  }              }
Magic Number,System.Text,BinHexEncoding,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Text\BinHexEncoding.cs,GetChars,The following statement contains a magic number: if (byteCount > 0)              {                  fixed (char* _val2char = Val2Char)                  {                      fixed (byte* _bytes = &bytes[byteIndex])                      {                          fixed (char* _chars = &chars[charIndex])                          {                              char* pch = _chars;                              byte* pb = _bytes;                              byte* pbMax = _bytes + byteCount;                              while (pb < pbMax)                              {                                  pch[0] = _val2char[pb[0] >> 4];                                  pch[1] = _val2char[pb[0] & 0x0F];                                  pb++;                                  pch += 2;                              }                          }                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,JsonDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonDataContract.cs,GetId,The following statement contains a magic number: lock (s_cacheLock)                  {                      IntRef id;                      s_typeHandleRef.Value = typeHandle;                      if (!s_typeToIDCache.TryGetValue(s_typeHandleRef' out id))                      {                          int value = s_dataContractID++;                          if (value >= s_dataContractCache.Length)                          {                              int newSize = (value < Int32.MaxValue / 2) ? value * 2 : Int32.MaxValue;                              if (newSize <= value)                              {                                  Fx.Assert("DataContract cache overflow");                                  throw new SerializationException(SR.DataContractCacheOverflow);                              }                              Array.Resize<JsonDataContract>(ref s_dataContractCache' newSize);                          }                          id = new IntRef(value);                          try                          {                              s_typeToIDCache.Add(new TypeHandleRef(typeHandle)' id);                          }                          catch (Exception ex)                          {                              if (DiagnosticUtility.IsFatal(ex))                              {                                  throw;                              }                              throw DiagnosticUtility.ExceptionUtility.ThrowHelperFatal(ex.Message' ex);                          }                      }                      return id.Value;                  }
Magic Number,System.Runtime.Serialization.Json,JsonDataContractCriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonDataContract.cs,GetId,The following statement contains a magic number: lock (s_cacheLock)                  {                      IntRef id;                      s_typeHandleRef.Value = typeHandle;                      if (!s_typeToIDCache.TryGetValue(s_typeHandleRef' out id))                      {                          int value = s_dataContractID++;                          if (value >= s_dataContractCache.Length)                          {                              int newSize = (value < Int32.MaxValue / 2) ? value * 2 : Int32.MaxValue;                              if (newSize <= value)                              {                                  Fx.Assert("DataContract cache overflow");                                  throw new SerializationException(SR.DataContractCacheOverflow);                              }                              Array.Resize<JsonDataContract>(ref s_dataContractCache' newSize);                          }                          id = new IntRef(value);                          try                          {                              s_typeToIDCache.Add(new TypeHandleRef(typeHandle)' id);                          }                          catch (Exception ex)                          {                              if (DiagnosticUtility.IsFatal(ex))                              {                                  throw;                              }                              throw DiagnosticUtility.ExceptionUtility.ThrowHelperFatal(ex.Message' ex);                          }                      }                      return id.Value;                  }
Magic Number,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateClassWriter,The following statement contains a magic number: _memberNamesArg = _ilg.GetArg(4);
Magic Number,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,InitArgs,The following statement contains a magic number: _contextArg = _ilg.GetArg(2);
Magic Number,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,InitArgs,The following statement contains a magic number: _dataContractArg = _ilg.GetArg(3);
Magic Number,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,GenerateCollectionReaderHelper,The following statement contains a magic number: _collectionContractArg = _ilg.GetArg(4);
Magic Number,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,InitArgs,The following statement contains a magic number: _emptyDictionaryStringArg = _ilg.GetArg(2);
Magic Number,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,InitArgs,The following statement contains a magic number: _memberNamesArg = _ilg.GetArg(3);
Magic Number,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadCollection,The following statement contains a magic number: if (isArray)                  {                      growingCollection = _ilg.DeclareLocal(type' "growingCollection");                      _ilg.NewArray(itemType' 32);                      _ilg.Stloc(growingCollection);                  }
Magic Number,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ParseJsonDateInDefaultFormat,The following statement contains a magic number: string ticksvalue = dateTimeValue.Substring(6' dateTimeValue.Length - 8);
Magic Number,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ParseJsonDateInDefaultFormat,The following statement contains a magic number: string ticksvalue = dateTimeValue.Substring(6' dateTimeValue.Length - 8);
Magic Number,System.Runtime.Serialization.Json,JsonReaderDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonReaderDelegator.cs,ParseJsonDateInDefaultFormat,The following statement contains a magic number: long ticks = millisecondsSinceUnixEpoch * 10000 + JsonGlobals.unixEpochTicks;
Magic Number,System.Runtime.Serialization.Json,JsonWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonWriterDelegator.cs,WriteDateTimeInDefaultFormat,The following statement contains a magic number: writer.WriteValue((value.ToUniversalTime().Ticks - JsonGlobals.unixEpochTicks) / 10000);
Magic Number,System.Runtime.Serialization.Json,XmlObjectSerializerReadContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerReadContextComplexJson.cs,ReadAttributes,The following statement contains a magic number: if (xmlReader.MoveToAttribute(JsonGlobals.typeString) && xmlReader.Value == JsonGlobals.nullString)              {                  attributes.XsiNil = true;              }              else if (xmlReader.MoveToAttribute(JsonGlobals.serverTypeString))              {                  XmlQualifiedName qualifiedTypeName = JsonReaderDelegator.ParseQualifiedName(xmlReader.Value);                  attributes.XsiTypeName = qualifiedTypeName.Name;                    string serverTypeNamespace = qualifiedTypeName.Namespace;                    if (!string.IsNullOrEmpty(serverTypeNamespace))                  {                      switch (serverTypeNamespace[0])                      {                          case '#':                              serverTypeNamespace = string.Concat(Globals.DataContractXsdBaseNamespace' serverTypeNamespace.Substring(1));                              break;                          case '\\':                              if (serverTypeNamespace.Length >= 2)                              {                                  switch (serverTypeNamespace[1])                                  {                                      case '#':                                      case '\\':                                          serverTypeNamespace = serverTypeNamespace.Substring(1);                                          break;                                      default:                                          break;                                  }                              }                              break;                          default:                              break;                      }                  }                    attributes.XsiTypeNamespace = serverTypeNamespace;              }
Magic Number,System.Runtime.Serialization.Json,XmlObjectSerializerReadContextComplexJson,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlObjectSerializerReadContextComplexJson.cs,TrimNamespace,The following statement contains a magic number: if (!string.IsNullOrEmpty(serverTypeNamespace))              {                  switch (serverTypeNamespace[0])                  {                      case '#':                          serverTypeNamespace = string.Concat(Globals.DataContractXsdBaseNamespace' serverTypeNamespace.Substring(1));                          break;                      case '\\':                          if (serverTypeNamespace.Length >= 2)                          {                              switch (serverTypeNamespace[1])                              {                                  case '#':                                  case '\\':                                      serverTypeNamespace = serverTypeNamespace.Substring(1);                                      break;                                  default:                                      break;                              }                          }                          break;                      default:                          break;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following statement contains a magic number: if (_scopeDepth == 0)              {                  ReadNonExistentElementName(StringHandleConstStringType.Root);              }              else if (IsReadingComplexText)              {                  switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }              }              else if (IsReadingCollection)              {                  ReadNonExistentElementName(StringHandleConstStringType.Item);              }              else if (ch == JsonGlobals.EndCollectionByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();                  ExitJsonScope();              }              else if (ch == JsonGlobals.ObjectByte)              {                  BufferReader.SkipByte();                  SkipWhitespaceInBufferReader();                  ch = (byte)BufferReader.GetByte();                  if (ch == JsonGlobals.EndObjectByte)                  {                      BufferReader.SkipByte();                      SkipWhitespaceInBufferReader();                      if (TryGetByte(out ch))                      {                          if (ch == JsonGlobals.MemberSeparatorByte)                          {                              BufferReader.SkipByte();                          }                      }                      else                      {                          _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      }                      MoveToEndElement();                  }                  else                  {                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }              }              else if (ch == JsonGlobals.EndObjectByte)              {                  BufferReader.SkipByte();                  if (_expectingFirstElementInNonPrimitiveChild)                  {                      SkipWhitespaceInBufferReader();                      ch = BufferReader.GetByte();                      if ((ch == JsonGlobals.MemberSeparatorByte) ||                          (ch == JsonGlobals.EndObjectByte))                      {                          BufferReader.SkipByte();                      }                      else                      {                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                              (char)ch)));                      }                      _expectingFirstElementInNonPrimitiveChild = false;                  }                  MoveToEndElement();              }              else if (ch == JsonGlobals.MemberSeparatorByte)              {                  BufferReader.SkipByte();                  MoveToEndElement();              }              else if (ch == JsonGlobals.QuoteByte)              {                  if (_readServerTypeElement)                  {                      _readServerTypeElement = false;                      EnterJsonScope(JsonNodeType.Object);                      ParseStartElement();                  }                  else if (this.Node.NodeType == XmlNodeType.Element)                  {                      if (_expectingFirstElementInNonPrimitiveChild)                      {                          EnterJsonScope(JsonNodeType.Object);                          ParseStartElement();                      }                      else                      {                          BufferReader.SkipByte();                          ReadQuotedText(true); //  moveToText                       }                  }                  else if (this.Node.NodeType == XmlNodeType.EndElement)                  {                      EnterJsonScope(JsonNodeType.Element);                      ParseStartElement();                  }                  else                  {                      XmlExceptionHelper.ThrowXmlException(this'                          new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter'                          JsonGlobals.QuoteChar)));                  }              }              else if (ch == (byte)'f')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  if (buffer[offset + 1] != (byte)'a' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'s' ||                      buffer[offset + 4] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 5));                  }                  BufferReader.Advance(5);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "false"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 5);              }              else if (ch == (byte)'t')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'r' ||                      buffer[offset + 2] != (byte)'u' ||                      buffer[offset + 3] != (byte)'e')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                    if (TryGetByte(out ch))                  {                      if (!IsWhitespace(ch) && ch != JsonGlobals.MemberSeparatorByte && ch != JsonGlobals.EndObjectChar && ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "true"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  MoveToAtomicText().Value.SetValue(ValueHandleType.UTF8' offset' 4);              }              else if (ch == (byte)'n')              {                  int offset;                  byte[] buffer = BufferReader.GetBuffer(4' out offset);                  if (buffer[offset + 1] != (byte)'u' ||                      buffer[offset + 2] != (byte)'l' ||                      buffer[offset + 3] != (byte)'l')                  {                      XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4));                  }                  BufferReader.Advance(4);                  SkipWhitespaceInBufferReader();                    if (TryGetByte(out ch))                  {                      if (ch == JsonGlobals.MemberSeparatorByte || ch == JsonGlobals.EndObjectChar)                      {                          BufferReader.SkipByte();                      }                      else if (ch != JsonGlobals.EndCollectionByte)                      {                          XmlExceptionHelper.ThrowTokenExpected(this' "null"' Encoding.UTF8.GetString(buffer' offset' 4) + (char)ch);                      }                  }                  else                  {                      _charactersToSkipOnNextRead[0] = JsonGlobals.MemberSeparatorByte;                      _charactersToSkipOnNextRead[1] = JsonGlobals.EndObjectByte;                  }                  MoveToEndElement();              }              else if ((ch == (byte)'-') ||                  (((byte)'0' <= ch) && (ch <= (byte)'9')) ||                  (ch == (byte)'I') ||                  (ch == (byte)'N'))              {                  ReadNumericalText();              }              else              {                  XmlExceptionHelper.ThrowXmlException(this'                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & 0x80) == 0x80)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                  int originalLength = length;                  do                  {                      length--;                  } while (length > 0 && (buffer[offset + length] & 0xC0) != 0xC0);                  // Couldn't find the lead char                  if (length == 0)                  {                      return originalLength; // Invalid utf8 sequence - can't break                  }                  // Count how many bytes follow the lead char                  byte b = unchecked((byte)(buffer[offset + length] << 2));                  int byteCount = 2;                  while ((b & 0x80) == 0x80)                  {                      b = (byte)(b << 1);                      byteCount++;                      // There shouldn't be more than 3 bytes following the lead char                      if (byteCount > 4)                      {                          return originalLength; // Invalid utf8 sequence - can't break                      }                  }                  if (length + byteCount == originalLength)                  {                      return originalLength; // sequence fits exactly                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & 0x80) == 0x80)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                  int originalLength = length;                  do                  {                      length--;                  } while (length > 0 && (buffer[offset + length] & 0xC0) != 0xC0);                  // Couldn't find the lead char                  if (length == 0)                  {                      return originalLength; // Invalid utf8 sequence - can't break                  }                  // Count how many bytes follow the lead char                  byte b = unchecked((byte)(buffer[offset + length] << 2));                  int byteCount = 2;                  while ((b & 0x80) == 0x80)                  {                      b = (byte)(b << 1);                      byteCount++;                      // There shouldn't be more than 3 bytes following the lead char                      if (byteCount > 4)                      {                          return originalLength; // Invalid utf8 sequence - can't break                      }                  }                  if (length + byteCount == originalLength)                  {                      return originalLength; // sequence fits exactly                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,BreakText,The following statement contains a magic number: if (length > 0 && (buffer[offset + length - 1] & 0x80) == 0x80)              {                  // Find the lead char of the utf8 sequence (0x11xxxxxx)                  int originalLength = length;                  do                  {                      length--;                  } while (length > 0 && (buffer[offset + length] & 0xC0) != 0xC0);                  // Couldn't find the lead char                  if (length == 0)                  {                      return originalLength; // Invalid utf8 sequence - can't break                  }                  // Count how many bytes follow the lead char                  byte b = unchecked((byte)(buffer[offset + length] << 2));                  int byteCount = 2;                  while ((b & 0x80) == 0x80)                  {                      b = (byte)(b << 1);                      byteCount++;                      // There shouldn't be more than 3 bytes following the lead char                      if (byteCount > 4)                      {                          return originalLength; // Invalid utf8 sequence - can't break                      }                  }                  if (length + byteCount == originalLength)                  {                      return originalLength; // sequence fits exactly                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,BufferElement,The following statement contains a magic number: const int byteCount = 128;
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,EnterJsonScope,The following statement contains a magic number: if (_scopes == null)              {                  _scopes = new JsonNodeType[4];              }              else if (_scopes.Length == _scopeDepth)              {                  JsonNodeType[] newScopes = new JsonNodeType[_scopeDepth * 2];                  Array.Copy(_scopes' 0' newScopes' 0' _scopeDepth);                  _scopes = newScopes;              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,EnterJsonScope,The following statement contains a magic number: if (_scopes == null)              {                  _scopes = new JsonNodeType[4];              }              else if (_scopes.Length == _scopeDepth)              {                  JsonNodeType[] newScopes = new JsonNodeType[_scopeDepth * 2];                  Array.Copy(_scopes' 0' newScopes' 0' _scopeDepth);                  _scopes = newScopes;              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch == 'u')              {                  BufferReader.SkipByte();                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  string bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                  BufferReader.Advance(4);                  int charValue = ParseChar(bufferAsString' NumberStyles.HexNumber);                  if (Char.IsHighSurrogate((char)charValue))                  {                      byte nextByte = BufferReader.GetByte();                      if (nextByte == (byte)'\\')                      {                          BufferReader.SkipByte();                          SkipExpectedByteInBufferReader((byte)'u');                          buffer = BufferReader.GetBuffer(5' out offset);                          bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                          BufferReader.Advance(4);                          char lowChar = ParseChar(bufferAsString' NumberStyles.HexNumber);                          if (!Char.IsLowSurrogate(lowChar))                          {                              XmlExceptionHelper.ThrowXmlException(this'                                  new XmlException(SR.Format(SR.XmlInvalidLowSurrogate' bufferAsString)));                          }                          charValue = new SurrogateChar(lowChar' (char)charValue).Char;                      }                  }                    if (buffer[offset + 4] == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }              else              {                  switch (ch)                  {                      case 'b':                          ch = '\b';                          break;                      case 'f':                          ch = '\f';                          break;                      case 'n':                          ch = '\n';                          break;                      case 'r':                          ch = '\r';                          break;                      case 't':                          ch = '\t';                          break;                      case '\"':                      case '\\':                      case '/':                          // Do nothing. These are the actual unescaped values.                          break;                      default:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }                  BufferReader.SkipByte();                  if (BufferReader.GetByte() == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch == 'u')              {                  BufferReader.SkipByte();                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  string bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                  BufferReader.Advance(4);                  int charValue = ParseChar(bufferAsString' NumberStyles.HexNumber);                  if (Char.IsHighSurrogate((char)charValue))                  {                      byte nextByte = BufferReader.GetByte();                      if (nextByte == (byte)'\\')                      {                          BufferReader.SkipByte();                          SkipExpectedByteInBufferReader((byte)'u');                          buffer = BufferReader.GetBuffer(5' out offset);                          bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                          BufferReader.Advance(4);                          char lowChar = ParseChar(bufferAsString' NumberStyles.HexNumber);                          if (!Char.IsLowSurrogate(lowChar))                          {                              XmlExceptionHelper.ThrowXmlException(this'                                  new XmlException(SR.Format(SR.XmlInvalidLowSurrogate' bufferAsString)));                          }                          charValue = new SurrogateChar(lowChar' (char)charValue).Char;                      }                  }                    if (buffer[offset + 4] == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }              else              {                  switch (ch)                  {                      case 'b':                          ch = '\b';                          break;                      case 'f':                          ch = '\f';                          break;                      case 'n':                          ch = '\n';                          break;                      case 'r':                          ch = '\r';                          break;                      case 't':                          ch = '\t';                          break;                      case '\"':                      case '\\':                      case '/':                          // Do nothing. These are the actual unescaped values.                          break;                      default:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }                  BufferReader.SkipByte();                  if (BufferReader.GetByte() == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch == 'u')              {                  BufferReader.SkipByte();                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  string bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                  BufferReader.Advance(4);                  int charValue = ParseChar(bufferAsString' NumberStyles.HexNumber);                  if (Char.IsHighSurrogate((char)charValue))                  {                      byte nextByte = BufferReader.GetByte();                      if (nextByte == (byte)'\\')                      {                          BufferReader.SkipByte();                          SkipExpectedByteInBufferReader((byte)'u');                          buffer = BufferReader.GetBuffer(5' out offset);                          bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                          BufferReader.Advance(4);                          char lowChar = ParseChar(bufferAsString' NumberStyles.HexNumber);                          if (!Char.IsLowSurrogate(lowChar))                          {                              XmlExceptionHelper.ThrowXmlException(this'                                  new XmlException(SR.Format(SR.XmlInvalidLowSurrogate' bufferAsString)));                          }                          charValue = new SurrogateChar(lowChar' (char)charValue).Char;                      }                  }                    if (buffer[offset + 4] == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }              else              {                  switch (ch)                  {                      case 'b':                          ch = '\b';                          break;                      case 'f':                          ch = '\f';                          break;                      case 'n':                          ch = '\n';                          break;                      case 'r':                          ch = '\r';                          break;                      case 't':                          ch = '\t';                          break;                      case '\"':                      case '\\':                      case '/':                          // Do nothing. These are the actual unescaped values.                          break;                      default:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }                  BufferReader.SkipByte();                  if (BufferReader.GetByte() == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch == 'u')              {                  BufferReader.SkipByte();                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  string bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                  BufferReader.Advance(4);                  int charValue = ParseChar(bufferAsString' NumberStyles.HexNumber);                  if (Char.IsHighSurrogate((char)charValue))                  {                      byte nextByte = BufferReader.GetByte();                      if (nextByte == (byte)'\\')                      {                          BufferReader.SkipByte();                          SkipExpectedByteInBufferReader((byte)'u');                          buffer = BufferReader.GetBuffer(5' out offset);                          bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                          BufferReader.Advance(4);                          char lowChar = ParseChar(bufferAsString' NumberStyles.HexNumber);                          if (!Char.IsLowSurrogate(lowChar))                          {                              XmlExceptionHelper.ThrowXmlException(this'                                  new XmlException(SR.Format(SR.XmlInvalidLowSurrogate' bufferAsString)));                          }                          charValue = new SurrogateChar(lowChar' (char)charValue).Char;                      }                  }                    if (buffer[offset + 4] == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }              else              {                  switch (ch)                  {                      case 'b':                          ch = '\b';                          break;                      case 'f':                          ch = '\f';                          break;                      case 'n':                          ch = '\n';                          break;                      case 'r':                          ch = '\r';                          break;                      case 't':                          ch = '\t';                          break;                      case '\"':                      case '\\':                      case '/':                          // Do nothing. These are the actual unescaped values.                          break;                      default:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }                  BufferReader.SkipByte();                  if (BufferReader.GetByte() == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch == 'u')              {                  BufferReader.SkipByte();                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  string bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                  BufferReader.Advance(4);                  int charValue = ParseChar(bufferAsString' NumberStyles.HexNumber);                  if (Char.IsHighSurrogate((char)charValue))                  {                      byte nextByte = BufferReader.GetByte();                      if (nextByte == (byte)'\\')                      {                          BufferReader.SkipByte();                          SkipExpectedByteInBufferReader((byte)'u');                          buffer = BufferReader.GetBuffer(5' out offset);                          bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                          BufferReader.Advance(4);                          char lowChar = ParseChar(bufferAsString' NumberStyles.HexNumber);                          if (!Char.IsLowSurrogate(lowChar))                          {                              XmlExceptionHelper.ThrowXmlException(this'                                  new XmlException(SR.Format(SR.XmlInvalidLowSurrogate' bufferAsString)));                          }                          charValue = new SurrogateChar(lowChar' (char)charValue).Char;                      }                  }                    if (buffer[offset + 4] == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }              else              {                  switch (ch)                  {                      case 'b':                          ch = '\b';                          break;                      case 'f':                          ch = '\f';                          break;                      case 'n':                          ch = '\n';                          break;                      case 'r':                          ch = '\r';                          break;                      case 't':                          ch = '\t';                          break;                      case '\"':                      case '\\':                      case '/':                          // Do nothing. These are the actual unescaped values.                          break;                      default:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }                  BufferReader.SkipByte();                  if (BufferReader.GetByte() == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch == 'u')              {                  BufferReader.SkipByte();                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  string bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                  BufferReader.Advance(4);                  int charValue = ParseChar(bufferAsString' NumberStyles.HexNumber);                  if (Char.IsHighSurrogate((char)charValue))                  {                      byte nextByte = BufferReader.GetByte();                      if (nextByte == (byte)'\\')                      {                          BufferReader.SkipByte();                          SkipExpectedByteInBufferReader((byte)'u');                          buffer = BufferReader.GetBuffer(5' out offset);                          bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                          BufferReader.Advance(4);                          char lowChar = ParseChar(bufferAsString' NumberStyles.HexNumber);                          if (!Char.IsLowSurrogate(lowChar))                          {                              XmlExceptionHelper.ThrowXmlException(this'                                  new XmlException(SR.Format(SR.XmlInvalidLowSurrogate' bufferAsString)));                          }                          charValue = new SurrogateChar(lowChar' (char)charValue).Char;                      }                  }                    if (buffer[offset + 4] == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }              else              {                  switch (ch)                  {                      case 'b':                          ch = '\b';                          break;                      case 'f':                          ch = '\f';                          break;                      case 'n':                          ch = '\n';                          break;                      case 'r':                          ch = '\r';                          break;                      case 't':                          ch = '\t';                          break;                      case '\"':                      case '\\':                      case '/':                          // Do nothing. These are the actual unescaped values.                          break;                      default:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }                  BufferReader.SkipByte();                  if (BufferReader.GetByte() == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadEscapedCharacter,The following statement contains a magic number: if (ch == 'u')              {                  BufferReader.SkipByte();                  int offset;                  byte[] buffer = BufferReader.GetBuffer(5' out offset);                  string bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                  BufferReader.Advance(4);                  int charValue = ParseChar(bufferAsString' NumberStyles.HexNumber);                  if (Char.IsHighSurrogate((char)charValue))                  {                      byte nextByte = BufferReader.GetByte();                      if (nextByte == (byte)'\\')                      {                          BufferReader.SkipByte();                          SkipExpectedByteInBufferReader((byte)'u');                          buffer = BufferReader.GetBuffer(5' out offset);                          bufferAsString = Encoding.UTF8.GetString(buffer' offset' 4);                          BufferReader.Advance(4);                          char lowChar = ParseChar(bufferAsString' NumberStyles.HexNumber);                          if (!Char.IsLowSurrogate(lowChar))                          {                              XmlExceptionHelper.ThrowXmlException(this'                                  new XmlException(SR.Format(SR.XmlInvalidLowSurrogate' bufferAsString)));                          }                          charValue = new SurrogateChar(lowChar' (char)charValue).Char;                      }                  }                    if (buffer[offset + 4] == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(charValue);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }              else              {                  switch (ch)                  {                      case 'b':                          ch = '\b';                          break;                      case 'f':                          ch = '\f';                          break;                      case 'n':                          ch = '\n';                          break;                      case 'r':                          ch = '\r';                          break;                      case 't':                          ch = '\t';                          break;                      case '\"':                      case '\\':                      case '/':                          // Do nothing. These are the actual unescaped values.                          break;                      default:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }                  BufferReader.SkipByte();                  if (BufferReader.GetByte() == JsonGlobals.QuoteByte)                  {                      BufferReader.SkipByte();                      if (moveToText)                      {                          MoveToAtomicText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.None;                  }                  else                  {                      if (moveToText)                      {                          MoveToComplexText().Value.SetCharValue(ch);                      }                      _complexTextMode = JsonComplexTextMode.QuotedText;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: byte[] buff = BufferReader.GetBuffer(3' out off);
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buff[off + 1] == 0xBF && (buff[off + 2] == 0xBE || buff[off + 2] == 0xBF))              {                  XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.JsonInvalidFFFE));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: if (buff[off + 1] == 0xBF && (buff[off + 2] == 0xBE || buff[off + 2] == 0xBF))              {                  XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.JsonInvalidFFFE));              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadNonFFFE,The following statement contains a magic number: return 3;
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: byte[] buffer = BufferReader.GetBuffer(8' out offset' out offsetMax);
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ReadServerTypeAttribute,The following statement contains a magic number: if (offset + 8 <= offsetMax)              {                  if (buffer[offset + 0] == (byte)'\"' &&                      buffer[offset + 1] == (byte)'_' &&                      buffer[offset + 2] == (byte)'_' &&                      buffer[offset + 3] == (byte)'t' &&                      buffer[offset + 4] == (byte)'y' &&                      buffer[offset + 5] == (byte)'p' &&                      buffer[offset + 6] == (byte)'e' &&                      buffer[offset + 7] == (byte)'\"')                  {                      XmlAttributeNode attribute = AddAttribute();                        attribute.LocalName.SetValue(offset + 1' 6);                      attribute.Namespace.Uri.SetValue(0' 0);                      attribute.Prefix.SetValue(PrefixHandleType.Empty);                      BufferReader.Advance(8);                        if (!_buffered)                      {                          BufferElement();                      }                        SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.NameValueSeparatorByte);                      SkipWhitespaceInBufferReader();                      SkipExpectedByteInBufferReader(JsonGlobals.QuoteByte);                        buffer = BufferReader.GetBuffer(out offset' out offsetMax);                        do                      {                          if (BufferReader.GetByte() == '\\')                          {                              ReadEscapedCharacter(false); //  moveToText                           }                          else                          {                              ReadQuotedText(false); //  moveToText                           }                      } while (_complexTextMode == JsonComplexTextMode.QuotedText);                        attribute.Value.SetValue(ValueHandleType.UTF8' offset' BufferReader.Offset - 1 - offset);                        SkipWhitespaceInBufferReader();                        if (BufferReader.GetByte() == JsonGlobals.MemberSeparatorByte)                      {                          BufferReader.SkipByte();                          _readServerTypeElement = true;                      }                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,ResetState,The following statement contains a magic number: _charactersToSkipOnNextRead = new byte[2];
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int i = 0; i < val.Length; i++)              {                  if (val[i] == '\\')                  {                      i++;                      if (sb == null)                      {                          sb = new StringBuilder();                      }                      sb.Append(val' startIndex' count);                      Fx.Assert(i < val.Length' "Found that an '\' was the last character in a string. ReadServerTypeAttriute validates that the escape sequence is valid when it calls ReadQuotedText and ReadEscapedCharacter");                      if (i >= val.Length)                      {                          XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' val[i])));                      }                      switch (val[i])                      {                          case '"':                          case '\'':                          case '/':                          case '\\':                              sb.Append(val[i]);                              break;                          case 'b':                              sb.Append('\b');                              break;                          case 'f':                              sb.Append('\f');                              break;                          case 'n':                              sb.Append('\n');                              break;                          case 'r':                              sb.Append('\r');                              break;                          case 't':                              sb.Append('\t');                              break;                          case 'u':                              if ((i + 3) >= val.Length)                              {                                  XmlExceptionHelper.ThrowXmlException(this'                                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' val[i])));                              }                              sb.Append(ParseChar(val.Substring(i + 1' 4)' NumberStyles.HexNumber));                              i += 4;                              break;                      }                      startIndex = i + 1;                      count = 0;                  }                  else                  {                      count++;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int i = 0; i < val.Length; i++)              {                  if (val[i] == '\\')                  {                      i++;                      if (sb == null)                      {                          sb = new StringBuilder();                      }                      sb.Append(val' startIndex' count);                      Fx.Assert(i < val.Length' "Found that an '\' was the last character in a string. ReadServerTypeAttriute validates that the escape sequence is valid when it calls ReadQuotedText and ReadEscapedCharacter");                      if (i >= val.Length)                      {                          XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' val[i])));                      }                      switch (val[i])                      {                          case '"':                          case '\'':                          case '/':                          case '\\':                              sb.Append(val[i]);                              break;                          case 'b':                              sb.Append('\b');                              break;                          case 'f':                              sb.Append('\f');                              break;                          case 'n':                              sb.Append('\n');                              break;                          case 'r':                              sb.Append('\r');                              break;                          case 't':                              sb.Append('\t');                              break;                          case 'u':                              if ((i + 3) >= val.Length)                              {                                  XmlExceptionHelper.ThrowXmlException(this'                                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' val[i])));                              }                              sb.Append(ParseChar(val.Substring(i + 1' 4)' NumberStyles.HexNumber));                              i += 4;                              break;                      }                      startIndex = i + 1;                      count = 0;                  }                  else                  {                      count++;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,UnescapeJsonString,The following statement contains a magic number: for (int i = 0; i < val.Length; i++)              {                  if (val[i] == '\\')                  {                      i++;                      if (sb == null)                      {                          sb = new StringBuilder();                      }                      sb.Append(val' startIndex' count);                      Fx.Assert(i < val.Length' "Found that an '\' was the last character in a string. ReadServerTypeAttriute validates that the escape sequence is valid when it calls ReadQuotedText and ReadEscapedCharacter");                      if (i >= val.Length)                      {                          XmlExceptionHelper.ThrowXmlException(this' new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' val[i])));                      }                      switch (val[i])                      {                          case '"':                          case '\'':                          case '/':                          case '\\':                              sb.Append(val[i]);                              break;                          case 'b':                              sb.Append('\b');                              break;                          case 'f':                              sb.Append('\f');                              break;                          case 'n':                              sb.Append('\n');                              break;                          case 'r':                              sb.Append('\r');                              break;                          case 't':                              sb.Append('\t');                              break;                          case 'u':                              if ((i + 3) >= val.Length)                              {                                  XmlExceptionHelper.ThrowXmlException(this'                                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' val[i])));                              }                              sb.Append(ParseChar(val.Substring(i + 1' 4)' NumberStyles.HexNumber));                              i += 4;                              break;                      }                      startIndex = i + 1;                      count = 0;                  }                  else                  {                      count++;                  }              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: if (_scopes == null)              {                  _scopes = new JsonNodeType[4];              }              else if (_scopes.Length == _depth)              {                  JsonNodeType[] newScopes = new JsonNodeType[_depth * 2];                  Array.Copy(_scopes' 0' newScopes' 0' _depth);                  _scopes = newScopes;              }
Magic Number,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,EnterScope,The following statement contains a magic number: if (_scopes == null)              {                  _scopes = new JsonNodeType[4];              }              else if (_scopes.Length == _depth)              {                  JsonNodeType[] newScopes = new JsonNodeType[_depth * 2];                  Array.Copy(_scopes' 0' newScopes' 0' _depth);                  _scopes = newScopes;              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,ProcessBuffer,The following statement contains a magic number: try              {                  SupportedEncoding expectedEnc = GetSupportedEncoding(encoding);                  SupportedEncoding dataEnc;                  if (count < 2)                  {                      dataEnc = SupportedEncoding.UTF8;                  }                  else                  {                      dataEnc = ReadEncoding(buffer[offset]' buffer[offset + 1]);                  }                  if ((expectedEnc != SupportedEncoding.None) && (expectedEnc != dataEnc))                  {                      ThrowExpectedEncodingMismatch(expectedEnc' dataEnc);                  }                    // Fastpath: UTF-8                  if (dataEnc == SupportedEncoding.UTF8)                  {                      return new ArraySegment<byte>(buffer' offset' count);                  }                    // Convert to UTF-8                  return                      new ArraySegment<byte>(s_validatingUTF8.GetBytes(GetEncoding(dataEnc).GetChars(buffer' offset' count)));              }              catch (DecoderFallbackException e)              {                  throw new XmlException(SR.JsonInvalidBytes' e);              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,Read,The following statement contains a magic number: try              {                  if (_byteCount == 0)                  {                      if (_encodingCode == SupportedEncoding.UTF8)                      {                          return _stream.Read(buffer' offset' count);                      }                        // No more bytes than can be turned into characters                      _byteOffset = 0;                      _byteCount = _stream.Read(_bytes' _byteCount' (_chars.Length - 1) * 2);                        // Check for end of stream                      if (_byteCount == 0)                      {                          return 0;                      }                        // Fix up incomplete chars                      CleanupCharBreak();                        // Change encoding                      int charCount = _encoding.GetChars(_bytes' 0' _byteCount' _chars' 0);                      _byteCount = Encoding.UTF8.GetBytes(_chars' 0' charCount' _bytes' 0);                  }                    // Give them bytes                  if (_byteCount < count)                  {                      count = _byteCount;                  }                  Buffer.BlockCopy(_bytes' _byteOffset' buffer' offset' count);                  _byteOffset += count;                  _byteCount -= count;                  return count;              }              catch (DecoderFallbackException ex)              {                  throw new XmlException(SR.JsonInvalidBytes' ex);              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if ((_byteCount % 2) != 0)              {                  int b = _stream.ReadByte();                  if (b < 0)                  {                      throw new XmlException(SR.JsonUnexpectedEndOfFile);                  }                    _bytes[max++] = (byte)b;                  _byteCount++;              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if (_encodingCode == SupportedEncoding.UTF16LE)              {                  w = _bytes[max - 2] + (_bytes[max - 1] << 8);              }              else              {                  w = _bytes[max - 1] + (_bytes[max - 2] << 8);              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,CleanupCharBreak,The following statement contains a magic number: if ((w & 0xDC00) != 0xDC00 && w >= 0xD800 && w <= 0xDBFF) // First 16-bit number of surrogate pair              {                  int b1 = _stream.ReadByte();                  int b2 = _stream.ReadByte();                  if (b2 < 0)                  {                      throw new XmlException(SR.JsonUnexpectedEndOfFile);                  }                  _bytes[max++] = (byte)b1;                  _bytes[max++] = (byte)b2;                  _byteCount += 2;              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,EnsureByteBuffer,The following statement contains a magic number: _bytes = new byte[BufferLength * 4];
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,InitForReading,The following statement contains a magic number: try              {                  //this.stream = new BufferedStream(inputStream);                  _stream = inputStream;                    SupportedEncoding expectedEnc = GetSupportedEncoding(expectedEncoding);                  SupportedEncoding dataEnc = ReadEncoding();                  if ((expectedEnc != SupportedEncoding.None) && (expectedEnc != dataEnc))                  {                      ThrowExpectedEncodingMismatch(expectedEnc' dataEnc);                  }                    // Fastpath: UTF-8 (do nothing)                  if (dataEnc != SupportedEncoding.UTF8)                  {                      // Convert to UTF-8                      EnsureBuffers();                      FillBuffer((BufferLength - 1) * 2);                      _encodingCode = dataEnc;                      _encoding = GetEncoding(dataEnc);                      CleanupCharBreak();                      int count = _encoding.GetChars(_bytes' _byteOffset' _byteCount' _chars' 0);                      _byteOffset = 0;                      _byteCount = s_validatingUTF8.GetBytes(_chars' 0' count' _bytes' 0);                  }              }              catch (DecoderFallbackException ex)              {                  throw new XmlException(SR.JsonInvalidBytes' ex);              }
Magic Number,System.Runtime.Serialization.Json,JsonEncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonEncodingStreamWrapper.cs,ReadEncoding,The following statement contains a magic number: if (b1 == -1)              {                  e = SupportedEncoding.UTF8;                  _byteCount = 0;              }              else if (b2 == -1)              {                  e = SupportedEncoding.UTF8;                  _bytes[0] = (byte)b1;                  _byteCount = 1;              }              else              {                  e = ReadEncoding((byte)b1' (byte)b2);                  _bytes[0] = (byte)b1;                  _bytes[1] = (byte)b2;                  _byteCount = 2;              }
Magic Number,System.Runtime.Serialization.Json,ReflectionJsonFormatWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\ReflectionJsonFormatWriter.cs,ReflectionWriteCollection,The following statement contains a magic number: if (collectionContract.Kind == CollectionKind.Array)              {                  context.IncrementArrayCount(jsonWriter' (Array)obj);                  Type itemType = collectionContract.ItemType;                  if (!ReflectionTryWritePrimitiveArray(jsonWriter' obj' collectionContract.UnderlyingType' itemType' itemName))                  {                      ReflectionWriteArrayAttribute(jsonWriter);                        Array array = (Array)obj;                      PrimitiveDataContract primitiveContract = PrimitiveDataContract.GetPrimitiveDataContract(itemType);                      for (int i = 0; i < array.Length; ++i)                      {                          _reflectionClassWriter.ReflectionWriteStartElement(jsonWriter' itemName);                          _reflectionClassWriter.ReflectionWriteValue(jsonWriter' context' itemType' array.GetValue(i)' false' primitiveContract);                          _reflectionClassWriter.ReflectionWriteEndElement(jsonWriter);                      }                  }              }              else              {                  collectionContract.IncrementCollectionCount(jsonWriter' obj' context);                    IEnumerator enumerator = collectionContract.GetEnumeratorForCollection(obj);                    bool canWriteSimpleDictionary = collectionContract.Kind == CollectionKind.GenericDictionary                                               || collectionContract.Kind == CollectionKind.Dictionary;                    bool useSimpleDictionaryFormat = context.UseSimpleDictionaryFormat;                    if (canWriteSimpleDictionary && useSimpleDictionaryFormat)                  {                      ReflectionWriteObjectAttribute(jsonWriter);                      Type[] itemTypeGenericArguments = collectionContract.ItemType.GetGenericArguments();                      Type dictionaryValueType = itemTypeGenericArguments.Length == 2 ? itemTypeGenericArguments[1] : null;                        while (enumerator.MoveNext())                      {                          object current = enumerator.Current;                          object key = ((IKeyValue)current).Key;                          object value = ((IKeyValue)current).Value;                          _reflectionClassWriter.ReflectionWriteStartElement(jsonWriter' key.ToString());                          _reflectionClassWriter.ReflectionWriteValue(jsonWriter' context' dictionaryValueType ?? value.GetType()' value' false' primitiveContractForParamType: null);                          _reflectionClassWriter.ReflectionWriteEndElement(jsonWriter);                      }                  }                  else                  {                      ReflectionWriteArrayAttribute(jsonWriter);                        PrimitiveDataContract primitiveContractForType = PrimitiveDataContract.GetPrimitiveDataContract(collectionContract.UnderlyingType);                      if (primitiveContractForType != null && primitiveContractForType.UnderlyingType != Globals.TypeOfObject)                      {                          while (enumerator.MoveNext())                          {                              object current = enumerator.Current;                              context.IncrementItemCount(1);                              primitiveContractForType.WriteXmlElement(jsonWriter' current' context' itemName' null /*namespace*/);                          }                      }                      else                      {                          Type elementType = collectionContract.GetCollectionElementType();                          bool isDictionary = collectionContract.Kind == CollectionKind.Dictionary || collectionContract.Kind == CollectionKind.GenericDictionary;                            DataContract itemContract = null;                          JsonDataContract jsonDataContract = null;                          if (isDictionary)                          {                              itemContract = XmlObjectSerializerWriteContextComplexJson.GetRevisedItemContract(collectionContract.ItemContract);                              jsonDataContract = JsonDataContract.GetJsonDataContract(itemContract);                          }                            while (enumerator.MoveNext())                          {                              object current = enumerator.Current;                              context.IncrementItemCount(1);                              _reflectionClassWriter.ReflectionWriteStartElement(jsonWriter' itemName);                              if (isDictionary)                              {                                  jsonDataContract.WriteJsonValue(jsonWriter' current' context' collectionContract.ItemType.TypeHandle);                              }                              else                              {                                  _reflectionClassWriter.ReflectionWriteValue(jsonWriter' context' elementType' current' false' primitiveContractForParamType: null);                              }                                _reflectionClassWriter.ReflectionWriteEndElement(jsonWriter);                          }                      }                  }              }
Duplicate Code,System.Xml,NamespaceManager,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBaseReader.cs,LookupAttributePrefix,The method contains a code clone-set at the following line numbers (starting from the method definition): ((11' 32)' (37' 58))
Duplicate Code,System.Runtime.Serialization.Json,XmlJsonWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonWriter.cs,WriteStartElement,The method contains a code clone-set at the following line numbers (starting from the method definition): ((53' 72)' (78' 97))
Missing Default,System.Runtime.Serialization,CollectionDataContract,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\CollectionDataContract.cs,IsCollectionOrTryCreate,The following switch statement is missing a default case: switch (kind)                  {                      case CollectionKind.GenericDictionary:                          addMethodTypeArray = knownInterfaceType.GetGenericArguments();                          bool isOpenGeneric = knownInterfaceType.IsGenericTypeDefinition                              || (addMethodTypeArray[0].IsGenericParameter && addMethodTypeArray[1].IsGenericParameter);                          itemType = isOpenGeneric ? Globals.TypeOfKeyValue : Globals.TypeOfKeyValue.MakeGenericType(addMethodTypeArray);                          break;                      case CollectionKind.Dictionary:                          addMethodTypeArray = new Type[] { Globals.TypeOfObject' Globals.TypeOfObject };                          itemType = Globals.TypeOfKeyValue.MakeGenericType(addMethodTypeArray);                          break;                      case CollectionKind.GenericList:                      case CollectionKind.GenericCollection:                          addMethodTypeArray = knownInterfaceType.GetGenericArguments();                          itemType = addMethodTypeArray[0];                          break;                      case CollectionKind.List:                          itemType = Globals.TypeOfObject;                          addMethodTypeArray = new Type[] { itemType };                          break;                  }
Missing Default,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,ReadCollection,The following switch statement is missing a default case: switch (collectionContract.Kind)                      {                          case CollectionKind.GenericDictionary:                              type = Globals.TypeOfDictionaryGeneric.MakeGenericType(itemType.GetGenericArguments());                              constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public' Array.Empty<Type>());                              break;                          case CollectionKind.Dictionary:                              type = Globals.TypeOfHashtable;                              constructor = XmlFormatGeneratorStatics.HashtableCtor;                              break;                          case CollectionKind.Collection:                          case CollectionKind.GenericCollection:                          case CollectionKind.Enumerable:                          case CollectionKind.GenericEnumerable:                          case CollectionKind.List:                          case CollectionKind.GenericList:                              type = itemType.MakeArrayType();                              isArray = true;                              break;                      }
Missing Default,System.Runtime.Serialization,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\DataMember.cs,WriteCollection,The following switch statement is missing a default case: switch (collectionContract.Kind)                      {                          case CollectionKind.Collection:                          case CollectionKind.List:                          case CollectionKind.Dictionary:                              incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountMethod;                              break;                          case CollectionKind.GenericCollection:                          case CollectionKind.GenericList:                              incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(collectionContract.ItemType);                              break;                          case CollectionKind.GenericDictionary:                              incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(Globals.TypeOfKeyValuePair.MakeGenericType(collectionContract.ItemType.GetGenericArguments()));                              break;                      }
Missing Default,System.Runtime.Serialization,ReflectionReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\ReflectionReader.cs,IsArrayLikeInterface,The following switch statement is missing a default case: switch (collectionContract.Kind)                  {                      case CollectionKind.Collection:                      case CollectionKind.GenericCollection:                      case CollectionKind.Enumerable:                      case CollectionKind.GenericEnumerable:                      case CollectionKind.List:                      case CollectionKind.GenericList:                          return true;                  }
Missing Default,System.Xml,XmlBinaryNodeWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlBinaryWriter.cs,ToBinary,The following switch statement is missing a default case: switch (dt.Kind)              {                  case DateTimeKind.Local:                      temp = temp | -9223372036854775808L; // 0x8000000000000000                      temp = temp | dt.ToUniversalTime().Ticks;                      break;                  case DateTimeKind.Utc:                      temp = temp | 0x4000000000000000L;                      temp = temp | dt.Ticks;                      break;                  case DateTimeKind.Unspecified:                      temp = dt.Ticks;                      break;              }
Missing Default,System.Xml,XmlDictionaryWriter,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlDictionaryWriter.cs,WriteNode,The following switch statement is missing a default case: switch (nodeType)                      {                          case XmlNodeType.Element:                              WriteElementNode(reader' defattr);                              break;                          case XmlNodeType.CDATA:                              WriteCData(reader.Value);                              break;                          case XmlNodeType.EntityReference:                              WriteEntityRef(reader.Name);                              break;                          case XmlNodeType.XmlDeclaration:                          case XmlNodeType.ProcessingInstruction:                              WriteProcessingInstruction(reader.Name' reader.Value);                              break;                          case XmlNodeType.DocumentType:                              WriteDocType(reader.Name' reader.GetAttribute("PUBLIC")' reader.GetAttribute("SYSTEM")' reader.Value);                              break;                          case XmlNodeType.Comment:                              WriteComment(reader.Value);                              break;                          case XmlNodeType.EndElement:                              WriteFullEndElement();                              break;                      }
Missing Default,System.Xml,XmlExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\XmlExceptionHelper.cs,GetWhatWasFound,The following switch statement is missing a default case: switch (reader.NodeType)              {                  case XmlNodeType.Element:                      return SR.Format(SR.XmlFoundElement' GetName(reader.Prefix' reader.LocalName)' reader.NamespaceURI);                  case XmlNodeType.EndElement:                      return SR.Format(SR.XmlFoundEndElement' GetName(reader.Prefix' reader.LocalName)' reader.NamespaceURI);                  case XmlNodeType.Text:                  case XmlNodeType.Whitespace:                  case XmlNodeType.SignificantWhitespace:                      return SR.Format(SR.XmlFoundText' reader.Value);                  case XmlNodeType.Comment:                      return SR.Format(SR.XmlFoundComment' reader.Value);                  case XmlNodeType.CDATA:                      return SR.Format(SR.XmlFoundCData' reader.Value);              }
Missing Default,System.Xml,EncodingStreamWrapper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Xml\EncodingStreamWrapper.cs,ReadBOMEncoding,The following switch statement is missing a default case: switch (preserve)              {                  case 1:                      _bytes[0] = (byte)b4;                      break;                    case 2:                      _bytes[0] = (byte)b3;                      _bytes[1] = (byte)b4;                      break;                    case 4:                      _bytes[0] = (byte)b1;                      _bytes[1] = (byte)b2;                      _bytes[2] = (byte)b3;                      _bytes[3] = (byte)b4;                      break;              }
Missing Default,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,WriteCollection,The following switch statement is missing a default case: switch (collectionContract.Kind)                      {                          case CollectionKind.Collection:                          case CollectionKind.List:                          case CollectionKind.Dictionary:                              incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountMethod;                              break;                          case CollectionKind.GenericCollection:                          case CollectionKind.GenericList:                              incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(collectionContract.ItemType);                              break;                          case CollectionKind.GenericDictionary:                              incrementCollectionCountMethod = XmlFormatGeneratorStatics.IncrementCollectionCountGenericMethod.MakeGenericMethod(Globals.TypeOfKeyValuePair.MakeGenericType(collectionContract.ItemType.GetGenericArguments()));                              break;                      }
Missing Default,System.Runtime.Serialization.Json,CriticalHelper,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonFormatWriterGenerator.cs,ReadCollection,The following switch statement is missing a default case: switch (collectionContract.Kind)                      {                          case CollectionKind.GenericDictionary:                              type = Globals.TypeOfDictionaryGeneric.MakeGenericType(itemType.GetGenericArguments());                              constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' Array.Empty<Type>());                              break;                          case CollectionKind.Dictionary:                              type = Globals.TypeOfHashtable;                              constructor = type.GetConstructor(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic' Array.Empty<Type>());                              break;                          case CollectionKind.Collection:                          case CollectionKind.GenericCollection:                          case CollectionKind.Enumerable:                          case CollectionKind.GenericEnumerable:                          case CollectionKind.List:                          case CollectionKind.GenericList:                              type = itemType.MakeArrayType();                              isArray = true;                              break;                      }
Missing Default,System.Runtime.Serialization.Json,JsonWriterDelegator,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\JsonWriterDelegator.cs,WriteDateTimeInDefaultFormat,The following switch statement is missing a default case: switch (value.Kind)              {                  case DateTimeKind.Unspecified:                  case DateTimeKind.Local:                      // +"zzzz";                      //TimeSpan ts = TimeZone.CurrentTimeZone.GetUtcOffset(value.ToLocalTime());                      TimeSpan ts = TimeZoneInfo.Local.GetUtcOffset(value.ToLocalTime());                      writer.WriteString(string.Format(CultureInfo.InvariantCulture' "{0:+00;-00}{1:00;00}"' ts.Hours' ts.Minutes));                      break;                  case DateTimeKind.Utc:                      break;              }
Missing Default,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,Read,The following switch statement is missing a default case: switch (_complexTextMode)                  {                      case JsonComplexTextMode.NumericalText:                          ReadNumericalText();                          break;                      case JsonComplexTextMode.QuotedText:                          if (ch == (byte)'\\')                          {                              ReadEscapedCharacter(true); //  moveToText                           }                          else                          {                              ReadQuotedText(true); //  moveToText                           }                          break;                      case JsonComplexTextMode.None:                          XmlExceptionHelper.ThrowXmlException(this'                              new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' (char)ch)));                          break;                  }
Missing Default,System.Runtime.Serialization.Json,XmlJsonReader,C:\selectedRepos\dotnet_corefx\src\System.Private.DataContractSerialization\src\System\Runtime\Serialization\Json\XmlJsonReader.cs,UnescapeJsonString,The following switch statement is missing a default case: switch (val[i])                      {                          case '"':                          case '\'':                          case '/':                          case '\\':                              sb.Append(val[i]);                              break;                          case 'b':                              sb.Append('\b');                              break;                          case 'f':                              sb.Append('\f');                              break;                          case 'n':                              sb.Append('\n');                              break;                          case 'r':                              sb.Append('\r');                              break;                          case 't':                              sb.Append('\t');                              break;                          case 'u':                              if ((i + 3) >= val.Length)                              {                                  XmlExceptionHelper.ThrowXmlException(this'                                      new XmlException(SR.Format(SR.JsonEncounteredUnexpectedCharacter' val[i])));                              }                              sb.Append(ParseChar(val.Substring(i + 1' 4)' NumberStyles.HexNumber));                              i += 4;                              break;                      }
