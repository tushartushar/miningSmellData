Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetCurrentUserSid,The method has 107 lines of code.
Long Method,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInitNoContainer,The method has 133 lines of code.
Long Method,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The method has 121 lines of code.
Long Method,System.DirectoryServices.AccountManagement,AuthZSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthZSet.cs,AuthZSet,The method has 167 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The method has 159 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadPropertyMappingTable,The method has 154 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The method has 201 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The method has 137 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,The method has 128 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The method has 102 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushChangesToNative,The method has 146 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The method has 176 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,UpdateGroupMembership,The method has 133 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberSearcher,The method has 105 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberEnum,The method has 127 lines of code.
Long Method,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextForeign,The method has 156 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,AccountControlToDirectoryEntry,The method has 101 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SDSCache,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSCache.cs,GetContext,The method has 128 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,The method has 107 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,PushChangesToNative,The method has 104 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindPrincipalByIdentRef,The method has 121 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,UpdateGroupMembership,The method has 110 lines of code.
Long Method,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextLocal,The method has 138 lines of code.
Complex Method,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,PrincipalContext,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ReadServerConfig,Cyclomatic complexity of the method is 9
Complex Method,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,Cyclomatic complexity of the method is 9
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadPropertyMappingTable,Cyclomatic complexity of the method is 28
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,SetCannotChangePasswordStatus,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,Move,Cyclomatic complexity of the method is 9
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,Cyclomatic complexity of the method is 13
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,Cyclomatic complexity of the method is 13
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,Cyclomatic complexity of the method is 11
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,DateTimeFilterBuilder,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushChangesToNative,Cyclomatic complexity of the method is 16
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,Cyclomatic complexity of the method is 10
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheToLdapConverter,Cyclomatic complexity of the method is 10
Complex Method,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,UpdateGroupMembership,Cyclomatic complexity of the method is 13
Complex Method,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,Reset,Cyclomatic complexity of the method is 13
Complex Method,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,BookmarkAndReset,Cyclomatic complexity of the method is 12
Complex Method,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,RestoreBookmark,Cyclomatic complexity of the method is 9
Complex Method,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,Dispose,Cyclomatic complexity of the method is 15
Complex Method,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,MultiStringToDirectoryEntryConverter,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.AccountManagement,RangeRetriever,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\RangeRetriever.cs,MoveNext,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,Cyclomatic complexity of the method is 10
Complex Method,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,PushChangesToNative,Cyclomatic complexity of the method is 11
Complex Method,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,UpdateGroupMembership,Cyclomatic complexity of the method is 10
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,IntADsOpenObject,The method has 6 parameters. Parameters: path' userName' password' flags' iid' ppObject
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,ADsOpenObject,The method has 6 parameters. Parameters: path' userName' password' flags' iid' ppObject
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,DsGetDcName,The method has 6 parameters. Parameters: computerName' domainName' domainGuid' siteName' flags' domainControllerInfo
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,CredUIParseUserName,The method has 5 parameters. Parameters: pszUserName' pszUser' ulUserMaxChars' pszDomain' ulDomainMaxChars
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,LookupAccountSid,The method has 7 parameters. Parameters: computerName' sid' name' nameLength' domainName' domainNameLength' usage
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,AuthzInitializeResourceManager,The method has 6 parameters. Parameters: flags' pfnAccessCheck' pfnComputeDynamicGroups' pfnFreeDynamicGroups' name' rm
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,AuthzInitializeContextFromSid,The method has 7 parameters. Parameters: Flags' UserSid' AuthzResourceManager' pExpirationTime' Identitifier' DynamicGroupArgs' pAuthzClientContext
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,AuthzGetInformationFromContext,The method has 5 parameters. Parameters: hAuthzClientContext' InfoClass' BufferSize' pSizeRequired' Buffer
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,GetTokenInformation,The method has 5 parameters. Parameters: tokenHandle' tokenInformationClass' buffer' bufferSize' returnLength
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,LsaLookupSids,The method has 5 parameters. Parameters: policyHandle' count' sids' referencedDomains' names
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,LogonUser,The method has 6 parameters. Parameters: lpszUsername' lpszDomain' lpszPassword' dwLogonType' dwLogonProvider' phToken
Long Parameter List,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,FormatMessageW,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' arguments
Long Parameter List,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,LookupSid,The method has 6 parameters. Parameters: serverName' credentials' sid' name' domainName' accountUsage
Long Parameter List,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,ConstructFakePrincipalFromSID,The method has 5 parameters. Parameters: sid' ctx' serverName' credentials' authorityName
Long Parameter List,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,PrincipalContext,The method has 5 parameters. Parameters: contextType' name' container' userName' password
Long Parameter List,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,PrincipalContext,The method has 6 parameters. Parameters: contextType' name' container' options' userName' password
Long Parameter List,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,FindByIdentityWithTypeHelper,The method has 5 parameters. Parameters: context' principalType' identityType' identityValue' refDate
Long Parameter List,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,PrincipalCollectionEnumerator,The method has 6 parameters. Parameters: resultSet' memberCollection' removedValuesCompleted' removedValuesPending' insertedValuesCompleted' insertedValuesPending
Long Parameter List,System.DirectoryServices.AccountManagement,AuthZSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthZSet.cs,AuthZSet,The method has 6 parameters. Parameters: userSid' credentials' contextOptions' flatUserAuthority' userStoreCtx' userCtxBase
Long Parameter List,System.DirectoryServices.AccountManagement,ConfigurationHandler,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\ConfigurationHandler.cs,RemoveEnumAttribute,The method has 5 parameters. Parameters: node' sectionName' attributeName' enumType' value
Long Parameter List,System.DirectoryServices.AccountManagement,ADDNConstraintLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNConstraintLinkedAttrSet.cs,ADDNConstraintLinkedAttrSet,The method has 8 parameters. Parameters: constraint' constraintData' groupDN' members' primaryGroupDN' queryMembersSearcher' recursive' storeCtx
Long Parameter List,System.DirectoryServices.AccountManagement,ADDNConstraintLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNConstraintLinkedAttrSet.cs,ADDNConstraintLinkedAttrSet,The method has 8 parameters. Parameters: constraint' constraintData' groupDN' membersSearcher' primaryGroupDN' primaryGroupMembersSearcher' recursive' storeCtx
Long Parameter List,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ADStoreCtx,The method has 5 parameters. Parameters: ctxBase' ownCtxBase' username' password' options
Long Parameter List,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,DateTimeFilterBuilder,The method has 5 parameters. Parameters: attributeName' searchValue' defaultValue' requirePresence' mt
Long Parameter List,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The method has 5 parameters. Parameters: principalType' urnScheme' urnValue' referenceDate' useSidHistory
Long Parameter List,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,DateTimeFromLdapConverter,The method has 5 parameters. Parameters: properties' suggestedAdProperty' p' propertyName' useAcctExpLogic
Long Parameter List,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ScanACLForChangePasswordRight,The method has 5 parameters. Parameters: adsSecurity' denySelfFound' denyWorldFound' allowSelfFound' allowWorldFound
Long Parameter List,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,BuildLdapFilterFromIdentityClaim,The method has 5 parameters. Parameters: urnValue' urnScheme' filter' useSidHistory' throwOnFail
Long Parameter List,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,ADDNLinkedAttrSet,The method has 6 parameters. Parameters: groupDN' members' primaryGroupDN' primaryGroupMembersSearcher' recursive' storeCtx
Long Parameter List,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,ADDNLinkedAttrSet,The method has 6 parameters. Parameters: groupDN' membersSearcher' primaryGroupDN' primaryGroupMembersSearcher' recursive' storeCtx
Long Parameter List,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,InsertPrincipal,The method has 6 parameters. Parameters: p' storeCtx' updateGroupMembership' credentials' authTypes' needToSetPassword
Long Parameter List,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ApplyChangesToDirectory,The method has 5 parameters. Parameters: p' storeCtx' updateGroupMembership' credentials' authTypes
Long Parameter List,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,WriteAttribute,The method has 5 parameters. Parameters: dePath' attribute' value' credentials' authTypes
Long Parameter List,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,WriteAttribute,The method has 5 parameters. Parameters: dePath' attribute' value' credentials' authTypes
Long Parameter List,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,AccountControlFromDirectoryEntry,The method has 5 parameters. Parameters: properties' suggestedProperty' p' propertyName' testCantChangePassword
Long Parameter List,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,AccountControlToDirectoryEntry,The method has 6 parameters. Parameters: p' propertyName' de' suggestedProperty' isSAM' isUnpersisted
Long Parameter List,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,ADAMStoreCtx,The method has 6 parameters. Parameters: ctxBase' ownCtxBase' username' password' serverName' options
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,The method has 5 parameters. Parameters: ctxBase' ownCtxBase' username' password' options
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,ExceptionToWinNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,StringToWinNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,MultiStringToWinNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,LogonHoursToWinNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,CertToWinNT,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,GroupTypeToWinNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,EmailToWinNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,AcctExpirDateToNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,UserFlagsToWinNTConverter,The method has 5 parameters. Parameters: p' propertyName' de' suggestedWinNTProperty' isLSAM
Long Parameter List,System.DirectoryServices.AccountManagement,SAMQuerySet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMQuerySet.cs,SAMQuerySet,The method has 6 parameters. Parameters: schemaTypes' entries' ctxBase' sizeLimit' storeCtx' samMatcher
Long Parameter List,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,SAMMembersSet,The method has 5 parameters. Parameters: groupPath' group' recursive' storeCtx' ctxBase
Long Identifier,System.DirectoryServices.AccountManagement,Constants,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,,The length of the parameter GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE is 45.
Long Identifier,System.DirectoryServices.AccountManagement,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,,The length of the parameter FORMAT_MESSAGE_ALLOCATE_BUFFER is 30.
Long Identifier,System.DirectoryServices.AccountManagement,AUTHZ_RM_FLAG,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\interopt.cs,,The length of the parameter AUTHZ_RM_FLAG_INITIALIZE_UNDER_IMPERSONATION is 44.
Long Identifier,System.DirectoryServices.AccountManagement,PropertyNames,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\constants.cs,,The length of the parameter PrincipalStructuralObjectClass is 30.
Long Identifier,System.DirectoryServices.AccountManagement,PropertyNames,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\constants.cs,,The length of the parameter AuthenticablePrincipalCertificates is 34.
Long Identifier,System.DirectoryServices.AccountManagement,PropertyNames,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\constants.cs,,The length of the parameter PwdInfoAllowReversiblePasswordEncryption is 40.
Long Identifier,System.DirectoryServices.AccountManagement,CapabilityMap,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,,The length of the parameter LDAP_CAP_ACTIVE_DIRECTORY_V51_OID is 33.
Long Identifier,System.DirectoryServices.AccountManagement,CapabilityMap,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,,The length of the parameter LDAP_CAP_ACTIVE_DIRECTORY_LDAP_INTEG_OID is 40.
Long Identifier,System.DirectoryServices.AccountManagement,CapabilityMap,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,,The length of the parameter LDAP_CAP_ACTIVE_DIRECTORY_ADAM_OID is 34.
Long Identifier,System.DirectoryServices.AccountManagement,CapabilityMap,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,,The length of the parameter LDAP_CAP_ACTIVE_DIRECTORY_PARTIAL_SECRETS_OID is 45.
Long Identifier,System.DirectoryServices.AccountManagement,CapabilityMap,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,,The length of the parameter LDAP_CAP_ACTIVE_DIRECTORY_V61_OID is 33.
Long Identifier,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,,The length of the parameter defaultContextOptionsNegotiate is 30.
Long Identifier,System.DirectoryServices.AccountManagement,StoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\StoreCtx.cs,,The length of the parameter authenticablePrincipalProperties is 32.
Long Identifier,System.DirectoryServices.AccountManagement,AuthenticablePrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthenticablePrincipal.cs,,The length of the parameter _certificateOriginalThumbprints is 31.
Long Identifier,System.DirectoryServices.AccountManagement,AuthenticablePrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthenticablePrincipal.cs,,The length of the parameter _X509Certificate2CollectionLoaded is 33.
Long Identifier,System.DirectoryServices.AccountManagement,AccountInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AccountInfo.cs,,The length of the parameter _smartcardLogonRequiredChanged is 30.
Long Identifier,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,,The length of the parameter _allowReversiblePasswordEncryption is 34.
Long Identifier,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,,The length of the parameter _allowReversiblePasswordEncryptionChanged is 41.
Long Identifier,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,,The length of the parameter ERROR_HRESULT_CONSTRAINT_VIOLATION is 34.
Long Identifier,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,,The length of the parameter s_propertyMappingTableByProperty is 32.
Long Identifier,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,,The length of the parameter NonPresentAttrDefaultStateMapping is 33.
Long Identifier,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,,The length of the parameter s_propertyMappingTableByPropertyFull is 36.
Long Identifier,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,,The length of the parameter _memberSearchResultsEnumerator is 30.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,PushChangesToNative,The length of the parameter propertyMappingTableByProperty is 30.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,Load,The length of the parameter propertyMappingTableByProperty is 30.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,,The length of the parameter s_userPropertyMappingTableByProperty is 36.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,,The length of the parameter s_userPropertyMappingTableByWinNT is 33.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,,The length of the parameter s_groupPropertyMappingTableByProperty is 37.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,,The length of the parameter s_groupPropertyMappingTableByWinNT is 34.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,,The length of the parameter s_computerPropertyMappingTableByProperty is 40.
Long Identifier,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,,The length of the parameter s_computerPropertyMappingTableByWinNT is 37.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalSearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalSearcher.cs,HasReferentialPropertiesSet,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalSearcher"' "HasReferentialPropertiesSet: using type " + t.ToString()); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalSearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalSearcher.cs,HasReferentialPropertiesSet,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Warn' "PrincipalSearcher"' "HasReferentialPropertiesSet: found ref property " + propertyName); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The length of the statement  "                if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) && " is 131.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The length of the statement  "                     ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f'))) " is 131.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,ClassifySID,The length of the statement  "                (UnsafeNativeMethods.SID_IDENTIFIER_AUTHORITY)Marshal.PtrToStructure(pIdentAuth' typeof(UnsafeNativeMethods.SID_IDENTIFIER_AUTHORITY)); " is 135.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,IsSamUser,The length of the statement  "            //      Get machine domain SID (via LsaOpenPolicy/LsaQueryInformationPolicy for PolicyAccountDomainInformation/LsaClose) " is 120.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,IsSamUser,The length of the statement  "                    // If user SID is the same domain as the machine domain' and the machine is not a DC then the user is a local (machine) user " is 124.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetCurrentUserSid,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetCurrentUserSid: GetTokenInformation (1st try) failed' gle=" + getTokenInfoError); " is 137.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetCurrentUserSid,The length of the statement  "                                      "GetCurrentUserSid: GetTokenInformation (2nd try) failed' neededBufferSize=" + neededBufferSize + "' gle=" + lastError); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetCurrentUserSid,The length of the statement  "                UnsafeNativeMethods.TOKEN_USER tokenUser = (UnsafeNativeMethods.TOKEN_USER)Marshal.PtrToStructure(pBuffer' typeof(UnsafeNativeMethods.TOKEN_USER)); " is 147.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetMachineDomainSid,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetMachineDomainSid: LsaOpenPolicy failed' gle=" + SafeNativeMethods.LsaNtStatusToWinError(err)); " is 150.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetMachineDomainSid,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetMachineDomainSid: LsaQueryInformationPolicy failed' gle=" + SafeNativeMethods.LsaNtStatusToWinError(err)); " is 162.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetDcName,The length of the statement  "                int err = UnsafeNativeMethods.DsGetDcName(computerName' domainName' IntPtr.Zero' siteName' flags' out domainControllerInfoPtr); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetDcName,The length of the statement  "                    (UnsafeNativeMethods.DomainControllerInfo)Marshal.PtrToStructure(domainControllerInfoPtr' typeof(UnsafeNativeMethods.DomainControllerInfo)); " is 140.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,LookupSid,The length of the statement  "                bool f = UnsafeNativeMethods.LookupAccountSid(serverName' pSid' null' ref nameLength' null' ref domainNameLength' ref accountUsage); " is 132.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,LookupSid,The length of the statement  "                f = UnsafeNativeMethods.LookupAccountSid(serverName' pSid' sbName' ref nameLength' sbDomainName' ref domainNameLength' ref accountUsage); " is 137.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,BeginImpersonation,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "BeginImpersonation: ImpersonateLoggedOnUser failed' gle=" + lastError); " is 124.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,IsMachineDC,The length of the statement  "                    err = UnsafeNativeMethods.DsRoleGetPrimaryDomainInformation(null' UnsafeNativeMethods.DSROLE_PRIMARY_DOMAIN_INFO_LEVEL.DsRolePrimaryDomainInfoBasic' out dsRoleInfoPtr); " is 168.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,IsMachineDC,The length of the statement  "                    err = UnsafeNativeMethods.DsRoleGetPrimaryDomainInformation(computerName' UnsafeNativeMethods.DSROLE_PRIMARY_DOMAIN_INFO_LEVEL.DsRolePrimaryDomainInfoBasic' out dsRoleInfoPtr); " is 176.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,IsMachineDC,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "IsMachineDC: DsRoleGetPrimaryDomainInformation failed' err=" + err); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,IsMachineDC,The length of the statement  "                    (UnsafeNativeMethods.DSROLE_PRIMARY_DOMAIN_INFO_BASIC)Marshal.PtrToStructure(dsRoleInfoPtr' typeof(UnsafeNativeMethods.DSROLE_PRIMARY_DOMAIN_INFO_BASIC)); " is 154.
Long Statement,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,IsMachineDC,The length of the statement  "                return (dsRolePrimaryDomainInfo.MachineRole == UnsafeNativeMethods.DSROLE_MACHINE_ROLE.DsRole_RoleBackupDomainController || " is 123.
Long Statement,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,BindSam,The length of the statement  "                int hr = UnsafeNativeMethods.ADsOpenObject(adsPath.ToString()' userName' password' (int)authenticationType' ref g' out value); " is 126.
Long Statement,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,BindLdap,The length of the statement  "                _directoryIdent = new LdapDirectoryIdentifier(_serverProperties.dnsHostName' useSSL ? _serverProperties.portSSL : _serverProperties.portLDAP); " is 142.
Long Statement,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,BindLdap,The length of the statement  "                _directoryIdent = new LdapDirectoryIdentifier(_serverName' useSSL ? LdapConstants.LDAP_SSL_PORT : LdapConstants.LDAP_PORT); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,BindLdap,The length of the statement  "            // If we are performing fastConcurrentBind there is no need to prevent multithreadaccess.  FSB is thread safe and multi cred safe " is 129.
Long Statement,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,BindLdap,The length of the statement  "            // FSB also always has the same contextoptions so there is no need to lock the code that is modifying the current connection " is 124.
Long Statement,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,Validate,The length of the statement  "                    if (_lastBindMethod == AuthMethod.Simple && (_fastConcurrentSupported || _contextType == ContextType.ApplicationDirectory)) " is 123.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoServerVerifyAndPropRetrieval,The length of the statement  "                    throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' SR.PassedContextTypeDoesNotMatchDetectedType' _serverProperties.contextType.ToString())); " is 159.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInit,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalContext"' "DoLDAPDirectoryInit: authTypes is " + authTypes.ToString()); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInitNoContainer,The length of the statement  "            byte[] USERS_CONTAINER_GUID = new byte[] { 0xa9' 0xd1' 0xca' 0x15' 0x76' 0x88' 0x11' 0xd1' 0xad' 0xed' 0x00' 0xc0' 0x4f' 0xd8' 0xd5' 0xcd }; " is 140.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInitNoContainer,The length of the statement  "            byte[] COMPUTERS_CONTAINER_GUID = new byte[] { 0xaa' 0x31' 0x28' 0x25' 0x76' 0x88' 0x11' 0xd1' 0xad' 0xed' 0x00' 0xc0' 0x4f' 0xd8' 0xd5' 0xcd }; " is 144.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInitNoContainer,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalContext"' "DoLDAPDirectoryInitNoContainer: serverName is " + serverName); " is 125.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInitNoContainer,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalContext"' "DoLDAPDirectoryInitNoContainer: authTypes is " + authTypes.ToString()); " is 134.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInitNoContainer,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalContext"' "DoLDAPDirectoryInitNoContainer: domainNC is " + domainNC); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,DoLDAPDirectoryInitNoContainer,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalContext"' "DoLDAPDirectoryInitNoContainer: adsPathBase is " + adsPathBase); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ReadServerConfig,The length of the statement  "            string[] proplist = new string[] { "msDS-PortSSL"' "msDS-PortLDAP"' "domainControllerFunctionality"' "dnsHostName"' "supportedCapabilities" }; " is 142.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ReadServerConfig,The length of the statement  "                    properties.OsVersion = (DomainControllerMode)Convert.ToInt32(searchResponse.Entries[0].Attributes["domainControllerFunctionality"][0]' CultureInfo.InvariantCulture); " is 165.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ReadServerConfig,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ReadServerConfig"' "portSSL : " + properties.portSSL.ToString(CultureInfo.InvariantCulture)); " is 136.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ReadServerConfig,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ReadServerConfig"' "portLDAP :" + properties.portLDAP.ToString(CultureInfo.InvariantCulture)); " is 137.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,CreateContextFromDirectoryEntry,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalContext"' "CreateContextFromDirectoryEntry: path is " + entry.Path); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ContextForType,The length of the statement  "            if (t == typeof(System.DirectoryServices.AccountManagement.UserPrincipal) || t.IsSubclassOf(typeof(System.DirectoryServices.AccountManagement.UserPrincipal))) " is 158.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ContextForType,The length of the statement  "            else if (t == typeof(System.DirectoryServices.AccountManagement.ComputerPrincipal) || t.IsSubclassOf(typeof(System.DirectoryServices.AccountManagement.ComputerPrincipal))) " is 171.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ContextForType,The length of the statement  "            else if (t == typeof(System.DirectoryServices.AccountManagement.AuthenticablePrincipal) || t.IsSubclassOf(typeof(System.DirectoryServices.AccountManagement.AuthenticablePrincipal))) " is 181.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ContextForType,The length of the statement  "                Debug.Assert(t == typeof(System.DirectoryServices.AccountManagement.GroupPrincipal) || t.IsSubclassOf(typeof(System.DirectoryServices.AccountManagement.GroupPrincipal))); " is 170.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,Save,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "Principal"' "Save: inserting principal of type {0} using {1}"' this.GetType()' storeCtxToUse.GetType()); " is 147.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,Save,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "Principal"' "Save: updating principal of type {0} using {1}"' this.GetType()' storeCtxToUse.GetType()); " is 146.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,Save,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "Principal"' "Save(context): inserting new principal of type {0} using {1}"' this.GetType()' newStoreCtx.GetType()); " is 158.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,Save,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "Principal"' "Save(context): Moving principal of type {0} using {1}"' this.GetType()' newStoreCtx.GetType()); " is 151.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,Save,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Error' "Principal"' "Save(context):'  Update Failed (attempting to move back) Exception {0} "' e.Message); " is 142.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,FindByIdentityWithTypeHelper,The length of the statement  "            Principal p = context.QueryCtx.FindPrincipalByIdentRef(principalType' (identityType == null) ? null : (string)IdentMap.StringMap[(int)identityType' 1]' identityValue' refDate); " is 176.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,LoadValueIntoProperty,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "Principal"' "LoadValueIntoProperty: name=" + propertyName + " value=" + (value == null ? "null" : value.ToString())); " is 160.
Long Statement,System.DirectoryServices.AccountManagement,Principal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Principal.cs,GetValueForProperty,The length of the statement  "                    Debug.Fail(String.Format(CultureInfo.CurrentCulture' "Principal.GetValueForProperty: Ran off end of list looking for {0}"' propertyName)); " is 138.
Long Statement,System.DirectoryServices.AccountManagement,AuthenticablePrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthenticablePrincipal.cs,GetChangeStatusForProperty,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthenticablePrincipal"' "GetChangeStatusForProperty: name=" + propertyName); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,AuthenticablePrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthenticablePrincipal.cs,LoadCertificateCollection,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthenticablePrincipal"' "LoadCertificateCollection: loading {0} certs"' certificatesToLoad.Count); " is 142.
Long Statement,System.DirectoryServices.AccountManagement,AuthenticablePrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthenticablePrincipal.cs,RefreshOriginalThumbprintList,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthenticablePrincipal"' "RefreshOriginalThumbprintList: resetting thumbprints"); " is 124.
Long Statement,System.DirectoryServices.AccountManagement,AuthenticablePrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthenticablePrincipal.cs,HasCertificateCollectionChanged,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthenticablePrincipal"' "RefreshOriginalThumbprintList: found inserted cert"); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,UserPrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\User.cs,LoadValueIntoProperty,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "User"' "LoadValueIntoProperty: name=" + propertyName + " value=" + value.ToString()); " is 128.
Long Statement,System.DirectoryServices.AccountManagement,UserPrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\User.cs,ResetAllChangeStatus,The length of the statement  "            _voiceTelephoneNumberChanged = (_voiceTelephoneNumberChanged == LoadState.Changed) ? LoadState.Loaded : LoadState.NotSet; ; " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ComputerPrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Computer.cs,LoadValueIntoProperty,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "Computer"' "LoadValueIntoProperty: name=" + propertyName + " value=" + (value == null ? "null" : value.ToString())); " is 159.
Long Statement,System.DirectoryServices.AccountManagement,GroupPrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Group.cs,GetMembers,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "Group"' "GetMembers: persisted' querying for members (recursive={0}"' recursive); " is 124.
Long Statement,System.DirectoryServices.AccountManagement,GroupPrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Group.cs,LoadValueIntoProperty,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "Group"' "LoadValueIntoProperty: name=" + propertyName + " value=" + (value != null ? value.ToString() : "null")); " is 156.
Long Statement,System.DirectoryServices.AccountManagement,GroupPrincipal,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Group.cs,IsSmallGroup,The length of the statement  "                using (DirectorySearcher ds = new DirectorySearcher(de' "(objectClass=*)"' new string[] { "member" }' SearchScope.Base)) " is 120.
Long Statement,System.DirectoryServices.AccountManagement,AccountInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AccountInfo.cs,LoadValueIntoProperty,The length of the statement  "            //            GlobalDebug.WriteLineIf(GlobalDebug.Info' "AccountInfo"' "LoadValueIntoProperty: name=" + propertyName + " value=" + value.ToString()); " is 149.
Long Statement,System.DirectoryServices.AccountManagement,AccountInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AccountInfo.cs,LoadValueIntoProperty,The length of the statement  "                    Debug.Fail(String.Format(CultureInfo.CurrentCulture' "AccountInfo.LoadValueIntoProperty: fell off end looking for {0}"' propertyName)); " is 135.
Long Statement,System.DirectoryServices.AccountManagement,AccountInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AccountInfo.cs,GetChangeStatusForProperty,The length of the statement  "                    Debug.Fail(String.Format(CultureInfo.CurrentCulture' "AccountInfo.GetChangeStatusForProperty: fell off end looking for {0}"' propertyName)); " is 140.
Long Statement,System.DirectoryServices.AccountManagement,AccountInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AccountInfo.cs,GetValueForProperty,The length of the statement  "                    Debug.Fail(String.Format(CultureInfo.CurrentCulture' "AccountInfo.GetValueForProperty: fell off end looking for {0}"' propertyName)); " is 133.
Long Statement,System.DirectoryServices.AccountManagement,AccountInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AccountInfo.cs,ResetAllChangeStatus,The length of the statement  "            _smartcardLogonRequiredChanged = (_smartcardLogonRequiredChanged == LoadState.Changed) ? LoadState.Loaded : LoadState.NotSet; " is 125.
Long Statement,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,LoadValueIntoProperty,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "PasswordInfo"' "LoadValueIntoProperty: name=" + propertyName + " value=" + value.ToString()); " is 136.
Long Statement,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,LoadValueIntoProperty,The length of the statement  "                    Debug.Fail(String.Format(CultureInfo.CurrentCulture' "PasswordInfo.LoadValueIntoProperty: fell off end looking for {0}"' propertyName)); " is 136.
Long Statement,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,GetChangeStatusForProperty,The length of the statement  "                    Debug.Fail(String.Format(CultureInfo.CurrentCulture' "PasswordInfo.GetChangeStatusForProperty: fell off end looking for {0}"' propertyName)); " is 141.
Long Statement,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,GetValueForProperty,The length of the statement  "                    Debug.Fail(String.Format(CultureInfo.CurrentCulture' "PasswordInfo.GetValueForProperty: fell off end looking for {0}"' propertyName)); " is 134.
Long Statement,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,ResetAllChangeStatus,The length of the statement  "            _passwordNeverExpiresChanged = (_passwordNeverExpiresChanged == LoadState.Changed) ? LoadState.Loaded : LoadState.NotSet; " is 121.
Long Statement,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,ResetAllChangeStatus,The length of the statement  "            _cannotChangePasswordChanged = (_cannotChangePasswordChanged == LoadState.Changed) ? LoadState.Loaded : LoadState.NotSet; " is 121.
Long Statement,System.DirectoryServices.AccountManagement,PasswordInfo,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PasswordInfo.cs,ResetAllChangeStatus,The length of the statement  "            _allowReversiblePasswordEncryptionChanged = (_allowReversiblePasswordEncryptionChanged == LoadState.Changed) ? LoadState.Loaded : LoadState.NotSet; " is 147.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollection.cs,Remove,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollection"' "Remove: making it a pending remove' removed={0}"' removed); " is 125.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollectionEnumerator"' "MoveNext: None mode' starting with existing values"); " is 129.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollectionEnumerator"' "MoveNext: None mode' skipping existing values"); " is 124.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "                                GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollectionEnumerator"' "MoveNext: ResultSet mode' found remove' skipping"); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "                                GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollectionEnumerator"' "MoveNext: ResultSet mode' found insert' skipping"); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollectionEnumerator"' "MoveNext: ResultSet mode' moving to InsValuesComp mode"); " is 133.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollectionEnumerator"' "MoveNext: InsValuesComp mode' moving to InsValuesPend mode"); " is 137.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalCollectionEnumerator"' "MoveNext: InsValuesPend mode' nothing left"); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalCollectionEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalCollectionEnumerator.cs,MoveNext,The length of the statement  "            Debug.Fail(String.Format(CultureInfo.CurrentCulture' "PrincipalCollectionEnumerator.MoveNext: fell off end of function' mode = {0}"' _currentMode.ToString())); " is 159.
Long Statement,System.DirectoryServices.AccountManagement,TrackedCollectionEnumerator<T>,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\TrackedCollectionEnumerator.cs,MoveNext,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "TrackedCollectionEnumerator"' "MoveNext: current ({0}) is inserted"' _current); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,TrackedCollectionEnumerator<T>,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\TrackedCollectionEnumerator.cs,MoveNext,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "TrackedCollectionEnumerator"' "MoveNext: current ({0}) is original"' _current); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalValueCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\ValueCollection.cs,IndexOf,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalValueCollection"' "IndexOf: found {0} on inserted at {1}"' value' index); " is 125.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalValueCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\ValueCollection.cs,IndexOf,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "PrincipalValueCollection"' "IndexOf: found {0} on original at {1}"' value' index); " is 125.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalValueCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\ValueCollection.cs,Insert,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Warn' "PrincipalValueCollection"' "Insert({0}): out of range (count={1})"' index' _inner.combinedValues.Count); " is 147.
Long Statement,System.DirectoryServices.AccountManagement,PrincipalValueCollection<T>,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\ValueCollection.cs,RemoveAt,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Warn' "PrincipalValueCollection"' "RemoveAt({0}): out of range (count={1})"' index' _inner.combinedValues.Count); " is 149.
Long Statement,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetExceptionFromCOMException,The length of the statement  "            else if (errorCode == unchecked((int)0x800708c5) || errorCode == unchecked((int)0x80070056) || errorCode == unchecked((int)0x8007052)) " is 134.
Long Statement,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetExceptionFromCOMException,The length of the statement  "                // Password does not meet complexity requirements or old password does not match or policy restriction has been enforced. " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetExceptionFromCOMException,The length of the statement  "            else if ((errorCode == unchecked((int)0x8007203a)) || (errorCode == unchecked((int)0x8007200e)) || (errorCode == unchecked((int)0x8007200f))) " is 141.
Long Statement,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetExceptionFromErrorCode,The length of the statement  "            else if ((errorCode == s_ERROR_NOT_ENOUGH_MEMORY) || (errorCode == s_ERROR_OUTOFMEMORY) || (errorCode == s_ERROR_DS_DRA_OUT_OF_MEM) || (errorCode == s_RPC_S_OUT_OF_RESOURCES)) " is 175.
Long Statement,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetExceptionFromErrorCode,The length of the statement  "            else if ((errorCode == s_ERROR_NO_LOGON_SERVERS) || (errorCode == s_ERROR_NO_SUCH_DOMAIN) || (errorCode == RPC_S_SERVER_UNAVAILABLE) || (errorCode == RPC_S_CALL_FAILED)) " is 169.
Long Statement,System.DirectoryServices.AccountManagement,AuthZSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthZSet.cs,MoveNext,The length of the statement  "                    if (Utils.ClassifySID(pSid) == SidType.RealObject && UnsafeNativeMethods.EqualDomainSid(_psUserSid.DangerousGetHandle()' pSid' ref sameDomain)) " is 143.
Long Statement,System.DirectoryServices.AccountManagement,ExtensionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\ExtensionHelper.cs,ReadStructuralObjectClass,The length of the statement  "            (DirectoryObjectClassAttribute[])Attribute.GetCustomAttributes(principalType' typeof(DirectoryObjectClassAttribute)' false); " is 124.
Long Statement,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The length of the statement  "                                (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)); " is 124.
Long Statement,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The length of the statement  "                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)); " is 204.
Long Statement,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The length of the statement  "                    domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)); " is 146.
Long Statement,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The length of the statement  "                    pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION))); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADDNConstraintLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNConstraintLinkedAttrSet.cs,MoveNext,The length of the statement  "                                    Debug.Fail("ADStoreCtx.ADDNConstraintLinkedAttrSet: Invalid constraint data. Expected: object of type ResultValidator"); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,Insert,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "Insert: new GUID is "' ((DirectoryEntry)p.UnderlyingObject).Guid); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,Insert,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Error' "ADStoreCtx"' "Insert'  Save Failed (attempting to delete) Exception {0} "' e.Message); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,SetPasswordSecurityifNeccessary,The length of the statement  "                SetCannotChangePasswordStatus((AuthenticablePrincipal)p' (bool)p.GetValueForProperty(PropertyNames.PwdInfoCannotChangePassword)' true); " is 135.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,SetCannotChangePasswordStatus,The length of the statement  "            ScanACLForChangePasswordRight(adsSecurity' out denySelfFound' out denyWorldFound' out allowSelfFound' out allowWorldFound); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,SetAuthPrincipalEnableStatus,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADStoreCtx"' "SetAuthPrincipalEnableStatus: Enabling (old uac={0})"' uacValue); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,SetAuthPrincipalEnableStatus,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADStoreCtx"' "SetAuthPrincipalEnableStatus: Disabling (old uac={0})"' uacValue); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,Move,The length of the statement  "                    (DirectoryRdnPrefixAttribute[])Attribute.GetCustomAttributes(principalType.BaseType' typeof(DirectoryRdnPrefixAttribute)' false); " is 129.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,Move,The length of the statement  "                ((DirectoryEntry)p.GetUnderlyingObject()).Properties[baseObjectRdnPrefix].Value = (string)p.GetValueForProperty(PropertyNames.PrincipalName); " is 141.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsLockedOut,The length of the statement  "                        ulong lockoutTime = (ulong)ADUtils.LargeIntToInt64((UnsafeNativeMethods.IADsLargeInteger)de.Properties["lockoutTime"][0]); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                if ((p.ContextType == ContextType.ApplicationDirectory) || (p.Context.ServerInformation.OsVersion == DomainControllerMode.Win2k)) " is 129.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    // A users group membership that applies to a particular domain includes the domain's universal' local and global groups plus the  " is 129.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    // universal groups from every other domain in the forest that the user is a member of.  To get this list we must contact both a GlobalCatalog to get the forest " is 160.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    // then we don't also need a DC because the domain local group memberships will show up as well.  The enumerator code that expands these lists must detect  " is 154.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    Forest forest = Forest.GetForest(new DirectoryContext(DirectoryContextType.Forest' this.DnsForestName' this.credentials != null ? this.credentials.UserName : null' this.credentials != null ? this.credentials.Password : null)); " is 226.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    DirectoryContext dc = new DirectoryContext(DirectoryContextType.Domain' this.DnsDomainName' this.credentials != null ? this.credentials.UserName : null' this.credentials != null ? this.credentials.Password : null); " is 214.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                        roots.Add(new DirectoryEntry("GC://" + gc.Name + "/" + p.DistinguishedName' this.credentials != null ? this.credentials.UserName : null' this.credentials != null ? this.credentials.Password : null' this.AuthTypes)); " is 215.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                            //In that case de is NOT owned by any other modules outside. Hence' configure RangeRetriever to dispose the DirEntry on its dispose.  " is 132.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "            //  If we can read the defaultNamingContext and retrive the well known path for the foreignSecurityPrincipal container start there. " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                        dncContainer = new DirectoryEntry(@"LDAP://" + this.UserSuppliedServerName + @"/" + this.DefaultNamingContext' Credentials != null ? this.Credentials.UserName : null' Credentials != null ? this.Credentials.Password : null' this.AuthTypes); " is 239.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): Read DNC of {0}"' this.DefaultNamingContext); " is 126.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                        fspWkDn = ADUtils.RetriveWkDn(dncContainer' this.DefaultNamingContext' this.UserSuppliedServerName' Constants.GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE); " is 157.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                            fspContainer = new DirectoryEntry(fspWkDn' Credentials != null ? this.credentials.UserName : null' Credentials != null ? this.credentials.Password : null' this.authTypes); " is 171.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    ds = new DirectorySearcher((fspContainer != null) ? fspContainer : ((dncContainer != null ? dncContainer : this.ctxBase))); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): primary group DN={0}"' primaryGroupDN); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    resultSet = new ADDNConstraintLinkedAttrSet(ADDNConstraintLinkedAttrSet.ConstraintType.ContainerStringMatch' this.ctxBase.Properties["distinguishedName"].Value' principalDN' new IEnumerable[] { memberOf }' primaryGroupDN' null' false' this); " is 241.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                    // We don't need to retrive the Primary group ID here because we have already established that this user is not from this domain " is 128.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOfAZ,The length of the statement  "                if (true == ADUtils.VerifyOutboundTrust(this.DnsDomainName' (this.credentials == null ? null : this.credentials.UserName)' (this.credentials == null ? null : this.credentials.Password))) " is 186.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetDirectorySearcherFromGroupID,The length of the statement  "            ds.Filter = GetObjectClassPortion(typeof(Principal)) + "(primaryGroupId=" + groupRid.ToString(CultureInfo.InvariantCulture) + "))"; " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,The length of the statement  "            UnsafeNativeMethods.IADsGroup adsGroup = (UnsafeNativeMethods.IADsGroup)((DirectoryEntry)g.UnderlyingObject).NativeObject; " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,The length of the statement  "            IEnumerable cachedMembersEnum = null; //This variables stores a reference to the direct members enumerator of the group. " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,The length of the statement  "                // the property list for the searcher of a group has "member" attribute. if there are more results than MaxValRange' there will also be a "member;range=..." attribute                " is 166.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,The length of the statement  "                    // small groups has special search object that holds the member attribute so we use it for our search (no need to use the DirectoryEntry) " is 137.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,The length of the statement  "                    if ((g.SmallGroupMemberSearchResult != null) && g.SmallGroupMemberSearchResult.Properties["member"].Contains(principalDN)) " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,CanGroupMemberBeRemoved,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "CanGroupMemberBeRemoved: member is not a domain or application directory principal"); " is 142.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The length of the statement  "            using (DirectoryEntry rootDse = new DirectoryEntry("LDAP://" + this.dnsHostName + "/rootDse"' ""' ""' AuthenticationTypes.Anonymous)) " is 133.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The length of the statement  "                long negativeLockoutDuration = ADUtils.LargeIntToInt64((UnsafeNativeMethods.IADsLargeInteger)domainNC.Properties["lockoutDuration"][0]); " is 136.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using lockout duration {0}"' lockoutDuration); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using user-supplied name {0}"' this.userSuppliedServerName); " is 135.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,BuildExtensionPropertyList,The length of the statement  "                DirectoryPropertyAttribute[] pAttributeList = (DirectoryPropertyAttribute[])(pInfo.GetCustomAttributes(typeof(DirectoryPropertyAttribute)' true)); " is 146.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushFilterToNativeSearcher,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "PushFilterToNativeSearcher: creating fresh DirectorySearcher"); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushFilterToNativeSearcher,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "PushFilterToNativeSearcher: using {0} filters"' filters.FiltersToApply.Count); " is 135.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushFilterToNativeSearcher,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "PushFilterToNativeSearcher: using LDAP filter {0}"' ds.Filter); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetObjectClassPortion,The length of the statement  "                ldapFilter = "(&(objectCategory=user)(objectClass=user)";   // objCat because we don't want to match on computer accounts " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,DefaultValutMatchingDateTimeConverter,The length of the statement  "            return (DateTimeFilterBuilder(suggestedAdProperty' (DateTime)qmt.Value' LdapConstants.defaultUtcTime' false' qmt.Match)); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LastLogonConverter,The length of the statement  "            sb.Append(DateTimeFilterBuilder("lastLogonTimestamp"' (DateTime)qmt.Value' LdapConstants.defaultUtcTime' true' qmt.Match)); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionTypeConverter,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionTypeConverter collection filter type " + o.GetType().ToString()); " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheConverter,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheConverter match type " + kvp.Value.MatchType.ToString()); " is 128.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheConverter,The length of the statement  "                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheConverter collection filter type " + o.GetType().ToString()); " is 132.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheConverter,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheConverter complete built filter  " + query.ToString()); " is 126.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushChangesToNative,The length of the statement  "                        // For the base objects ( User' Computer and Group ) Their RDNPrefix is a required field along with the RDNPrefix for the " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushChangesToNative,The length of the statement  "                        // derived object.  This is only done for classes that derive from User' Computer or Group.  If a user derives his own class from AuthPrincipal " is 143.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushChangesToNative,The length of the statement  "                            (DirectoryRdnPrefixAttribute[])Attribute.GetCustomAttributes(principalType.BaseType' typeof(DirectoryRdnPrefixAttribute)' false); " is 129.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushChangesToNative,The length of the statement  "                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "PushChangesToNative: pushing {0}"' propertyEntry.propertyName); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetAsPrincipal,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetAsPrincipal: using path={0}"' (null != de ? de.Path : "searchResult")); " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetAsPrincipal,The length of the statement  "                // if the object is not from a GC but belongs to another domain' we just have to construct a new context. We can still use the storeObject or searchresult's DirectoryEntry. " is 172.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetAsPrincipal,The length of the statement  "                // if our context is not a domain (that is' it's ADLDS) we don't build a new context unless the object was obtained from a GC.  " is 126.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetAsPrincipal,The length of the statement  "                        (!String.IsNullOrEmpty(this.domainDnsName) && String.Compare(this.DnsDomainName' dnsDomainName' StringComparison.OrdinalIgnoreCase) != 0)) " is 138.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetAsPrincipal,The length of the statement  "                        dcEntry = SDSUtils.BuildDirectoryEntry("LDAP://" + dnsDomainName + "/" + GetEscapedDN(distinguishedName)' this.Credentials' this.authTypes); " is 140.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetAsPrincipal,The length of the statement  "                    p = SDSUtils.DirectoryEntryToPrincipal((targetIsFromGC ? dcEntry : de)' constructedContext ?? this.OwningContext' (Type)discriminant); " is 134.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,Load,The length of the statement  "            // We don't support this property and cannot load it.  To maintain backward compatibility with the old code just return. " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,Load,The length of the statement  "                        entry.ldapToPapiConverter(new dSPropertyCollection(de.Properties)' entry.suggestedADPropertyName' p' entry.propertyName); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The length of the statement  "                // i.e. if the objects objectClass is User we will construct a UserPrincipal even though they searched for Principal.FindByIdentity " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The length of the statement  "                // At this time we don't know the actual object type so we have to ask AD for all the attributes of the derived types so they are there " is 135.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The length of the statement  "                         (principalType == typeof(Principal) || principalType == typeof(GroupPrincipal) || principalType.IsSubclassOf(typeof(GroupPrincipal)))) " is 134.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The length of the statement  "                    if (principalType == typeof(Principal) || principalType == typeof(GroupPrincipal) || principalType.IsSubclassOf(typeof(GroupPrincipal))) " is 136.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "FindPrincipalByIdentRefHelper: using LDAP filter {0}"' ds.Filter); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,CannotChangePwdFromLdapConverter,The length of the statement  "            ScanACLForChangePasswordRight(adsSecurity' out denySelfFound' out denyWorldFound' out allowSelfFound' out allowWorldFound); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,CannotChangePwdFromLdapConverter,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADStoreCtx"' "CannotChangePwdFromLdapConverter: fallback' assume user can change pwd"); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ScanACLForChangePasswordRight,The length of the statement  "            foreach (ActiveDirectoryAccessRule rule in adsSecurity.GetAccessRules(true' true' typeof(MACLPrinc.SecurityIdentifier))) " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheToLdapConverter,The length of the statement  "                    // Single collection ( .Length == 1 ) &&  typeof(array[0] == ICollection ) && typeof(array[0][0] != ICollection or IList ) " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheToLdapConverter,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheToLdapConverter - Value Type " + kvp.Value.Value.GetType().ToString()); " is 142.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheToLdapConverter,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheToLdapConverter - Value implements ICollection"); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheToLdapConverter,The length of the statement  "                                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheToLdapConverter - Element Value Type " + oVal.GetType().ToString()); " is 139.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheToLdapConverter,The length of the statement  "                                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheToLdapConverter - Adding  Element " + oVal.ToString()); " is 126.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionCacheToLdapConverter,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "ExtensionCacheToLdapConverter - Adding " + kvp.Value.Value.ToString()); " is 128.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GroupTypeToLdapConverter,The length of the statement  "                groupTypeCombined = unchecked((int)(0x80000000 | 0x00000002));  //  GROUP_TYPE_SECURITY_ENABLED | GROUP_TYPE_ACCOUNT_GROUP " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,UpdateGroupMembership,The length of the statement  "                    // Since we are using PropertyValueCollection to do the item removal we are constrainted to items that are in the collection " is 124.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,UpdateGroupMembership,The length of the statement  "                    // For principals that are in the same forest just use their DN to do the removal.  This is how they are represented in the member attr. " is 136.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,UpdateGroupMembership,The length of the statement  "                    // For foreign principals we must represent them with their SID binding string since they are locally represented by an FSP object. " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,UpdateGroupMembership,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "UpdateGroupMembership: remove via DN {0}"' member.DistinguishedName); " is 126.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextPrimaryGroupDN,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextMemberSearcher: returning primary group {0}"' ((DirectoryEntry)this.current).Path); " is 155.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberSearcher,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextMemberSearcher: got a value from the enumerator: {0}"' memberDN); " is 137.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberSearcher,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextMemberSearcher: foreign principal' adding to foreignMembers"); " is 134.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberSearcher,The length of the statement  "                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextMemberSearcher: recursively processing {0}"' groupDN); " is 126.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberSearcher,The length of the statement  "                            DirectoryEntry groupDE = SDSUtils.BuildDirectoryEntry(BuildPathFromDN(groupDN)' _storeCtx.Credentials' _storeCtx.AuthTypes); " is 124.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberEnum,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextMemberEnum: got a value from the enumerator: {0}"' memberDN); " is 133.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberEnum,The length of the statement  "                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextMemberEnum: foreign principal' adding to foreignMembers"); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextMemberEnum,The length of the statement  "                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextMemberEnum: recursively processing {0}"' groupDN); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextForeign,The length of the statement  "                    foreignPrincipal = _storeCtx.ConstructFakePrincipalFromSID((Byte[])_fakePrincipalMembers[0].Properties["objectSid"].Value); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextForeign,The length of the statement  "                            UnknownPrincipal unknownPrincipal = UnknownPrincipal.CreateUnknownPrincipal(_storeCtx.OwningContext' sid' foreignSid.name); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextForeign,The length of the statement  "                        PrincipalContext remoteCtx = SDSCache.Domain.GetContext(foreignSid.sidIssuerName' _storeCtx.Credentials' remoteOptions); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextForeign,The length of the statement  "                        // Determine the domainFunctionalityMode of the foreign domain.  If they are W2k or not a global group then we can't use ASQ.                     " is 125.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,MoveNextForeign,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "MoveNextForeign: using as currentForeignDE/currentForeignPrincipal"); " is 133.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,ExpandForeignGroupEnumerator,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "ExpandForeignGroupEnumerator: recursively processing {0}"' groupDN); " is 132.
Long Statement,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,ExpandForeignGroupSearcher,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADDNLinkedAttrSet"' "ExpandForeignGroupSearcher: recursively processing {0}"' groupDN); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,HexStringToLdapHexString,The length of the statement  "                if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) && " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,HexStringToLdapHexString,The length of the statement  "                     ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f'))) " is 131.
Long Statement,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,VerifyOutboundTrust,The length of the statement  "            Domain targetdom = Domain.GetDomain(new DirectoryContext(DirectoryContextType.Domain' targetDomain' username' password)); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,RetriveWkDn,The length of the statement  "                                return @"LDAP://" + this.UserSuppliedServerName + @"/<WKGUID= " + Constants.GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_W + @"'" + this.DefaultNamingContext + @">"; " is 161.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,IsOfObjectClass,The length of the statement  "            Debug.Assert(sr.Path.StartsWith("LDAP:"' StringComparison.Ordinal) || sr.Path.StartsWith("GC:"' StringComparison.Ordinal)); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ApplyChangesToDirectory,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Error' "SDSUtils"' "ApplyChangesToDirectory: caught COMException with message " + e.Message); " is 129.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,SetPassword,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Error' "SDSUtils"' "SetPassword: caught TargetInvocationException with message " + e.Message); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,SetPassword,The length of the statement  "                    if (((System.Runtime.InteropServices.COMException)e.InnerException).ErrorCode == unchecked((int)ExceptionHelper.ERROR_HRESULT_CONSTRAINT_VIOLATION)) " is 148.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,SetPassword,The length of the statement  "                        throw (new PasswordException(((System.Runtime.InteropServices.COMException)e.InnerException).Message' (System.Runtime.InteropServices.COMException)e.InnerException)); " is 166.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ChangePassword,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Error' "SDSUtils"' "ChangePassword: caught TargetInvocationException with message " + e.Message); " is 133.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ChangePassword,The length of the statement  "                    if (((System.Runtime.InteropServices.COMException)e.InnerException).ErrorCode == unchecked((int)ExceptionHelper.ERROR_HRESULT_CONSTRAINT_VIOLATION)) " is 148.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ChangePassword,The length of the statement  "                        throw (new PasswordException(((System.Runtime.InteropServices.COMException)e.InnerException).Message' (System.Runtime.InteropServices.COMException)e.InnerException)); " is 166.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,AccountControlFromDirectoryEntry,The length of the statement  "                (!testCantChangePassword && (String.Compare(suggestedProperty' "userAccountControl"' StringComparison.OrdinalIgnoreCase) == 0)) || " is 130.
Long Statement,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,AccountControlFromDirectoryEntry,The length of the statement  "            Debug.Assert((String.Compare(propertyName' PropertyNames.PwdInfoCannotChangePassword' StringComparison.OrdinalIgnoreCase) != 0) || testCantChangePassword); " is 155.
Long Statement,System.DirectoryServices.AccountManagement,SDSCache,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSCache.cs,GetContext,The length of the statement  "                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SDSCache"' "GetContext: credHolder for " + contextName + " has a Placeholder"); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,RangeRetriever,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\RangeRetriever.cs,GetNextChunk,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Error' "RangeRetriever"' "GetNextChunk: caught COMException' ErrorCode={0}"' e.ErrorCode); " is 126.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,SetAuthPrincipalEnableStatus,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADAMStoreCtx"' "SetAuthPrincipalEnableStatus: can't read userAccountControl"); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,SetAuthPrincipalEnableStatus,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADAMStoreCtx"' "SetAuthPrincipalEnableStatus: Enabling (old enabled ={0} new enabled= {1})"' !acctDisabled' enable); " is 159.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,LoadDomainInfo,The length of the statement  "            using (DirectoryEntry rootDse = new DirectoryEntry("LDAP://" + this.userSuppliedServerName + "/rootDse"' ""' ""' AuthenticationTypes.Anonymous)) " is 144.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,LoadDomainInfo,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using user-supplied name {0}"' this.userSuppliedServerName); " is 135.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,SetupPasswordModification,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Error' "ADAMStoreCtx"' "SetupPasswordModification: caught TargetInvocationException with message " + e.Message); " is 148.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,PopulatAuxObjectList,The length of the statement  "                using (DirectoryEntry deRoot = new DirectoryEntry("LDAP://" + userSuppliedServerName + "/rootDSE"' credentials == null ? null : credentials.UserName' credentials == null ? null : credentials.Password' authTypes)) " is 212.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,PopulatAuxObjectList,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Error' "ADAMStoreCtx"' "PopulatAuxObjectList Unable to read schemaNamingContrext from " + userSuppliedServerName); " is 150.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,PopulatAuxObjectList,The length of the statement  "                using (DirectoryEntry deSCN = new DirectoryEntry("LDAP://" + userSuppliedServerName + "/" + SchemaNamingContext' credentials == null ? null : credentials.UserName' credentials == null ? null : credentials.Password' authTypes)) " is 226.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,PopulatAuxObjectList,The length of the statement  "                                    GlobalDebug.WriteLineIf(GlobalDebug.Error' "ADAMStoreCtx"' "PopulatAuxObjectList Unable to read ldapDisplayName from " + SchemaNamingContext); " is 142.
Long Statement,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,PopulatAuxObjectList,The length of the statement  "                                GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADAMStoreCtx"' "PopulatAuxObjectList Adding " + res.Properties["ldapDisplayName"][0].ToString()); " is 140.
Long Statement,System.DirectoryServices.AccountManagement,TokenGroupSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\TokenGroupsSet.cs,MoveNext,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "TokenGroupSet"' "MoveNextLocal: returning primary group {0}"' _current.Path); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,TokenGroupSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\TokenGroupsSet.cs,MoveNext,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "TokenGroupSet"' "MoveNextLocal: got a value from the enumerator: {0}"' _currentSID.ToString()); " is 138.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,Insert,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "Insert: new SID is "' Utils.ByteArrayToString((byte[])de.Properties["objectSid"].Value)); " is 147.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,UnlockAccount,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Error' "SAMStoreCtx"' "UnlockAccount: caught COMException' message={0}"' e.Message); " is 120.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,GetGroupsMemberOf,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "GetGroupsMemberOf(ctx): no corresponding user' returning empty set"); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,ResolveCrossStoreRefToPrincipal,The length of the statement  "            PrincipalContext remoteCtx = SDSCache.Domain.GetContext(domainName' _credentials' DefaultContextOptions.ADDefaultContextOption); " is 128.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,LoadComputerInfo,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "LoadComputerInfo: machineUserSuppliedName={0}"' _machineUserSuppliedName); " is 132.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,PushChangesToNative,The length of the statement  "                                GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "PushChangesToNative: pushing {0}"' propertyEntry.propertyName); " is 121.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,Load,The length of the statement  "            // We don't support this property and cannot load it.  To maintain backward compatibility with the old code just return. " is 120.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindPrincipalByIdentRef,The length of the statement  "                    if (principalType == typeof(Principal) || principalType == typeof(GroupPrincipal) || principalType.IsSubclassOf(typeof(GroupPrincipal))) " is 136.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindNativeBySIDIdentRef,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "FindNativeBySIDIdentRef: mapped to {0}\\{1}"' domainName' name); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindNativeBySIDIdentRef,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "FindNativeBySIDIdentRef: using {0} for domainName"' domainName); " is 122.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindNativeBySIDIdentRef,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Warn' "SAMStoreCtx"' "FindNativeBySIDIdentRef: {0} != {1}' no match"' domainName' this.MachineFlatName); " is 140.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindNativeByNT4IdentRef,The length of the statement  "                if (SAMUtils.IsOfObjectClass(de' "User") || SAMUtils.IsOfObjectClass(de' "Group") || SAMUtils.IsOfObjectClass(de' "Computer")) " is 126.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,StringFromWinNTConverter,The length of the statement  "            SDSUtils.SingleScalarFromDirectoryEntry<string>(new dSPropertyCollection(de.Properties)' suggestedWinNTProperty' p' propertyName); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SamAccountNameFromWinNTConverter,The length of the statement  "            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "SamAccountNameFromWinNTConverter: loading SAM{0}"' samAccountName); " is 125.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,MultiStringFromWinNTConverter,The length of the statement  "            SDSUtils.MultiScalarFromDirectoryEntry<string>(new dSPropertyCollection(de.Properties)' suggestedWinNTProperty' p' propertyName); " is 129.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,IntFromWinNTConverter,The length of the statement  "            SDSUtils.SingleScalarFromDirectoryEntry<int>(new dSPropertyCollection(de.Properties)' suggestedWinNTProperty' p' propertyName); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,BinaryFromWinNTConverter,The length of the statement  "            SDSUtils.SingleScalarFromDirectoryEntry<byte[]>(new dSPropertyCollection(de.Properties)' suggestedWinNTProperty' p' propertyName); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,UserFlagsFromWinNTConverter,The length of the statement  "            SDSUtils.AccountControlFromDirectoryEntry(new dSPropertyCollection(de.Properties)' suggestedWinNTProperty' p' propertyName' true); " is 130.
Long Statement,System.DirectoryServices.AccountManagement,GroupMemberMatcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMQuerySet.cs,Matches,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMQuerySet"' "GroupMemberMatcher: Matches: skipping no-SID group={0}"' groupDE.Path); " is 129.
Long Statement,System.DirectoryServices.AccountManagement,GroupMemberMatcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMQuerySet.cs,Matches,The length of the statement  "                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMQuerySet"' "GroupMemberMatcher: Matches: skipping member no-SID member={0}"' memberDE.Path); " is 138.
Long Statement,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextLocal,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: fake principal' sid={0}"' Utils.ByteArrayToString(sid)); " is 131.
Long Statement,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextLocal,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: fake domain: {0} --> {1}"' builtinADsPath' adsPath); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextLocal,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: recursive processing' groupsToVisit={0}"' _groupsToVisit.Count); " is 139.
Long Statement,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextForeign,The length of the statement  "                GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextForeign: foreignMembers count={0}"' _foreignMembers.Count); " is 127.
Long Statement,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextForeign,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextForeign: setting currentForeign to {0}"' foreignDE.Path); " is 125.
Long Statement,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextForeign,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextForeign: adding {0} to foreignGroups"' foreignDE.Path); " is 123.
Long Statement,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextForeign,The length of the statement  "                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextForeign: ran out of members' using next foreignResultSet"); " is 127.
Complex Conditional,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The conditional expression  "((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f'))"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,ClassifySID,The conditional expression  "!(identAuth.b1 == 0) &&                    (identAuth.b2 == 0) &&                    (identAuth.b3 == 0) &&                    (identAuth.b4 == 0) &&                    (identAuth.b5 == 0) &&                    (identAuth.b6 == 5)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,PrincipalContext,The conditional expression  "(userName == null && password != null) ||                  (userName != null && password == null)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,PrincipalContext,The conditional expression  "(contextType == ContextType.Domain || contextType == ContextType.ApplicationDirectory) &&                  (((options & (ContextOptions.Negotiate | ContextOptions.SimpleBind)) == 0) ||                  (((options & (ContextOptions.Negotiate | ContextOptions.SimpleBind)) == ((ContextOptions.Negotiate | ContextOptions.SimpleBind)))))"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ValidateCredentials,The conditional expression  "(userName == null && password != null) ||                  (userName != null && password == null)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,PrincipalContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,ValidateCredentials,The conditional expression  "(userName == null && password != null) ||                  (userName != null && password == null)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetExceptionFromErrorCode,The conditional expression  "(errorCode == s_ERROR_NOT_ENOUGH_MEMORY) || (errorCode == s_ERROR_OUTOFMEMORY) || (errorCode == s_ERROR_DS_DRA_OUT_OF_MEM) || (errorCode == s_RPC_S_OUT_OF_RESOURCES)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetExceptionFromErrorCode,The conditional expression  "(errorCode == s_ERROR_NO_LOGON_SERVERS) || (errorCode == s_ERROR_NO_SUCH_DOMAIN) || (errorCode == RPC_S_SERVER_UNAVAILABLE) || (errorCode == RPC_S_CALL_FAILED)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,CanGroupMemberBeRemoved,The conditional expression  "(g.ContextType == ContextType.Domain && member.ContextType != ContextType.Domain) ||                  (member.ContextType != ContextType.Domain && member.ContextType != ContextType.ApplicationDirectory)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The conditional expression  "(urnScheme == UrnScheme.SidScheme) &&                           (principalType == typeof(Principal) || principalType == typeof(GroupPrincipal) || principalType.IsSubclassOf(typeof(GroupPrincipal)))"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,CannotChangePwdFromLdapConverter,The conditional expression  "(!denySelfFound && !denyWorldFound) && (allowSelfFound || allowWorldFound)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,UpdateGroupMembership,The conditional expression  "(memberType != typeof(UserPrincipal)) && (!memberType.IsSubclassOf(typeof(UserPrincipal))) &&                          (memberType != typeof(ComputerPrincipal)) && (!memberType.IsSubclassOf(typeof(ComputerPrincipal))) &&                          (memberType != typeof(GroupPrincipal)) && (!memberType.IsSubclassOf(typeof(GroupPrincipal))) &&                          (!memberType.IsSubclassOf(typeof(AuthenticablePrincipal)))"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,HexStringToLdapHexString,The conditional expression  "((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f'))"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,InsertPrincipal,The conditional expression  "(!(p is UserPrincipal)) &&                   (!(p is GroupPrincipal)) &&                   (!(p is AuthenticablePrincipal)) &&                   (!(p is ComputerPrincipal))"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,SetAuthPrincipalEnableStatus,The conditional expression  "(enable && acctDisabled) || (!enable && !acctDisabled)"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindNativeByNT4IdentRef,The conditional expression  "(e.ErrorCode == unchecked((int)0x800708AB)) ||     // unknown user                       (e.ErrorCode == unchecked((int)0x800708AC)) ||     // unknown group                       (e.ErrorCode == unchecked((int)0x80070035)) ||     // bad net path                       (e.ErrorCode == unchecked((int)0x800708AD))"  is complex.
Complex Conditional,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,UpdateGroupMembership,The conditional expression  "(memberType != typeof(UserPrincipal)) && (!memberType.IsSubclassOf(typeof(UserPrincipal))) &&                           (memberType != typeof(ComputerPrincipal)) && (!memberType.IsSubclassOf(typeof(ComputerPrincipal))) &&                           (memberType != typeof(GroupPrincipal)) && (!memberType.IsSubclassOf(typeof(GroupPrincipal)))"  is complex.
Virtual Method Call from Constructor,System.DirectoryServices.AccountManagement,ReferentialProperties,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\constants.cs,ReferentialProperties,The constructor "ReferentialProperties" calls a virtual method "Add".
Virtual Method Call from Constructor,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,The constructor "SAMStoreCtx" calls a virtual method "Add".
Virtual Method Call from Constructor,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,The constructor "SAMStoreCtx" calls a virtual method "Add".
Empty Catch Block,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,Validate,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,Validate,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,VerifyOutboundTrust,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,VerifyOutboundTrust,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindPrincipalByIdentRef,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,FindPrincipalByIdentRef,The method has an empty catch block.
Magic Number,System.DirectoryServices.AccountManagement,PrincipalSearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\PrincipalSearcher.cs,SetDefaultPageSizeForContext,The following statement contains a magic number: if (_qbeFilter != null)              {                  // If our context is AD-backed (has an ADStoreCtx)' use pagesize of 256.                  // Otherwise' turn off paging.                  GlobalDebug.WriteLineIf(                          GlobalDebug.Info'                          "PrincipalSearcher"'                          "SetDefaultPageSizeForContext: type is " + _ctx.QueryCtx.GetType().ToString());                    if (_ctx.QueryCtx is ADStoreCtx)                  {                      // Found an AD context                      _pageSize = 256;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The following statement contains a magic number: if (s.Length % 2 != 0)              {                  GlobalDebug.WriteLineIf(GlobalDebug.Warn' "Utils"' "StringToByteArray: string has bad length " + s.Length);                  return null;              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The following statement contains a magic number: byte[] bytes = new byte[s.Length / 2];
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      byte b = Byte.Parse(s.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);                      bytes[i] = b;                  }                  else                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "Utils"' "StringToByteArray: invalid string: " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      byte b = Byte.Parse(s.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);                      bytes[i] = b;                  }                  else                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "Utils"' "StringToByteArray: invalid string: " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      byte b = Byte.Parse(s.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);                      bytes[i] = b;                  }                  else                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "Utils"' "StringToByteArray: invalid string: " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      byte b = Byte.Parse(s.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);                      bytes[i] = b;                  }                  else                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "Utils"' "StringToByteArray: invalid string: " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,StringToByteArray,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      byte b = Byte.Parse(s.Substring(i * 2' 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture);                      bytes[i] = b;                  }                  else                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "Utils"' "StringToByteArray: invalid string: " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,ClassifySID,The following statement contains a magic number: if (!(identAuth.b1 == 0) &&                    (identAuth.b2 == 0) &&                    (identAuth.b3 == 0) &&                    (identAuth.b4 == 0) &&                    (identAuth.b5 == 0) &&                    (identAuth.b6 == 5))              {                  // No' so it can't be an account or builtin SID.                  // Probably something like \Everyone or \LOCAL.                  return SidType.FakeObject;              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,ClassifySID,The following statement contains a magic number: switch (rid)              {                  case 21:                      // Account SID                      return SidType.RealObject;                    case 32:                      // BUILTIN SID                      return SidType.RealObjectFakeDomain;                    default:                      return SidType.FakeObject;              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,ClassifySID,The following statement contains a magic number: switch (rid)              {                  case 21:                      // Account SID                      return SidType.RealObject;                    case 32:                      // BUILTIN SID                      return SidType.RealObjectFakeDomain;                    default:                      return SidType.FakeObject;              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetCurrentUserSid,The following statement contains a magic number: try              {                  //                  // Get the current user's SID                  //                  int error = 0;                    // Get the current thread's token                  if (!UnsafeNativeMethods.OpenThreadToken(                                  UnsafeNativeMethods.GetCurrentThread()'                                  0x8' // TOKEN_QUERY                                  true'                                  ref pTokenHandle                                  ))                  {                      if ((error = Marshal.GetLastWin32Error()) == 1008) // ERROR_NO_TOKEN                      {                          Debug.Assert(pTokenHandle == IntPtr.Zero);                            // Current thread doesn't have a token' try the process                          if (!UnsafeNativeMethods.OpenProcessToken(                                          UnsafeNativeMethods.GetCurrentProcess()'                                          0x8' // TOKEN_QUERY                                          ref pTokenHandle                                          ))                          {                              int lastError = Marshal.GetLastWin32Error();                              GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetCurrentUserSid: OpenProcessToken failed' gle=" + lastError);                                throw new PrincipalOperationException(                                              String.Format(CultureInfo.CurrentCulture'                                                            SR.UnableToOpenToken'                                                            lastError));                          }                      }                      else                      {                          GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetCurrentUserSid: OpenThreadToken failed' gle=" + error);                            throw new PrincipalOperationException(                                          String.Format(CultureInfo.CurrentCulture'                                                        SR.UnableToOpenToken'                                                        error));                      }                  }                    Debug.Assert(pTokenHandle != IntPtr.Zero);                    int neededBufferSize = 0;                    // Retrieve the user info from the current thread's token                  // First' determine how big a buffer we need.                  bool success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          IntPtr.Zero'                                          0'                                          ref neededBufferSize);                    int getTokenInfoError = 0;                  if ((getTokenInfoError = Marshal.GetLastWin32Error()) != 122) // ERROR_INSUFFICIENT_BUFFER                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetCurrentUserSid: GetTokenInformation (1st try) failed' gle=" + getTokenInfoError);                        throw new PrincipalOperationException(                                      String.Format(CultureInfo.CurrentCulture' SR.UnableToRetrieveTokenInfo' getTokenInfoError));                  }                    // Allocate the necessary buffer.                  Debug.Assert(neededBufferSize > 0);                  pBuffer = Marshal.AllocHGlobal(neededBufferSize);                    // Load the user info into the buffer                  success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          pBuffer'                                          neededBufferSize'                                          ref neededBufferSize);                    if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      GlobalDebug.WriteLineIf(GlobalDebug.Error'                                        "Utils"'                                        "GetCurrentUserSid: GetTokenInformation (2nd try) failed' neededBufferSize=" + neededBufferSize + "' gle=" + lastError);                        throw new PrincipalOperationException(                                      String.Format(CultureInfo.CurrentCulture' SR.UnableToRetrieveTokenInfo' lastError));                  }                    // Retrieve the user's SID from the user info                  UnsafeNativeMethods.TOKEN_USER tokenUser = (UnsafeNativeMethods.TOKEN_USER)Marshal.PtrToStructure(pBuffer' typeof(UnsafeNativeMethods.TOKEN_USER));                  IntPtr pUserSid = tokenUser.sidAndAttributes.pSid;   // this is a reference into the NATIVE memory (into pBuffer)                    Debug.Assert(UnsafeNativeMethods.IsValidSid(pUserSid));                    // Now we make a copy of the SID to return                  int userSidLength = UnsafeNativeMethods.GetLengthSid(pUserSid);                  IntPtr pCopyOfUserSid = Marshal.AllocHGlobal(userSidLength);                  success = UnsafeNativeMethods.CopySid(userSidLength' pCopyOfUserSid' pUserSid);                  if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      GlobalDebug.WriteLineIf(GlobalDebug.Error'                                        "Utils"'                                        "GetCurrentUserSid: CopySid failed' errorcode=" + lastError);                        throw new PrincipalOperationException(                                      String.Format(CultureInfo.CurrentCulture' SR.UnableToRetrieveTokenInfo' lastError));                  }                    return pCopyOfUserSid;              }              finally              {                  if (pTokenHandle != IntPtr.Zero)                      UnsafeNativeMethods.CloseHandle(pTokenHandle);                    if (pBuffer != IntPtr.Zero)                      Marshal.FreeHGlobal(pBuffer);              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetCurrentUserSid,The following statement contains a magic number: try              {                  //                  // Get the current user's SID                  //                  int error = 0;                    // Get the current thread's token                  if (!UnsafeNativeMethods.OpenThreadToken(                                  UnsafeNativeMethods.GetCurrentThread()'                                  0x8' // TOKEN_QUERY                                  true'                                  ref pTokenHandle                                  ))                  {                      if ((error = Marshal.GetLastWin32Error()) == 1008) // ERROR_NO_TOKEN                      {                          Debug.Assert(pTokenHandle == IntPtr.Zero);                            // Current thread doesn't have a token' try the process                          if (!UnsafeNativeMethods.OpenProcessToken(                                          UnsafeNativeMethods.GetCurrentProcess()'                                          0x8' // TOKEN_QUERY                                          ref pTokenHandle                                          ))                          {                              int lastError = Marshal.GetLastWin32Error();                              GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetCurrentUserSid: OpenProcessToken failed' gle=" + lastError);                                throw new PrincipalOperationException(                                              String.Format(CultureInfo.CurrentCulture'                                                            SR.UnableToOpenToken'                                                            lastError));                          }                      }                      else                      {                          GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetCurrentUserSid: OpenThreadToken failed' gle=" + error);                            throw new PrincipalOperationException(                                          String.Format(CultureInfo.CurrentCulture'                                                        SR.UnableToOpenToken'                                                        error));                      }                  }                    Debug.Assert(pTokenHandle != IntPtr.Zero);                    int neededBufferSize = 0;                    // Retrieve the user info from the current thread's token                  // First' determine how big a buffer we need.                  bool success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          IntPtr.Zero'                                          0'                                          ref neededBufferSize);                    int getTokenInfoError = 0;                  if ((getTokenInfoError = Marshal.GetLastWin32Error()) != 122) // ERROR_INSUFFICIENT_BUFFER                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetCurrentUserSid: GetTokenInformation (1st try) failed' gle=" + getTokenInfoError);                        throw new PrincipalOperationException(                                      String.Format(CultureInfo.CurrentCulture' SR.UnableToRetrieveTokenInfo' getTokenInfoError));                  }                    // Allocate the necessary buffer.                  Debug.Assert(neededBufferSize > 0);                  pBuffer = Marshal.AllocHGlobal(neededBufferSize);                    // Load the user info into the buffer                  success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          pBuffer'                                          neededBufferSize'                                          ref neededBufferSize);                    if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      GlobalDebug.WriteLineIf(GlobalDebug.Error'                                        "Utils"'                                        "GetCurrentUserSid: GetTokenInformation (2nd try) failed' neededBufferSize=" + neededBufferSize + "' gle=" + lastError);                        throw new PrincipalOperationException(                                      String.Format(CultureInfo.CurrentCulture' SR.UnableToRetrieveTokenInfo' lastError));                  }                    // Retrieve the user's SID from the user info                  UnsafeNativeMethods.TOKEN_USER tokenUser = (UnsafeNativeMethods.TOKEN_USER)Marshal.PtrToStructure(pBuffer' typeof(UnsafeNativeMethods.TOKEN_USER));                  IntPtr pUserSid = tokenUser.sidAndAttributes.pSid;   // this is a reference into the NATIVE memory (into pBuffer)                    Debug.Assert(UnsafeNativeMethods.IsValidSid(pUserSid));                    // Now we make a copy of the SID to return                  int userSidLength = UnsafeNativeMethods.GetLengthSid(pUserSid);                  IntPtr pCopyOfUserSid = Marshal.AllocHGlobal(userSidLength);                  success = UnsafeNativeMethods.CopySid(userSidLength' pCopyOfUserSid' pUserSid);                  if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      GlobalDebug.WriteLineIf(GlobalDebug.Error'                                        "Utils"'                                        "GetCurrentUserSid: CopySid failed' errorcode=" + lastError);                        throw new PrincipalOperationException(                                      String.Format(CultureInfo.CurrentCulture' SR.UnableToRetrieveTokenInfo' lastError));                  }                    return pCopyOfUserSid;              }              finally              {                  if (pTokenHandle != IntPtr.Zero)                      UnsafeNativeMethods.CloseHandle(pTokenHandle);                    if (pBuffer != IntPtr.Zero)                      Marshal.FreeHGlobal(pBuffer);              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,GetMachineDomainSid,The following statement contains a magic number: try              {                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                  int err = UnsafeNativeMethods.LsaOpenPolicy(                                  IntPtr.Zero'                                  pOA'                                  1'          // POLICY_VIEW_LOCAL_INFORMATION                                  ref pPolicyHandle);                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetMachineDomainSid: LsaOpenPolicy failed' gle=" + SafeNativeMethods.LsaNtStatusToWinError(err));                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.UnableToRetrievePolicy'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                  err = UnsafeNativeMethods.LsaQueryInformationPolicy(                                  pPolicyHandle'                                  5'              // PolicyAccountDomainInformation                                  ref pBuffer);                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "GetMachineDomainSid: LsaQueryInformationPolicy failed' gle=" + SafeNativeMethods.LsaNtStatusToWinError(err));                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.UnableToRetrievePolicy'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pBuffer != IntPtr.Zero);                  UnsafeNativeMethods.POLICY_ACCOUNT_DOMAIN_INFO info = (UnsafeNativeMethods.POLICY_ACCOUNT_DOMAIN_INFO)                                      Marshal.PtrToStructure(pBuffer' typeof(UnsafeNativeMethods.POLICY_ACCOUNT_DOMAIN_INFO));                    Debug.Assert(UnsafeNativeMethods.IsValidSid(info.domainSid));                    // Now we make a copy of the SID to return                  int sidLength = UnsafeNativeMethods.GetLengthSid(info.domainSid);                  IntPtr pCopyOfSid = Marshal.AllocHGlobal(sidLength);                  bool success = UnsafeNativeMethods.CopySid(sidLength' pCopyOfSid' info.domainSid);                  if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      GlobalDebug.WriteLineIf(GlobalDebug.Error'                                        "Utils"'                                        "GetMachineDomainSid: CopySid failed' errorcode=" + lastError);                        throw new PrincipalOperationException(                                      String.Format(CultureInfo.CurrentCulture' SR.UnableToRetrievePolicy' lastError));                  }                    return pCopyOfSid;              }              finally              {                  if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pBuffer != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pBuffer);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,LookupSid,The following statement contains a magic number: try              {                  pSid = ConvertByteArrayToIntPtr(sid);                    Utils.BeginImpersonation(credentials' out hUser);                    // hUser could be null if no credentials were specified                  Debug.Assert(hUser != IntPtr.Zero ||                                  (credentials == null || (credentials.UserName == null && credentials.Password == null)));                    bool f = UnsafeNativeMethods.LookupAccountSid(serverName' pSid' null' ref nameLength' null' ref domainNameLength' ref accountUsage);                    int lastErr = Marshal.GetLastWin32Error();                  if (lastErr != 122) // ERROR_INSUFFICIENT_BUFFER                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "LookupSid: LookupAccountSid (1st try) failed' gle=" + lastErr);                      return lastErr;                  }                    Debug.Assert(f == false);   // should never succeed' with a 0 buffer size                                    Debug.Assert(nameLength > 0);                  Debug.Assert(domainNameLength > 0);                    sbName = new StringBuilder(nameLength);                  sbDomainName = new StringBuilder(domainNameLength);                    f = UnsafeNativeMethods.LookupAccountSid(serverName' pSid' sbName' ref nameLength' sbDomainName' ref domainNameLength' ref accountUsage);                    if (f == false)                  {                      lastErr = Marshal.GetLastWin32Error();                      Debug.Assert(lastErr != 0);                        GlobalDebug.WriteLineIf(GlobalDebug.Error' "Utils"' "LookupSid: LookupAccountSid (2nd try) failed' gle=" + lastErr);                      return lastErr;                  }                    name = sbName.ToString();                  domainName = sbDomainName.ToString();                    return 0;              }              finally              {                  if (pSid != IntPtr.Zero)                      Marshal.FreeHGlobal(pSid);                    if (hUser != IntPtr.Zero)                      Utils.EndImpersonation(hUser);              }
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,BeginImpersonation,The following statement contains a magic number: int result = UnsafeNativeMethods.LogonUser(                                              userName'                                              domainName'                                              password'                                              9' /* LOGON32_LOGON_NEW_CREDENTIALS */                                              3' /* LOGON32_PROVIDER_WINNT50 */                                              ref hToken);
Magic Number,System.DirectoryServices.AccountManagement,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Utils.cs,BeginImpersonation,The following statement contains a magic number: int result = UnsafeNativeMethods.LogonUser(                                              userName'                                              domainName'                                              password'                                              9' /* LOGON32_LOGON_NEW_CREDENTIALS */                                              3' /* LOGON32_PROVIDER_WINNT50 */                                              ref hToken);
Magic Number,System.DirectoryServices.AccountManagement,CredentialValidator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\Context.cs,BindLdap,The following statement contains a magic number: int index = Convert.ToInt32(attemptFastConcurrent) * 2 + Convert.ToInt32(useSSL);
Magic Number,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetErrorMessage,The following statement contains a magic number: if (!hresult)              {                  temp = ((((temp) & 0x0000FFFF) | (7 << 16) | 0x80000000));              }
Magic Number,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetErrorMessage,The following statement contains a magic number: if (!hresult)              {                  temp = ((((temp) & 0x0000FFFF) | (7 << 16) | 0x80000000));              }
Magic Number,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetErrorMessage,The following statement contains a magic number: StringBuilder sb = new StringBuilder(256);
Magic Number,System.DirectoryServices.AccountManagement,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\exceptions.cs,GetErrorMessage,The following statement contains a magic number: if (result != 0)              {                  errorMsg = sb.ToString(0' result);              }              else              {                  errorMsg = SR.DSUnknown + Convert.ToString(temp' 16);              }
Magic Number,System.DirectoryServices.AccountManagement,AuthZSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthZSet.cs,AuthZSet,The following statement contains a magic number: try              {                  UnsafeNativeMethods.LUID luid = new UnsafeNativeMethods.LUID();                  luid.low = 0;                  luid.high = 0;                    _psMachineSid = new SafeMemoryPtr(Utils.GetMachineDomainSid());                  _psUserSid = new SafeMemoryPtr(Utils.ConvertByteArrayToIntPtr(userSid));                    bool f;                  int lastError = 0;                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Initializing resource manager");                    // Create a resource manager                  f = UnsafeNativeMethods.AuthzInitializeResourceManager(                                              UnsafeNativeMethods.AUTHZ_RM_FLAG.AUTHZ_RM_FLAG_NO_AUDIT'                                              IntPtr.Zero'                                              IntPtr.Zero'                                              IntPtr.Zero'                                              null'                                              out pResManager                                              );                    if (f)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting ctx from SID");                        // Construct a context for the user based on the user's SID                      f = UnsafeNativeMethods.AuthzInitializeContextFromSid(                                                  0'                  // default flags                                                  _psUserSid.DangerousGetHandle()'                                                  pResManager'                                                  IntPtr.Zero'                                                  luid'                                                  IntPtr.Zero'                                                  out pClientContext                                                  );                        if (f)                      {                          int bufferSize = 0;                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting info from ctx");                            // Extract the group SIDs from the user's context.  Determine the size of the buffer we need.                          f = UnsafeNativeMethods.AuthzGetInformationFromContext(                                                      pClientContext'                                                      2'	                // AuthzContextInfoGroupsSids                                                       0'                                                      out bufferSize'                                                      IntPtr.Zero                                                      );                          if (!f && (bufferSize > 0) && (Marshal.GetLastWin32Error() == 122) /*ERROR_INSUFFICIENT_BUFFER*/)                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting info from ctx (size={0})"' bufferSize);                                Debug.Assert(bufferSize > 0);                                // Set up the needed buffer                              pBuffer = Marshal.AllocHGlobal(bufferSize);                                // Extract the group SIDs from the user's context' into our buffer.0                              f = UnsafeNativeMethods.AuthzGetInformationFromContext(                                                          pClientContext'                                                          2'	                // AuthzContextInfoGroupsSids                                                           bufferSize'                                                          out bufferSize'                                                          pBuffer                                                          );                                if (f)                              {                                  // Marshall the native buffer into managed SID_AND_ATTR structures.                                  // The native buffer holds a TOKEN_GROUPS structure:                                  //                                  //        struct TOKEN_GROUPS {                                  //                DWORD GroupCount;                                  //                SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];                                  //        };                                  //                                    // Extract TOKEN_GROUPS.GroupCount                                                    UnsafeNativeMethods.TOKEN_GROUPS tokenGroups = (UnsafeNativeMethods.TOKEN_GROUPS)Marshal.PtrToStructure(pBuffer' typeof(UnsafeNativeMethods.TOKEN_GROUPS));                                    int groupCount = tokenGroups.groupCount;                                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Found {0} groups"' groupCount);                                    // Extract TOKEN_GROUPS.Groups' by iterating over the array and marshalling                                  // each native SID_AND_ATTRIBUTES into a managed SID_AND_ATTR.                                  UnsafeNativeMethods.SID_AND_ATTR[] groups = new UnsafeNativeMethods.SID_AND_ATTR[groupCount];                                    IntPtr currentItem = new IntPtr(pBuffer.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.TOKEN_GROUPS)) - IntPtr.Size);                                    for (int i = 0; i < groupCount; i++)                                  {                                      groups[i] = (UnsafeNativeMethods.SID_AND_ATTR)Marshal.PtrToStructure(currentItem' typeof(UnsafeNativeMethods.SID_AND_ATTR));                                        currentItem = new IntPtr(currentItem.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.SID_AND_ATTR)));                                  }                                    _groupSidList = new SidList(groups);                              }                              else                              {                                  lastError = Marshal.GetLastWin32Error();                              }                          }                          else                          {                              lastError = Marshal.GetLastWin32Error();                              // With a zero-length buffer' this should have never succeeded                              Debug.Assert(false);                          }                      }                      else                      {                          lastError = Marshal.GetLastWin32Error();                      }                  }                  else                  {                      lastError = Marshal.GetLastWin32Error();                  }                    if (!f)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "Failed to retrieve group list' {0}"' lastError);                        throw new PrincipalOperationException(                                      String.Format(                                              CultureInfo.CurrentCulture'                                              SR.AuthZFailedToRetrieveGroupList'                                              lastError));                  }                    // Save off the buffer since it still holds the native SIDs referenced by SidList                  _psBuffer = new SafeMemoryPtr(pBuffer);                  pBuffer = IntPtr.Zero;              }              catch (Exception e)              {                  GlobalDebug.WriteLineIf(GlobalDebug.Error' "AuthZSet"' "Caught exception {0} with message {1}"' e.GetType()' e.Message);                    if (_psBuffer != null && !_psBuffer.IsInvalid)                      _psBuffer.Close();                    if (_psUserSid != null && !_psUserSid.IsInvalid)                      _psUserSid.Close();                    if (_psMachineSid != null && !_psMachineSid.IsInvalid)                      _psMachineSid.Close();                    // We're on a platform that doesn't have the AuthZ library                  if (e is DllNotFoundException)                      throw new NotSupportedException(SR.AuthZNotSupported' e);                    if (e is EntryPointNotFoundException)                      throw new NotSupportedException(SR.AuthZNotSupported' e);                    throw;              }              finally              {                  if (pClientContext != IntPtr.Zero)                      UnsafeNativeMethods.AuthzFreeContext(pClientContext);                    if (pResManager != IntPtr.Zero)                      UnsafeNativeMethods.AuthzFreeResourceManager(pResManager);                    if (pBuffer != IntPtr.Zero)                      Marshal.FreeHGlobal(pBuffer);              }
Magic Number,System.DirectoryServices.AccountManagement,AuthZSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthZSet.cs,AuthZSet,The following statement contains a magic number: try              {                  UnsafeNativeMethods.LUID luid = new UnsafeNativeMethods.LUID();                  luid.low = 0;                  luid.high = 0;                    _psMachineSid = new SafeMemoryPtr(Utils.GetMachineDomainSid());                  _psUserSid = new SafeMemoryPtr(Utils.ConvertByteArrayToIntPtr(userSid));                    bool f;                  int lastError = 0;                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Initializing resource manager");                    // Create a resource manager                  f = UnsafeNativeMethods.AuthzInitializeResourceManager(                                              UnsafeNativeMethods.AUTHZ_RM_FLAG.AUTHZ_RM_FLAG_NO_AUDIT'                                              IntPtr.Zero'                                              IntPtr.Zero'                                              IntPtr.Zero'                                              null'                                              out pResManager                                              );                    if (f)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting ctx from SID");                        // Construct a context for the user based on the user's SID                      f = UnsafeNativeMethods.AuthzInitializeContextFromSid(                                                  0'                  // default flags                                                  _psUserSid.DangerousGetHandle()'                                                  pResManager'                                                  IntPtr.Zero'                                                  luid'                                                  IntPtr.Zero'                                                  out pClientContext                                                  );                        if (f)                      {                          int bufferSize = 0;                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting info from ctx");                            // Extract the group SIDs from the user's context.  Determine the size of the buffer we need.                          f = UnsafeNativeMethods.AuthzGetInformationFromContext(                                                      pClientContext'                                                      2'	                // AuthzContextInfoGroupsSids                                                       0'                                                      out bufferSize'                                                      IntPtr.Zero                                                      );                          if (!f && (bufferSize > 0) && (Marshal.GetLastWin32Error() == 122) /*ERROR_INSUFFICIENT_BUFFER*/)                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting info from ctx (size={0})"' bufferSize);                                Debug.Assert(bufferSize > 0);                                // Set up the needed buffer                              pBuffer = Marshal.AllocHGlobal(bufferSize);                                // Extract the group SIDs from the user's context' into our buffer.0                              f = UnsafeNativeMethods.AuthzGetInformationFromContext(                                                          pClientContext'                                                          2'	                // AuthzContextInfoGroupsSids                                                           bufferSize'                                                          out bufferSize'                                                          pBuffer                                                          );                                if (f)                              {                                  // Marshall the native buffer into managed SID_AND_ATTR structures.                                  // The native buffer holds a TOKEN_GROUPS structure:                                  //                                  //        struct TOKEN_GROUPS {                                  //                DWORD GroupCount;                                  //                SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];                                  //        };                                  //                                    // Extract TOKEN_GROUPS.GroupCount                                                    UnsafeNativeMethods.TOKEN_GROUPS tokenGroups = (UnsafeNativeMethods.TOKEN_GROUPS)Marshal.PtrToStructure(pBuffer' typeof(UnsafeNativeMethods.TOKEN_GROUPS));                                    int groupCount = tokenGroups.groupCount;                                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Found {0} groups"' groupCount);                                    // Extract TOKEN_GROUPS.Groups' by iterating over the array and marshalling                                  // each native SID_AND_ATTRIBUTES into a managed SID_AND_ATTR.                                  UnsafeNativeMethods.SID_AND_ATTR[] groups = new UnsafeNativeMethods.SID_AND_ATTR[groupCount];                                    IntPtr currentItem = new IntPtr(pBuffer.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.TOKEN_GROUPS)) - IntPtr.Size);                                    for (int i = 0; i < groupCount; i++)                                  {                                      groups[i] = (UnsafeNativeMethods.SID_AND_ATTR)Marshal.PtrToStructure(currentItem' typeof(UnsafeNativeMethods.SID_AND_ATTR));                                        currentItem = new IntPtr(currentItem.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.SID_AND_ATTR)));                                  }                                    _groupSidList = new SidList(groups);                              }                              else                              {                                  lastError = Marshal.GetLastWin32Error();                              }                          }                          else                          {                              lastError = Marshal.GetLastWin32Error();                              // With a zero-length buffer' this should have never succeeded                              Debug.Assert(false);                          }                      }                      else                      {                          lastError = Marshal.GetLastWin32Error();                      }                  }                  else                  {                      lastError = Marshal.GetLastWin32Error();                  }                    if (!f)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "Failed to retrieve group list' {0}"' lastError);                        throw new PrincipalOperationException(                                      String.Format(                                              CultureInfo.CurrentCulture'                                              SR.AuthZFailedToRetrieveGroupList'                                              lastError));                  }                    // Save off the buffer since it still holds the native SIDs referenced by SidList                  _psBuffer = new SafeMemoryPtr(pBuffer);                  pBuffer = IntPtr.Zero;              }              catch (Exception e)              {                  GlobalDebug.WriteLineIf(GlobalDebug.Error' "AuthZSet"' "Caught exception {0} with message {1}"' e.GetType()' e.Message);                    if (_psBuffer != null && !_psBuffer.IsInvalid)                      _psBuffer.Close();                    if (_psUserSid != null && !_psUserSid.IsInvalid)                      _psUserSid.Close();                    if (_psMachineSid != null && !_psMachineSid.IsInvalid)                      _psMachineSid.Close();                    // We're on a platform that doesn't have the AuthZ library                  if (e is DllNotFoundException)                      throw new NotSupportedException(SR.AuthZNotSupported' e);                    if (e is EntryPointNotFoundException)                      throw new NotSupportedException(SR.AuthZNotSupported' e);                    throw;              }              finally              {                  if (pClientContext != IntPtr.Zero)                      UnsafeNativeMethods.AuthzFreeContext(pClientContext);                    if (pResManager != IntPtr.Zero)                      UnsafeNativeMethods.AuthzFreeResourceManager(pResManager);                    if (pBuffer != IntPtr.Zero)                      Marshal.FreeHGlobal(pBuffer);              }
Magic Number,System.DirectoryServices.AccountManagement,AuthZSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthZSet.cs,AuthZSet,The following statement contains a magic number: try              {                  UnsafeNativeMethods.LUID luid = new UnsafeNativeMethods.LUID();                  luid.low = 0;                  luid.high = 0;                    _psMachineSid = new SafeMemoryPtr(Utils.GetMachineDomainSid());                  _psUserSid = new SafeMemoryPtr(Utils.ConvertByteArrayToIntPtr(userSid));                    bool f;                  int lastError = 0;                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Initializing resource manager");                    // Create a resource manager                  f = UnsafeNativeMethods.AuthzInitializeResourceManager(                                              UnsafeNativeMethods.AUTHZ_RM_FLAG.AUTHZ_RM_FLAG_NO_AUDIT'                                              IntPtr.Zero'                                              IntPtr.Zero'                                              IntPtr.Zero'                                              null'                                              out pResManager                                              );                    if (f)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting ctx from SID");                        // Construct a context for the user based on the user's SID                      f = UnsafeNativeMethods.AuthzInitializeContextFromSid(                                                  0'                  // default flags                                                  _psUserSid.DangerousGetHandle()'                                                  pResManager'                                                  IntPtr.Zero'                                                  luid'                                                  IntPtr.Zero'                                                  out pClientContext                                                  );                        if (f)                      {                          int bufferSize = 0;                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting info from ctx");                            // Extract the group SIDs from the user's context.  Determine the size of the buffer we need.                          f = UnsafeNativeMethods.AuthzGetInformationFromContext(                                                      pClientContext'                                                      2'	                // AuthzContextInfoGroupsSids                                                       0'                                                      out bufferSize'                                                      IntPtr.Zero                                                      );                          if (!f && (bufferSize > 0) && (Marshal.GetLastWin32Error() == 122) /*ERROR_INSUFFICIENT_BUFFER*/)                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Getting info from ctx (size={0})"' bufferSize);                                Debug.Assert(bufferSize > 0);                                // Set up the needed buffer                              pBuffer = Marshal.AllocHGlobal(bufferSize);                                // Extract the group SIDs from the user's context' into our buffer.0                              f = UnsafeNativeMethods.AuthzGetInformationFromContext(                                                          pClientContext'                                                          2'	                // AuthzContextInfoGroupsSids                                                           bufferSize'                                                          out bufferSize'                                                          pBuffer                                                          );                                if (f)                              {                                  // Marshall the native buffer into managed SID_AND_ATTR structures.                                  // The native buffer holds a TOKEN_GROUPS structure:                                  //                                  //        struct TOKEN_GROUPS {                                  //                DWORD GroupCount;                                  //                SID_AND_ATTRIBUTES Groups[ANYSIZE_ARRAY];                                  //        };                                  //                                    // Extract TOKEN_GROUPS.GroupCount                                                    UnsafeNativeMethods.TOKEN_GROUPS tokenGroups = (UnsafeNativeMethods.TOKEN_GROUPS)Marshal.PtrToStructure(pBuffer' typeof(UnsafeNativeMethods.TOKEN_GROUPS));                                    int groupCount = tokenGroups.groupCount;                                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "Found {0} groups"' groupCount);                                    // Extract TOKEN_GROUPS.Groups' by iterating over the array and marshalling                                  // each native SID_AND_ATTRIBUTES into a managed SID_AND_ATTR.                                  UnsafeNativeMethods.SID_AND_ATTR[] groups = new UnsafeNativeMethods.SID_AND_ATTR[groupCount];                                    IntPtr currentItem = new IntPtr(pBuffer.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.TOKEN_GROUPS)) - IntPtr.Size);                                    for (int i = 0; i < groupCount; i++)                                  {                                      groups[i] = (UnsafeNativeMethods.SID_AND_ATTR)Marshal.PtrToStructure(currentItem' typeof(UnsafeNativeMethods.SID_AND_ATTR));                                        currentItem = new IntPtr(currentItem.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.SID_AND_ATTR)));                                  }                                    _groupSidList = new SidList(groups);                              }                              else                              {                                  lastError = Marshal.GetLastWin32Error();                              }                          }                          else                          {                              lastError = Marshal.GetLastWin32Error();                              // With a zero-length buffer' this should have never succeeded                              Debug.Assert(false);                          }                      }                      else                      {                          lastError = Marshal.GetLastWin32Error();                      }                  }                  else                  {                      lastError = Marshal.GetLastWin32Error();                  }                    if (!f)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "Failed to retrieve group list' {0}"' lastError);                        throw new PrincipalOperationException(                                      String.Format(                                              CultureInfo.CurrentCulture'                                              SR.AuthZFailedToRetrieveGroupList'                                              lastError));                  }                    // Save off the buffer since it still holds the native SIDs referenced by SidList                  _psBuffer = new SafeMemoryPtr(pBuffer);                  pBuffer = IntPtr.Zero;              }              catch (Exception e)              {                  GlobalDebug.WriteLineIf(GlobalDebug.Error' "AuthZSet"' "Caught exception {0} with message {1}"' e.GetType()' e.Message);                    if (_psBuffer != null && !_psBuffer.IsInvalid)                      _psBuffer.Close();                    if (_psUserSid != null && !_psUserSid.IsInvalid)                      _psUserSid.Close();                    if (_psMachineSid != null && !_psMachineSid.IsInvalid)                      _psMachineSid.Close();                    // We're on a platform that doesn't have the AuthZ library                  if (e is DllNotFoundException)                      throw new NotSupportedException(SR.AuthZNotSupported' e);                    if (e is EntryPointNotFoundException)                      throw new NotSupportedException(SR.AuthZNotSupported' e);                    throw;              }              finally              {                  if (pClientContext != IntPtr.Zero)                      UnsafeNativeMethods.AuthzFreeContext(pClientContext);                    if (pResManager != IntPtr.Zero)                      UnsafeNativeMethods.AuthzFreeResourceManager(pResManager);                    if (pBuffer != IntPtr.Zero)                      Marshal.FreeHGlobal(pBuffer);              }
Magic Number,System.DirectoryServices.AccountManagement,AuthZSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AuthZSet.cs,MoveNext,The following statement contains a magic number: do              {                  needToRetry = false;                    _currentGroup++;                    if (_currentGroup >= _groupSidList.Length)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "MoveNext: ran off end of list ({0})"' _groupSidList.Length);                      return false;                  }                    // Test for the NONE group for a local user.  We recognize it by:                  //      * we're enumerating the authz groups for a local machine user                  //      * it's a domain sid (SidType.RealObject) for the same domain as the user                  //      * it has the RID of the "Domain Users" group' 513                  if (_userType == ContextType.Machine)                  {                      IntPtr pSid = _groupSidList[_currentGroup].pSid;                        bool sameDomain = false;                      if (Utils.ClassifySID(pSid) == SidType.RealObject && UnsafeNativeMethods.EqualDomainSid(_psUserSid.DangerousGetHandle()' pSid' ref sameDomain))                      {                          if (sameDomain)                          {                              int lastRid = Utils.GetLastRidFromSid(pSid);                                if (lastRid == 513)     // DOMAIN_GROUP_RID_USERS                              {                                  // This is the NONE group for a local user.  This isn't a real group' and                                  // has no impact on authorization (per ColinBr).  Skip it.                                  needToRetry = true;                                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "MoveNext: found NONE group' skipping");                              }                          }                      }                  }              }              while (needToRetry);
Magic Number,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The following statement contains a magic number: try              {                  //                  // Get the policy handle                  //                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                    int err = 0;                  if (target == null)                  {                      err = UnsafeNativeMethods.LsaOpenPolicy(                                      IntPtr.Zero'                                      pOA'                                      0x800'        // POLICY_LOOKUP_NAMES                                      ref pPolicyHandle);                  }                  else                  {                      // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      UnsafeNativeMethods.LSA_UNICODE_STRING_Managed lsaTargetString = new UnsafeNativeMethods.LSA_UNICODE_STRING_Managed();                      lsaTargetString.buffer = target;                      lsaTargetString.length = (ushort)(target.Length * 2);                      lsaTargetString.maximumLength = lsaTargetString.length;                        IntPtr lsaTargetPr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)));                        try                      {                          Marshal.StructureToPtr(lsaTargetString' lsaTargetPr' false);                            err = UnsafeNativeMethods.LsaOpenPolicy(                                          lsaTargetPr'                                          pOA'                                          0x800'        // POLICY_LOOKUP_NAMES                                          ref pPolicyHandle);                      }                      finally                      {                          if (lsaTargetPr != IntPtr.Zero)                          {                              UnsafeNativeMethods.LSA_UNICODE_STRING lsaTargetUnmanagedPtr =                                  (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING));                              if (lsaTargetUnmanagedPtr.buffer != IntPtr.Zero)                              {                                  Marshal.FreeHGlobal(lsaTargetUnmanagedPtr.buffer);                                  lsaTargetUnmanagedPtr.buffer = IntPtr.Zero;                              }                              Marshal.FreeHGlobal(lsaTargetPr);                          }                      }                  }                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: couldn't get policy handle' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                    //                  // Translate the SIDs                  //                    err = UnsafeNativeMethods.LsaLookupSids(                                      pPolicyHandle'                                      sidCount'                                      pSids'                                      out pDomains'                                      out pNames);                    // ignore error STATUS_SOME_NOT_MAPPED = 0x00000107 and                   // STATUS_NONE_MAPPED = 0xC0000073                  if (err != 0 &&                       err != 263 &&                       err != -1073741709)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: LsaLookupSids failed' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    //                  // Get the group names in managed form                  //                  names = new UnsafeNativeMethods.LSA_TRANSLATED_NAME[sidCount];                  IntPtr pCurrentName = pNames;                    for (int i = 0; i < sidCount; i++)                  {                      names[i] = (UnsafeNativeMethods.LSA_TRANSLATED_NAME)                                      Marshal.PtrToStructure(pCurrentName' typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME));                        pCurrentName = new IntPtr(pCurrentName.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME)));                  }                    //                  // Get the domain names in managed form                  //                    // Extract LSA_REFERENCED_DOMAIN_LIST.Entries                                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST));                    int domainCount = referencedDomains.entries;                    // Extract LSA_REFERENCED_DOMAIN_LIST.Domains' by iterating over the array and marshalling                  // each native LSA_TRUST_INFORMATION into a managed LSA_TRUST_INFORMATION.                    domains = new UnsafeNativeMethods.LSA_TRUST_INFORMATION[domainCount];                    IntPtr pCurrentDomain = referencedDomains.domains;                    for (int i = 0; i < domainCount; i++)                  {                      domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION));                      pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)));                  }                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "SidList: got {0} groups in {1} domains"' sidCount' domainCount);                    //                  // Build the list of entries                  //                  Debug.Assert(names.Length == sidCount);                    for (int i = 0; i < names.Length; i++)                  {                      UnsafeNativeMethods.LSA_TRANSLATED_NAME name = names[i];                        // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      SidListEntry entry = new SidListEntry();                        Debug.Assert(name.name.length % 2 == 0);                      entry.name = Marshal.PtrToStringUni(name.name.buffer' name.name.length / 2);                        // Get the domain associated with this name                      Debug.Assert(name.domainIndex < domains.Length);                      if (name.domainIndex >= 0)                      {                          UnsafeNativeMethods.LSA_TRUST_INFORMATION domain = domains[name.domainIndex];                          Debug.Assert(domain.name.length % 2 == 0);                          entry.sidIssuerName = Marshal.PtrToStringUni(domain.name.buffer' domain.name.length / 2);                      }                        entry.pSid = pSids[i];                        _entries.Add(entry);                  }                    // Sort the list so they are oriented by the issuer name.                  // this.entries.Sort( new SidListComparer());              }              finally              {                  if (pDomains != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pDomains);                    if (pNames != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pNames);                    if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The following statement contains a magic number: try              {                  //                  // Get the policy handle                  //                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                    int err = 0;                  if (target == null)                  {                      err = UnsafeNativeMethods.LsaOpenPolicy(                                      IntPtr.Zero'                                      pOA'                                      0x800'        // POLICY_LOOKUP_NAMES                                      ref pPolicyHandle);                  }                  else                  {                      // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      UnsafeNativeMethods.LSA_UNICODE_STRING_Managed lsaTargetString = new UnsafeNativeMethods.LSA_UNICODE_STRING_Managed();                      lsaTargetString.buffer = target;                      lsaTargetString.length = (ushort)(target.Length * 2);                      lsaTargetString.maximumLength = lsaTargetString.length;                        IntPtr lsaTargetPr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)));                        try                      {                          Marshal.StructureToPtr(lsaTargetString' lsaTargetPr' false);                            err = UnsafeNativeMethods.LsaOpenPolicy(                                          lsaTargetPr'                                          pOA'                                          0x800'        // POLICY_LOOKUP_NAMES                                          ref pPolicyHandle);                      }                      finally                      {                          if (lsaTargetPr != IntPtr.Zero)                          {                              UnsafeNativeMethods.LSA_UNICODE_STRING lsaTargetUnmanagedPtr =                                  (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING));                              if (lsaTargetUnmanagedPtr.buffer != IntPtr.Zero)                              {                                  Marshal.FreeHGlobal(lsaTargetUnmanagedPtr.buffer);                                  lsaTargetUnmanagedPtr.buffer = IntPtr.Zero;                              }                              Marshal.FreeHGlobal(lsaTargetPr);                          }                      }                  }                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: couldn't get policy handle' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                    //                  // Translate the SIDs                  //                    err = UnsafeNativeMethods.LsaLookupSids(                                      pPolicyHandle'                                      sidCount'                                      pSids'                                      out pDomains'                                      out pNames);                    // ignore error STATUS_SOME_NOT_MAPPED = 0x00000107 and                   // STATUS_NONE_MAPPED = 0xC0000073                  if (err != 0 &&                       err != 263 &&                       err != -1073741709)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: LsaLookupSids failed' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    //                  // Get the group names in managed form                  //                  names = new UnsafeNativeMethods.LSA_TRANSLATED_NAME[sidCount];                  IntPtr pCurrentName = pNames;                    for (int i = 0; i < sidCount; i++)                  {                      names[i] = (UnsafeNativeMethods.LSA_TRANSLATED_NAME)                                      Marshal.PtrToStructure(pCurrentName' typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME));                        pCurrentName = new IntPtr(pCurrentName.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME)));                  }                    //                  // Get the domain names in managed form                  //                    // Extract LSA_REFERENCED_DOMAIN_LIST.Entries                                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST));                    int domainCount = referencedDomains.entries;                    // Extract LSA_REFERENCED_DOMAIN_LIST.Domains' by iterating over the array and marshalling                  // each native LSA_TRUST_INFORMATION into a managed LSA_TRUST_INFORMATION.                    domains = new UnsafeNativeMethods.LSA_TRUST_INFORMATION[domainCount];                    IntPtr pCurrentDomain = referencedDomains.domains;                    for (int i = 0; i < domainCount; i++)                  {                      domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION));                      pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)));                  }                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "SidList: got {0} groups in {1} domains"' sidCount' domainCount);                    //                  // Build the list of entries                  //                  Debug.Assert(names.Length == sidCount);                    for (int i = 0; i < names.Length; i++)                  {                      UnsafeNativeMethods.LSA_TRANSLATED_NAME name = names[i];                        // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      SidListEntry entry = new SidListEntry();                        Debug.Assert(name.name.length % 2 == 0);                      entry.name = Marshal.PtrToStringUni(name.name.buffer' name.name.length / 2);                        // Get the domain associated with this name                      Debug.Assert(name.domainIndex < domains.Length);                      if (name.domainIndex >= 0)                      {                          UnsafeNativeMethods.LSA_TRUST_INFORMATION domain = domains[name.domainIndex];                          Debug.Assert(domain.name.length % 2 == 0);                          entry.sidIssuerName = Marshal.PtrToStringUni(domain.name.buffer' domain.name.length / 2);                      }                        entry.pSid = pSids[i];                        _entries.Add(entry);                  }                    // Sort the list so they are oriented by the issuer name.                  // this.entries.Sort( new SidListComparer());              }              finally              {                  if (pDomains != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pDomains);                    if (pNames != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pNames);                    if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The following statement contains a magic number: try              {                  //                  // Get the policy handle                  //                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                    int err = 0;                  if (target == null)                  {                      err = UnsafeNativeMethods.LsaOpenPolicy(                                      IntPtr.Zero'                                      pOA'                                      0x800'        // POLICY_LOOKUP_NAMES                                      ref pPolicyHandle);                  }                  else                  {                      // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      UnsafeNativeMethods.LSA_UNICODE_STRING_Managed lsaTargetString = new UnsafeNativeMethods.LSA_UNICODE_STRING_Managed();                      lsaTargetString.buffer = target;                      lsaTargetString.length = (ushort)(target.Length * 2);                      lsaTargetString.maximumLength = lsaTargetString.length;                        IntPtr lsaTargetPr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)));                        try                      {                          Marshal.StructureToPtr(lsaTargetString' lsaTargetPr' false);                            err = UnsafeNativeMethods.LsaOpenPolicy(                                          lsaTargetPr'                                          pOA'                                          0x800'        // POLICY_LOOKUP_NAMES                                          ref pPolicyHandle);                      }                      finally                      {                          if (lsaTargetPr != IntPtr.Zero)                          {                              UnsafeNativeMethods.LSA_UNICODE_STRING lsaTargetUnmanagedPtr =                                  (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING));                              if (lsaTargetUnmanagedPtr.buffer != IntPtr.Zero)                              {                                  Marshal.FreeHGlobal(lsaTargetUnmanagedPtr.buffer);                                  lsaTargetUnmanagedPtr.buffer = IntPtr.Zero;                              }                              Marshal.FreeHGlobal(lsaTargetPr);                          }                      }                  }                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: couldn't get policy handle' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                    //                  // Translate the SIDs                  //                    err = UnsafeNativeMethods.LsaLookupSids(                                      pPolicyHandle'                                      sidCount'                                      pSids'                                      out pDomains'                                      out pNames);                    // ignore error STATUS_SOME_NOT_MAPPED = 0x00000107 and                   // STATUS_NONE_MAPPED = 0xC0000073                  if (err != 0 &&                       err != 263 &&                       err != -1073741709)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: LsaLookupSids failed' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    //                  // Get the group names in managed form                  //                  names = new UnsafeNativeMethods.LSA_TRANSLATED_NAME[sidCount];                  IntPtr pCurrentName = pNames;                    for (int i = 0; i < sidCount; i++)                  {                      names[i] = (UnsafeNativeMethods.LSA_TRANSLATED_NAME)                                      Marshal.PtrToStructure(pCurrentName' typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME));                        pCurrentName = new IntPtr(pCurrentName.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME)));                  }                    //                  // Get the domain names in managed form                  //                    // Extract LSA_REFERENCED_DOMAIN_LIST.Entries                                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST));                    int domainCount = referencedDomains.entries;                    // Extract LSA_REFERENCED_DOMAIN_LIST.Domains' by iterating over the array and marshalling                  // each native LSA_TRUST_INFORMATION into a managed LSA_TRUST_INFORMATION.                    domains = new UnsafeNativeMethods.LSA_TRUST_INFORMATION[domainCount];                    IntPtr pCurrentDomain = referencedDomains.domains;                    for (int i = 0; i < domainCount; i++)                  {                      domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION));                      pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)));                  }                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "SidList: got {0} groups in {1} domains"' sidCount' domainCount);                    //                  // Build the list of entries                  //                  Debug.Assert(names.Length == sidCount);                    for (int i = 0; i < names.Length; i++)                  {                      UnsafeNativeMethods.LSA_TRANSLATED_NAME name = names[i];                        // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      SidListEntry entry = new SidListEntry();                        Debug.Assert(name.name.length % 2 == 0);                      entry.name = Marshal.PtrToStringUni(name.name.buffer' name.name.length / 2);                        // Get the domain associated with this name                      Debug.Assert(name.domainIndex < domains.Length);                      if (name.domainIndex >= 0)                      {                          UnsafeNativeMethods.LSA_TRUST_INFORMATION domain = domains[name.domainIndex];                          Debug.Assert(domain.name.length % 2 == 0);                          entry.sidIssuerName = Marshal.PtrToStringUni(domain.name.buffer' domain.name.length / 2);                      }                        entry.pSid = pSids[i];                        _entries.Add(entry);                  }                    // Sort the list so they are oriented by the issuer name.                  // this.entries.Sort( new SidListComparer());              }              finally              {                  if (pDomains != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pDomains);                    if (pNames != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pNames);                    if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The following statement contains a magic number: try              {                  //                  // Get the policy handle                  //                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                    int err = 0;                  if (target == null)                  {                      err = UnsafeNativeMethods.LsaOpenPolicy(                                      IntPtr.Zero'                                      pOA'                                      0x800'        // POLICY_LOOKUP_NAMES                                      ref pPolicyHandle);                  }                  else                  {                      // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      UnsafeNativeMethods.LSA_UNICODE_STRING_Managed lsaTargetString = new UnsafeNativeMethods.LSA_UNICODE_STRING_Managed();                      lsaTargetString.buffer = target;                      lsaTargetString.length = (ushort)(target.Length * 2);                      lsaTargetString.maximumLength = lsaTargetString.length;                        IntPtr lsaTargetPr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)));                        try                      {                          Marshal.StructureToPtr(lsaTargetString' lsaTargetPr' false);                            err = UnsafeNativeMethods.LsaOpenPolicy(                                          lsaTargetPr'                                          pOA'                                          0x800'        // POLICY_LOOKUP_NAMES                                          ref pPolicyHandle);                      }                      finally                      {                          if (lsaTargetPr != IntPtr.Zero)                          {                              UnsafeNativeMethods.LSA_UNICODE_STRING lsaTargetUnmanagedPtr =                                  (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING));                              if (lsaTargetUnmanagedPtr.buffer != IntPtr.Zero)                              {                                  Marshal.FreeHGlobal(lsaTargetUnmanagedPtr.buffer);                                  lsaTargetUnmanagedPtr.buffer = IntPtr.Zero;                              }                              Marshal.FreeHGlobal(lsaTargetPr);                          }                      }                  }                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: couldn't get policy handle' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                    //                  // Translate the SIDs                  //                    err = UnsafeNativeMethods.LsaLookupSids(                                      pPolicyHandle'                                      sidCount'                                      pSids'                                      out pDomains'                                      out pNames);                    // ignore error STATUS_SOME_NOT_MAPPED = 0x00000107 and                   // STATUS_NONE_MAPPED = 0xC0000073                  if (err != 0 &&                       err != 263 &&                       err != -1073741709)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: LsaLookupSids failed' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    //                  // Get the group names in managed form                  //                  names = new UnsafeNativeMethods.LSA_TRANSLATED_NAME[sidCount];                  IntPtr pCurrentName = pNames;                    for (int i = 0; i < sidCount; i++)                  {                      names[i] = (UnsafeNativeMethods.LSA_TRANSLATED_NAME)                                      Marshal.PtrToStructure(pCurrentName' typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME));                        pCurrentName = new IntPtr(pCurrentName.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME)));                  }                    //                  // Get the domain names in managed form                  //                    // Extract LSA_REFERENCED_DOMAIN_LIST.Entries                                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST));                    int domainCount = referencedDomains.entries;                    // Extract LSA_REFERENCED_DOMAIN_LIST.Domains' by iterating over the array and marshalling                  // each native LSA_TRUST_INFORMATION into a managed LSA_TRUST_INFORMATION.                    domains = new UnsafeNativeMethods.LSA_TRUST_INFORMATION[domainCount];                    IntPtr pCurrentDomain = referencedDomains.domains;                    for (int i = 0; i < domainCount; i++)                  {                      domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION));                      pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)));                  }                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "SidList: got {0} groups in {1} domains"' sidCount' domainCount);                    //                  // Build the list of entries                  //                  Debug.Assert(names.Length == sidCount);                    for (int i = 0; i < names.Length; i++)                  {                      UnsafeNativeMethods.LSA_TRANSLATED_NAME name = names[i];                        // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      SidListEntry entry = new SidListEntry();                        Debug.Assert(name.name.length % 2 == 0);                      entry.name = Marshal.PtrToStringUni(name.name.buffer' name.name.length / 2);                        // Get the domain associated with this name                      Debug.Assert(name.domainIndex < domains.Length);                      if (name.domainIndex >= 0)                      {                          UnsafeNativeMethods.LSA_TRUST_INFORMATION domain = domains[name.domainIndex];                          Debug.Assert(domain.name.length % 2 == 0);                          entry.sidIssuerName = Marshal.PtrToStringUni(domain.name.buffer' domain.name.length / 2);                      }                        entry.pSid = pSids[i];                        _entries.Add(entry);                  }                    // Sort the list so they are oriented by the issuer name.                  // this.entries.Sort( new SidListComparer());              }              finally              {                  if (pDomains != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pDomains);                    if (pNames != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pNames);                    if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The following statement contains a magic number: try              {                  //                  // Get the policy handle                  //                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                    int err = 0;                  if (target == null)                  {                      err = UnsafeNativeMethods.LsaOpenPolicy(                                      IntPtr.Zero'                                      pOA'                                      0x800'        // POLICY_LOOKUP_NAMES                                      ref pPolicyHandle);                  }                  else                  {                      // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      UnsafeNativeMethods.LSA_UNICODE_STRING_Managed lsaTargetString = new UnsafeNativeMethods.LSA_UNICODE_STRING_Managed();                      lsaTargetString.buffer = target;                      lsaTargetString.length = (ushort)(target.Length * 2);                      lsaTargetString.maximumLength = lsaTargetString.length;                        IntPtr lsaTargetPr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)));                        try                      {                          Marshal.StructureToPtr(lsaTargetString' lsaTargetPr' false);                            err = UnsafeNativeMethods.LsaOpenPolicy(                                          lsaTargetPr'                                          pOA'                                          0x800'        // POLICY_LOOKUP_NAMES                                          ref pPolicyHandle);                      }                      finally                      {                          if (lsaTargetPr != IntPtr.Zero)                          {                              UnsafeNativeMethods.LSA_UNICODE_STRING lsaTargetUnmanagedPtr =                                  (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING));                              if (lsaTargetUnmanagedPtr.buffer != IntPtr.Zero)                              {                                  Marshal.FreeHGlobal(lsaTargetUnmanagedPtr.buffer);                                  lsaTargetUnmanagedPtr.buffer = IntPtr.Zero;                              }                              Marshal.FreeHGlobal(lsaTargetPr);                          }                      }                  }                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: couldn't get policy handle' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                    //                  // Translate the SIDs                  //                    err = UnsafeNativeMethods.LsaLookupSids(                                      pPolicyHandle'                                      sidCount'                                      pSids'                                      out pDomains'                                      out pNames);                    // ignore error STATUS_SOME_NOT_MAPPED = 0x00000107 and                   // STATUS_NONE_MAPPED = 0xC0000073                  if (err != 0 &&                       err != 263 &&                       err != -1073741709)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: LsaLookupSids failed' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    //                  // Get the group names in managed form                  //                  names = new UnsafeNativeMethods.LSA_TRANSLATED_NAME[sidCount];                  IntPtr pCurrentName = pNames;                    for (int i = 0; i < sidCount; i++)                  {                      names[i] = (UnsafeNativeMethods.LSA_TRANSLATED_NAME)                                      Marshal.PtrToStructure(pCurrentName' typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME));                        pCurrentName = new IntPtr(pCurrentName.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME)));                  }                    //                  // Get the domain names in managed form                  //                    // Extract LSA_REFERENCED_DOMAIN_LIST.Entries                                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST));                    int domainCount = referencedDomains.entries;                    // Extract LSA_REFERENCED_DOMAIN_LIST.Domains' by iterating over the array and marshalling                  // each native LSA_TRUST_INFORMATION into a managed LSA_TRUST_INFORMATION.                    domains = new UnsafeNativeMethods.LSA_TRUST_INFORMATION[domainCount];                    IntPtr pCurrentDomain = referencedDomains.domains;                    for (int i = 0; i < domainCount; i++)                  {                      domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION));                      pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)));                  }                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "SidList: got {0} groups in {1} domains"' sidCount' domainCount);                    //                  // Build the list of entries                  //                  Debug.Assert(names.Length == sidCount);                    for (int i = 0; i < names.Length; i++)                  {                      UnsafeNativeMethods.LSA_TRANSLATED_NAME name = names[i];                        // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      SidListEntry entry = new SidListEntry();                        Debug.Assert(name.name.length % 2 == 0);                      entry.name = Marshal.PtrToStringUni(name.name.buffer' name.name.length / 2);                        // Get the domain associated with this name                      Debug.Assert(name.domainIndex < domains.Length);                      if (name.domainIndex >= 0)                      {                          UnsafeNativeMethods.LSA_TRUST_INFORMATION domain = domains[name.domainIndex];                          Debug.Assert(domain.name.length % 2 == 0);                          entry.sidIssuerName = Marshal.PtrToStringUni(domain.name.buffer' domain.name.length / 2);                      }                        entry.pSid = pSids[i];                        _entries.Add(entry);                  }                    // Sort the list so they are oriented by the issuer name.                  // this.entries.Sort( new SidListComparer());              }              finally              {                  if (pDomains != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pDomains);                    if (pNames != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pNames);                    if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The following statement contains a magic number: try              {                  //                  // Get the policy handle                  //                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                    int err = 0;                  if (target == null)                  {                      err = UnsafeNativeMethods.LsaOpenPolicy(                                      IntPtr.Zero'                                      pOA'                                      0x800'        // POLICY_LOOKUP_NAMES                                      ref pPolicyHandle);                  }                  else                  {                      // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      UnsafeNativeMethods.LSA_UNICODE_STRING_Managed lsaTargetString = new UnsafeNativeMethods.LSA_UNICODE_STRING_Managed();                      lsaTargetString.buffer = target;                      lsaTargetString.length = (ushort)(target.Length * 2);                      lsaTargetString.maximumLength = lsaTargetString.length;                        IntPtr lsaTargetPr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)));                        try                      {                          Marshal.StructureToPtr(lsaTargetString' lsaTargetPr' false);                            err = UnsafeNativeMethods.LsaOpenPolicy(                                          lsaTargetPr'                                          pOA'                                          0x800'        // POLICY_LOOKUP_NAMES                                          ref pPolicyHandle);                      }                      finally                      {                          if (lsaTargetPr != IntPtr.Zero)                          {                              UnsafeNativeMethods.LSA_UNICODE_STRING lsaTargetUnmanagedPtr =                                  (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING));                              if (lsaTargetUnmanagedPtr.buffer != IntPtr.Zero)                              {                                  Marshal.FreeHGlobal(lsaTargetUnmanagedPtr.buffer);                                  lsaTargetUnmanagedPtr.buffer = IntPtr.Zero;                              }                              Marshal.FreeHGlobal(lsaTargetPr);                          }                      }                  }                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: couldn't get policy handle' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                    //                  // Translate the SIDs                  //                    err = UnsafeNativeMethods.LsaLookupSids(                                      pPolicyHandle'                                      sidCount'                                      pSids'                                      out pDomains'                                      out pNames);                    // ignore error STATUS_SOME_NOT_MAPPED = 0x00000107 and                   // STATUS_NONE_MAPPED = 0xC0000073                  if (err != 0 &&                       err != 263 &&                       err != -1073741709)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: LsaLookupSids failed' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    //                  // Get the group names in managed form                  //                  names = new UnsafeNativeMethods.LSA_TRANSLATED_NAME[sidCount];                  IntPtr pCurrentName = pNames;                    for (int i = 0; i < sidCount; i++)                  {                      names[i] = (UnsafeNativeMethods.LSA_TRANSLATED_NAME)                                      Marshal.PtrToStructure(pCurrentName' typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME));                        pCurrentName = new IntPtr(pCurrentName.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME)));                  }                    //                  // Get the domain names in managed form                  //                    // Extract LSA_REFERENCED_DOMAIN_LIST.Entries                                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST));                    int domainCount = referencedDomains.entries;                    // Extract LSA_REFERENCED_DOMAIN_LIST.Domains' by iterating over the array and marshalling                  // each native LSA_TRUST_INFORMATION into a managed LSA_TRUST_INFORMATION.                    domains = new UnsafeNativeMethods.LSA_TRUST_INFORMATION[domainCount];                    IntPtr pCurrentDomain = referencedDomains.domains;                    for (int i = 0; i < domainCount; i++)                  {                      domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION));                      pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)));                  }                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "SidList: got {0} groups in {1} domains"' sidCount' domainCount);                    //                  // Build the list of entries                  //                  Debug.Assert(names.Length == sidCount);                    for (int i = 0; i < names.Length; i++)                  {                      UnsafeNativeMethods.LSA_TRANSLATED_NAME name = names[i];                        // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      SidListEntry entry = new SidListEntry();                        Debug.Assert(name.name.length % 2 == 0);                      entry.name = Marshal.PtrToStringUni(name.name.buffer' name.name.length / 2);                        // Get the domain associated with this name                      Debug.Assert(name.domainIndex < domains.Length);                      if (name.domainIndex >= 0)                      {                          UnsafeNativeMethods.LSA_TRUST_INFORMATION domain = domains[name.domainIndex];                          Debug.Assert(domain.name.length % 2 == 0);                          entry.sidIssuerName = Marshal.PtrToStringUni(domain.name.buffer' domain.name.length / 2);                      }                        entry.pSid = pSids[i];                        _entries.Add(entry);                  }                    // Sort the list so they are oriented by the issuer name.                  // this.entries.Sort( new SidListComparer());              }              finally              {                  if (pDomains != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pDomains);                    if (pNames != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pNames);                    if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,SidList,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SidList.cs,TranslateSids,The following statement contains a magic number: try              {                  //                  // Get the policy handle                  //                  UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES oa = new UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                    int err = 0;                  if (target == null)                  {                      err = UnsafeNativeMethods.LsaOpenPolicy(                                      IntPtr.Zero'                                      pOA'                                      0x800'        // POLICY_LOOKUP_NAMES                                      ref pPolicyHandle);                  }                  else                  {                      // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      UnsafeNativeMethods.LSA_UNICODE_STRING_Managed lsaTargetString = new UnsafeNativeMethods.LSA_UNICODE_STRING_Managed();                      lsaTargetString.buffer = target;                      lsaTargetString.length = (ushort)(target.Length * 2);                      lsaTargetString.maximumLength = lsaTargetString.length;                        IntPtr lsaTargetPr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_UNICODE_STRING)));                        try                      {                          Marshal.StructureToPtr(lsaTargetString' lsaTargetPr' false);                            err = UnsafeNativeMethods.LsaOpenPolicy(                                          lsaTargetPr'                                          pOA'                                          0x800'        // POLICY_LOOKUP_NAMES                                          ref pPolicyHandle);                      }                      finally                      {                          if (lsaTargetPr != IntPtr.Zero)                          {                              UnsafeNativeMethods.LSA_UNICODE_STRING lsaTargetUnmanagedPtr =                                  (UnsafeNativeMethods.LSA_UNICODE_STRING)Marshal.PtrToStructure(lsaTargetPr' typeof(UnsafeNativeMethods.LSA_UNICODE_STRING));                              if (lsaTargetUnmanagedPtr.buffer != IntPtr.Zero)                              {                                  Marshal.FreeHGlobal(lsaTargetUnmanagedPtr.buffer);                                  lsaTargetUnmanagedPtr.buffer = IntPtr.Zero;                              }                              Marshal.FreeHGlobal(lsaTargetPr);                          }                      }                  }                    if (err != 0)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: couldn't get policy handle' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                    //                  // Translate the SIDs                  //                    err = UnsafeNativeMethods.LsaLookupSids(                                      pPolicyHandle'                                      sidCount'                                      pSids'                                      out pDomains'                                      out pNames);                    // ignore error STATUS_SOME_NOT_MAPPED = 0x00000107 and                   // STATUS_NONE_MAPPED = 0xC0000073                  if (err != 0 &&                       err != 263 &&                       err != -1073741709)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "AuthZSet"' "SidList: LsaLookupSids failed' err={0}"' err);                        throw new PrincipalOperationException(String.Format(CultureInfo.CurrentCulture'                                                                 SR.AuthZErrorEnumeratingGroups'                                                                 SafeNativeMethods.LsaNtStatusToWinError(err)));                  }                    //                  // Get the group names in managed form                  //                  names = new UnsafeNativeMethods.LSA_TRANSLATED_NAME[sidCount];                  IntPtr pCurrentName = pNames;                    for (int i = 0; i < sidCount; i++)                  {                      names[i] = (UnsafeNativeMethods.LSA_TRANSLATED_NAME)                                      Marshal.PtrToStructure(pCurrentName' typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME));                        pCurrentName = new IntPtr(pCurrentName.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRANSLATED_NAME)));                  }                    //                  // Get the domain names in managed form                  //                    // Extract LSA_REFERENCED_DOMAIN_LIST.Entries                                UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST referencedDomains = (UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST)Marshal.PtrToStructure(pDomains' typeof(UnsafeNativeMethods.LSA_REFERENCED_DOMAIN_LIST));                    int domainCount = referencedDomains.entries;                    // Extract LSA_REFERENCED_DOMAIN_LIST.Domains' by iterating over the array and marshalling                  // each native LSA_TRUST_INFORMATION into a managed LSA_TRUST_INFORMATION.                    domains = new UnsafeNativeMethods.LSA_TRUST_INFORMATION[domainCount];                    IntPtr pCurrentDomain = referencedDomains.domains;                    for (int i = 0; i < domainCount; i++)                  {                      domains[i] = (UnsafeNativeMethods.LSA_TRUST_INFORMATION)Marshal.PtrToStructure(pCurrentDomain' typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION));                      pCurrentDomain = new IntPtr(pCurrentDomain.ToInt64() + Marshal.SizeOf(typeof(UnsafeNativeMethods.LSA_TRUST_INFORMATION)));                  }                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "AuthZSet"' "SidList: got {0} groups in {1} domains"' sidCount' domainCount);                    //                  // Build the list of entries                  //                  Debug.Assert(names.Length == sidCount);                    for (int i = 0; i < names.Length; i++)                  {                      UnsafeNativeMethods.LSA_TRANSLATED_NAME name = names[i];                        // Build an entry.  Note that LSA_UNICODE_STRING.length is in bytes'                      // while PtrToStringUni expects a length in characters.                      SidListEntry entry = new SidListEntry();                        Debug.Assert(name.name.length % 2 == 0);                      entry.name = Marshal.PtrToStringUni(name.name.buffer' name.name.length / 2);                        // Get the domain associated with this name                      Debug.Assert(name.domainIndex < domains.Length);                      if (name.domainIndex >= 0)                      {                          UnsafeNativeMethods.LSA_TRUST_INFORMATION domain = domains[name.domainIndex];                          Debug.Assert(domain.name.length % 2 == 0);                          entry.sidIssuerName = Marshal.PtrToStringUni(domain.name.buffer' domain.name.length / 2);                      }                        entry.pSid = pSids[i];                        _entries.Add(entry);                  }                    // Sort the list so they are oriented by the issuer name.                  // this.entries.Sort( new SidListComparer());              }              finally              {                  if (pDomains != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pDomains);                    if (pNames != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pNames);                    if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadFilterMappingTable,The following statement contains a magic number: for (int i = 0; i < rawFilterPropertiesTable.GetLength(0); i++)              {                  Type qbeType = rawFilterPropertiesTable[i' 0] as Type;                  string adPropertyName = rawFilterPropertiesTable[i' 1] as string;                  FilterConverterDelegate f = rawFilterPropertiesTable[i' 2] as FilterConverterDelegate;                    Debug.Assert(qbeType != null);                  Debug.Assert(f != null);                    // There should only be one entry per QBE type                  Debug.Assert(mappingTable[qbeType] == null);                    FilterPropertyTableEntry entry = new FilterPropertyTableEntry();                  entry.suggestedADPropertyName = adPropertyName;                  entry.converter = f;                    mappingTable[qbeType] = entry;              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadPropertyMappingTable,The following statement contains a magic number: for (int i = 0; i < s_propertyMappingTableRaw.GetLength(0); i++)              {                  string propertyName = rawPropertyMappingTable[i' 0] as string;                  string ldapAttribute = rawPropertyMappingTable[i' 1] as string;                  FromLdapConverterDelegate fromLdap = rawPropertyMappingTable[i' 2] as FromLdapConverterDelegate;                  ToLdapConverterDelegate toLdap = rawPropertyMappingTable[i' 3] as ToLdapConverterDelegate;                    Debug.Assert(propertyName != null);                  Debug.Assert((ldapAttribute != null && fromLdap != null) || (fromLdap == null));                  //Debug.Assert(toLdap != null);                    // Build the table entry.  The same entry will be used in both tables.                  // Once constructed' the table entries are treated as read-only' so there's                  // no danger in sharing the entries between tables.                  PropertyMappingTableEntry propertyEntry = new PropertyMappingTableEntry();                  propertyEntry.propertyName = propertyName;                  propertyEntry.suggestedADPropertyName = ldapAttribute;                  propertyEntry.ldapToPapiConverter = fromLdap;                  propertyEntry.papiToLdapConverter = toLdap;                    // Build a mapping table from PAPI propertyname to ldapAttribute that we can use below                  // to build a list of ldap attributes for each object type.                  if (null != ldapAttribute)                  {                      if (propertyNameToLdapAttr.ContainsKey(propertyName))                      {                          string[] props = new string[propertyNameToLdapAttr[propertyName].Length + 1];                          propertyNameToLdapAttr[propertyName].CopyTo(props' 0);                          props[propertyNameToLdapAttr[propertyName].Length] = ldapAttribute;                          propertyNameToLdapAttr[propertyName] = props;                      }                      else                          propertyNameToLdapAttr.Add(propertyName' new string[] { ldapAttribute });                  }                    // propertyMappingTableByProperty                  // If toLdap is null' there's no PAPI->LDAP mapping for this property                  // (it's probably read-only' e.g.' "lastLogon").                  if (toLdap != null)                  {                      if (mappingTableByProperty[propertyName] == null)                          mappingTableByProperty[propertyName] = new ArrayList();                        ((ArrayList)mappingTableByProperty[propertyName]).Add(propertyEntry);                  }                    if (mappingTableByPropertyFull[propertyName] == null)                      mappingTableByPropertyFull[propertyName] = new ArrayList();                    ((ArrayList)mappingTableByPropertyFull[propertyName]).Add(propertyEntry);                    // mappingTableByLDAP                  // If fromLdap is null' there's no direct LDAP->PAPI mapping for this property.                  // It's probably a property that requires custom handling' such as IdentityClaim.                  if (fromLdap != null)                  {                      string ldapAttributeLower = ldapAttribute.ToLower(CultureInfo.InvariantCulture);                        if (mappingTableByLDAP[ldapAttributeLower] == null)                          mappingTableByLDAP[ldapAttributeLower] = new ArrayList();                        ((ArrayList)mappingTableByLDAP[ldapAttributeLower]).Add(propertyEntry);                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadPropertyMappingTable,The following statement contains a magic number: for (int i = 0; i < s_propertyMappingTableRaw.GetLength(0); i++)              {                  string propertyName = rawPropertyMappingTable[i' 0] as string;                  string ldapAttribute = rawPropertyMappingTable[i' 1] as string;                  FromLdapConverterDelegate fromLdap = rawPropertyMappingTable[i' 2] as FromLdapConverterDelegate;                  ToLdapConverterDelegate toLdap = rawPropertyMappingTable[i' 3] as ToLdapConverterDelegate;                    Debug.Assert(propertyName != null);                  Debug.Assert((ldapAttribute != null && fromLdap != null) || (fromLdap == null));                  //Debug.Assert(toLdap != null);                    // Build the table entry.  The same entry will be used in both tables.                  // Once constructed' the table entries are treated as read-only' so there's                  // no danger in sharing the entries between tables.                  PropertyMappingTableEntry propertyEntry = new PropertyMappingTableEntry();                  propertyEntry.propertyName = propertyName;                  propertyEntry.suggestedADPropertyName = ldapAttribute;                  propertyEntry.ldapToPapiConverter = fromLdap;                  propertyEntry.papiToLdapConverter = toLdap;                    // Build a mapping table from PAPI propertyname to ldapAttribute that we can use below                  // to build a list of ldap attributes for each object type.                  if (null != ldapAttribute)                  {                      if (propertyNameToLdapAttr.ContainsKey(propertyName))                      {                          string[] props = new string[propertyNameToLdapAttr[propertyName].Length + 1];                          propertyNameToLdapAttr[propertyName].CopyTo(props' 0);                          props[propertyNameToLdapAttr[propertyName].Length] = ldapAttribute;                          propertyNameToLdapAttr[propertyName] = props;                      }                      else                          propertyNameToLdapAttr.Add(propertyName' new string[] { ldapAttribute });                  }                    // propertyMappingTableByProperty                  // If toLdap is null' there's no PAPI->LDAP mapping for this property                  // (it's probably read-only' e.g.' "lastLogon").                  if (toLdap != null)                  {                      if (mappingTableByProperty[propertyName] == null)                          mappingTableByProperty[propertyName] = new ArrayList();                        ((ArrayList)mappingTableByProperty[propertyName]).Add(propertyEntry);                  }                    if (mappingTableByPropertyFull[propertyName] == null)                      mappingTableByPropertyFull[propertyName] = new ArrayList();                    ((ArrayList)mappingTableByPropertyFull[propertyName]).Add(propertyEntry);                    // mappingTableByLDAP                  // If fromLdap is null' there's no direct LDAP->PAPI mapping for this property.                  // It's probably a property that requires custom handling' such as IdentityClaim.                  if (fromLdap != null)                  {                      string ldapAttributeLower = ldapAttribute.ToLower(CultureInfo.InvariantCulture);                        if (mappingTableByLDAP[ldapAttributeLower] == null)                          mappingTableByLDAP[ldapAttributeLower] = new ArrayList();                        ((ArrayList)mappingTableByLDAP[ldapAttributeLower]).Add(propertyEntry);                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindByDate,The following statement contains a magic number: try              {                  // Pick some reasonable default values                  ds.PageSize = 256;                  ds.ServerTimeLimit = new TimeSpan(0' 0' 30);  // 30 seconds                    // We don't need any attributes returned' since we're just going to get a DirectoryEntry                  // for the result.  Per RFC 2251' OID 1.1 == no attributes.                  BuildPropertySet(subtype' ds.PropertiesToLoad);                    // Build the LDAP filter                  string ldapValue = ADUtils.DateTimeToADString(value);                  StringBuilder ldapFilter = new StringBuilder();                    ldapFilter.Append(GetObjectClassPortion(subtype));                  ldapFilter.Append("(|");                    foreach (string ldapAttribute in ldapAttributes)                  {                      ldapFilter.Append("(");                        switch (matchType)                      {                          case MatchType.Equals:                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=");                              ldapFilter.Append(ldapValue);                              break;                            case MatchType.NotEquals:                              ldapFilter.Append("!(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=");                              ldapFilter.Append(ldapValue);                              ldapFilter.Append(")");                              break;                            case MatchType.GreaterThanOrEquals:                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append(">=");                              ldapFilter.Append(ldapValue);                              break;                            case MatchType.LessThanOrEquals:                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("<=");                              ldapFilter.Append(ldapValue);                              break;                            case MatchType.GreaterThan:                              ldapFilter.Append("&");                                // Greater-than-or-equals (or less-than-or-equals))                              ldapFilter.Append("(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append(matchType == MatchType.GreaterThan ? ">=" : "<=");                              ldapFilter.Append(ldapValue);                              ldapFilter.Append(")");                                // And not-equal                              ldapFilter.Append("(!(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=");                              ldapFilter.Append(ldapValue);                              ldapFilter.Append("))");                                // And exists (need to include because of tristate LDAP logic)                              ldapFilter.Append("(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=*)");                              break;                            case MatchType.LessThan:                              goto case MatchType.GreaterThan;                            default:                              Debug.Fail("ADStoreCtx.FindByDate: fell off end looking for " + matchType.ToString());                              break;                      }                        ldapFilter.Append(")");                  }                    ldapFilter.Append("))");                    ds.Filter = ldapFilter.ToString();                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "FindByDate: using LDAP filter {0}"' ds.Filter);                    // Perform the search                  SearchResultCollection src = ds.FindAll();                  Debug.Assert(src != null);                    // Create a ResultSet for the search results                  ADEntriesSet resultSet = new ADEntriesSet(src' this);                    return resultSet;              }              catch (System.Runtime.InteropServices.COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(e);              }              finally              {                  ds.Dispose();              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindByDate,The following statement contains a magic number: try              {                  // Pick some reasonable default values                  ds.PageSize = 256;                  ds.ServerTimeLimit = new TimeSpan(0' 0' 30);  // 30 seconds                    // We don't need any attributes returned' since we're just going to get a DirectoryEntry                  // for the result.  Per RFC 2251' OID 1.1 == no attributes.                  BuildPropertySet(subtype' ds.PropertiesToLoad);                    // Build the LDAP filter                  string ldapValue = ADUtils.DateTimeToADString(value);                  StringBuilder ldapFilter = new StringBuilder();                    ldapFilter.Append(GetObjectClassPortion(subtype));                  ldapFilter.Append("(|");                    foreach (string ldapAttribute in ldapAttributes)                  {                      ldapFilter.Append("(");                        switch (matchType)                      {                          case MatchType.Equals:                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=");                              ldapFilter.Append(ldapValue);                              break;                            case MatchType.NotEquals:                              ldapFilter.Append("!(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=");                              ldapFilter.Append(ldapValue);                              ldapFilter.Append(")");                              break;                            case MatchType.GreaterThanOrEquals:                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append(">=");                              ldapFilter.Append(ldapValue);                              break;                            case MatchType.LessThanOrEquals:                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("<=");                              ldapFilter.Append(ldapValue);                              break;                            case MatchType.GreaterThan:                              ldapFilter.Append("&");                                // Greater-than-or-equals (or less-than-or-equals))                              ldapFilter.Append("(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append(matchType == MatchType.GreaterThan ? ">=" : "<=");                              ldapFilter.Append(ldapValue);                              ldapFilter.Append(")");                                // And not-equal                              ldapFilter.Append("(!(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=");                              ldapFilter.Append(ldapValue);                              ldapFilter.Append("))");                                // And exists (need to include because of tristate LDAP logic)                              ldapFilter.Append("(");                              ldapFilter.Append(ldapAttribute);                              ldapFilter.Append("=*)");                              break;                            case MatchType.LessThan:                              goto case MatchType.GreaterThan;                            default:                              Debug.Fail("ADStoreCtx.FindByDate: fell off end looking for " + matchType.ToString());                              break;                      }                        ldapFilter.Append(")");                  }                    ldapFilter.Append("))");                    ds.Filter = ldapFilter.ToString();                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "FindByDate: using LDAP filter {0}"' ds.Filter);                    // Perform the search                  SearchResultCollection src = ds.FindAll();                  Debug.Assert(src != null);                    // Create a ResultSet for the search results                  ADEntriesSet resultSet = new ADEntriesSet(src' this);                    return resultSet;              }              catch (System.Runtime.InteropServices.COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(e);              }              finally              {                  ds.Dispose();              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The following statement contains a magic number: try              {                  if (rootPrincipalExists)                  {                      if (this.DefaultNamingContext != null)                      {                          dncContainer = new DirectoryEntry(@"LDAP://" + this.UserSuppliedServerName + @"/" + this.DefaultNamingContext' Credentials != null ? this.Credentials.UserName : null' Credentials != null ? this.Credentials.Password : null' this.AuthTypes);                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): Read DNC of {0}"' this.DefaultNamingContext);                            fspWkDn = ADUtils.RetriveWkDn(dncContainer' this.DefaultNamingContext' this.UserSuppliedServerName' Constants.GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE);                            if (null != fspWkDn)                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): Read fsp DN {0}"' fspWkDn);                              fspContainer = new DirectoryEntry(fspWkDn' Credentials != null ? this.credentials.UserName : null' Credentials != null ? this.credentials.Password : null' this.authTypes);                          }                      }                        ds = new DirectorySearcher((fspContainer != null) ? fspContainer : ((dncContainer != null ? dncContainer : this.ctxBase)));                        // Pick some reasonable default values                      ds.PageSize = 256;                      ds.ServerTimeLimit = new TimeSpan(0' 0' 30);  // 30 seconds                        // Build the LDAP filter                      // Converr the object to a SDDL format                      string stringSid = Utils.SecurityIdentifierToLdapHexFilterString(Sid);                      if (stringSid == null)                          throw new InvalidOperationException(SR.StoreCtxNeedValueSecurityIdentityClaimToQuery);                        ds.Filter = "(objectSid=" + stringSid + ")";                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): using LDAP filter {0}"' ds.Filter);                        // We only need a few attributes                      ds.PropertiesToLoad.Add("memberOf");                      ds.PropertiesToLoad.Add("distinguishedName");                      ds.PropertiesToLoad.Add("primaryGroupID");                      ds.PropertiesToLoad.Add("objectSid");                        // If no corresponding principal exists in this store' then by definition the principal isn't                      // a member of any groups in this store.                      SearchResult sr = ds.FindOne();                        if (sr == null)                      {                          // no match so we better do a root level search in case we are targetting a domain where                          // the user is not an FSP.                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): No match");                            // We already did a root level search so just exit.                            if (null == fspWkDn)                              return new EmptySet();                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): performing DNC level search");                            ds.SearchRoot = dncContainer;                          sr = ds.FindOne();                            if (sr == null)                              return new EmptySet();                      }                        // Now that we found the corresponding principal' the rest is very similiar to the plain GetGroupsMemberOf()                      // case' exception we're working with search results (SearchResult/ResultPropertyValueCollection) rather                      // than DirectoryEntry/PropertyValueCollection.                      string principalDN = (string)sr.Properties["distinguishedName"][0];                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): match' DN={0}"' principalDN);                        //Here a new DirectoryEntry object is created by sr.GetDirectoryEntry() and passed                       //to RangeRetriever object. Hence' configuring RangeRetriever to dispose the DirEntry on its dispose.                       IEnumerable memberOf = new RangeRetriever(sr.GetDirectoryEntry()' "memberOf"' true);                        string primaryGroupDN = null;                        if ((sr.Properties["primaryGroupID"].Count > 0) &&                          (sr.Properties["objectSid"].Count > 0))                      {                          Debug.Assert(sr.Properties["primaryGroupID"].Count == 1);                          Debug.Assert(sr.Properties["objectSid"].Count == 1);                            int primaryGroupID = (int)sr.Properties["primaryGroupID"][0];                          byte[] principalSid = (byte[])sr.Properties["objectSid"][0];                            primaryGroupDN = GetGroupDnFromGroupID(principalSid' primaryGroupID);                          GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): primary group DN={0}"' primaryGroupDN);                      }                        resultSet = new ADDNConstraintLinkedAttrSet(ADDNConstraintLinkedAttrSet.ConstraintType.ContainerStringMatch' this.ctxBase.Properties["distinguishedName"].Value' principalDN' new IEnumerable[] { memberOf }' primaryGroupDN' null' false' this);                  }                  else                  {                      // We don't need to retrive the Primary group ID here because we have already established that this user is not from this domain                      // and the users primary group must be from the same domain as the user.                      Debug.Assert(foreignPrincipal.ContextType != ContextType.ApplicationDirectory);                        DirectorySearcher[] memberSearcher = { SDSUtils.ConstructSearcher(this.ctxBase) };                      memberSearcher[0].Filter = "(&(objectClass=Group)(member=" + foreignPrincipal.DistinguishedName + "))";                      memberSearcher[0].CacheResults = false;                        resultSet = new ADDNLinkedAttrSet(foreignPrincipal.DistinguishedName' memberSearcher' null' null' false' this);                  }                    return resultSet;              }              catch (System.Runtime.InteropServices.COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(e);              }              finally              {                  if (null != fspContainer)                      fspContainer.Dispose();                  if (null != ds)                      ds.Dispose();                  if (null != dncContainer)                      dncContainer.Dispose();              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetGroupsMemberOf,The following statement contains a magic number: try              {                  if (rootPrincipalExists)                  {                      if (this.DefaultNamingContext != null)                      {                          dncContainer = new DirectoryEntry(@"LDAP://" + this.UserSuppliedServerName + @"/" + this.DefaultNamingContext' Credentials != null ? this.Credentials.UserName : null' Credentials != null ? this.Credentials.Password : null' this.AuthTypes);                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): Read DNC of {0}"' this.DefaultNamingContext);                            fspWkDn = ADUtils.RetriveWkDn(dncContainer' this.DefaultNamingContext' this.UserSuppliedServerName' Constants.GUID_FOREIGNSECURITYPRINCIPALS_CONTAINER_BYTE);                            if (null != fspWkDn)                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): Read fsp DN {0}"' fspWkDn);                              fspContainer = new DirectoryEntry(fspWkDn' Credentials != null ? this.credentials.UserName : null' Credentials != null ? this.credentials.Password : null' this.authTypes);                          }                      }                        ds = new DirectorySearcher((fspContainer != null) ? fspContainer : ((dncContainer != null ? dncContainer : this.ctxBase)));                        // Pick some reasonable default values                      ds.PageSize = 256;                      ds.ServerTimeLimit = new TimeSpan(0' 0' 30);  // 30 seconds                        // Build the LDAP filter                      // Converr the object to a SDDL format                      string stringSid = Utils.SecurityIdentifierToLdapHexFilterString(Sid);                      if (stringSid == null)                          throw new InvalidOperationException(SR.StoreCtxNeedValueSecurityIdentityClaimToQuery);                        ds.Filter = "(objectSid=" + stringSid + ")";                        GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): using LDAP filter {0}"' ds.Filter);                        // We only need a few attributes                      ds.PropertiesToLoad.Add("memberOf");                      ds.PropertiesToLoad.Add("distinguishedName");                      ds.PropertiesToLoad.Add("primaryGroupID");                      ds.PropertiesToLoad.Add("objectSid");                        // If no corresponding principal exists in this store' then by definition the principal isn't                      // a member of any groups in this store.                      SearchResult sr = ds.FindOne();                        if (sr == null)                      {                          // no match so we better do a root level search in case we are targetting a domain where                          // the user is not an FSP.                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): No match");                            // We already did a root level search so just exit.                            if (null == fspWkDn)                              return new EmptySet();                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): performing DNC level search");                            ds.SearchRoot = dncContainer;                          sr = ds.FindOne();                            if (sr == null)                              return new EmptySet();                      }                        // Now that we found the corresponding principal' the rest is very similiar to the plain GetGroupsMemberOf()                      // case' exception we're working with search results (SearchResult/ResultPropertyValueCollection) rather                      // than DirectoryEntry/PropertyValueCollection.                      string principalDN = (string)sr.Properties["distinguishedName"][0];                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): match' DN={0}"' principalDN);                        //Here a new DirectoryEntry object is created by sr.GetDirectoryEntry() and passed                       //to RangeRetriever object. Hence' configuring RangeRetriever to dispose the DirEntry on its dispose.                       IEnumerable memberOf = new RangeRetriever(sr.GetDirectoryEntry()' "memberOf"' true);                        string primaryGroupDN = null;                        if ((sr.Properties["primaryGroupID"].Count > 0) &&                          (sr.Properties["objectSid"].Count > 0))                      {                          Debug.Assert(sr.Properties["primaryGroupID"].Count == 1);                          Debug.Assert(sr.Properties["objectSid"].Count == 1);                            int primaryGroupID = (int)sr.Properties["primaryGroupID"][0];                          byte[] principalSid = (byte[])sr.Properties["objectSid"][0];                            primaryGroupDN = GetGroupDnFromGroupID(principalSid' primaryGroupID);                          GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "GetGroupsMemberOf(ctx): primary group DN={0}"' primaryGroupDN);                      }                        resultSet = new ADDNConstraintLinkedAttrSet(ADDNConstraintLinkedAttrSet.ConstraintType.ContainerStringMatch' this.ctxBase.Properties["distinguishedName"].Value' principalDN' new IEnumerable[] { memberOf }' primaryGroupDN' null' false' this);                  }                  else                  {                      // We don't need to retrive the Primary group ID here because we have already established that this user is not from this domain                      // and the users primary group must be from the same domain as the user.                      Debug.Assert(foreignPrincipal.ContextType != ContextType.ApplicationDirectory);                        DirectorySearcher[] memberSearcher = { SDSUtils.ConstructSearcher(this.ctxBase) };                      memberSearcher[0].Filter = "(&(objectClass=Group)(member=" + foreignPrincipal.DistinguishedName + "))";                      memberSearcher[0].CacheResults = false;                        resultSet = new ADDNLinkedAttrSet(foreignPrincipal.DistinguishedName' memberSearcher' null' null' false' this);                  }                    return resultSet;              }              catch (System.Runtime.InteropServices.COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(e);              }              finally              {                  if (null != fspContainer)                      fspContainer.Dispose();                  if (null != ds)                      ds.Dispose();                  if (null != dncContainer)                      dncContainer.Dispose();              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetDirectorySearcherFromGroupID,The following statement contains a magic number: ds.PageSize = 256;
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetDirectorySearcherFromGroupID,The following statement contains a magic number: ds.ServerTimeLimit = new TimeSpan(0' 0' 30);
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,IsMemberOfInStore,The following statement contains a magic number: try              {                  string path = String.Format(                      CultureInfo.InvariantCulture'                      "LDAP://{0}/{1}"'                      String.IsNullOrEmpty(this.UserSuppliedServerName) ? this.DnsHostName : this.UserSuppliedServerName'                      this.ContextBasePartitionDN                      );                    defaultNCDirEntry = SDSUtils.BuildDirectoryEntry(path' this.credentials' this.authTypes);                    ds = new DirectorySearcher(defaultNCDirEntry);                    // Pick some reasonable default values                  ds.ServerTimeLimit = new TimeSpan(0' 0' 30);  // 30 seconds                    // Build the LDAP filter' Convert the sid to SDDL format                  string stringSid = Utils.SecurityIdentifierToLdapHexFilterString(Sid);                  if (stringSid == null)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADStoreCtx"' "IsMemberOfInStore: bad SID IC");                      throw new ArgumentException(SR.StoreCtxNeedValueSecurityIdentityClaimToQuery);                  }                    ds.Filter = "(&(objectClass=foreignSecurityPrincipal)(objectSid=" + stringSid + "))";                  GlobalDebug.WriteLineIf(GlobalDebug.Info'                                          "ADStoreCtx"'                                          "IsMemberOfInStore: FPO principal' using LDAP filter {0}"'                                          ds.Filter);                    ds.PropertiesToLoad.Add("distinguishedName");                    SearchResult sr = ds.FindOne();                    // No FPO ---> not a member                  if (sr == null)                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "IsMemberOfInStore: no FPO found");                      return false;                  }                  string fpoDN = (string)sr.Properties["distinguishedName"][0];                  foreach (string memberDN in cachedMembersEnum)                  {                      if (string.Equals(fpoDN' memberDN' StringComparison.OrdinalIgnoreCase))                      {                          return true;                      }                  }                  return false;              }              catch (System.Runtime.InteropServices.COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(e);              }              finally              {                  if (ds != null)                  {                      ds.Dispose();                  }                  if (defaultNCDirEntry != null)                  {                      defaultNCDirEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The following statement contains a magic number: using (DirectoryEntry rootDse = new DirectoryEntry("LDAP://" + this.dnsHostName + "/rootDse"' ""' ""' AuthenticationTypes.Anonymous))              {                  this.defaultNamingContext = (string)rootDse.Properties["defaultNamingContext"][0];                  this.contextBasePartitionDN = this.defaultNamingContext;                    // Split the naming context's DN into its RDNs                  string[] ncComponents = defaultNamingContext.Split(new char[] { ''' });                    StringBuilder sb = new StringBuilder();                    // Reassemble the RDNs (minus the tag) into the DNS domain name                  foreach (string component in ncComponents)                  {                      // If it's not a "DC=" component' skip it                      if ((component.Length > 3) &&                          (String.Compare(component.Substring(0' 3)' "DC="' StringComparison.OrdinalIgnoreCase) == 0))                      {                          sb.Append(component.Substring(3));                          sb.Append(".");                      }                  }                    dnsDomainName = sb.ToString();                    // The loop added an extra period at the end.  Remove it.                  if (dnsDomainName.Length > 0)                      dnsDomainName = dnsDomainName.Substring(0' dnsDomainName.Length - 1);                    this.domainDnsName = dnsDomainName;                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using DNS domain name {0}"' dnsDomainName);              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The following statement contains a magic number: using (DirectoryEntry rootDse = new DirectoryEntry("LDAP://" + this.dnsHostName + "/rootDse"' ""' ""' AuthenticationTypes.Anonymous))              {                  this.defaultNamingContext = (string)rootDse.Properties["defaultNamingContext"][0];                  this.contextBasePartitionDN = this.defaultNamingContext;                    // Split the naming context's DN into its RDNs                  string[] ncComponents = defaultNamingContext.Split(new char[] { ''' });                    StringBuilder sb = new StringBuilder();                    // Reassemble the RDNs (minus the tag) into the DNS domain name                  foreach (string component in ncComponents)                  {                      // If it's not a "DC=" component' skip it                      if ((component.Length > 3) &&                          (String.Compare(component.Substring(0' 3)' "DC="' StringComparison.OrdinalIgnoreCase) == 0))                      {                          sb.Append(component.Substring(3));                          sb.Append(".");                      }                  }                    dnsDomainName = sb.ToString();                    // The loop added an extra period at the end.  Remove it.                  if (dnsDomainName.Length > 0)                      dnsDomainName = dnsDomainName.Substring(0' dnsDomainName.Length - 1);                    this.domainDnsName = dnsDomainName;                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using DNS domain name {0}"' dnsDomainName);              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The following statement contains a magic number: using (DirectoryEntry rootDse = new DirectoryEntry("LDAP://" + this.dnsHostName + "/rootDse"' ""' ""' AuthenticationTypes.Anonymous))              {                  this.defaultNamingContext = (string)rootDse.Properties["defaultNamingContext"][0];                  this.contextBasePartitionDN = this.defaultNamingContext;                    // Split the naming context's DN into its RDNs                  string[] ncComponents = defaultNamingContext.Split(new char[] { ''' });                    StringBuilder sb = new StringBuilder();                    // Reassemble the RDNs (minus the tag) into the DNS domain name                  foreach (string component in ncComponents)                  {                      // If it's not a "DC=" component' skip it                      if ((component.Length > 3) &&                          (String.Compare(component.Substring(0' 3)' "DC="' StringComparison.OrdinalIgnoreCase) == 0))                      {                          sb.Append(component.Substring(3));                          sb.Append(".");                      }                  }                    dnsDomainName = sb.ToString();                    // The loop added an extra period at the end.  Remove it.                  if (dnsDomainName.Length > 0)                      dnsDomainName = dnsDomainName.Substring(0' dnsDomainName.Length - 1);                    this.domainDnsName = dnsDomainName;                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using DNS domain name {0}"' dnsDomainName);              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,LoadDomainInfo,The following statement contains a magic number: try              {                  this.userSuppliedServerName = pathName.Retrieve(9 /*ADS_FORMAT_SERVER */);                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using user-supplied name {0}"' this.userSuppliedServerName);              }              catch (COMException e)              {                  if (((uint)e.ErrorCode) == ((uint)0x80005000))  // E_ADS_BAD_PATHNAME                  {                      // Serverless path                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using empty string as user-supplied name");                      this.userSuppliedServerName = "";                  }                  else                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Error'                                              "ADStoreCtx"'                                              "LoadComputerInfo: caught COMException {0} {1} looking for user-supplied name"'                                              e.ErrorCode'                                              e.Message);                        throw;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,PushFilterToNativeSearcher,The following statement contains a magic number: if (ps.UnderlyingSearcher == null)              {                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "PushFilterToNativeSearcher: creating fresh DirectorySearcher");                    ps.UnderlyingSearcher = new DirectorySearcher(this.ctxBase);                  ((DirectorySearcher)ps.UnderlyingSearcher).PageSize = ps.PageSize;                  ((DirectorySearcher)ps.UnderlyingSearcher).ServerTimeLimit = new TimeSpan(0' 0' 30);  // 30 seconds              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetEscapedDN,The following statement contains a magic number: pathCracker.EscapedMode = 2 /* ADS_ESCAPEDMODE_ON */;
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetEscapedDN,The following statement contains a magic number: pathCracker.Set(dn' 4 /* ADS_SETTYPE_DN */);
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,GetEscapedDN,The following statement contains a magic number: return pathCracker.Retrieve(7 /* ADS_FORMAT_X500_DN */);
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,FindPrincipalByIdentRefHelper,The following statement contains a magic number: try              {                  ds.SizeLimit = 2;   // so we can efficiently check for duplicates                    // If we are searching for AuthPrincpal or Principal in the end we will construct the acutal type                  // i.e. if the objects objectClass is User we will construct a UserPrincipal even though they searched for Principal.FindByIdentity                  // At this time we don't know the actual object type so we have to ask AD for all the attributes of the derived types so they are there                  // when we go to load the principal.                  if (principalType == typeof(Principal) || principalType == typeof(AuthenticablePrincipal))                  {                      BuildPropertySet(typeof(UserPrincipal)' ds.PropertiesToLoad);                      BuildPropertySet(typeof(GroupPrincipal)' ds.PropertiesToLoad);                      BuildPropertySet(typeof(ComputerPrincipal)' ds.PropertiesToLoad);                        if (principalType == typeof(Principal))                      {                          BuildPropertySet(typeof(AuthenticablePrincipal)' ds.PropertiesToLoad);                      }                  }                    BuildPropertySet(principalType' ds.PropertiesToLoad);                    //                  // Build an appropriate filter                  //                    StringBuilder ldapFilter = new StringBuilder();                    // Limit the results returned to principalType by specifying the corresponding objectClass/objectCategory                  ldapFilter.Append(GetObjectClassPortion(principalType));                    // Build the rest of the filter based off of the user's specified IdentityReference.                  if (urnScheme != null)                  {                      // If they're searching by SID for a SID corresponding to a fake group' construct                      // and return the fake group                      if ((urnScheme == UrnScheme.SidScheme) &&                           (principalType == typeof(Principal) || principalType == typeof(GroupPrincipal) || principalType.IsSubclassOf(typeof(GroupPrincipal))))                      {                          SecurityIdentifier sid = new SecurityIdentifier(urnValue);                          byte[] sidb = new byte[sid.BinaryLength];                          sid.GetBinaryForm(sidb' 0);                          //                        = Utils.StringToByteArray(urnValue);                            if (sid == null)                              throw new ArgumentException(SR.StoreCtxSecurityIdentityClaimBadFormat);                            IntPtr pSid = IntPtr.Zero;                            try                          {                              pSid = Utils.ConvertByteArrayToIntPtr(sidb);                                if (UnsafeNativeMethods.IsValidSid(pSid) && (Utils.ClassifySID(pSid) == SidType.FakeObject))                              {                                  GlobalDebug.WriteLineIf(GlobalDebug.Info'                                                          "ADStoreCtx"'                                                          "FindPrincipalByIdentRefHelper: fake principal' SID Scheme' {0}"'                                                          sid.ToString());                                    return ConstructFakePrincipalFromSID(sidb);                              }                          }                          finally                          {                              if (pSid != IntPtr.Zero)                                  Marshal.FreeHGlobal(pSid);                          }                      }                        // This is the simple case --- we got a specific UrnScheme' so we'll just build                      // a filter for it.                        // Ignore referenceDate --- all IdentityClaims in AD are forever                      string innerLdapFilter = null;                      BuildLdapFilterFromIdentityClaim(urnValue' urnScheme' ref innerLdapFilter' useSidHistory' true);                        ldapFilter.Append(innerLdapFilter);                  }                  else                  {                      // Are they perhaps searching for a fake group?                      // If they passed in a valid SID for a fake group' construct and return the fake                      // group.                                      if (principalType == typeof(Principal) || principalType == typeof(GroupPrincipal) || principalType.IsSubclassOf(typeof(GroupPrincipal)))                      {                          SecurityIdentifier sid = null;                          byte[] sidb = null;                          try                          {                              sid = new SecurityIdentifier(urnValue);                              sidb = new byte[sid.BinaryLength];                              sid.GetBinaryForm(sidb' 0);                          }                          catch (ArgumentException)                          {                          }                            if (sidb != null)                          {                              // They passed in a hex string' is it a valid SID' and if so' does it correspond to a fake                              // principal?                              IntPtr pSid = IntPtr.Zero;                                try                              {                                  pSid = Utils.ConvertByteArrayToIntPtr(sidb);                                    if (UnsafeNativeMethods.IsValidSid(pSid) && (Utils.ClassifySID(pSid) == SidType.FakeObject))                                  {                                      GlobalDebug.WriteLineIf(GlobalDebug.Info'                                                              "ADStoreCtx"'                                                              "FindPrincipalByIdentRefHelper: fake principal' null Scheme' {0}"'                                                              sid.ToString());                                        return ConstructFakePrincipalFromSID(sidb);                                  }                              }                              finally                              {                                  if (pSid != IntPtr.Zero)                                      Marshal.FreeHGlobal(pSid);                              }                          }                      }                        // This is the tricky case.  They didn't specify a UrnScheme' so we need to                      // try all of them.                        string[] urnSchemesToTry = new string[]                      {                          UrnScheme.SamAccountScheme'                          UrnScheme.UpnScheme'                          UrnScheme.DistinguishedNameScheme'                          UrnScheme.SidScheme'                          UrnScheme.GuidScheme'                          UrnScheme.NameScheme                      };                        StringBuilder innerLdapFilter = new StringBuilder();                        innerLdapFilter.Append("(|");                        string filterVal = null;                        foreach (string urnSchemeToTry in urnSchemesToTry)                      {                          if (BuildLdapFilterFromIdentityClaim(urnValue' urnSchemeToTry' ref filterVal' useSidHistory' false))                              if (null != filterVal)                                  innerLdapFilter.Append(filterVal);                      }                        innerLdapFilter.Append(")");                        ldapFilter.Append(innerLdapFilter.ToString());                  }                    // Wrap off the filter                  ldapFilter.Append(")");                    ds.Filter = ldapFilter.ToString();                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "FindPrincipalByIdentRefHelper: using LDAP filter {0}"' ds.Filter);                    //                  // Perform the actual search                  //                  src = ds.FindAll();                    Debug.Assert(src != null);                    if (src == null)                      return null;                    // Did we find a match?                  int count = src.Count;                    GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "FindPrincipalByIdentRefHelper: found {0} matches"' count);                    // Did we find more than one match?                  if (count > 1)                      throw new MultipleMatchesException(SR.MultipleMatchingPrincipals);                    if (count == 0)                      return null;                    return GetAsPrincipal(src[0]' principalType);              }              catch (System.Runtime.InteropServices.COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(e);              }              finally              {                  ds.Dispose();                  if (src != null)                  {                      src.Dispose();                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,AcctExpirToLdapConverter,The following statement contains a magic number: if (!dt.HasValue)              {                  // no expiration date                  largeInt.LowPart = unchecked((int)0xffffffff);                  largeInt.HighPart = (int)0x7fffffff;              }              else              {                  Int64 filetime = ADUtils.DateTimeToADFileTime(dt.Value);                    uint lowPart = (uint)(((ulong)filetime) & ((ulong)0x00000000ffffffff));                  uint highPart = (uint)((((ulong)filetime) & ((ulong)0xffffffff00000000)) >> 32);                    largeInt.LowPart = (int)lowPart;                  largeInt.HighPart = (int)highPart;              }
Magic Number,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,BuildPathFromDN,The following statement contains a magic number: if (null == _pathCracker)              {                  lock (_pathLock)                  {                      if (null == _pathCracker)                      {                          UnsafeNativeMethods.Pathname pathNameObj = new UnsafeNativeMethods.Pathname();                          _pathCracker = (UnsafeNativeMethods.IADsPathname)pathNameObj;                          _pathCracker.EscapedMode = 2 /* ADS_ESCAPEDMODE_ON */;                      }                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,BuildPathFromDN,The following statement contains a magic number: _pathCracker.Set(dn' 4 /* ADS_SETTYPE_DN */);
Magic Number,System.DirectoryServices.AccountManagement,ADDNLinkedAttrSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADDNLinkedAttrSet.cs,BuildPathFromDN,The following statement contains a magic number: string escapedDn = _pathCracker.Retrieve(7 /* ADS_FORMAT_X500_DN */);
Magic Number,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,EscapeBinaryValue,The following statement contains a magic number: StringBuilder sb = new StringBuilder(bytes.Length * 3);
Magic Number,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,LargeIntToInt64,The following statement contains a magic number: Int64 i = (long)(((ulong)lowPart) | (((ulong)highPart) << 32));
Magic Number,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,HexStringToLdapHexString,The following statement contains a magic number: if (s.Length % 2 != 0)              {                  GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADUtils"' "HexStringToLdapHexString: string has bad length " + s.Length);                  return null;              }
Magic Number,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,HexStringToLdapHexString,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      sb.Append(@"\");                      sb.Append(firstChar);                      sb.Append(secondChar);                  }                  else                  {                      // not a hex character                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADUtils"' "HexStringToLdapHexString: invalid string " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,HexStringToLdapHexString,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      sb.Append(@"\");                      sb.Append(firstChar);                      sb.Append(secondChar);                  }                  else                  {                      // not a hex character                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADUtils"' "HexStringToLdapHexString: invalid string " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADUtils.cs,HexStringToLdapHexString,The following statement contains a magic number: for (int i = 0; i < (s.Length) / 2; i++)              {                  char firstChar = s[i * 2];                  char secondChar = s[(i * 2) + 1];                    if (((firstChar >= '0' && firstChar <= '9') || (firstChar >= 'A' && firstChar <= 'F') || (firstChar >= 'a' && firstChar <= 'f')) &&                       ((secondChar >= '0' && secondChar <= '9') || (secondChar >= 'A' && secondChar <= 'F') || (secondChar >= 'a' && secondChar <= 'f')))                  {                      sb.Append(@"\");                      sb.Append(firstChar);                      sb.Append(secondChar);                  }                  else                  {                      // not a hex character                      GlobalDebug.WriteLineIf(GlobalDebug.Warn' "ADUtils"' "HexStringToLdapHexString: invalid string " + s);                      return null;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ConstructSearcher,The following statement contains a magic number: ds.ClientTimeout = new TimeSpan(0' 0' 30);
Magic Number,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ConstructSearcher,The following statement contains a magic number: ds.PageSize = 256;
Magic Number,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ConstructDnsDomainNameFromDn,The following statement contains a magic number: foreach (string component in ncComponents)              {                  if ((component.Length > 3) &&                      (String.Compare(component.Substring(0' 3)' "DC="' StringComparison.OrdinalIgnoreCase) == 0))                  {                      sb.Append(component.Substring(3));                      sb.Append(".");                  }              }
Magic Number,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ConstructDnsDomainNameFromDn,The following statement contains a magic number: foreach (string component in ncComponents)              {                  if ((component.Length > 3) &&                      (String.Compare(component.Substring(0' 3)' "DC="' StringComparison.OrdinalIgnoreCase) == 0))                  {                      sb.Append(component.Substring(3));                      sb.Append(".");                  }              }
Magic Number,System.DirectoryServices.AccountManagement,SDSUtils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\SDSUtils.cs,ConstructDnsDomainNameFromDn,The following statement contains a magic number: foreach (string component in ncComponents)              {                  if ((component.Length > 3) &&                      (String.Compare(component.Substring(0' 3)' "DC="' StringComparison.OrdinalIgnoreCase) == 0))                  {                      sb.Append(component.Substring(3));                      sb.Append(".");                  }              }
Magic Number,System.DirectoryServices.AccountManagement,ADAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADAMStoreCtx.cs,LoadDomainInfo,The following statement contains a magic number: try              {                  this.userSuppliedServerName = pathName.Retrieve(9 /*ADS_FORMAT_SERVER */);                  GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using user-supplied name {0}"' this.userSuppliedServerName);              }              catch (COMException e)              {                  if (((uint)e.ErrorCode) == ((uint)0x80005000))  // E_ADS_BAD_PATHNAME                  {                      // Serverless path                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "ADStoreCtx"' "LoadComputerInfo: using empty string as user-supplied name");                      this.userSuppliedServerName = "";                  }                  else                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Error'                                              "ADStoreCtx"'                                              "LoadComputerInfo: caught COMException {0} {1} looking for user-supplied name"'                                              e.ErrorCode'                                              e.Message);                        throw;                  }              }
Magic Number,System.DirectoryServices.AccountManagement,TokenGroupSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\TokenGroupsSet.cs,BuildPathFromDN,The following statement contains a magic number: pathName.EscapedMode = 2 /* ADS_ESCAPEDMODE_ON */;
Magic Number,System.DirectoryServices.AccountManagement,TokenGroupSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\TokenGroupsSet.cs,BuildPathFromDN,The following statement contains a magic number: pathName.Set(dn' 4 /* ADS_SETTYPE_DN */);
Magic Number,System.DirectoryServices.AccountManagement,TokenGroupSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\TokenGroupsSet.cs,BuildPathFromDN,The following statement contains a magic number: string escapedDn = pathName.Retrieve(7 /* ADS_FORMAT_X500_DN */);
Magic Number,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,The following statement contains a magic number: for (int i = 0; i < s_propertyMappingTableRaw.GetLength(0); i++)              {                  string propertyName = s_propertyMappingTableRaw[i' 0] as string;                  Type principalType = s_propertyMappingTableRaw[i' 1] as Type;                  string winNTAttribute = s_propertyMappingTableRaw[i' 2] as string;                  FromWinNTConverterDelegate fromWinNT = s_propertyMappingTableRaw[i' 3] as FromWinNTConverterDelegate;                  ToWinNTConverterDelegate toWinNT = s_propertyMappingTableRaw[i' 4] as ToWinNTConverterDelegate;                    Debug.Assert(propertyName != null);                  Debug.Assert((winNTAttribute != null && fromWinNT != null) || (fromWinNT == null));                  Debug.Assert(principalType == typeof(Principal) || principalType.IsSubclassOf(typeof(Principal)));                    // Build the table entry.  The same entry will be used in both tables.                  // Once constructed' the table entries are treated as read-only' so there's                  // no danger in sharing the entries between tables.                  PropertyMappingTableEntry propertyEntry = new PropertyMappingTableEntry();                  propertyEntry.propertyName = propertyName;                  propertyEntry.suggestedWinNTPropertyName = winNTAttribute;                  propertyEntry.winNTToPapiConverter = fromWinNT;                  propertyEntry.papiToWinNTConverter = toWinNT;                    // Add it to the appropriate tables                  List<Hashtable> byPropertyTables = new List<Hashtable>();                  List<Hashtable> byWinNTTables = new List<Hashtable>();                    ObjectMask BitMask = 0;                    if (principalType == typeof(UserPrincipal))                  {                      byPropertyTables.Add(s_userPropertyMappingTableByProperty);                      byWinNTTables.Add(s_userPropertyMappingTableByWinNT);                      BitMask = ObjectMask.User;                  }                  else if (principalType == typeof(ComputerPrincipal))                  {                      byPropertyTables.Add(s_computerPropertyMappingTableByProperty);                      byWinNTTables.Add(s_computerPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Computer;                  }                  else if (principalType == typeof(GroupPrincipal))                  {                      byPropertyTables.Add(s_groupPropertyMappingTableByProperty);                      byWinNTTables.Add(s_groupPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Group;                  }                  else                  {                      Debug.Assert(principalType == typeof(Principal));                        byPropertyTables.Add(s_userPropertyMappingTableByProperty);                      byPropertyTables.Add(s_computerPropertyMappingTableByProperty);                      byPropertyTables.Add(s_groupPropertyMappingTableByProperty);                        byWinNTTables.Add(s_userPropertyMappingTableByWinNT);                      byWinNTTables.Add(s_computerPropertyMappingTableByWinNT);                      byWinNTTables.Add(s_groupPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Principal;                  }                    if ((winNTAttribute == null) || (winNTAttribute == "*******"))                  {                      BitMask = ObjectMask.None;                  }                    ObjectMask currentMask;                  if (s_validPropertyMap.TryGetValue(propertyName' out currentMask))                  {                      s_validPropertyMap[propertyName] = currentMask | BitMask;                  }                  else                  {                      s_validPropertyMap.Add(propertyName' BitMask);                  }                    // *PropertyMappingTableByProperty                  // If toWinNT is null' there's no PAPI->WinNT mapping for this property                  // (it's probably read-only' e.g.' "LastLogon").                  //                if (toWinNT != null)                  //                {                  foreach (Hashtable propertyMappingTableByProperty in byPropertyTables)                  {                      if (propertyMappingTableByProperty[propertyName] == null)                          propertyMappingTableByProperty[propertyName] = new ArrayList();                        ((ArrayList)propertyMappingTableByProperty[propertyName]).Add(propertyEntry);                  }                  //                }                    // *PropertyMappingTableByWinNT                  // If fromLdap is null' there's no direct WinNT->PAPI mapping for this property.                  // It's probably a property that requires custom handling' such as an IdentityClaim.                  if (fromWinNT != null)                  {                      string winNTAttributeLower = winNTAttribute.ToLower(CultureInfo.InvariantCulture);                        foreach (Hashtable propertyMappingTableByWinNT in byWinNTTables)                      {                          if (propertyMappingTableByWinNT[winNTAttributeLower] == null)                              propertyMappingTableByWinNT[winNTAttributeLower] = new ArrayList();                            ((ArrayList)propertyMappingTableByWinNT[winNTAttributeLower]).Add(propertyEntry);                      }                  }              }
Magic Number,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,The following statement contains a magic number: for (int i = 0; i < s_propertyMappingTableRaw.GetLength(0); i++)              {                  string propertyName = s_propertyMappingTableRaw[i' 0] as string;                  Type principalType = s_propertyMappingTableRaw[i' 1] as Type;                  string winNTAttribute = s_propertyMappingTableRaw[i' 2] as string;                  FromWinNTConverterDelegate fromWinNT = s_propertyMappingTableRaw[i' 3] as FromWinNTConverterDelegate;                  ToWinNTConverterDelegate toWinNT = s_propertyMappingTableRaw[i' 4] as ToWinNTConverterDelegate;                    Debug.Assert(propertyName != null);                  Debug.Assert((winNTAttribute != null && fromWinNT != null) || (fromWinNT == null));                  Debug.Assert(principalType == typeof(Principal) || principalType.IsSubclassOf(typeof(Principal)));                    // Build the table entry.  The same entry will be used in both tables.                  // Once constructed' the table entries are treated as read-only' so there's                  // no danger in sharing the entries between tables.                  PropertyMappingTableEntry propertyEntry = new PropertyMappingTableEntry();                  propertyEntry.propertyName = propertyName;                  propertyEntry.suggestedWinNTPropertyName = winNTAttribute;                  propertyEntry.winNTToPapiConverter = fromWinNT;                  propertyEntry.papiToWinNTConverter = toWinNT;                    // Add it to the appropriate tables                  List<Hashtable> byPropertyTables = new List<Hashtable>();                  List<Hashtable> byWinNTTables = new List<Hashtable>();                    ObjectMask BitMask = 0;                    if (principalType == typeof(UserPrincipal))                  {                      byPropertyTables.Add(s_userPropertyMappingTableByProperty);                      byWinNTTables.Add(s_userPropertyMappingTableByWinNT);                      BitMask = ObjectMask.User;                  }                  else if (principalType == typeof(ComputerPrincipal))                  {                      byPropertyTables.Add(s_computerPropertyMappingTableByProperty);                      byWinNTTables.Add(s_computerPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Computer;                  }                  else if (principalType == typeof(GroupPrincipal))                  {                      byPropertyTables.Add(s_groupPropertyMappingTableByProperty);                      byWinNTTables.Add(s_groupPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Group;                  }                  else                  {                      Debug.Assert(principalType == typeof(Principal));                        byPropertyTables.Add(s_userPropertyMappingTableByProperty);                      byPropertyTables.Add(s_computerPropertyMappingTableByProperty);                      byPropertyTables.Add(s_groupPropertyMappingTableByProperty);                        byWinNTTables.Add(s_userPropertyMappingTableByWinNT);                      byWinNTTables.Add(s_computerPropertyMappingTableByWinNT);                      byWinNTTables.Add(s_groupPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Principal;                  }                    if ((winNTAttribute == null) || (winNTAttribute == "*******"))                  {                      BitMask = ObjectMask.None;                  }                    ObjectMask currentMask;                  if (s_validPropertyMap.TryGetValue(propertyName' out currentMask))                  {                      s_validPropertyMap[propertyName] = currentMask | BitMask;                  }                  else                  {                      s_validPropertyMap.Add(propertyName' BitMask);                  }                    // *PropertyMappingTableByProperty                  // If toWinNT is null' there's no PAPI->WinNT mapping for this property                  // (it's probably read-only' e.g.' "LastLogon").                  //                if (toWinNT != null)                  //                {                  foreach (Hashtable propertyMappingTableByProperty in byPropertyTables)                  {                      if (propertyMappingTableByProperty[propertyName] == null)                          propertyMappingTableByProperty[propertyName] = new ArrayList();                        ((ArrayList)propertyMappingTableByProperty[propertyName]).Add(propertyEntry);                  }                  //                }                    // *PropertyMappingTableByWinNT                  // If fromLdap is null' there's no direct WinNT->PAPI mapping for this property.                  // It's probably a property that requires custom handling' such as an IdentityClaim.                  if (fromWinNT != null)                  {                      string winNTAttributeLower = winNTAttribute.ToLower(CultureInfo.InvariantCulture);                        foreach (Hashtable propertyMappingTableByWinNT in byWinNTTables)                      {                          if (propertyMappingTableByWinNT[winNTAttributeLower] == null)                              propertyMappingTableByWinNT[winNTAttributeLower] = new ArrayList();                            ((ArrayList)propertyMappingTableByWinNT[winNTAttributeLower]).Add(propertyEntry);                      }                  }              }
Magic Number,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,SAMStoreCtx,The following statement contains a magic number: for (int i = 0; i < s_propertyMappingTableRaw.GetLength(0); i++)              {                  string propertyName = s_propertyMappingTableRaw[i' 0] as string;                  Type principalType = s_propertyMappingTableRaw[i' 1] as Type;                  string winNTAttribute = s_propertyMappingTableRaw[i' 2] as string;                  FromWinNTConverterDelegate fromWinNT = s_propertyMappingTableRaw[i' 3] as FromWinNTConverterDelegate;                  ToWinNTConverterDelegate toWinNT = s_propertyMappingTableRaw[i' 4] as ToWinNTConverterDelegate;                    Debug.Assert(propertyName != null);                  Debug.Assert((winNTAttribute != null && fromWinNT != null) || (fromWinNT == null));                  Debug.Assert(principalType == typeof(Principal) || principalType.IsSubclassOf(typeof(Principal)));                    // Build the table entry.  The same entry will be used in both tables.                  // Once constructed' the table entries are treated as read-only' so there's                  // no danger in sharing the entries between tables.                  PropertyMappingTableEntry propertyEntry = new PropertyMappingTableEntry();                  propertyEntry.propertyName = propertyName;                  propertyEntry.suggestedWinNTPropertyName = winNTAttribute;                  propertyEntry.winNTToPapiConverter = fromWinNT;                  propertyEntry.papiToWinNTConverter = toWinNT;                    // Add it to the appropriate tables                  List<Hashtable> byPropertyTables = new List<Hashtable>();                  List<Hashtable> byWinNTTables = new List<Hashtable>();                    ObjectMask BitMask = 0;                    if (principalType == typeof(UserPrincipal))                  {                      byPropertyTables.Add(s_userPropertyMappingTableByProperty);                      byWinNTTables.Add(s_userPropertyMappingTableByWinNT);                      BitMask = ObjectMask.User;                  }                  else if (principalType == typeof(ComputerPrincipal))                  {                      byPropertyTables.Add(s_computerPropertyMappingTableByProperty);                      byWinNTTables.Add(s_computerPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Computer;                  }                  else if (principalType == typeof(GroupPrincipal))                  {                      byPropertyTables.Add(s_groupPropertyMappingTableByProperty);                      byWinNTTables.Add(s_groupPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Group;                  }                  else                  {                      Debug.Assert(principalType == typeof(Principal));                        byPropertyTables.Add(s_userPropertyMappingTableByProperty);                      byPropertyTables.Add(s_computerPropertyMappingTableByProperty);                      byPropertyTables.Add(s_groupPropertyMappingTableByProperty);                        byWinNTTables.Add(s_userPropertyMappingTableByWinNT);                      byWinNTTables.Add(s_computerPropertyMappingTableByWinNT);                      byWinNTTables.Add(s_groupPropertyMappingTableByWinNT);                      BitMask = ObjectMask.Principal;                  }                    if ((winNTAttribute == null) || (winNTAttribute == "*******"))                  {                      BitMask = ObjectMask.None;                  }                    ObjectMask currentMask;                  if (s_validPropertyMap.TryGetValue(propertyName' out currentMask))                  {                      s_validPropertyMap[propertyName] = currentMask | BitMask;                  }                  else                  {                      s_validPropertyMap.Add(propertyName' BitMask);                  }                    // *PropertyMappingTableByProperty                  // If toWinNT is null' there's no PAPI->WinNT mapping for this property                  // (it's probably read-only' e.g.' "LastLogon").                  //                if (toWinNT != null)                  //                {                  foreach (Hashtable propertyMappingTableByProperty in byPropertyTables)                  {                      if (propertyMappingTableByProperty[propertyName] == null)                          propertyMappingTableByProperty[propertyName] = new ArrayList();                        ((ArrayList)propertyMappingTableByProperty[propertyName]).Add(propertyEntry);                  }                  //                }                    // *PropertyMappingTableByWinNT                  // If fromLdap is null' there's no direct WinNT->PAPI mapping for this property.                  // It's probably a property that requires custom handling' such as an IdentityClaim.                  if (fromWinNT != null)                  {                      string winNTAttributeLower = winNTAttribute.ToLower(CultureInfo.InvariantCulture);                        foreach (Hashtable propertyMappingTableByWinNT in byWinNTTables)                      {                          if (propertyMappingTableByWinNT[winNTAttributeLower] == null)                              propertyMappingTableByWinNT[winNTAttributeLower] = new ArrayList();                            ((ArrayList)propertyMappingTableByWinNT[winNTAttributeLower]).Add(propertyEntry);                      }                  }              }
Magic Number,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,LoadComputerInfo,The following statement contains a magic number: if (versionMajor >= 6)      // 6.0 == Longhorn                  _isLSAM = true;              else                  _isLSAM = false;
Magic Number,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,LoadComputerInfo,The following statement contains a magic number: try              {                  // This function takes in a flat or DNS name' and returns the flat name of the computer                  int err = UnsafeNativeMethods.NetWkstaGetInfo(_machineUserSuppliedName' 100' ref buffer);                  if (err == 0)                  {                      UnsafeNativeMethods.WKSTA_INFO_100 wkstaInfo =                          (UnsafeNativeMethods.WKSTA_INFO_100)Marshal.PtrToStructure(buffer' typeof(UnsafeNativeMethods.WKSTA_INFO_100));                        _machineFlatName = wkstaInfo.wki100_computername;                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMStoreCtx"' "LoadComputerInfo: machineFlatName={0}"' _machineFlatName);                  }                  else                  {                      throw new PrincipalOperationException(                                      String.Format(                                          CultureInfo.CurrentCulture'                                          SR.SAMStoreCtxUnableToRetrieveFlatMachineName'                                          err));                  }              }              finally              {                  if (buffer != IntPtr.Zero)                      UnsafeNativeMethods.NetApiBufferFree(buffer);              }
Magic Number,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,GroupTypeFromWinNTConverter,The following statement contains a magic number: if (propertyName == PropertyNames.GroupIsSecurityGroup)              {                  // Do nothing for this property.              }              else              {                  Debug.Assert(propertyName == PropertyNames.GroupGroupScope);                    // All local machine SAM groups are local  #if DEBUG                  PropertyValueCollection values = de.Properties[suggestedWinNTProperty];                  if (values.Count != 0)                      Debug.Assert(((int)values[0]) == 4);  #endif                    p.LoadValueIntoProperty(propertyName' GroupScope.Local);              }
Magic Number,System.DirectoryServices.AccountManagement,SAMStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMStoreCtx.cs,AcctExpirDateToNTConverter,The following statement contains a magic number: if (value.HasValue)                  de.Properties[suggestedWinNTProperty].Value = (DateTime)value;              else                  de.Properties[suggestedWinNTProperty].Value = new DateTime(1970' 1' 1);
Magic Number,System.DirectoryServices.AccountManagement,QbeMatcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMQuerySet.cs,QbeMatcher,The following statement contains a magic number: for (int i = 0; i < s_filterPropertiesTableRaw.GetLength(0); i++)              {                  Type qbeType = s_filterPropertiesTableRaw[i' 0] as Type;                  string winNTPropertyName = s_filterPropertiesTableRaw[i' 1] as string;                  MatcherDelegate f = s_filterPropertiesTableRaw[i' 2] as MatcherDelegate;                    Debug.Assert(qbeType != null);                  Debug.Assert(winNTPropertyName != null);                  Debug.Assert(f != null);                    // There should only be one entry per QBE type                  Debug.Assert(s_filterPropertiesTable[qbeType] == null);                    FilterPropertyTableEntry entry = new FilterPropertyTableEntry();                  entry.winNTPropertyName = winNTPropertyName;                  entry.matcher = f;                    s_filterPropertiesTable[qbeType] = entry;              }
Magic Number,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextLocal,The following statement contains a magic number: do              {                  needToRetry = false;                    object[] nativeMembers = new object[1];                    bool f = _membersEnumerator.MoveNext();                    if (f) // got a value                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: got a value from the enumerator");                        UnsafeNativeMethods.IADs nativeMember = (UnsafeNativeMethods.IADs)_membersEnumerator.Current;                        // If we encountered a group member corresponding to a fake principal such as                      // NT AUTHORITY/NETWORK SERVICE' construct and prepare to return the fake principal.                      byte[] sid = (byte[])nativeMember.Get("objectSid");                      SidType sidType = Utils.ClassifySID(sid);                      if (sidType == SidType.FakeObject)                      {                          GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: fake principal' sid={0}"' Utils.ByteArrayToString(sid));                            _currentFakePrincipal = _storeCtx.ConstructFakePrincipalFromSID(sid);                          _current = null;                          _currentForeign = null;                            if (_foreignResultSet != null)                              _foreignResultSet.Dispose();                          _foreignResultSet = null;                          return true;                      }                        // We do this' rather than using the DirectoryEntry constructor that takes a native IADs object'                      // is so the credentials get transferred to the new DirectoryEntry.  If we just use the native                      // object constructor' the native object will have the right credentials' but the DirectoryEntry                      // will have default (null) credentials' which it'll use anytime it needs to use credentials.                      DirectoryEntry de = SDSUtils.BuildDirectoryEntry(                                                          _storeCtx.Credentials'                                                          _storeCtx.AuthTypes);                        if (sidType == SidType.RealObjectFakeDomain)                      {                          // Transform the "WinNT://BUILTIN/foo" path to "WinNT://machineName/foo"                          string builtinADsPath = nativeMember.ADsPath;                            UnsafeNativeMethods.Pathname pathCracker = new UnsafeNativeMethods.Pathname();                          UnsafeNativeMethods.IADsPathname pathName = (UnsafeNativeMethods.IADsPathname)pathCracker;                            pathName.Set(builtinADsPath' 1 /* ADS_SETTYPE_FULL */);                            // Build the "WinNT://" portion of the new path                          StringBuilder adsPath = new StringBuilder();                          adsPath.Append("WinNT://");                          //adsPath.Append(pathName.Retrieve(9 /*ADS_FORMAT_SERVER */));                            // Build the "WinNT://machineName/" portion of the new path                          adsPath.Append(_storeCtx.MachineUserSuppliedName);                          adsPath.Append("/");                            // Build the "WinNT://machineName/foo" portion of the new path                          int cElements = pathName.GetNumElements();                            Debug.Assert(cElements >= 2);       // "WinNT://BUILTIN/foo" == 2 elements                            // Note that the ADSI WinNT provider indexes them backwards' e.g.' in                          // "WinNT://BUILTIN/A/B"' BUILTIN == 2' A == 1' B == 0.                          for (int i = cElements - 2; i >= 0; i--)                          {                              adsPath.Append(pathName.GetElement(i));                              adsPath.Append("/");                          }                            adsPath.Remove(adsPath.Length - 1' 1);  // remove the trailing "/"                            de.Path = adsPath.ToString();                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: fake domain: {0} --> {1}"' builtinADsPath' adsPath);                      }                      else                      {                          Debug.Assert(sidType == SidType.RealObject);                          de.Path = nativeMember.ADsPath;                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: real domain {0}"' de.Path);                      }                        //  Debug.Assert(Utils.AreBytesEqual(sid' (byte[]) de.Properties["objectSid"].Value));                        if (IsLocalMember(sid))                      {                          // If we're processing recursively' and the member is a group'                          // we don't return it but instead treat it as something to recursively                          // visit (expand) later.                          if (!_recursive || !SAMUtils.IsOfObjectClass(de' "Group"))                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: setting current to {0}"' de.Path);                                // Not recursive' or not a group.  Return the principal.                              _current = de;                              _currentFakePrincipal = null;                              _currentForeign = null;                                if (_foreignResultSet != null)                                  _foreignResultSet.Dispose();                              _foreignResultSet = null;                              return true;                          }                          else                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: adding {0} to groupsToVisit"' de.Path);                                // Save off for later' if we haven't done so already.                              if (!_groupsVisited.Contains(de.Path) && !_groupsToVisit.Contains(de.Path))                                  _groupsToVisit.Add(de.Path);                                needToRetry = true;                              continue;                          }                      }                      else                      {                          // It's a foreign principal (e..g' an AD user or group).                          // Save it off for later.                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: adding {0} to foreignMembers"' de.Path);                            _foreignMembers.Add(de);                          needToRetry = true;                          continue;                      }                  }                  else                  {                      // We reached the end of this group's membership.                      // If we're supposed to be recursively expanding' we need to expand                      // any remaining non-foreign groups we earlier visited.                      if (_recursive)                      {                          GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: recursive processing' groupsToVisit={0}"' _groupsToVisit.Count);                            if (_groupsToVisit.Count > 0)                          {                              // Pull off the next group to visit                              string groupPath = _groupsToVisit[0];                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: recursively processing {0}"' groupPath);                                _groupsToVisit.RemoveAt(0);                              _groupsVisited.Add(groupPath);                                // Set up for the next round of enumeration                              DirectoryEntry de = SDSUtils.BuildDirectoryEntry(                                                                          groupPath'                                                                          _storeCtx.Credentials'                                                                          _storeCtx.AuthTypes);                                _group = (UnsafeNativeMethods.IADsGroup)de.NativeObject;                                UnsafeNativeMethods.IADsMembers iADsMembers = _group.Members();                              _membersEnumerator = ((IEnumerable)iADsMembers).GetEnumerator();                                // and go on to the first member of this new group                              needToRetry = true;                              continue;                          }                      }                  }              }              while (needToRetry);
Magic Number,System.DirectoryServices.AccountManagement,SAMMembersSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\SAM\SAMMembersSet.cs,MoveNextLocal,The following statement contains a magic number: do              {                  needToRetry = false;                    object[] nativeMembers = new object[1];                    bool f = _membersEnumerator.MoveNext();                    if (f) // got a value                  {                      GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: got a value from the enumerator");                        UnsafeNativeMethods.IADs nativeMember = (UnsafeNativeMethods.IADs)_membersEnumerator.Current;                        // If we encountered a group member corresponding to a fake principal such as                      // NT AUTHORITY/NETWORK SERVICE' construct and prepare to return the fake principal.                      byte[] sid = (byte[])nativeMember.Get("objectSid");                      SidType sidType = Utils.ClassifySID(sid);                      if (sidType == SidType.FakeObject)                      {                          GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: fake principal' sid={0}"' Utils.ByteArrayToString(sid));                            _currentFakePrincipal = _storeCtx.ConstructFakePrincipalFromSID(sid);                          _current = null;                          _currentForeign = null;                            if (_foreignResultSet != null)                              _foreignResultSet.Dispose();                          _foreignResultSet = null;                          return true;                      }                        // We do this' rather than using the DirectoryEntry constructor that takes a native IADs object'                      // is so the credentials get transferred to the new DirectoryEntry.  If we just use the native                      // object constructor' the native object will have the right credentials' but the DirectoryEntry                      // will have default (null) credentials' which it'll use anytime it needs to use credentials.                      DirectoryEntry de = SDSUtils.BuildDirectoryEntry(                                                          _storeCtx.Credentials'                                                          _storeCtx.AuthTypes);                        if (sidType == SidType.RealObjectFakeDomain)                      {                          // Transform the "WinNT://BUILTIN/foo" path to "WinNT://machineName/foo"                          string builtinADsPath = nativeMember.ADsPath;                            UnsafeNativeMethods.Pathname pathCracker = new UnsafeNativeMethods.Pathname();                          UnsafeNativeMethods.IADsPathname pathName = (UnsafeNativeMethods.IADsPathname)pathCracker;                            pathName.Set(builtinADsPath' 1 /* ADS_SETTYPE_FULL */);                            // Build the "WinNT://" portion of the new path                          StringBuilder adsPath = new StringBuilder();                          adsPath.Append("WinNT://");                          //adsPath.Append(pathName.Retrieve(9 /*ADS_FORMAT_SERVER */));                            // Build the "WinNT://machineName/" portion of the new path                          adsPath.Append(_storeCtx.MachineUserSuppliedName);                          adsPath.Append("/");                            // Build the "WinNT://machineName/foo" portion of the new path                          int cElements = pathName.GetNumElements();                            Debug.Assert(cElements >= 2);       // "WinNT://BUILTIN/foo" == 2 elements                            // Note that the ADSI WinNT provider indexes them backwards' e.g.' in                          // "WinNT://BUILTIN/A/B"' BUILTIN == 2' A == 1' B == 0.                          for (int i = cElements - 2; i >= 0; i--)                          {                              adsPath.Append(pathName.GetElement(i));                              adsPath.Append("/");                          }                            adsPath.Remove(adsPath.Length - 1' 1);  // remove the trailing "/"                            de.Path = adsPath.ToString();                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: fake domain: {0} --> {1}"' builtinADsPath' adsPath);                      }                      else                      {                          Debug.Assert(sidType == SidType.RealObject);                          de.Path = nativeMember.ADsPath;                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: real domain {0}"' de.Path);                      }                        //  Debug.Assert(Utils.AreBytesEqual(sid' (byte[]) de.Properties["objectSid"].Value));                        if (IsLocalMember(sid))                      {                          // If we're processing recursively' and the member is a group'                          // we don't return it but instead treat it as something to recursively                          // visit (expand) later.                          if (!_recursive || !SAMUtils.IsOfObjectClass(de' "Group"))                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: setting current to {0}"' de.Path);                                // Not recursive' or not a group.  Return the principal.                              _current = de;                              _currentFakePrincipal = null;                              _currentForeign = null;                                if (_foreignResultSet != null)                                  _foreignResultSet.Dispose();                              _foreignResultSet = null;                              return true;                          }                          else                          {                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: adding {0} to groupsToVisit"' de.Path);                                // Save off for later' if we haven't done so already.                              if (!_groupsVisited.Contains(de.Path) && !_groupsToVisit.Contains(de.Path))                                  _groupsToVisit.Add(de.Path);                                needToRetry = true;                              continue;                          }                      }                      else                      {                          // It's a foreign principal (e..g' an AD user or group).                          // Save it off for later.                            GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: adding {0} to foreignMembers"' de.Path);                            _foreignMembers.Add(de);                          needToRetry = true;                          continue;                      }                  }                  else                  {                      // We reached the end of this group's membership.                      // If we're supposed to be recursively expanding' we need to expand                      // any remaining non-foreign groups we earlier visited.                      if (_recursive)                      {                          GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: recursive processing' groupsToVisit={0}"' _groupsToVisit.Count);                            if (_groupsToVisit.Count > 0)                          {                              // Pull off the next group to visit                              string groupPath = _groupsToVisit[0];                              GlobalDebug.WriteLineIf(GlobalDebug.Info' "SAMMembersSet"' "MoveNextLocal: recursively processing {0}"' groupPath);                                _groupsToVisit.RemoveAt(0);                              _groupsVisited.Add(groupPath);                                // Set up for the next round of enumeration                              DirectoryEntry de = SDSUtils.BuildDirectoryEntry(                                                                          groupPath'                                                                          _storeCtx.Credentials'                                                                          _storeCtx.AuthTypes);                                _group = (UnsafeNativeMethods.IADsGroup)de.NativeObject;                                UnsafeNativeMethods.IADsMembers iADsMembers = _group.Members();                              _membersEnumerator = ((IEnumerable)iADsMembers).GetEnumerator();                                // and go on to the first member of this new group                              needToRetry = true;                              continue;                          }                      }                  }              }              while (needToRetry);
Missing Default,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,DateTimeFilterBuilder,The following switch statement is missing a default case: switch (mt)              {                  case MatchType.Equals:                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=");                      ldapFilter.Append(ldapSearchValue);                      break;                    case MatchType.NotEquals:                      ldapFilter.Append("!(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=");                      ldapFilter.Append(ldapSearchValue);                      ldapFilter.Append(")");                      break;                    case MatchType.GreaterThanOrEquals:                      ldapFilter.Append(attributeName);                      ldapFilter.Append(">=");                      ldapFilter.Append(ldapSearchValue);                      break;                    case MatchType.LessThanOrEquals:                      ldapFilter.Append(attributeName);                      ldapFilter.Append("<=");                      ldapFilter.Append(ldapSearchValue);                      break;                    case MatchType.GreaterThan:                      ldapFilter.Append("&");                        // Greater-than-or-equals (or less-than-or-equals))                      ldapFilter.Append("(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append(mt == MatchType.GreaterThan ? ">=" : "<=");                      ldapFilter.Append(ldapSearchValue);                      ldapFilter.Append(")");                        // And not-equal                      ldapFilter.Append("(!(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=");                      ldapFilter.Append(ldapSearchValue);                      ldapFilter.Append("))");                        // And exists (need to include because of tristate LDAP logic)                      ldapFilter.Append("(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=*)");                      break;                    case MatchType.LessThan:                      goto case MatchType.GreaterThan;              }
Missing Default,System.DirectoryServices.AccountManagement,ADStoreCtx,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices.AccountManagement\src\System\DirectoryServices\AccountManagement\AD\ADStoreCtx.cs,ExtensionTypeConverter,The following switch statement is missing a default case: switch (mt)              {                  case MatchType.Equals:                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=");                      ldapFilter.Append(ldapValue);                      break;                    case MatchType.NotEquals:                      ldapFilter.Append("!(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=");                      ldapFilter.Append(ldapValue);                      ldapFilter.Append(")");                      break;                    case MatchType.GreaterThanOrEquals:                      ldapFilter.Append(attributeName);                      ldapFilter.Append(">=");                      ldapFilter.Append(ldapValue);                      break;                    case MatchType.LessThanOrEquals:                      ldapFilter.Append(attributeName);                      ldapFilter.Append("<=");                      ldapFilter.Append(ldapValue);                      break;                    case MatchType.GreaterThan:                      ldapFilter.Append("&");                        // Greater-than-or-equals (or less-than-or-equals))                      ldapFilter.Append("(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append(mt == MatchType.GreaterThan ? ">=" : "<=");                      ldapFilter.Append(ldapValue);                      ldapFilter.Append(")");                        // And not-equal                      ldapFilter.Append("(!(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=");                      ldapFilter.Append(ldapValue);                      ldapFilter.Append("))");                        // And exists (need to include because of tristate LDAP logic)                      ldapFilter.Append("(");                      ldapFilter.Append(attributeName);                      ldapFilter.Append("=*)");                      break;                    case MatchType.LessThan:                      goto case MatchType.GreaterThan;              }
