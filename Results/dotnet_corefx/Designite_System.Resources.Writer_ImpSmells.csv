Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The method has 143 lines of code.
Long Method,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,WriteValue,The method has 102 lines of code.
Long Identifier,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,,The length of the parameter ResourceReaderFullyQualifiedName is 32.
Long Statement,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The length of the statement  "                Debug.Assert(startOfDataSection == bw.Seek(0' SeekOrigin.Current)' "ResourceWriter::Generate - start of data section is wrong!"); " is 129.
Long Statement,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,WriteValue,The length of the statement  "                    Contract.Assert(typeCode >= ResourceTypeCode.StartOfUserTypes' string.Format(CultureInfo.InvariantCulture' "ResourceReader: Unsupported ResourceTypeCode in .resources file!  {0}"' typeCode)); " is 191.
Magic Number,System.Resources,FastResourceComparer,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\__FastResourceComparer.cs,HashFunction,The following statement contains a magic number: uint hash = 5381;
Magic Number,System.Resources,FastResourceComparer,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\__FastResourceComparer.cs,HashFunction,The following statement contains a magic number: for (int i = 0; i < key.Length; i++)                  hash = unchecked((hash << 5) + hash) ^ key[i];
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The following statement contains a magic number: MemoryStream resMgrHeaderBlob = new MemoryStream(240);
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The following statement contains a magic number: using (dataSection)              {                  BinaryWriter data = new BinaryWriter(dataSection' Encoding.UTF8);                    if (_preserializedData != null)                  {                      foreach (KeyValuePair<string' PrecannedResource> entry in _preserializedData)                      {                          _resourceList.Add(entry.Key' entry.Value);                      }                  }                    // Write resource name and position to the file' and the value                  // to our temporary buffer.  Save Type as well.                  foreach (var item in _resourceList)                  {                      nameHashes[curNameNumber] = FastResourceComparer.HashFunction(item.Key);                      namePositions[curNameNumber++] = (int)names.Seek(0' SeekOrigin.Current);                      names.Write(item.Key); // key                      names.Write((int)data.Seek(0' SeekOrigin.Current)); // virtual offset of value.                        object value = item.Value;                      ResourceTypeCode typeCode = FindTypeCode(value' typeNames);                        // Write out type code                      Write7BitEncodedInt(data' (int)typeCode);                        var userProvidedResource = value as PrecannedResource;                      if (userProvidedResource != null)                      {                          data.Write(userProvidedResource.Data);                      }                      else                      {                          WriteValue(typeCode' value' data);                      }                  }                    // At this point' the ResourceManager header has been written.                  // Finish RuntimeResourceSet header                  // The reader expects a list of user defined type names                   // following the size of the list' write 0 for this                   // writer implementation                  bw.Write(typeNames.Count);                  foreach (var typeName in typeNames)                  {                      bw.Write(typeName);                  }                    // Write out the name-related items for lookup.                  //  Note that the hash array and the namePositions array must                  //  be sorted in parallel.                  Array.Sort(nameHashes' namePositions);                      //  Prepare to write sorted name hashes (alignment fixup)                  //   Note: For 64-bit machines' these MUST be aligned on 8 byte                   //   boundaries!  Pointers on IA64 must be aligned!  And we'll                  //   run faster on X86 machines too.                  bw.Flush();                  int alignBytes = ((int)bw.BaseStream.Position) & 7;                  if (alignBytes > 0)                  {                      for (int i = 0; i < 8 - alignBytes; i++)                          bw.Write("PAD"[i % 3]);                  }                    //  Write out sorted name hashes.                  //   Align to 8 bytes.                  Debug.Assert((bw.BaseStream.Position & 7) == 0' "ResourceWriter: Name hashes array won't be 8 byte aligned!  Ack!");                    foreach (int hash in nameHashes)                  {                      bw.Write(hash);                  }                    //  Write relative positions of all the names in the file.                  //   Note: this data is 4 byte aligned' occurring immediately                   //   after the 8 byte aligned name hashes (whose length may                   //   potentially be odd).                  Debug.Assert((bw.BaseStream.Position & 3) == 0' "ResourceWriter: Name positions array won't be 4 byte aligned!  Ack!");                    foreach (int pos in namePositions)                  {                      bw.Write(pos);                  }                    // Flush all BinaryWriters to their underlying streams.                  bw.Flush();                  names.Flush();                  data.Flush();                    // Write offset to data section                  int startOfDataSection = (int)(bw.Seek(0' SeekOrigin.Current) + nameSection.Length);                  startOfDataSection += 4;  // We're writing an int to store this data' adding more bytes to the header                  bw.Write(startOfDataSection);                    // Write name section.                  if (nameSection.Length > 0)                  {                      nameSection.Seek(0' SeekOrigin.Begin);                      nameSection.CopyTo(bw.BaseStream' (int)nameSection.Length);                  }                  names.Dispose();                    // Write data section.                  Debug.Assert(startOfDataSection == bw.Seek(0' SeekOrigin.Current)' "ResourceWriter::Generate - start of data section is wrong!");                  dataSection.Position = 0;                  dataSection.CopyTo(bw.BaseStream);                  data.Dispose();              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The following statement contains a magic number: using (dataSection)              {                  BinaryWriter data = new BinaryWriter(dataSection' Encoding.UTF8);                    if (_preserializedData != null)                  {                      foreach (KeyValuePair<string' PrecannedResource> entry in _preserializedData)                      {                          _resourceList.Add(entry.Key' entry.Value);                      }                  }                    // Write resource name and position to the file' and the value                  // to our temporary buffer.  Save Type as well.                  foreach (var item in _resourceList)                  {                      nameHashes[curNameNumber] = FastResourceComparer.HashFunction(item.Key);                      namePositions[curNameNumber++] = (int)names.Seek(0' SeekOrigin.Current);                      names.Write(item.Key); // key                      names.Write((int)data.Seek(0' SeekOrigin.Current)); // virtual offset of value.                        object value = item.Value;                      ResourceTypeCode typeCode = FindTypeCode(value' typeNames);                        // Write out type code                      Write7BitEncodedInt(data' (int)typeCode);                        var userProvidedResource = value as PrecannedResource;                      if (userProvidedResource != null)                      {                          data.Write(userProvidedResource.Data);                      }                      else                      {                          WriteValue(typeCode' value' data);                      }                  }                    // At this point' the ResourceManager header has been written.                  // Finish RuntimeResourceSet header                  // The reader expects a list of user defined type names                   // following the size of the list' write 0 for this                   // writer implementation                  bw.Write(typeNames.Count);                  foreach (var typeName in typeNames)                  {                      bw.Write(typeName);                  }                    // Write out the name-related items for lookup.                  //  Note that the hash array and the namePositions array must                  //  be sorted in parallel.                  Array.Sort(nameHashes' namePositions);                      //  Prepare to write sorted name hashes (alignment fixup)                  //   Note: For 64-bit machines' these MUST be aligned on 8 byte                   //   boundaries!  Pointers on IA64 must be aligned!  And we'll                  //   run faster on X86 machines too.                  bw.Flush();                  int alignBytes = ((int)bw.BaseStream.Position) & 7;                  if (alignBytes > 0)                  {                      for (int i = 0; i < 8 - alignBytes; i++)                          bw.Write("PAD"[i % 3]);                  }                    //  Write out sorted name hashes.                  //   Align to 8 bytes.                  Debug.Assert((bw.BaseStream.Position & 7) == 0' "ResourceWriter: Name hashes array won't be 8 byte aligned!  Ack!");                    foreach (int hash in nameHashes)                  {                      bw.Write(hash);                  }                    //  Write relative positions of all the names in the file.                  //   Note: this data is 4 byte aligned' occurring immediately                   //   after the 8 byte aligned name hashes (whose length may                   //   potentially be odd).                  Debug.Assert((bw.BaseStream.Position & 3) == 0' "ResourceWriter: Name positions array won't be 4 byte aligned!  Ack!");                    foreach (int pos in namePositions)                  {                      bw.Write(pos);                  }                    // Flush all BinaryWriters to their underlying streams.                  bw.Flush();                  names.Flush();                  data.Flush();                    // Write offset to data section                  int startOfDataSection = (int)(bw.Seek(0' SeekOrigin.Current) + nameSection.Length);                  startOfDataSection += 4;  // We're writing an int to store this data' adding more bytes to the header                  bw.Write(startOfDataSection);                    // Write name section.                  if (nameSection.Length > 0)                  {                      nameSection.Seek(0' SeekOrigin.Begin);                      nameSection.CopyTo(bw.BaseStream' (int)nameSection.Length);                  }                  names.Dispose();                    // Write data section.                  Debug.Assert(startOfDataSection == bw.Seek(0' SeekOrigin.Current)' "ResourceWriter::Generate - start of data section is wrong!");                  dataSection.Position = 0;                  dataSection.CopyTo(bw.BaseStream);                  data.Dispose();              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The following statement contains a magic number: using (dataSection)              {                  BinaryWriter data = new BinaryWriter(dataSection' Encoding.UTF8);                    if (_preserializedData != null)                  {                      foreach (KeyValuePair<string' PrecannedResource> entry in _preserializedData)                      {                          _resourceList.Add(entry.Key' entry.Value);                      }                  }                    // Write resource name and position to the file' and the value                  // to our temporary buffer.  Save Type as well.                  foreach (var item in _resourceList)                  {                      nameHashes[curNameNumber] = FastResourceComparer.HashFunction(item.Key);                      namePositions[curNameNumber++] = (int)names.Seek(0' SeekOrigin.Current);                      names.Write(item.Key); // key                      names.Write((int)data.Seek(0' SeekOrigin.Current)); // virtual offset of value.                        object value = item.Value;                      ResourceTypeCode typeCode = FindTypeCode(value' typeNames);                        // Write out type code                      Write7BitEncodedInt(data' (int)typeCode);                        var userProvidedResource = value as PrecannedResource;                      if (userProvidedResource != null)                      {                          data.Write(userProvidedResource.Data);                      }                      else                      {                          WriteValue(typeCode' value' data);                      }                  }                    // At this point' the ResourceManager header has been written.                  // Finish RuntimeResourceSet header                  // The reader expects a list of user defined type names                   // following the size of the list' write 0 for this                   // writer implementation                  bw.Write(typeNames.Count);                  foreach (var typeName in typeNames)                  {                      bw.Write(typeName);                  }                    // Write out the name-related items for lookup.                  //  Note that the hash array and the namePositions array must                  //  be sorted in parallel.                  Array.Sort(nameHashes' namePositions);                      //  Prepare to write sorted name hashes (alignment fixup)                  //   Note: For 64-bit machines' these MUST be aligned on 8 byte                   //   boundaries!  Pointers on IA64 must be aligned!  And we'll                  //   run faster on X86 machines too.                  bw.Flush();                  int alignBytes = ((int)bw.BaseStream.Position) & 7;                  if (alignBytes > 0)                  {                      for (int i = 0; i < 8 - alignBytes; i++)                          bw.Write("PAD"[i % 3]);                  }                    //  Write out sorted name hashes.                  //   Align to 8 bytes.                  Debug.Assert((bw.BaseStream.Position & 7) == 0' "ResourceWriter: Name hashes array won't be 8 byte aligned!  Ack!");                    foreach (int hash in nameHashes)                  {                      bw.Write(hash);                  }                    //  Write relative positions of all the names in the file.                  //   Note: this data is 4 byte aligned' occurring immediately                   //   after the 8 byte aligned name hashes (whose length may                   //   potentially be odd).                  Debug.Assert((bw.BaseStream.Position & 3) == 0' "ResourceWriter: Name positions array won't be 4 byte aligned!  Ack!");                    foreach (int pos in namePositions)                  {                      bw.Write(pos);                  }                    // Flush all BinaryWriters to their underlying streams.                  bw.Flush();                  names.Flush();                  data.Flush();                    // Write offset to data section                  int startOfDataSection = (int)(bw.Seek(0' SeekOrigin.Current) + nameSection.Length);                  startOfDataSection += 4;  // We're writing an int to store this data' adding more bytes to the header                  bw.Write(startOfDataSection);                    // Write name section.                  if (nameSection.Length > 0)                  {                      nameSection.Seek(0' SeekOrigin.Begin);                      nameSection.CopyTo(bw.BaseStream' (int)nameSection.Length);                  }                  names.Dispose();                    // Write data section.                  Debug.Assert(startOfDataSection == bw.Seek(0' SeekOrigin.Current)' "ResourceWriter::Generate - start of data section is wrong!");                  dataSection.Position = 0;                  dataSection.CopyTo(bw.BaseStream);                  data.Dispose();              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The following statement contains a magic number: using (dataSection)              {                  BinaryWriter data = new BinaryWriter(dataSection' Encoding.UTF8);                    if (_preserializedData != null)                  {                      foreach (KeyValuePair<string' PrecannedResource> entry in _preserializedData)                      {                          _resourceList.Add(entry.Key' entry.Value);                      }                  }                    // Write resource name and position to the file' and the value                  // to our temporary buffer.  Save Type as well.                  foreach (var item in _resourceList)                  {                      nameHashes[curNameNumber] = FastResourceComparer.HashFunction(item.Key);                      namePositions[curNameNumber++] = (int)names.Seek(0' SeekOrigin.Current);                      names.Write(item.Key); // key                      names.Write((int)data.Seek(0' SeekOrigin.Current)); // virtual offset of value.                        object value = item.Value;                      ResourceTypeCode typeCode = FindTypeCode(value' typeNames);                        // Write out type code                      Write7BitEncodedInt(data' (int)typeCode);                        var userProvidedResource = value as PrecannedResource;                      if (userProvidedResource != null)                      {                          data.Write(userProvidedResource.Data);                      }                      else                      {                          WriteValue(typeCode' value' data);                      }                  }                    // At this point' the ResourceManager header has been written.                  // Finish RuntimeResourceSet header                  // The reader expects a list of user defined type names                   // following the size of the list' write 0 for this                   // writer implementation                  bw.Write(typeNames.Count);                  foreach (var typeName in typeNames)                  {                      bw.Write(typeName);                  }                    // Write out the name-related items for lookup.                  //  Note that the hash array and the namePositions array must                  //  be sorted in parallel.                  Array.Sort(nameHashes' namePositions);                      //  Prepare to write sorted name hashes (alignment fixup)                  //   Note: For 64-bit machines' these MUST be aligned on 8 byte                   //   boundaries!  Pointers on IA64 must be aligned!  And we'll                  //   run faster on X86 machines too.                  bw.Flush();                  int alignBytes = ((int)bw.BaseStream.Position) & 7;                  if (alignBytes > 0)                  {                      for (int i = 0; i < 8 - alignBytes; i++)                          bw.Write("PAD"[i % 3]);                  }                    //  Write out sorted name hashes.                  //   Align to 8 bytes.                  Debug.Assert((bw.BaseStream.Position & 7) == 0' "ResourceWriter: Name hashes array won't be 8 byte aligned!  Ack!");                    foreach (int hash in nameHashes)                  {                      bw.Write(hash);                  }                    //  Write relative positions of all the names in the file.                  //   Note: this data is 4 byte aligned' occurring immediately                   //   after the 8 byte aligned name hashes (whose length may                   //   potentially be odd).                  Debug.Assert((bw.BaseStream.Position & 3) == 0' "ResourceWriter: Name positions array won't be 4 byte aligned!  Ack!");                    foreach (int pos in namePositions)                  {                      bw.Write(pos);                  }                    // Flush all BinaryWriters to their underlying streams.                  bw.Flush();                  names.Flush();                  data.Flush();                    // Write offset to data section                  int startOfDataSection = (int)(bw.Seek(0' SeekOrigin.Current) + nameSection.Length);                  startOfDataSection += 4;  // We're writing an int to store this data' adding more bytes to the header                  bw.Write(startOfDataSection);                    // Write name section.                  if (nameSection.Length > 0)                  {                      nameSection.Seek(0' SeekOrigin.Begin);                      nameSection.CopyTo(bw.BaseStream' (int)nameSection.Length);                  }                  names.Dispose();                    // Write data section.                  Debug.Assert(startOfDataSection == bw.Seek(0' SeekOrigin.Current)' "ResourceWriter::Generate - start of data section is wrong!");                  dataSection.Position = 0;                  dataSection.CopyTo(bw.BaseStream);                  data.Dispose();              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The following statement contains a magic number: using (dataSection)              {                  BinaryWriter data = new BinaryWriter(dataSection' Encoding.UTF8);                    if (_preserializedData != null)                  {                      foreach (KeyValuePair<string' PrecannedResource> entry in _preserializedData)                      {                          _resourceList.Add(entry.Key' entry.Value);                      }                  }                    // Write resource name and position to the file' and the value                  // to our temporary buffer.  Save Type as well.                  foreach (var item in _resourceList)                  {                      nameHashes[curNameNumber] = FastResourceComparer.HashFunction(item.Key);                      namePositions[curNameNumber++] = (int)names.Seek(0' SeekOrigin.Current);                      names.Write(item.Key); // key                      names.Write((int)data.Seek(0' SeekOrigin.Current)); // virtual offset of value.                        object value = item.Value;                      ResourceTypeCode typeCode = FindTypeCode(value' typeNames);                        // Write out type code                      Write7BitEncodedInt(data' (int)typeCode);                        var userProvidedResource = value as PrecannedResource;                      if (userProvidedResource != null)                      {                          data.Write(userProvidedResource.Data);                      }                      else                      {                          WriteValue(typeCode' value' data);                      }                  }                    // At this point' the ResourceManager header has been written.                  // Finish RuntimeResourceSet header                  // The reader expects a list of user defined type names                   // following the size of the list' write 0 for this                   // writer implementation                  bw.Write(typeNames.Count);                  foreach (var typeName in typeNames)                  {                      bw.Write(typeName);                  }                    // Write out the name-related items for lookup.                  //  Note that the hash array and the namePositions array must                  //  be sorted in parallel.                  Array.Sort(nameHashes' namePositions);                      //  Prepare to write sorted name hashes (alignment fixup)                  //   Note: For 64-bit machines' these MUST be aligned on 8 byte                   //   boundaries!  Pointers on IA64 must be aligned!  And we'll                  //   run faster on X86 machines too.                  bw.Flush();                  int alignBytes = ((int)bw.BaseStream.Position) & 7;                  if (alignBytes > 0)                  {                      for (int i = 0; i < 8 - alignBytes; i++)                          bw.Write("PAD"[i % 3]);                  }                    //  Write out sorted name hashes.                  //   Align to 8 bytes.                  Debug.Assert((bw.BaseStream.Position & 7) == 0' "ResourceWriter: Name hashes array won't be 8 byte aligned!  Ack!");                    foreach (int hash in nameHashes)                  {                      bw.Write(hash);                  }                    //  Write relative positions of all the names in the file.                  //   Note: this data is 4 byte aligned' occurring immediately                   //   after the 8 byte aligned name hashes (whose length may                   //   potentially be odd).                  Debug.Assert((bw.BaseStream.Position & 3) == 0' "ResourceWriter: Name positions array won't be 4 byte aligned!  Ack!");                    foreach (int pos in namePositions)                  {                      bw.Write(pos);                  }                    // Flush all BinaryWriters to their underlying streams.                  bw.Flush();                  names.Flush();                  data.Flush();                    // Write offset to data section                  int startOfDataSection = (int)(bw.Seek(0' SeekOrigin.Current) + nameSection.Length);                  startOfDataSection += 4;  // We're writing an int to store this data' adding more bytes to the header                  bw.Write(startOfDataSection);                    // Write name section.                  if (nameSection.Length > 0)                  {                      nameSection.Seek(0' SeekOrigin.Begin);                      nameSection.CopyTo(bw.BaseStream' (int)nameSection.Length);                  }                  names.Dispose();                    // Write data section.                  Debug.Assert(startOfDataSection == bw.Seek(0' SeekOrigin.Current)' "ResourceWriter::Generate - start of data section is wrong!");                  dataSection.Position = 0;                  dataSection.CopyTo(bw.BaseStream);                  data.Dispose();              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Generate,The following statement contains a magic number: using (dataSection)              {                  BinaryWriter data = new BinaryWriter(dataSection' Encoding.UTF8);                    if (_preserializedData != null)                  {                      foreach (KeyValuePair<string' PrecannedResource> entry in _preserializedData)                      {                          _resourceList.Add(entry.Key' entry.Value);                      }                  }                    // Write resource name and position to the file' and the value                  // to our temporary buffer.  Save Type as well.                  foreach (var item in _resourceList)                  {                      nameHashes[curNameNumber] = FastResourceComparer.HashFunction(item.Key);                      namePositions[curNameNumber++] = (int)names.Seek(0' SeekOrigin.Current);                      names.Write(item.Key); // key                      names.Write((int)data.Seek(0' SeekOrigin.Current)); // virtual offset of value.                        object value = item.Value;                      ResourceTypeCode typeCode = FindTypeCode(value' typeNames);                        // Write out type code                      Write7BitEncodedInt(data' (int)typeCode);                        var userProvidedResource = value as PrecannedResource;                      if (userProvidedResource != null)                      {                          data.Write(userProvidedResource.Data);                      }                      else                      {                          WriteValue(typeCode' value' data);                      }                  }                    // At this point' the ResourceManager header has been written.                  // Finish RuntimeResourceSet header                  // The reader expects a list of user defined type names                   // following the size of the list' write 0 for this                   // writer implementation                  bw.Write(typeNames.Count);                  foreach (var typeName in typeNames)                  {                      bw.Write(typeName);                  }                    // Write out the name-related items for lookup.                  //  Note that the hash array and the namePositions array must                  //  be sorted in parallel.                  Array.Sort(nameHashes' namePositions);                      //  Prepare to write sorted name hashes (alignment fixup)                  //   Note: For 64-bit machines' these MUST be aligned on 8 byte                   //   boundaries!  Pointers on IA64 must be aligned!  And we'll                  //   run faster on X86 machines too.                  bw.Flush();                  int alignBytes = ((int)bw.BaseStream.Position) & 7;                  if (alignBytes > 0)                  {                      for (int i = 0; i < 8 - alignBytes; i++)                          bw.Write("PAD"[i % 3]);                  }                    //  Write out sorted name hashes.                  //   Align to 8 bytes.                  Debug.Assert((bw.BaseStream.Position & 7) == 0' "ResourceWriter: Name hashes array won't be 8 byte aligned!  Ack!");                    foreach (int hash in nameHashes)                  {                      bw.Write(hash);                  }                    //  Write relative positions of all the names in the file.                  //   Note: this data is 4 byte aligned' occurring immediately                   //   after the 8 byte aligned name hashes (whose length may                   //   potentially be odd).                  Debug.Assert((bw.BaseStream.Position & 3) == 0' "ResourceWriter: Name positions array won't be 4 byte aligned!  Ack!");                    foreach (int pos in namePositions)                  {                      bw.Write(pos);                  }                    // Flush all BinaryWriters to their underlying streams.                  bw.Flush();                  names.Flush();                  data.Flush();                    // Write offset to data section                  int startOfDataSection = (int)(bw.Seek(0' SeekOrigin.Current) + nameSection.Length);                  startOfDataSection += 4;  // We're writing an int to store this data' adding more bytes to the header                  bw.Write(startOfDataSection);                    // Write name section.                  if (nameSection.Length > 0)                  {                      nameSection.Seek(0' SeekOrigin.Begin);                      nameSection.CopyTo(bw.BaseStream' (int)nameSection.Length);                  }                  names.Dispose();                    // Write data section.                  Debug.Assert(startOfDataSection == bw.Seek(0' SeekOrigin.Current)' "ResourceWriter::Generate - start of data section is wrong!");                  dataSection.Position = 0;                  dataSection.CopyTo(bw.BaseStream);                  data.Dispose();              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,Write7BitEncodedInt,The following statement contains a magic number: while (v >= 0x80)              {                  store.Write((byte)(v | 0x80));                  v >>= 7;              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,FindTypeCode,The following statement contains a magic number: if (type == typeof(PrecannedResource)) {                  typeName = ((PrecannedResource)value).TypeName;                  if (typeName.StartsWith("ResourceTypeCode."' StringComparison.Ordinal)) {                      typeName = typeName.Substring(17);  // Remove through '.'                      ResourceTypeCode typeCode = (ResourceTypeCode)Enum.Parse(typeof(ResourceTypeCode)' typeName);                      return typeCode;                  }              }              else               {                  typeName = MultitargetingHelpers.GetAssemblyQualifiedName(type' TypeNameConverter);              }
Magic Number,System.Resources,ResourceWriter,C:\selectedRepos\dotnet_corefx\src\System.Resources.Writer\src\System\Resources\ResourceWriter.cs,WriteValue,The following statement contains a magic number: switch (typeCode)              {                  case ResourceTypeCode.Null:                      break;                    case ResourceTypeCode.String:                      writer.Write((string)value);                      break;                    case ResourceTypeCode.Boolean:                      writer.Write((bool)value);                      break;                    case ResourceTypeCode.Char:                      writer.Write((ushort)(char)value);                      break;                    case ResourceTypeCode.Byte:                      writer.Write((byte)value);                      break;                    case ResourceTypeCode.SByte:                      writer.Write((sbyte)value);                      break;                    case ResourceTypeCode.Int16:                      writer.Write((short)value);                      break;                    case ResourceTypeCode.UInt16:                      writer.Write((ushort)value);                      break;                    case ResourceTypeCode.Int32:                      writer.Write((int)value);                      break;                    case ResourceTypeCode.UInt32:                      writer.Write((uint)value);                      break;                    case ResourceTypeCode.Int64:                      writer.Write((long)value);                      break;                    case ResourceTypeCode.UInt64:                      writer.Write((ulong)value);                      break;                    case ResourceTypeCode.Single:                      writer.Write((float)value);                      break;                    case ResourceTypeCode.Double:                      writer.Write((double)value);                      break;                    case ResourceTypeCode.Decimal:                      writer.Write((decimal)value);                      break;                    case ResourceTypeCode.DateTime:                      // Use DateTime's ToBinary & FromBinary.                      long data = ((DateTime)value).ToBinary();                      writer.Write(data);                      break;                    case ResourceTypeCode.TimeSpan:                      writer.Write(((TimeSpan)value).Ticks);                      break;                    // Special Types                  case ResourceTypeCode.ByteArray:                      {                          byte[] bytes = (byte[])value;                          writer.Write(bytes.Length);                          writer.Write(bytes' 0' bytes.Length);                          break;                      }                    case ResourceTypeCode.Stream:                      {                          StreamWrapper sw = (StreamWrapper)value;                          if (sw.Stream.GetType() == typeof(MemoryStream))                          {                              MemoryStream ms = (MemoryStream)sw.Stream;                              if (ms.Length > int.MaxValue)                                  throw new ArgumentException(SR.ArgumentOutOfRange_StreamLength);                              byte[] arr = ms.ToArray();                              writer.Write(arr.Length);                              writer.Write(arr' 0' arr.Length);                          }                          else                          {                              Stream s = sw.Stream;                              // we've already verified that the Stream is seekable                              if (s.Length > int.MaxValue)                                  throw new ArgumentException(SR.ArgumentOutOfRange_StreamLength);                                s.Position = 0;                              writer.Write((int)s.Length);                              byte[] buffer = new byte[4096];                              int read = 0;                              while ((read = s.Read(buffer' 0' buffer.Length)) != 0)                              {                                  writer.Write(buffer' 0' read);                              }                              if (sw.CloseAfterWrite)                              {                                  s.Close();                              }                          }                          break;                      }                    default:                      Contract.Assert(typeCode >= ResourceTypeCode.StartOfUserTypes' string.Format(CultureInfo.InvariantCulture' "ResourceReader: Unsupported ResourceTypeCode in .resources file!  {0}"' typeCode));                      throw new PlatformNotSupportedException(SR.NotSupported_BinarySerializedResources);              }
