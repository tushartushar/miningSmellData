Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,DoRemove,The method has 105 lines of code.
Complex Method,System.Collections.Generic,HashSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,IsProperSubsetOf,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,HashSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,IsProperSupersetOf,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,Queue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\Queue.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,SortedList<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedList.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,AddIfNotPresent,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,SortedSetEquals,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,UnionWith,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,IntersectWith,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,ExceptWith,Cyclomatic complexity of the method is 9
Complex Method,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,IsProperSupersetOf,Cyclomatic complexity of the method is 8
Complex Method,System.Collections.Generic,TreeSubSet,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.TreeSubSet.cs,InOrderTreeWalk,Cyclomatic complexity of the method is 8
Long Parameter List,System.Collections.Generic,TreeSubSet,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.TreeSubSet.cs,TreeSubSet,The method has 5 parameters. Parameters: Underlying' Min' Max' lowerBoundActive' upperBoundActive
Long Statement,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The length of the statement  "                    b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask " is 124.
Long Statement,System.Collections.Generic,KeyCollection,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedDictionary.cs,CopyTo,The length of the statement  "                _dictionary._set.InOrderTreeWalk(delegate (TreeSet<KeyValuePair<TKey' TValue>>.Node node) { array[index++] = node.Item.Key; return true; }); " is 140.
Long Statement,System.Collections.Generic,KeyCollection,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedDictionary.cs,CopyTo,The length of the statement  "                        _dictionary._set.InOrderTreeWalk(delegate (TreeSet<KeyValuePair<TKey' TValue>>.Node node) { objects[index++] = node.Item.Key; return true; }); " is 142.
Long Statement,System.Collections.Generic,ValueCollection,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedDictionary.cs,CopyTo,The length of the statement  "                _dictionary._set.InOrderTreeWalk(delegate (TreeSet<KeyValuePair<TKey' TValue>>.Node node) { array[index++] = node.Item.Value; return true; }); " is 142.
Long Statement,System.Collections.Generic,ValueCollection,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedDictionary.cs,CopyTo,The length of the statement  "                        _dictionary._set.InOrderTreeWalk(delegate (TreeSet<KeyValuePair<TKey' TValue>>.Node node) { objects[index++] = node.Item.Value; return true; }); " is 144.
Long Statement,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,HasEqualComparer,The length of the statement  "            // Commonly' both comparers will be the default comparer (and reference-equal). Avoid a virtual method call to Equals() in that case. " is 133.
Long Statement,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,ConstructRootFromSortedArray,The length of the statement  "            // This is done recursively because the iterative way to do this ends up wasting more space than it saves in stack frames " is 121.
Long Statement,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,Overlaps,The length of the statement  "            if (asSorted != null && HasEqualComparer(asSorted) && (comparer.Compare(Min' asSorted.Max) > 0 || comparer.Compare(Max' asSorted.Min) < 0)) " is 139.
Long Statement,System.Collections.Generic,TreeSubSet,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.TreeSubSet.cs,InOrderTreeWalk,The length of the statement  "                Stack<Node> stack = new Stack<Node>(2 * (int)SortedSet<T>.Log2(count + 1)); // this is not exactly right if count is out of date' but the stack can grow " is 152.
Long Statement,System.Collections.Generic,Stack<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\Stack.cs,Clear,The length of the statement  "                Array.Clear(_array' 0' _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references. " is 125.
Complex Conditional,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,UnionWith,The conditional expression  "asSorted != null && treeSubset == null && HasEqualComparer(asSorted) && (asSorted.Count > this.Count / 2)"  is complex.
Complex Conditional,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,Overlaps,The conditional expression  "asSorted != null && HasEqualComparer(asSorted) && (comparer.Compare(Min' asSorted.Max) > 0 || comparer.Compare(Max' asSorted.Min) < 0)"  is complex.
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: while (bytes.Length - j >= 4)              {                  m_array[i++] = (bytes[j] & 0xff) |                                ((bytes[j + 1] & 0xff) << 8) |                                ((bytes[j + 2] & 0xff) << 16) |                                ((bytes[j + 3] & 0xff) << 24);                  j += 4;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: while (bytes.Length - j >= 4)              {                  m_array[i++] = (bytes[j] & 0xff) |                                ((bytes[j + 1] & 0xff) << 8) |                                ((bytes[j + 2] & 0xff) << 16) |                                ((bytes[j + 3] & 0xff) << 24);                  j += 4;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: while (bytes.Length - j >= 4)              {                  m_array[i++] = (bytes[j] & 0xff) |                                ((bytes[j + 1] & 0xff) << 8) |                                ((bytes[j + 2] & 0xff) << 16) |                                ((bytes[j + 3] & 0xff) << 24);                  j += 4;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: while (bytes.Length - j >= 4)              {                  m_array[i++] = (bytes[j] & 0xff) |                                ((bytes[j + 1] & 0xff) << 8) |                                ((bytes[j + 2] & 0xff) << 16) |                                ((bytes[j + 3] & 0xff) << 24);                  j += 4;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: while (bytes.Length - j >= 4)              {                  m_array[i++] = (bytes[j] & 0xff) |                                ((bytes[j + 1] & 0xff) << 8) |                                ((bytes[j + 2] & 0xff) << 16) |                                ((bytes[j + 3] & 0xff) << 24);                  j += 4;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: while (bytes.Length - j >= 4)              {                  m_array[i++] = (bytes[j] & 0xff) |                                ((bytes[j + 1] & 0xff) << 8) |                                ((bytes[j + 2] & 0xff) << 16) |                                ((bytes[j + 3] & 0xff) << 24);                  j += 4;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: while (bytes.Length - j >= 4)              {                  m_array[i++] = (bytes[j] & 0xff) |                                ((bytes[j + 1] & 0xff) << 8) |                                ((bytes[j + 2] & 0xff) << 16) |                                ((bytes[j + 3] & 0xff) << 24);                  j += 4;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: Debug.Assert(bytes.Length - j < 4' "BitArray byteLength problem #2");
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: switch (bytes.Length - j)              {                  case 3:                      m_array[i] = ((bytes[j + 2] & 0xff) << 16);                      goto case 2;                  // fall through                  case 2:                      m_array[i] |= ((bytes[j + 1] & 0xff) << 8);                      goto case 1;                  // fall through                  case 1:                      m_array[i] |= (bytes[j] & 0xff);                      break;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: switch (bytes.Length - j)              {                  case 3:                      m_array[i] = ((bytes[j + 2] & 0xff) << 16);                      goto case 2;                  // fall through                  case 2:                      m_array[i] |= ((bytes[j + 1] & 0xff) << 8);                      goto case 1;                  // fall through                  case 1:                      m_array[i] |= (bytes[j] & 0xff);                      break;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: switch (bytes.Length - j)              {                  case 3:                      m_array[i] = ((bytes[j + 2] & 0xff) << 16);                      goto case 2;                  // fall through                  case 2:                      m_array[i] |= ((bytes[j + 1] & 0xff) << 8);                      goto case 1;                  // fall through                  case 1:                      m_array[i] |= (bytes[j] & 0xff);                      break;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: switch (bytes.Length - j)              {                  case 3:                      m_array[i] = ((bytes[j + 2] & 0xff) << 16);                      goto case 2;                  // fall through                  case 2:                      m_array[i] |= ((bytes[j + 1] & 0xff) << 8);                      goto case 1;                  // fall through                  case 1:                      m_array[i] |= (bytes[j] & 0xff);                      break;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: switch (bytes.Length - j)              {                  case 3:                      m_array[i] = ((bytes[j + 2] & 0xff) << 16);                      goto case 2;                  // fall through                  case 2:                      m_array[i] |= ((bytes[j + 1] & 0xff) << 8);                      goto case 1;                  // fall through                  case 1:                      m_array[i] |= (bytes[j] & 0xff);                      break;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: switch (bytes.Length - j)              {                  case 3:                      m_array[i] = ((bytes[j + 2] & 0xff) << 16);                      goto case 2;                  // fall through                  case 2:                      m_array[i] |= ((bytes[j + 1] & 0xff) << 8);                      goto case 1;                  // fall through                  case 1:                      m_array[i] |= (bytes[j] & 0xff);                      break;              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: for (int i = 0; i < values.Length; i++)              {                  if (values[i])                      m_array[i / 32] |= (1 << (i % 32));              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following statement contains a magic number: for (int i = 0; i < values.Length; i++)              {                  if (values[i])                      m_array[i / 32] |= (1 << (i % 32));              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,Get,The following statement contains a magic number: return (m_array[index / 32] & (1 << (index % 32))) != 0;
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,Get,The following statement contains a magic number: return (m_array[index / 32] & (1 << (index % 32))) != 0;
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,Set,The following statement contains a magic number: if (value)              {                  m_array[index / 32] |= (1 << (index % 32));              }              else              {                  m_array[index / 32] &= ~(1 << (index % 32));              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,Set,The following statement contains a magic number: if (value)              {                  m_array[index / 32] |= (1 << (index % 32));              }              else              {                  m_array[index / 32] &= ~(1 << (index % 32));              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,Set,The following statement contains a magic number: if (value)              {                  m_array[index / 32] |= (1 << (index % 32));              }              else              {                  m_array[index / 32] &= ~(1 << (index % 32));              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,Set,The following statement contains a magic number: if (value)              {                  m_array[index / 32] |= (1 << (index % 32));              }              else              {                  m_array[index / 32] &= ~(1 << (index % 32));              }
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,CopyTo,The following statement contains a magic number: if (intArray != null)              {                  int last = GetArrayLength(m_length' BitsPerInt32) - 1;                  int extraBits = m_length % BitsPerInt32;                    if (extraBits == 0)                  {                      // we have perfect bit alignment' no need to sanitize' just copy                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32));                  }                  else                  {                      // do not copy the last int' as it is not completely used                      Array.Copy(m_array' 0' intArray' index' GetArrayLength(m_length' BitsPerInt32) - 1);                        // the last int needs to be masked                      intArray[index + last] = m_array[last] & unchecked((1 << extraBits) - 1);                  }              }              else if (array is byte[])              {                  int extraBits = m_length % BitsPerByte;                    int arrayLength = GetArrayLength(m_length' BitsPerByte);                  if ((array.Length - index) < arrayLength)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    if (extraBits > 0)                  {                      // last byte is not aligned' we will directly copy one less byte                      arrayLength -= 1;                  }                    byte[] b = (byte[])array;                    // copy all the perfectly-aligned bytes                  for (int i = 0; i < arrayLength; i++)                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & 0x000000FF); // Shift to bring the required byte to LSB' then mask                    if (extraBits > 0)                  {                      // mask the final byte                      int i = arrayLength;                      b[index + i] = (byte)((m_array[i / 4] >> ((i % 4) * 8)) & ((1 << extraBits) - 1));                  }              }              else if (array is bool[])              {                  if (array.Length - index < m_length)                      throw new ArgumentException(SR.Argument_InvalidOffLen);                    bool[] b = (bool[])array;                  for (int i = 0; i < m_length; i++)                      b[index + i] = ((m_array[i / 32] >> (i % 32)) & 0x00000001) != 0;              }              else                  throw new ArgumentException(SR.Arg_BitArrayTypeUnsupported' nameof(array));
Magic Number,System.Collections,HashHelpers,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\HashHelpers.cs,ExpandPrime,The following statement contains a magic number: int newSize = 2 * oldSize;
Magic Number,System.Collections.Generic,HashSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,SymmetricExceptWithEnumerable,The following statement contains a magic number: if (intArrayLength <= StackAllocThreshold / 2)              {                  int* itemsToRemovePtr = stackalloc int[intArrayLength];                  itemsToRemove = new BitHelper(itemsToRemovePtr' intArrayLength);                    int* itemsAddedFromOtherPtr = stackalloc int[intArrayLength];                  itemsAddedFromOther = new BitHelper(itemsAddedFromOtherPtr' intArrayLength);              }              else              {                  int[] itemsToRemoveArray = new int[intArrayLength];                  itemsToRemove = new BitHelper(itemsToRemoveArray' intArrayLength);                    int[] itemsAddedFromOtherArray = new int[intArrayLength];                  itemsAddedFromOther = new BitHelper(itemsAddedFromOtherArray' intArrayLength);              }
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,Dispose,The following statement contains a magic number: _index = -2;
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,MoveNext,The following statement contains a magic number: if (_index == -2)                      return false;
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,MoveNext,The following statement contains a magic number: if (_index == _q._size)                  {                      // We've run past the last element                      _index = -2;                      _currentElement = default(T);                      return false;                  }
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,ThrowEnumerationNotStartedOrEnded,The following statement contains a magic number: Debug.Assert(_index == -1 || _index == -2);
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,Enumerator,The following statement contains a magic number: _stack = new Stack<Node>(2 * (int)Log2(set.Count + 1));
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,Enumerator,The following statement contains a magic number: _index = -2;
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,MoveNext,The following statement contains a magic number: if (_index == -2)                  {  // First call to enumerator.                      _index = _stack._size - 1;                      retval = (_index >= 0);                      if (retval)                          _currentElement = _stack._array[_index];                      return retval;                  }
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,ThrowEnumerationNotStartedOrEnded,The following statement contains a magic number: Debug.Assert(_index == -1 || _index == -2);
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,ThrowEnumerationNotStartedOrEnded,The following statement contains a magic number: throw new InvalidOperationException(_index == -2 ? SR.InvalidOperation_EnumNotStarted : SR.InvalidOperation_EnumEnded);
Magic Number,System.Collections.Generic,Enumerator,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\HashSet.cs,Reset,The following statement contains a magic number: _index = -2;
Magic Number,System.Collections.Generic,Queue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\Queue.cs,Enqueue,The following statement contains a magic number: if (_size == _array.Length)              {                  int newcapacity = (int)((long)_array.Length * (long)GrowFactor / 100);                  if (newcapacity < _array.Length + MinimumGrow)                  {                      newcapacity = _array.Length + MinimumGrow;                  }                  SetCapacity(newcapacity);              }
Magic Number,System.Collections.Generic,Queue<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\Queue.cs,TrimExcess,The following statement contains a magic number: int threshold = (int)(((double)_array.Length) * 0.9);
Magic Number,System.Collections.Generic,SortedList<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedList.cs,EnsureCapacity,The following statement contains a magic number: int newCapacity = keys.Length == 0 ? DefaultCapacity : keys.Length * 2;
Magic Number,System.Collections.Generic,SortedList<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedList.cs,TrimExcess,The following statement contains a magic number: int threshold = (int)(((double)keys.Length) * 0.9);
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,InOrderTreeWalk,The following statement contains a magic number: var stack = new Stack<Node>(2 * (int)Log2(Count + 1));
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,InternalIndexOf,The following statement contains a magic number: while (current != null)              {                  int order = comparer.Compare(item' current.Item);                  if (order == 0)                  {                      return count;                  }                    current = order < 0 ? current.Left : current.Right;                  count = order < 0 ? (2 * count + 1) : (2 * count + 2);              }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,InternalIndexOf,The following statement contains a magic number: while (current != null)              {                  int order = comparer.Compare(item' current.Item);                  if (order == 0)                  {                      return count;                  }                    current = order < 0 ? current.Left : current.Right;                  count = order < 0 ? (2 * count + 1) : (2 * count + 2);              }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,InternalIndexOf,The following statement contains a magic number: while (current != null)              {                  int order = comparer.Compare(item' current.Item);                  if (order == 0)                  {                      return count;                  }                    current = order < 0 ? current.Left : current.Right;                  count = order < 0 ? (2 * count + 1) : (2 * count + 2);              }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,UnionWith,The following statement contains a magic number: if (asSorted != null && treeSubset == null && HasEqualComparer(asSorted) && (asSorted.Count > this.Count / 2))              {                  // First do a merge sort to an array.                  T[] merged = new T[asSorted.Count + this.Count];                  int c = 0;                  Enumerator mine = this.GetEnumerator();                  Enumerator theirs = asSorted.GetEnumerator();                  bool mineEnded = !mine.MoveNext()' theirsEnded = !theirs.MoveNext();                  while (!mineEnded && !theirsEnded)                  {                      int comp = Comparer.Compare(mine.Current' theirs.Current);                      if (comp < 0)                      {                          merged[c++] = mine.Current;                          mineEnded = !mine.MoveNext();                      }                      else if (comp == 0)                      {                          merged[c++] = theirs.Current;                          mineEnded = !mine.MoveNext();                          theirsEnded = !theirs.MoveNext();                      }                      else                      {                          merged[c++] = theirs.Current;                          theirsEnded = !theirs.MoveNext();                      }                  }                    if (!mineEnded || !theirsEnded)                  {                      Enumerator remaining = (mineEnded ? theirs : mine);                      do                      {                          merged[c++] = remaining.Current;                      }                      while (remaining.MoveNext());                  }                    // now merged has all c elements                    // safe to gc the root' we  have all the elements                  root = null;                    root = ConstructRootFromSortedArray(merged' 0' c - 1' null);                  count = c;                  version++;              }              else              {                  AddAllElements(other);              }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: switch (size)              {                  case 0:                      return null;                  case 1:                      root = new Node(arr[startIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 2:                      root = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      root.Right.ColorRed();                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 3:                      root = new Node(arr[startIndex + 1]' NodeColor.Black);                      root.Left = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left.Left = redNode;                      }                      break;                  default:                      int midpt = ((startIndex + endIndex) / 2);                      root = new Node(arr[midpt]' NodeColor.Black);                      root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                      root.Right = size % 2 == 0 ?                          ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' NodeColor.Red)) :                          ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                      break;                }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: switch (size)              {                  case 0:                      return null;                  case 1:                      root = new Node(arr[startIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 2:                      root = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      root.Right.ColorRed();                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 3:                      root = new Node(arr[startIndex + 1]' NodeColor.Black);                      root.Left = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left.Left = redNode;                      }                      break;                  default:                      int midpt = ((startIndex + endIndex) / 2);                      root = new Node(arr[midpt]' NodeColor.Black);                      root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                      root.Right = size % 2 == 0 ?                          ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' NodeColor.Red)) :                          ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                      break;                }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: switch (size)              {                  case 0:                      return null;                  case 1:                      root = new Node(arr[startIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 2:                      root = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      root.Right.ColorRed();                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 3:                      root = new Node(arr[startIndex + 1]' NodeColor.Black);                      root.Left = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left.Left = redNode;                      }                      break;                  default:                      int midpt = ((startIndex + endIndex) / 2);                      root = new Node(arr[midpt]' NodeColor.Black);                      root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                      root.Right = size % 2 == 0 ?                          ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' NodeColor.Red)) :                          ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                      break;                }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: switch (size)              {                  case 0:                      return null;                  case 1:                      root = new Node(arr[startIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 2:                      root = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      root.Right.ColorRed();                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 3:                      root = new Node(arr[startIndex + 1]' NodeColor.Black);                      root.Left = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left.Left = redNode;                      }                      break;                  default:                      int midpt = ((startIndex + endIndex) / 2);                      root = new Node(arr[midpt]' NodeColor.Black);                      root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                      root.Right = size % 2 == 0 ?                          ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' NodeColor.Red)) :                          ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                      break;                }
Magic Number,System.Collections.Generic,SortedSet<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,ConstructRootFromSortedArray,The following statement contains a magic number: switch (size)              {                  case 0:                      return null;                  case 1:                      root = new Node(arr[startIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 2:                      root = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      root.Right.ColorRed();                      if (redNode != null)                      {                          root.Left = redNode;                      }                      break;                  case 3:                      root = new Node(arr[startIndex + 1]' NodeColor.Black);                      root.Left = new Node(arr[startIndex]' NodeColor.Black);                      root.Right = new Node(arr[endIndex]' NodeColor.Black);                      if (redNode != null)                      {                          root.Left.Left = redNode;                      }                      break;                  default:                      int midpt = ((startIndex + endIndex) / 2);                      root = new Node(arr[midpt]' NodeColor.Black);                      root.Left = ConstructRootFromSortedArray(arr' startIndex' midpt - 1' redNode);                      root.Right = size % 2 == 0 ?                          ConstructRootFromSortedArray(arr' midpt + 2' endIndex' new Node(arr[midpt + 1]' NodeColor.Red)) :                          ConstructRootFromSortedArray(arr' midpt + 1' endIndex' null);                      break;                }
Magic Number,System.Collections.Generic,Node,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,DeepClone,The following statement contains a magic number: var originalNodes = new Stack<Node>(2 * Log2(count) + 2);
Magic Number,System.Collections.Generic,Node,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,DeepClone,The following statement contains a magic number: var originalNodes = new Stack<Node>(2 * Log2(count) + 2);
Magic Number,System.Collections.Generic,Node,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,DeepClone,The following statement contains a magic number: var newNodes = new Stack<Node>(2 * Log2(count) + 2);
Magic Number,System.Collections.Generic,Node,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.cs,DeepClone,The following statement contains a magic number: var newNodes = new Stack<Node>(2 * Log2(count) + 2);
Magic Number,System.Collections.Generic,TreeSubSet,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\SortedSet.TreeSubSet.cs,InOrderTreeWalk,The following statement contains a magic number: Stack<Node> stack = new Stack<Node>(2 * (int)SortedSet<T>.Log2(count + 1));
Magic Number,System.Collections.Generic,Stack<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\Stack.cs,TrimExcess,The following statement contains a magic number: int threshold = (int)(((double)_array.Length) * 0.9);
Magic Number,System.Collections.Generic,Stack<T>,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\Generic\Stack.cs,Push,The following statement contains a magic number: if (_size == _array.Length)              {                  Array.Resize(ref _array' (_array.Length == 0) ? DefaultCapacity : 2 * _array.Length);              }
Magic Number,System.Collections.Generic,ArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\ArrayBuilder.cs,EnsureCapacity,The following statement contains a magic number: int nextCapacity = capacity == 0 ? DefaultCapacity : 2 * capacity;
Magic Number,System.Collections.Generic,EnumerableHelpers,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\EnumerableHelpers.cs,ToArray,The following statement contains a magic number: if (source is ICollection<T> ic)              {                  int count = ic.Count;                  if (count != 0)                  {                      // Allocate an array of the desired size' then copy the elements into it. Note that this has the same                      // issue regarding concurrency as other existing collections like List<T>. If the collection size                      // concurrently changes between the array allocation and the CopyTo' we could end up either getting an                      // exception from overrunning the array (if the size went up) or we could end up not filling as many                      // items as 'count' suggests (if the size went down).  This is only an issue for concurrent collections                      // that implement ICollection<T>' which as of .NET 4.6 is just ConcurrentDictionary<TKey' TValue>.                      T[] arr = new T[count];                      ic.CopyTo(arr' 0);                      length = count;                      return arr;                  }              }              else              {                  using (var en = source.GetEnumerator())                  {                      if (en.MoveNext())                      {                          const int DefaultCapacity = 4;                          T[] arr = new T[DefaultCapacity];                          arr[0] = en.Current;                          int count = 1;                            while (en.MoveNext())                          {                              if (count == arr.Length)                              {                                  // MaxArrayLength is defined in Array.MaxArrayLength and in gchelpers in CoreCLR.                                  // It represents the maximum number of elements that can be in an array where                                  // the size of the element is greater than one byte; a separate' slightly larger constant'                                  // is used when the size of the element is one.                                  const int MaxArrayLength = 0x7FEFFFFF;                                    // This is the same growth logic as in List<T>:                                  // If the array is currently empty' we make it a default size.  Otherwise' we attempt to                                  // double the size of the array.  Doubling will overflow once the size of the array reaches                                  // 2^30' since doubling to 2^31 is 1 larger than Int32.MaxValue.  In that case' we instead                                  // constrain the length to be MaxArrayLength (this overflow check works because of the                                  // cast to uint).  Because a slightly larger constant is used when T is one byte in size' we                                  // could then end up in a situation where arr.Length is MaxArrayLength or slightly larger' such                                  // that we constrain newLength to be MaxArrayLength but the needed number of elements is actually                                  // larger than that.  For that case' we then ensure that the newLength is large enough to hold                                  // the desired capacity.  This does mean that in the very rare case where we've grown to such a                                  // large size' each new element added after MaxArrayLength will end up doing a resize.                                  int newLength = count << 1;                                  if ((uint)newLength > MaxArrayLength)                                  {                                      newLength = MaxArrayLength <= count ? count + 1 : MaxArrayLength;                                  }                                    Array.Resize(ref arr' newLength);                              }                                arr[count++] = en.Current;                          }                            length = count;                          return arr;                      }                  }              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,GetBuffer,The following statement contains a magic number: Debug.Assert(index >= 0 && index < _buffers.Count + 2);
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Magic Number,System.Collections.Generic,LargeArrayBuilder,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LargeArrayBuilder.cs,AllocateBuffer,The following statement contains a magic number: if ((uint)_count < (uint)ResizeLimit)              {                  // We haven't passed ResizeLimit. Resize _first' copying over the previous items.                  Debug.Assert(_current == _first && _count == _first.Length);                    int nextCapacity = Math.Min(_count == 0 ? StartingCapacity : _count * 2' _maxCapacity);                    _current = new T[nextCapacity];                  Array.Copy(_first' 0' _current' 0' _count);                  _first = _current;              }              else              {                  Debug.Assert(_maxCapacity > ResizeLimit);                  Debug.Assert(_count == ResizeLimit ^ _current != _first);                    int nextCapacity;                  if (_count == ResizeLimit)                  {                      nextCapacity = ResizeLimit;                  }                  else                  {                      // Example scenario: Let's say _count == 64.                      // Then our buffers look like this: | 8 | 8 | 16 | 32 |                      // As you can see' our count will be just double the last buffer.                      // Now' say _maxCapacity is 100. We will find the right amount to allocate by                      // doing min(64' 100 - 64). The lhs represents double the last buffer'                      // the rhs the limit minus the amount we've already allocated.                        Debug.Assert(_count >= ResizeLimit * 2);                      Debug.Assert(_count == _current.Length * 2);                        _buffers.Add(_current);                      nextCapacity = Math.Min(_count' _maxCapacity - _count);                  }                    _current = new T[nextCapacity];                  _index = 0;              }
Missing Default,System.Collections,BitArray,C:\selectedRepos\dotnet_corefx\src\System.Collections\src\System\Collections\BitArray.cs,BitArray,The following switch statement is missing a default case: switch (bytes.Length - j)              {                  case 3:                      m_array[i] = ((bytes[j + 2] & 0xff) << 16);                      goto case 2;                  // fall through                  case 2:                      m_array[i] |= ((bytes[j + 1] & 0xff) << 8);                      goto case 1;                  // fall through                  case 1:                      m_array[i] |= (bytes[j] & 0xff);                      break;              }
