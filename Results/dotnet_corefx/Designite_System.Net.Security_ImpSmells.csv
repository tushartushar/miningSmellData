Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,The method has 103 lines of code.
Long Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The method has 243 lines of code.
Long Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,GenerateToken,The method has 102 lines of code.
Long Method,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The method has 155 lines of code.
Complex Method,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Format,Cyclomatic complexity of the method is 8
Complex Method,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,Cyclomatic complexity of the method is 16
Complex Method,System.Net,StreamFramer,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\StreamFramer.cs,ReadMessage,Cyclomatic complexity of the method is 8
Complex Method,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,Cyclomatic complexity of the method is 9
Complex Method,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadSource,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Security,SslStreamInternal,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.Adapters.cs,ReadAsyncInternal,Cyclomatic complexity of the method is 13
Complex Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,EnsurePrivateKey,Cyclomatic complexity of the method is 14
Complex Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,Cyclomatic complexity of the method is 20
Complex Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireServerCredentials,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,VerifyRemoteCertificate,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,CreateFatalHandshakeAlertToken,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,GetAlertMessageFromChain,Cyclomatic complexity of the method is 8
Complex Method,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,LogCertificateValidation,Cyclomatic complexity of the method is 9
Complex Method,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,Cyclomatic complexity of the method is 13
Complex Method,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ValidateCreateContext,Cyclomatic complexity of the method is 10
Complex Method,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,Cyclomatic complexity of the method is 14
Complex Method,System.Security.Authentication.ExtendedProtection,ServiceNameCollection,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Security\Authentication\ExtendedProtection\ServiceNameCollection.cs,NormalizeServiceName,Cyclomatic complexity of the method is 11
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,SspiSelectedCipherSuite,The method has 8 parameters. Parameters: process' sslProtocol' cipherAlgorithm' cipherStrength' hashAlgorithm' hashStrength' keyExchangeAlgorithm' keyExchangeStrength
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The method has 9 parameters. Parameters: eventId' arg1' arg2' arg3' arg4' arg5' arg6' arg7' arg8
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Enter,The method has 5 parameters. Parameters: thisOrContextObject' arg0' arg1' arg2' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,DumpBuffer,The method has 5 parameters. Parameters: thisOrContextObject' buffer' offset' count' memberName
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The method has 5 parameters. Parameters: eventId' arg1' arg2' arg3' arg4
Long Parameter List,System.Net,BufferAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\BufferAsyncResult.cs,BufferAsyncResult,The method has 6 parameters. Parameters: asyncObject' buffer' offset' count' asyncState' asyncCallback
Long Parameter List,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,Encrypt,The method has 5 parameters. Parameters: buffer' offset' count' output' sequenceNumber
Long Parameter List,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,Decrypt,The method has 5 parameters. Parameters: payload' offset' count' newOffset' expectedSeqNumber
Long Parameter List,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,NTAuthentication,The method has 6 parameters. Parameters: isServer' package' credential' spn' requestedContextFlags' channelBinding
Long Parameter List,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,Initialize,The method has 6 parameters. Parameters: isServer' package' credential' spn' requestedContextFlags' channelBinding
Long Parameter List,System.Net,InitializeCallbackContext,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,InitializeCallbackContext,The method has 7 parameters. Parameters: thisPtr' isServer' package' credential' spn' requestedContextFlags' channelBinding
Long Parameter List,System.Net,WorkerAsyncResult,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\StreamFramer.cs,WorkerAsyncResult,The method has 6 parameters. Parameters: asyncObject' asyncState' savedAsyncCallback' buffer' offset' end
Long Parameter List,System.Net.Security,SslStreamInternal,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.Adapters.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.Net.Security,SslStreamInternal,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.Adapters.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.Net.Security,SslSessionsCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,CacheCredential,The method has 5 parameters. Parameters: creds' thumbPrint' sslProtocols' isServer' encryptionPolicy
Long Parameter List,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SslStream,The method has 5 parameters. Parameters: innerStream' leaveInnerStreamOpen' userCertificateValidationCallback' userCertificateSelectionCallback' encryptionPolicy
Long Parameter List,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsClient,The method has 5 parameters. Parameters: targetHost' clientCertificates' checkCertificateRevocation' asyncCallback' asyncState
Long Parameter List,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsClient,The method has 6 parameters. Parameters: targetHost' clientCertificates' enabledSslProtocols' checkCertificateRevocation' asyncCallback' asyncState
Long Parameter List,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsServer,The method has 5 parameters. Parameters: serverCertificate' clientCertificateRequired' checkCertificateRevocation' asyncCallback' asyncState
Long Parameter List,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsServer,The method has 6 parameters. Parameters: serverCertificate' clientCertificateRequired' enabledSslProtocols' checkCertificateRevocation' asyncCallback' asyncState
Long Parameter List,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsClient,The method has 5 parameters. Parameters: credential' binding' targetName' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsClient,The method has 6 parameters. Parameters: credential' targetName' requiredProtectionLevel' allowedImpersonationLevel' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsClient,The method has 7 parameters. Parameters: credential' binding' targetName' requiredProtectionLevel' allowedImpersonationLevel' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsServer,The method has 5 parameters. Parameters: credential' requiredProtectionLevel' requiredImpersonationLevel' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsServer,The method has 6 parameters. Parameters: credential' policy' requiredProtectionLevel' requiredImpersonationLevel' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClient,The method has 5 parameters. Parameters: credential' binding' targetName' requiredProtectionLevel' allowedImpersonationLevel
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClientAsync,The method has 5 parameters. Parameters: credential' binding' targetName' requiredProtectionLevel' allowedImpersonationLevel
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' asyncCallback' asyncState
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The method has 5 parameters. Parameters: readBytes' buffer' offset' count' asyncRequest
Long Parameter List,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,ProcessFrameBody,The method has 5 parameters. Parameters: readBytes' buffer' offset' count' asyncRequest
Long Parameter List,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ValidateCreateContext,The method has 6 parameters. Parameters: package' credential' servicePrincipalName' policy' protectionLevel' impersonationLevel
Long Parameter List,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ValidateCreateContext,The method has 7 parameters. Parameters: package' isServer' credential' servicePrincipalName' channelBinding' protectionLevel' impersonationLevel
Long Identifier,System.Net,SecurityProtocol,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\SecurityProtocol.cs,,The length of the parameter SystemDefaultSecurityProtocols is 30.
Long Identifier,System.Net.Security,SslAuthenticationOptions,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslAuthenticationOptions.cs,SslAuthenticationOptions,The length of the parameter sslClientAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslAuthenticationOptions,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslAuthenticationOptions.cs,SslAuthenticationOptions,The length of the parameter sslServerAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,,The length of the parameter _negotiatedApplicationProtocol is 30.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SslStream,The length of the parameter userCertificateValidationCallback is 33.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SslStream,The length of the parameter userCertificateValidationCallback is 33.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SslStream,The length of the parameter userCertificateSelectionCallback is 32.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SslStream,The length of the parameter userCertificateValidationCallback is 33.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SslStream,The length of the parameter userCertificateSelectionCallback is 32.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsClient,The length of the parameter sslClientAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsServer,The length of the parameter sslServerAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsClient,The length of the parameter sslClientAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsServer,The length of the parameter sslServerAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsClientAsync,The length of the parameter sslClientAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsServerAsync,The length of the parameter sslServerAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,,The length of the parameter _userCertificateValidationCallback is 34.
Long Identifier,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,,The length of the parameter _userCertificateSelectionCallback is 33.
Long Identifier,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,ValidateCreateContext,The length of the parameter sslClientAuthenticationOptions is 30.
Long Identifier,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,ValidateCreateContext,The length of the parameter sslServerAuthenticationOptions is 30.
Long Statement,System.Net,FixedSizeReader,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\FixedSizeReader.cs,ReadPacketAsync,The length of the statement  "                    int bytes = await transport.ReadAsync(request.Buffer' offset' remainingCount' CancellationToken.None).ConfigureAwait(false); " is 124.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Enter,The length of the statement  "            if (IsEnabled) Log.Enter(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 134.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Exit,The length of the statement  "            if (IsEnabled) Log.Exit(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Info,The length of the statement  "            if (IsEnabled) Log.Info(IdOf(thisOrContextObject)' memberName' formattableString != null ? Format(formattableString) : NoParameters); " is 133.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,DumpBuffer,The length of the statement  "                    Fail(thisOrContextObject' $"Invalid {nameof(DumpBuffer)} Args. Length={buffer.Length}' Offset={offset}' Count={count}"' memberName); " is 132.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is ValueType)' $"Should not be passing value type {arg?.GetType()} to logging without IsEnabled check"); " is 123.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,DebugValidateArg,The length of the statement  "                Debug.Assert(!(arg is FormattableString)' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 124.
Long Statement,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,DebugValidateArg,The length of the statement  "            Debug.Assert(IsEnabled || arg == null' $"Should not be formatting FormattableString \"{arg}\" if tracing isn't enabled"); " is 121.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,InitializeCallback,The length of the statement  "            context.ThisPtr.Initialize(context.IsServer' context.Package' context.Credential' context.Spn' context.RequestedContextFlags' context.ChannelBinding); " is 150.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,Decrypt,The length of the statement  "            return NegotiateStreamPal.Decrypt(_securityContext' payload' offset' count' IsConfidentialityFlag' IsNTLM' out newOffset' expectedSeqNumber); " is 141.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,The length of the statement  "                    if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"SSPIWrapper.InitializeSecurityContext() returns statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 169.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,The length of the statement  "                        if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"SSPIWrapper.CompleteAuthToken() returns statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 161.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,The length of the statement  "                    if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"SSPIWrapper.AcceptSecurityContext() returns statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 165.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Exit(this' $"null statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode})"); " is 126.
Long Statement,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"need continue statusCode:0x{((int)statusCode.ErrorCode):x8} ({statusCode}) _securityContext:{_securityContext}"); " is 171.
Long Statement,System.Net,StreamFramer,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\StreamFramer.cs,ReadFrameComplete,The length of the statement  "                transportResult = TaskToApm.Begin(_transport.ReadAsync(workerResult.Buffer' workerResult.Offset' workerResult.End - workerResult.Offset)' " is 137.
Long Statement,System.Net,StreamFramer,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\StreamFramer.cs,EndReadMessage,The length of the statement  "                throw new ArgumentException(SR.Format(SR.net_io_async_result' typeof(WorkerAsyncResult).FullName)' nameof(asyncResult)); " is 120.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread changed from User to System; user's thread shouldn't be hijacked."); " is 133.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread changed from Async to Sync' may block an Async thread."); " is 122.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadKind,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "Thread from a limited resource changed to Sync' may deadlock or bottleneck."); " is 136.
Long Statement,System.Net,DebugThreadTracking,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\Logging\DebugThreadTracking.cs,SetThreadSource,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Error(null' "SetThreadSource must be called at the base of the stack' or the stack has been corrupted."); " is 150.
Long Statement,System.Net.Security,SslStreamInternal,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStreamInternal.Adapters.cs,FillBufferAsync,The length of the statement  "                ValueTask<int> t = adapter.ReadAsync(_internalBuffer' _internalBufferCount' _internalBuffer.Length - _internalBufferCount); " is 123.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "            X509Certificate clientCertificate = null;        // This is a candidate that can come from the user callback or be guessed when targeting a session restart. " is 156.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "            var filteredCerts = new List<X509Certificate>(); // This is an intermediate client certs collection that try to use if no selectedCert is available yet. " is 152.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "            string[] issuers = null;                         // This is a list of issuers sent by the server' only valid is we do know what the server cert is. " is 147.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "                    clientCertificate = _sslAuthenticationOptions.CertSelectionDelegate(_sslAuthenticationOptions.TargetHost' _sslAuthenticationOptions.ClientCertificates' remoteCert' issuers); " is 173.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "            else if (_credentialsHandle == null && _sslAuthenticationOptions.ClientCertificates != null && _sslAuthenticationOptions.ClientCertificates.Count > 0) " is 150.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "            else if (_sslAuthenticationOptions.ClientCertificates != null && _sslAuthenticationOptions.ClientCertificates.Count > 0) " is 120.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "            X509Certificate2 selectedCert = null;      // This is a final selected cert (ensured that it does have private key with it). " is 124.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "                // SECURITY: selectedCert ref if not null is a safe object that does not depend on possible **user** inherited X509Certificate type. " is 132.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "                SafeFreeCredentials cachedCredentialHandle = SslSessionsCache.TryCachedCredential(guessedThumbPrint' _sslAuthenticationOptions.EnabledSslProtocols' _sslAuthenticationOptions.IsServer' _sslAuthenticationOptions.EncryptionPolicy); " is 228.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "                    // So we don't want to reuse **anonymous** cached credential for a new SSL connection if the client has passed some certificate. " is 128.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The length of the statement  "                    _credentialsHandle = SslStreamPal.AcquireCredentialsHandle(selectedCert' _sslAuthenticationOptions.EnabledSslProtocols' _sslAuthenticationOptions.EncryptionPolicy' _sslAuthenticationOptions.IsServer); " is 200.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireServerCredentials,The length of the statement  "                localCertificate = _sslAuthenticationOptions.CertSelectionDelegate(string.Empty' tempCollection' null' Array.Empty<string>()); " is 126.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireServerCredentials,The length of the statement  "                SafeFreeCredentials cachedCredentialHandle = SslSessionsCache.TryCachedCredential(guessedThumbPrint' _sslAuthenticationOptions.EnabledSslProtocols' _sslAuthenticationOptions.IsServer' _sslAuthenticationOptions.EncryptionPolicy); " is 228.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireServerCredentials,The length of the statement  "                    _credentialsHandle = SslStreamPal.AcquireCredentialsHandle(selectedCert' _sslAuthenticationOptions.EnabledSslProtocols' _sslAuthenticationOptions.EncryptionPolicy' _sslAuthenticationOptions.IsServer); " is 200.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,GenerateToken,The length of the statement  "                    if (!cachedCreds && _securityContext != null && !_securityContext.IsInvalid && _credentialsHandle != null && !_credentialsHandle.IsInvalid) " is 139.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,GenerateToken,The length of the statement  "                        SslSessionsCache.CacheCredential(_credentialsHandle' thumbPrint' _sslAuthenticationOptions.EnabledSslProtocols' _sslAuthenticationOptions.IsServer' _sslAuthenticationOptions.EncryptionPolicy); " is 192.
Long Statement,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,VerifyRemoteCertificate,The length of the statement  "                    success = remoteCertValidationCallback(_sslAuthenticationOptions.TargetHost' remoteCertificateEx' chain' sslPolicyErrors); " is 122.
Long Statement,System.Net.Security,SslSessionsCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,TryCachedCredential,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(null' $"Not found or invalid' Current Cache Coun = {s_cachedCreds.Count}"); " is 125.
Long Statement,System.Net.Security,SslSessionsCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,CacheCredential,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(null' $"Refused to cache an Invalid Handle {creds}' Current Cache Count = {s_cachedCreds.Count}"); " is 148.
Long Statement,System.Net.Security,SslSessionsCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,CacheCredential,The length of the statement  "                        if (NetEventSource.IsEnabled) NetEventSource.Info(null' $"Caching New Handle = {creds}' Current Cache Count = {s_cachedCreds.Count}"); " is 134.
Long Statement,System.Net.Security,SslSessionsCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,CacheCredential,The length of the statement  "                        if (NetEventSource.IsEnabled) NetEventSource.Info(null' $"CacheCredential() (locked retry) Found already cached Handle = {cached.Target}"); " is 139.
Long Statement,System.Net.Security,SslSessionsCache,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,CacheCredential,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(null' $"CacheCredential() Ignoring incoming handle = {creds} since found already cached Handle = {cached.Target}"); " is 165.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SetAndVerifyValidationCallback,The length of the statement  "                throw new InvalidOperationException(SR.Format(SR.net_conflicting_options' nameof(RemoteCertificateValidationCallback))); " is 120.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,SetAndVerifySelectionCallback,The length of the statement  "                _certSelectionDelegate = _userCertificateSelectionCallback == null ? null : new LocalCertSelectionCallback(UserCertSelectionCallbackWrapper); " is 141.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsClient,The length of the statement  "            return BeginAuthenticateAsClient(targetHost' clientCertificates' SecurityProtocol.SystemDefaultSecurityProtocols' checkCertificateRevocation' asyncCallback' asyncState); " is 169.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,BeginAuthenticateAsServer,The length of the statement  "            return BeginAuthenticateAsServer(serverCertificate' clientCertificateRequired' SecurityProtocol.SystemDefaultSecurityProtocols' checkCertificateRevocation' asyncCallback' asyncState); " is 183.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsClient,The length of the statement  "            AuthenticateAsClient(targetHost' clientCertificates' SecurityProtocol.SystemDefaultSecurityProtocols' checkCertificateRevocation); " is 130.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsServer,The length of the statement  "            AuthenticateAsServer(serverCertificate' clientCertificateRequired' SecurityProtocol.SystemDefaultSecurityProtocols' checkCertificateRevocation); " is 144.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsClientAsync,The length of the statement  "            var beginMethod = checkCertificateRevocation ? (Func<string' X509CertificateCollection' SslProtocols' AsyncCallback' object' IAsyncResult>) " is 139.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsClientAsync,The length of the statement  "                ((arg1' arg2' arg3' callback' state) => ((SslStream)state).BeginAuthenticateAsClient(arg1' arg2' arg3' true' callback' state)) : " is 128.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsClientAsync,The length of the statement  "                ((arg1' arg2' arg3' callback' state) => ((SslStream)state).BeginAuthenticateAsClient(arg1' arg2' arg3' false' callback' state)); " is 128.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsServerAsync,The length of the statement  "            var beginMethod = checkCertificateRevocation ? (Func<X509Certificate' bool' SslProtocols' AsyncCallback' object' IAsyncResult>) " is 127.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsServerAsync,The length of the statement  "                ((arg1' arg2' arg3' callback' state) => ((SslStream)state).BeginAuthenticateAsServer(arg1' arg2' arg3' true' callback' state)) : " is 128.
Long Statement,System.Net.Security,SslStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslStream.cs,AuthenticateAsServerAsync,The length of the statement  "                ((arg1' arg2' arg3' callback' state) => ((SslStream)state).BeginAuthenticateAsServer(arg1' arg2' arg3' false' callback' state)); " is 128.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,ValidateCreateContext,The length of the statement  "                sslClientAuthenticationOptions.TargetHost = "?" + Interlocked.Increment(ref s_uniqueNameInteger).ToString(NumberFormatInfo.InvariantInfo); " is 138.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,EnqueueOldKeyDecryptedData,The length of the statement  "                    return new IOException(SR.Format(SR.net_auth_ignored_reauth' MaxQueuedReadBytes.ToString(NumberFormatInfo.CurrentInfo))); " is 121.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,ProcessAuthentication,The length of the statement  "                throw new InvalidOperationException(SR.Format(SR.net_io_invalidnestedcall' lazyResult == null ? "BeginAuthenticate" : "Authenticate"' "authenticate")); " is 151.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,ReplyOnReAuthentication,The length of the statement  "            AsyncProtocolRequest asyncRequest = new AsyncProtocolRequest(new LazyAsyncResult(this' null' new AsyncCallback(RehandshakeCompleteCallback))); " is 142.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,CheckCompletionBeforeNextReceive,The length of the statement  "                StartSendAuthResetSignal(null' asyncRequest' ExceptionDispatchInfo.Capture(new AuthenticationException(SR.net_auth_SSPI' message.GetException()))); " is 147.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,CheckCompletionBeforeNextReceive,The length of the statement  "                    StartSendAuthResetSignal(alertToken' asyncRequest' ExceptionDispatchInfo.Capture(new AuthenticationException(SR.net_ssl_io_cert_validation' null))); " is 148.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,ProcessReceivedBlob,The length of the statement  "                    StartSendAuthResetSignal(null' asyncRequest' ExceptionDispatchInfo.Capture(new AuthenticationException(SR.net_auth_SSPI' message.GetException()))); " is 147.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,CheckEnqueueReadAsync,The length of the statement  "                TaskCompletionSource<int> taskCompletionSource = new TaskCompletionSource<int>(buffer' TaskCreationOptions.RunContinuationsAsynchronously); " is 139.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,CheckEnqueueWriteAsync,The length of the statement  "                TaskCompletionSource<int> completionSource = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously); " is 127.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The length of the statement  "                    if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"WARNING: SslState::DetectFraming() SSL protocol is > 3' trying SSL3 framing in retail = {bytes[i]:x}"); " is 161.
Long Statement,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The length of the statement  "                if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"WARNING: SslState::DetectFraming() SSL v <=2 HELLO has no high bit set for 3 bytes header' we are broken' received byte = {bytes[0]:x}"); " is 195.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsClient,The length of the statement  "                _negoState.ValidateCreateContext(_package' false' credential' targetName' binding' requiredProtectionLevel' allowedImpersonationLevel); " is 135.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsServer,The length of the statement  "            AuthenticateAsServer((NetworkCredential)CredentialCache.DefaultCredentials' null' ProtectionLevel.EncryptAndSign' TokenImpersonationLevel.Identification); " is 154.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsServer,The length of the statement  "            AuthenticateAsServer((NetworkCredential)CredentialCache.DefaultCredentials' policy' ProtectionLevel.EncryptAndSign' TokenImpersonationLevel.Identification); " is 156.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsServer,The length of the statement  "                _negoState.ValidateCreateContext(_package' credential' string.Empty' policy' requiredProtectionLevel' requiredImpersonationLevel); " is 130.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsServer,The length of the statement  "            return BeginAuthenticateAsServer((NetworkCredential)CredentialCache.DefaultCredentials' null' ProtectionLevel.EncryptAndSign' TokenImpersonationLevel.Identification' asyncCallback' asyncState); " is 193.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsServer,The length of the statement  "            return BeginAuthenticateAsServer((NetworkCredential)CredentialCache.DefaultCredentials' policy' ProtectionLevel.EncryptAndSign' TokenImpersonationLevel.Identification' asyncCallback' asyncState); " is 195.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsServer,The length of the statement  "            return BeginAuthenticateAsServer(credential' null' requiredProtectionLevel' requiredImpersonationLevel' asyncCallback' asyncState); " is 131.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,BeginAuthenticateAsServer,The length of the statement  "                _negoState.ValidateCreateContext(_package' credential' string.Empty' policy' requiredProtectionLevel' requiredImpersonationLevel); " is 130.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClient,The length of the statement  "            AuthenticateAsClient((NetworkCredential)CredentialCache.DefaultCredentials' null' string.Empty' ProtectionLevel.EncryptAndSign' TokenImpersonationLevel.Identification); " is 168.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClient,The length of the statement  "            AuthenticateAsClient(credential' null' targetName' ProtectionLevel.EncryptAndSign' TokenImpersonationLevel.Identification); " is 123.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClient,The length of the statement  "            AuthenticateAsClient(credential' binding' targetName' ProtectionLevel.EncryptAndSign' TokenImpersonationLevel.Identification); " is 126.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClient,The length of the statement  "                _negoState.ValidateCreateContext(_package' false' credential' targetName' binding' requiredProtectionLevel' allowedImpersonationLevel); " is 135.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClientAsync,The length of the statement  "            return Task.Factory.FromAsync((callback' state) => BeginAuthenticateAsClient(credential' targetName' requiredProtectionLevel' allowedImpersonationLevel' callback' state)' EndAuthenticateAsClient' null); " is 202.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClientAsync,The length of the statement  "            return Task.Factory.FromAsync(BeginAuthenticateAsClient' EndAuthenticateAsClient' credential' binding' targetName' null); " is 121.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsClientAsync,The length of the statement  "            return Task.Factory.FromAsync((callback' state) => BeginAuthenticateAsClient(credential' binding' targetName' requiredProtectionLevel' allowedImpersonationLevel' callback' state)' EndAuthenticateAsClient' null); " is 211.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsServerAsync,The length of the statement  "            return Task.Factory.FromAsync(BeginAuthenticateAsServer' EndAuthenticateAsServer' credential' requiredProtectionLevel' requiredImpersonationLevel' null); " is 153.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,AuthenticateAsServerAsync,The length of the statement  "            return Task.Factory.FromAsync((callback' state) => BeginAuthenticateAsServer(credential' policy' requiredProtectionLevel' requiredImpersonationLevel' callback' state)' EndAuthenticateAsClient' null); " is 199.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,ProcessWrite,The length of the statement  "                throw new NotSupportedException(SR.Format(SR.net_io_invalidnestedcall' (asyncRequest != null ? "BeginWrite" : "Write")' "write")); " is 130.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,ProcessRead,The length of the statement  "                throw new NotSupportedException(SR.Format(SR.net_io_invalidnestedcall' (asyncRequest != null ? "BeginRead" : "Read")' "read")); " is 127.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The length of the statement  "            // A user buffer can be shared by many threads in that case decryption/integrity check may fail cause of data corruption. " is 121.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,ReadCallback,The length of the statement  "                    negoStream.StartFrameBody(asyncRequest.Result' bufferResult.Buffer' bufferResult.Offset' bufferResult.Count' asyncRequest); " is 123.
Long Statement,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,ReadCallback,The length of the statement  "                    if (-1 == negoStream.ProcessFrameBody(asyncRequest.Result' bufferResult.Buffer' bufferResult.Offset' bufferResult.Count' asyncRequest)) " is 135.
Long Statement,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ValidateCreateContext,The length of the statement  "            ValidateCreateContext(package' true' credential' servicePrincipalName' _extendedProtectionPolicy.CustomChannelBinding' protectionLevel' impersonationLevel); " is 156.
Long Statement,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ProcessAuthentication,The length of the statement  "                throw new InvalidOperationException(SR.Format(SR.net_io_invalidnestedcall' lazyResult == null ? "BeginAuthenticate" : "Authenticate"' "authenticate")); " is 151.
Long Statement,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The length of the statement  "                    exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' _expectedImpersonationLevel.ToString()' PrivateImpersonationLevel.ToString())); " is 162.
Long Statement,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The length of the statement  "                ProtectionLevel result = _context.IsConfidentialityFlag ? ProtectionLevel.EncryptAndSign : _context.IsIntegrityFlag ? ProtectionLevel.Sign : ProtectionLevel.None; " is 162.
Long Statement,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The length of the statement  "                    exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' result.ToString()' _expectedProtectionLevel.ToString())); " is 140.
Long Statement,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ProcessReceivedBlob,The length of the statement  "                throw new AuthenticationException(SR.Format(SR.net_io_header_id' "MessageId"' _framer.ReadHeader.MessageId' FrameHeader.HandshakeId)' null); " is 140.
Long Statement,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,CheckCompletionBeforeNextSend,The length of the statement  "                    throw new AuthenticationException(SR.Format(SR.net_io_header_id' "MessageId"' _framer.ReadHeader.MessageId' FrameHeader.HandshakeDoneId)' null); " is 144.
Long Statement,System.Threading.Tasks,TaskToApm,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Threading\Tasks\TaskToApm.cs,Begin,The length of the statement  "                asyncResult = task.AsyncState == state ? (IAsyncResult)task : new TaskWrapperAsyncResult(task' state' completedSynchronously: false); " is 133.
Complex Conditional,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,AcquireClientCredentials,The conditional expression  "sessionRestartAttempt &&                      cachedCredentialHandle == null &&                      selectedCert != null &&                      SslStreamPal.StartMutualAuthAsAnonymous"  is complex.
Complex Conditional,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,GenerateToken,The conditional expression  "!cachedCreds && _securityContext != null && !_securityContext.IsInvalid && _credentialsHandle != null && !_credentialsHandle.IsInvalid"  is complex.
Virtual Method Call from Constructor,System.Security.Authentication.ExtendedProtection,ServiceNameCollection,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Security\Authentication\ExtendedProtection\ServiceNameCollection.cs,ServiceNameCollection,The constructor "ServiceNameCollection" calls a virtual method "Add".
Empty Catch Block,System.Net,LazyAsyncResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\LazyAsyncResult.cs,ProtectedInvokeCallback,The method has an empty catch block.
Empty Catch Block,System.Net,LazyAsyncResult,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\LazyAsyncResult.cs,WaitForCompletion,The method has an empty catch block.
Empty Catch Block,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,EnsurePrivateKey,The method has an empty catch block.
Empty Catch Block,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,MakeEx,The method has an empty catch block.
Empty Catch Block,System.Net.Security,SecureChannel,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SecureChannel.cs,MakeEx,The method has an empty catch block.
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 8;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        descrs[4].DataPointer = (IntPtr)(&arg5);                      descrs[4].Size = sizeof(int);                        descrs[5].DataPointer = (IntPtr)(&arg6);                      descrs[5].Size = sizeof(int);                        descrs[6].DataPointer = (IntPtr)(&arg7);                      descrs[6].Size = sizeof(int);                        descrs[7].DataPointer = (IntPtr)(&arg8);                      descrs[7].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,Format,The following statement contains a magic number: switch (s.ArgumentCount)              {                  case 0: return s.Format;                  case 1: return string.Format(s.Format' Format(s.GetArgument(0)));                  case 2: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1)));                  case 3: return string.Format(s.Format' Format(s.GetArgument(0))' Format(s.GetArgument(1))' Format(s.GetArgument(2)));                  default:                      object[] args = s.GetArguments();                      object[] formattedArgs = new object[args.Length];                      for (int i = 0; i < args.Length; i++)                      {                          formattedArgs[i] = Format(args[i]);                      }                      return string.Format(s.Format' formattedArgs);              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  if (arg4 == null) arg4 = "";                    fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  fixed (char* string4Bytes = arg4)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                        descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                        descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                        descrs[3].DataPointer = (IntPtr)string4Bytes;                      descrs[3].Size = ((arg4.Length + 1) * 2);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = Array.Empty<byte>();                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (byte* arg3Ptr = arg3)                  {                      int bufferLength = arg3.Length;                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)arg1Ptr;                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)arg2Ptr;                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&bufferLength);                      descrs[2].Size = 4;                        descrs[3].DataPointer = (IntPtr)arg3Ptr;                      descrs[3].Size = bufferLength;                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                    fixed (char* arg1Ptr = arg1)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = sizeof(int);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  {                      const int NumEventDatas = 3;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NetEventSource,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Logging\NetEventSource.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled())              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                    fixed (char* arg1Ptr = arg1)                  fixed (char* arg2Ptr = arg2)                  fixed (char* arg3Ptr = arg3)                  {                      const int NumEventDatas = 4;                      var descrs = stackalloc EventData[NumEventDatas];                        descrs[0].DataPointer = (IntPtr)(arg1Ptr);                      descrs[0].Size = (arg1.Length + 1) * sizeof(char);                        descrs[1].DataPointer = (IntPtr)(arg2Ptr);                      descrs[1].Size = (arg2.Length + 1) * sizeof(char);                        descrs[2].DataPointer = (IntPtr)(arg3Ptr);                      descrs[2].Size = (arg3.Length + 1) * sizeof(char);                        descrs[3].DataPointer = (IntPtr)(&arg4);                      descrs[3].Size = sizeof(int);                        WriteEventCore(eventId' NumEventDatas' descrs);                  }              }
Magic Number,System.Net,NTAuthentication,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\NTAuthentication.cs,GetOutgoingBlob,The following statement contains a magic number: var list = new List<SecurityBuffer>(2);
Magic Number,System.Net,FrameHeader,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\StreamFramer.cs,CopyTo,The following statement contains a magic number: dest[start++] = (byte)((_PayloadSize >> 8) & 0xFF);
Magic Number,System.Net,FrameHeader,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\StreamFramer.cs,CopyFrom,The following statement contains a magic number: _PayloadSize = (int)((bytes[start++] << 8) | bytes[start]);
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,SslApplicationProtocol,The following statement contains a magic number: if (protocol.Length == 0 || protocol.Length > 255)              {                  throw new ArgumentException(SR.net_ssl_app_protocol_invalid' nameof(protocol));              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,GetHashCode,The following statement contains a magic number: for (int i = 0; i < _readOnlyProtocol.Length; i++)              {                  hash1 = ((hash1 << 5) + hash1) ^ pSpan[i];              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslApplicationProtocol,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslApplicationProtocol.cs,ToString,The following statement contains a magic number: try              {                  if (_readOnlyProtocol.Length == 0)                  {                      return null;                  }                    return s_utf8.GetString(_readOnlyProtocol.Span);              }              catch              {                  // In case of decoding errors' return the byte values as hex string.                  int byteCharsLength = _readOnlyProtocol.Length * 5;                  char[] byteChars = new char[byteCharsLength];                  int index = 0;                    ReadOnlySpan<byte> pSpan = _readOnlyProtocol.Span;                  for (int i = 0; i < byteCharsLength; i += 5)                  {                      byte b = pSpan[index++];                      byteChars[i] = '0';                      byteChars[i + 1] = 'x';                      byteChars[i + 2] = GetHexValue(Math.DivRem(b' 16' out int rem));                      byteChars[i + 3] = GetHexValue(rem);                      byteChars[i + 4] = ' ';                  }                    return new string(byteChars' 0' byteCharsLength - 1);                    char GetHexValue(int i)                  {                      if (i < 10)                          return (char)(i + '0');                        return (char)(i - 10 + 'a');                  }              }
Magic Number,System.Net.Security,SslCredKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,GetHashCode,The following statement contains a magic number: if (_thumbPrint.Length > 0)                  {                      hashCode ^= _thumbPrint[0];                      if (1 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[1] << 8);                      }                        if (2 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[2] << 16);                      }                        if (3 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[3] << 24);                      }                  }
Magic Number,System.Net.Security,SslCredKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,GetHashCode,The following statement contains a magic number: if (_thumbPrint.Length > 0)                  {                      hashCode ^= _thumbPrint[0];                      if (1 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[1] << 8);                      }                        if (2 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[2] << 16);                      }                        if (3 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[3] << 24);                      }                  }
Magic Number,System.Net.Security,SslCredKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,GetHashCode,The following statement contains a magic number: if (_thumbPrint.Length > 0)                  {                      hashCode ^= _thumbPrint[0];                      if (1 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[1] << 8);                      }                        if (2 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[2] << 16);                      }                        if (3 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[3] << 24);                      }                  }
Magic Number,System.Net.Security,SslCredKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,GetHashCode,The following statement contains a magic number: if (_thumbPrint.Length > 0)                  {                      hashCode ^= _thumbPrint[0];                      if (1 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[1] << 8);                      }                        if (2 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[2] << 16);                      }                        if (3 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[3] << 24);                      }                  }
Magic Number,System.Net.Security,SslCredKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,GetHashCode,The following statement contains a magic number: if (_thumbPrint.Length > 0)                  {                      hashCode ^= _thumbPrint[0];                      if (1 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[1] << 8);                      }                        if (2 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[2] << 16);                      }                        if (3 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[3] << 24);                      }                  }
Magic Number,System.Net.Security,SslCredKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,GetHashCode,The following statement contains a magic number: if (_thumbPrint.Length > 0)                  {                      hashCode ^= _thumbPrint[0];                      if (1 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[1] << 8);                      }                        if (2 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[2] << 16);                      }                        if (3 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[3] << 24);                      }                  }
Magic Number,System.Net.Security,SslCredKey,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslSessionsCache.cs,GetHashCode,The following statement contains a magic number: if (_thumbPrint.Length > 0)                  {                      hashCode ^= _thumbPrint[0];                      if (1 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[1] << 8);                      }                        if (2 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[2] << 16);                      }                        if (3 < _thumbPrint.Length)                      {                          hashCode ^= (_thumbPrint[3] << 24);                      }                  }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,StartSendBlob,The following statement contains a magic number: if (message.Size != 0)              {                  if (Context.IsServer && _CachedSession == CachedSessionStatus.Unknown)                  {                      //                      //[Schannel] If the first call to ASC returns a token less than 200 bytes'                      //           then it's a reconnect (a handshake based on a cache entry).                      //                      _CachedSession = message.Size < 200 ? CachedSessionStatus.IsCached : CachedSessionStatus.IsNotCached;                  }                    if (_Framing == Framing.Unified)                  {                      _Framing = DetectFraming(message.Payload' message.Payload.Length);                  }                    if (asyncRequest == null)                  {                      InnerStream.Write(message.Payload' 0' message.Size);                  }                  else                  {                      asyncRequest.AsyncState = message;                      Task t = InnerStream.WriteAsync(message.Payload' 0' message.Size);                      if (t.IsCompleted)                      {                          t.GetAwaiter().GetResult();                      }                      else                      {                          IAsyncResult ar = TaskToApm.Begin(t' s_writeCallback' asyncRequest);                          if (!ar.CompletedSynchronously)                          {  #if DEBUG                              asyncRequest._DebugAsyncChain = ar;  #endif                              return;                          }                          TaskToApm.End(ar);                      }                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[0] == (byte)FrameType.Handshake || bytes[0] == (byte)FrameType.AppData                  || bytes[0] == (byte)FrameType.Alert)              {                  if (length < 3)                  {                      return Framing.Invalid;                  }    #if TRACE_VERBOSE                  if (bytes[1] != 3 && NetEventSource.IsEnabled)                  {                      if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"WARNING: SslState::DetectFraming() SSL protocol is > 3' trying SSL3 framing in retail = {bytes[i]:x}");                  }  #endif                    version = (bytes[1] << 8) | bytes[2];                  if (version < 0x300 || version >= 0x500)                  {                      return Framing.Invalid;                  }                    //                  // This is an SSL3 Framing                  //                  return Framing.SinceSSL3;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[0] == (byte)FrameType.Handshake || bytes[0] == (byte)FrameType.AppData                  || bytes[0] == (byte)FrameType.Alert)              {                  if (length < 3)                  {                      return Framing.Invalid;                  }    #if TRACE_VERBOSE                  if (bytes[1] != 3 && NetEventSource.IsEnabled)                  {                      if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"WARNING: SslState::DetectFraming() SSL protocol is > 3' trying SSL3 framing in retail = {bytes[i]:x}");                  }  #endif                    version = (bytes[1] << 8) | bytes[2];                  if (version < 0x300 || version >= 0x500)                  {                      return Framing.Invalid;                  }                    //                  // This is an SSL3 Framing                  //                  return Framing.SinceSSL3;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[0] == (byte)FrameType.Handshake || bytes[0] == (byte)FrameType.AppData                  || bytes[0] == (byte)FrameType.Alert)              {                  if (length < 3)                  {                      return Framing.Invalid;                  }    #if TRACE_VERBOSE                  if (bytes[1] != 3 && NetEventSource.IsEnabled)                  {                      if (NetEventSource.IsEnabled) NetEventSource.Info(this' $"WARNING: SslState::DetectFraming() SSL protocol is > 3' trying SSL3 framing in retail = {bytes[i]:x}");                  }  #endif                    version = (bytes[1] << 8) | bytes[2];                  if (version < 0x300 || version >= 0x500)                  {                      return Framing.Invalid;                  }                    //                  // This is an SSL3 Framing                  //                  return Framing.SinceSSL3;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (length < 3)              {                  return Framing.Invalid;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] > 8)              {                  return Framing.Invalid;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] > 8)              {                  return Framing.Invalid;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,DetectFraming,The following statement contains a magic number: if (bytes[2] == 0x1)  // SSL_MT_CLIENT_HELLO              {                  if (length >= 5)                  {                      version = (bytes[3] << 8) | bytes[4];                  }              }              else if (bytes[2] == 0x4) // SSL_MT_SERVER_HELLO              {                  if (length >= 7)                  {                      version = (bytes[5] << 8) | bytes[6];                  }              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,SslState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\SslState.cs,GetRemainingFrameSize,The following statement contains a magic number: switch (_Framing)              {                  case Framing.Unified:                  case Framing.BeforeSSL3:                      if (dataSize < 2)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                      // Note: Cannot detect version mismatch for <= SSL2                        if ((buffer[offset] & 0x80) != 0)                      {                          // Two bytes                          payloadSize = (((buffer[offset] & 0x7f) << 8) | buffer[offset + 1]) + 2;                          payloadSize -= dataSize;                      }                      else                      {                          // Three bytes                          payloadSize = (((buffer[offset] & 0x3f) << 8) | buffer[offset + 1]) + 3;                          payloadSize -= dataSize;                      }                        break;                  case Framing.SinceSSL3:                      if (dataSize < 5)                      {                          throw new System.IO.IOException(SR.net_ssl_io_frame);                      }                        payloadSize = ((buffer[offset + 3] << 8) | buffer[offset + 4]) + 5;                      payloadSize -= dataSize;                      break;                  default:                      break;              }
Magic Number,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,InitializeStreamPart,The following statement contains a magic number: _ReadHeader = new byte[4];
Magic Number,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The following statement contains a magic number: readBytes = _ReadHeader[3];
Magic Number,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The following statement contains a magic number: readBytes = (readBytes << 8) | _ReadHeader[2];
Magic Number,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The following statement contains a magic number: readBytes = (readBytes << 8) | _ReadHeader[2];
Magic Number,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The following statement contains a magic number: readBytes = (readBytes << 8) | _ReadHeader[1];
Magic Number,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The following statement contains a magic number: readBytes = (readBytes << 8) | _ReadHeader[0];
Magic Number,System.Net.Security,NegotiateStream,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegotiateStream.cs,StartFrameBody,The following statement contains a magic number: if (readBytes <= 4 || readBytes > NegoState.MaxReadFrameSize)              {                  throw new IOException(SR.net_frame_read_size);              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The following statement contains a magic number: if (HandshakeComplete)              {                  if (_context.IsServer && !CheckSpn())                  {                      exception = new AuthenticationException(SR.net_auth_bad_client_creds_or_target_mismatch);                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    if (PrivateImpersonationLevel < _expectedImpersonationLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' _expectedImpersonationLevel.ToString()' PrivateImpersonationLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    ProtectionLevel result = _context.IsConfidentialityFlag ? ProtectionLevel.EncryptAndSign : _context.IsIntegrityFlag ? ProtectionLevel.Sign : ProtectionLevel.None;                    if (result < _expectedProtectionLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' result.ToString()' _expectedProtectionLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    // Signal remote party that we are done                  _framer.WriteHeader.MessageId = FrameHeader.HandshakeDoneId;                  if (_context.IsServer)                  {                      // Server may complete now because client SSPI would not complain at this point.                      _remoteOk = true;                        // However the client will wait for server to send this ACK                      //Force signaling server OK to the client                      if (message == null)                      {                          message = s_emptyMessage;                      }                  }              }              else if (message == null || message == s_emptyMessage)              {                  throw new InternalException();              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The following statement contains a magic number: if (HandshakeComplete)              {                  if (_context.IsServer && !CheckSpn())                  {                      exception = new AuthenticationException(SR.net_auth_bad_client_creds_or_target_mismatch);                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    if (PrivateImpersonationLevel < _expectedImpersonationLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' _expectedImpersonationLevel.ToString()' PrivateImpersonationLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    ProtectionLevel result = _context.IsConfidentialityFlag ? ProtectionLevel.EncryptAndSign : _context.IsIntegrityFlag ? ProtectionLevel.Sign : ProtectionLevel.None;                    if (result < _expectedProtectionLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' result.ToString()' _expectedProtectionLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    // Signal remote party that we are done                  _framer.WriteHeader.MessageId = FrameHeader.HandshakeDoneId;                  if (_context.IsServer)                  {                      // Server may complete now because client SSPI would not complain at this point.                      _remoteOk = true;                        // However the client will wait for server to send this ACK                      //Force signaling server OK to the client                      if (message == null)                      {                          message = s_emptyMessage;                      }                  }              }              else if (message == null || message == s_emptyMessage)              {                  throw new InternalException();              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The following statement contains a magic number: if (HandshakeComplete)              {                  if (_context.IsServer && !CheckSpn())                  {                      exception = new AuthenticationException(SR.net_auth_bad_client_creds_or_target_mismatch);                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    if (PrivateImpersonationLevel < _expectedImpersonationLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' _expectedImpersonationLevel.ToString()' PrivateImpersonationLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    ProtectionLevel result = _context.IsConfidentialityFlag ? ProtectionLevel.EncryptAndSign : _context.IsIntegrityFlag ? ProtectionLevel.Sign : ProtectionLevel.None;                    if (result < _expectedProtectionLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' result.ToString()' _expectedProtectionLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    // Signal remote party that we are done                  _framer.WriteHeader.MessageId = FrameHeader.HandshakeDoneId;                  if (_context.IsServer)                  {                      // Server may complete now because client SSPI would not complain at this point.                      _remoteOk = true;                        // However the client will wait for server to send this ACK                      //Force signaling server OK to the client                      if (message == null)                      {                          message = s_emptyMessage;                      }                  }              }              else if (message == null || message == s_emptyMessage)              {                  throw new InternalException();              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The following statement contains a magic number: if (HandshakeComplete)              {                  if (_context.IsServer && !CheckSpn())                  {                      exception = new AuthenticationException(SR.net_auth_bad_client_creds_or_target_mismatch);                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    if (PrivateImpersonationLevel < _expectedImpersonationLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' _expectedImpersonationLevel.ToString()' PrivateImpersonationLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    ProtectionLevel result = _context.IsConfidentialityFlag ? ProtectionLevel.EncryptAndSign : _context.IsIntegrityFlag ? ProtectionLevel.Sign : ProtectionLevel.None;                    if (result < _expectedProtectionLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' result.ToString()' _expectedProtectionLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    // Signal remote party that we are done                  _framer.WriteHeader.MessageId = FrameHeader.HandshakeDoneId;                  if (_context.IsServer)                  {                      // Server may complete now because client SSPI would not complain at this point.                      _remoteOk = true;                        // However the client will wait for server to send this ACK                      //Force signaling server OK to the client                      if (message == null)                      {                          message = s_emptyMessage;                      }                  }              }              else if (message == null || message == s_emptyMessage)              {                  throw new InternalException();              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The following statement contains a magic number: if (HandshakeComplete)              {                  if (_context.IsServer && !CheckSpn())                  {                      exception = new AuthenticationException(SR.net_auth_bad_client_creds_or_target_mismatch);                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    if (PrivateImpersonationLevel < _expectedImpersonationLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' _expectedImpersonationLevel.ToString()' PrivateImpersonationLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    ProtectionLevel result = _context.IsConfidentialityFlag ? ProtectionLevel.EncryptAndSign : _context.IsIntegrityFlag ? ProtectionLevel.Sign : ProtectionLevel.None;                    if (result < _expectedProtectionLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' result.ToString()' _expectedProtectionLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    // Signal remote party that we are done                  _framer.WriteHeader.MessageId = FrameHeader.HandshakeDoneId;                  if (_context.IsServer)                  {                      // Server may complete now because client SSPI would not complain at this point.                      _remoteOk = true;                        // However the client will wait for server to send this ACK                      //Force signaling server OK to the client                      if (message == null)                      {                          message = s_emptyMessage;                      }                  }              }              else if (message == null || message == s_emptyMessage)              {                  throw new InternalException();              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,StartSendBlob,The following statement contains a magic number: if (HandshakeComplete)              {                  if (_context.IsServer && !CheckSpn())                  {                      exception = new AuthenticationException(SR.net_auth_bad_client_creds_or_target_mismatch);                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    if (PrivateImpersonationLevel < _expectedImpersonationLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' _expectedImpersonationLevel.ToString()' PrivateImpersonationLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    ProtectionLevel result = _context.IsConfidentialityFlag ? ProtectionLevel.EncryptAndSign : _context.IsIntegrityFlag ? ProtectionLevel.Sign : ProtectionLevel.None;                    if (result < _expectedProtectionLevel)                  {                      exception = new AuthenticationException(SR.Format(SR.net_auth_context_expectation' result.ToString()' _expectedProtectionLevel.ToString()));                      int statusCode = ERROR_TRUST_FAILURE;                      message = new byte[8];  //sizeof(long)                        for (int i = message.Length - 1; i >= 0; --i)                      {                          message[i] = (byte)(statusCode & 0xFF);                          statusCode = (int)((uint)statusCode >> 8);                      }                        StartSendAuthResetSignal(lazyResult' message' exception);                      return;                  }                    // Signal remote party that we are done                  _framer.WriteHeader.MessageId = FrameHeader.HandshakeDoneId;                  if (_context.IsServer)                  {                      // Server may complete now because client SSPI would not complain at this point.                      _remoteOk = true;                        // However the client will wait for server to send this ACK                      //Force signaling server OK to the client                      if (message == null)                      {                          message = s_emptyMessage;                      }                  }              }              else if (message == null || message == s_emptyMessage)              {                  throw new InternalException();              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ProcessReceivedBlob,The following statement contains a magic number: if (_framer.ReadHeader.MessageId == FrameHeader.HandshakeErrId)              {                  if (message.Length >= 8)    // sizeof(long)                  {                      // Try to recover remote win32 Exception.                      long error = 0;                      for (int i = 0; i < 8; ++i)                      {                          error = (error << 8) + message[i];                      }                        ThrowCredentialException(error);                  }                    throw new AuthenticationException(SR.net_auth_alert' null);              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ProcessReceivedBlob,The following statement contains a magic number: if (_framer.ReadHeader.MessageId == FrameHeader.HandshakeErrId)              {                  if (message.Length >= 8)    // sizeof(long)                  {                      // Try to recover remote win32 Exception.                      long error = 0;                      for (int i = 0; i < 8; ++i)                      {                          error = (error << 8) + message[i];                      }                        ThrowCredentialException(error);                  }                    throw new AuthenticationException(SR.net_auth_alert' null);              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,ProcessReceivedBlob,The following statement contains a magic number: if (_framer.ReadHeader.MessageId == FrameHeader.HandshakeErrId)              {                  if (message.Length >= 8)    // sizeof(long)                  {                      // Try to recover remote win32 Exception.                      long error = 0;                      for (int i = 0; i < 8; ++i)                      {                          error = (error << 8) + message[i];                      }                        ThrowCredentialException(error);                  }                    throw new AuthenticationException(SR.net_auth_alert' null);              }
Magic Number,System.Net.Security,NegoState,C:\selectedRepos\dotnet_corefx\src\System.Net.Security\src\System\Net\Security\NegoState.cs,GetOutgoingBlob,The following statement contains a magic number: if (IsError(statusCode))              {                  e = NegotiateStreamPal.CreateExceptionFromError(statusCode);                  uint error = (uint)e.HResult;                    message = new byte[sizeof(long)];                  for (int i = message.Length - 1; i >= 0; --i)                  {                      message[i] = (byte)(error & 0xFF);                      error = (error >> 8);                  }              }
