Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.CSharp.RuntimeBinder,BinderHelper,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\BinderHelper.cs,Bind,The method has 103 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder,ExpressionTreeCallRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\ExpressionTreeCallRewriter.cs,VisitCALL,The method has 106 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder,ExpressionTreeCallRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\ExpressionTreeCallRewriter.cs,GetExpression,The method has 174 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,CreateMemberGroupEXPR,The method has 104 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindCall,The method has 101 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddAggregateToSymbolTable,The method has 136 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddPropertyToSymbolTable,The method has 127 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,SetParameterAttributes,The method has 117 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Errors,ErrorFacts,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Errors\ErrorFacts.cs,GetMessage,The method has 201 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Errors,ErrorHandling,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Errors\ErrorHandling.cs,Error,The method has 120 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Errors,UserStringBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Errors\UserStringBuilder.cs,ErrAppendType,The method has 143 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The method has 374 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindConstantCast,The method has 180 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,AdjustCallArgumentsForParams,The method has 184 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConstantInRange,The method has 151 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetStandardAndLiftedBinopSignatures,The method has 182 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindStandardUnaryOperator,The method has 126 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,FindApplicableSignatures,The method has 105 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The method has 121 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,LookForCandidates,The method has 153 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,Bind,The method has 168 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,BindNubConversion,The method has 115 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,SearchSingleType,The method has 208 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,Fix,The method has 137 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,CSemanticChecker,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\SemanticChecker.cs,CheckAccessCore,The method has 109 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,HasImplicitReferenceConversion,The method has 112 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExprVisitorBase,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExprVisitorBase.cs,Dispatch,The method has 151 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExprVisitorBase,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExprVisitorBase.cs,VisitChildren,The method has 180 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckSingleConstraint,The method has 126 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,SubstEqualTypesCore,The method has 100 lines of code.
Long Method,Microsoft.CSharp.RuntimeBinder.Syntax,TokenFacts,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\TokenFacts.cs,GetText,The method has 117 lines of code.
Complex Method,Microsoft.CSharp.RuntimeBinder,ExpressionTreeCallRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\ExpressionTreeCallRewriter.cs,GetMethodInfoFromExpr,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,CreateMemberGroupEXPR,Cyclomatic complexity of the method is 14
Complex Method,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindCall,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindProperty,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder,RuntimeBinderExtensions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinderExtensions.cs,IsEquivalentTo,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp.RuntimeBinder,RuntimeBinderExtensions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinderExtensions.cs,IsGenericallyEquivalentTo,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddNamesInInheritanceHierarchy,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddAggregateToSymbolTable,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddPropertyToSymbolTable,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddConversionsForOneType,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder.Errors,ErrorHandling,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Errors\ErrorHandling.cs,Error,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CSharp.RuntimeBinder.Errors,UserStringBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Errors\UserStringBuilder.cs,ErrAppendMethod,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,WhichMethodIsBetterTieBreaker,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,WhichMethodIsBetter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,WhichConversionIsBetter,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,FindBestMethod,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,mustCastCore,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,Cyclomatic complexity of the method is 46
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindConstantCast,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindToProperty,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUDUnop,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,AdjustMemberObject,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,AdjustCallArgumentsForParams,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConstantInRange,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,FindBestSignatureInList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetEnumBinOpSigs,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindStandardUnaryOperator,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,Bind,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionToEnum,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionBetweenSimpleTypes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,LookForCandidates,Cyclomatic complexity of the method is 17
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReOrderArgsForNamedArguments,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,FindMostDerivedMethod,Cyclomatic complexity of the method is 11
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,NamedArgumentNamesAppearInParameterList,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ArgumentsAreConvertible,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReportErrorsOnFailure,Cyclomatic complexity of the method is 15
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,Bind,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,BindNubConversion,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,bindImplicitConversionBetweenSimpleTypes,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,SearchSingleType,Cyclomatic complexity of the method is 26
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,LookupInInterfaces,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,ReportErrors,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,CMethodIterator,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookupResults.cs,CanUseCurrentSymbol,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,Fix,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,CSemanticChecker,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\SemanticChecker.cs,CheckAccessCore,Cyclomatic complexity of the method is 13
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,HasVariantConversion,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,IsBaseAggregate,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateBuiltInBinaryOperator,Cyclomatic complexity of the method is 9
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckConstraints,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckSingleConstraint,Cyclomatic complexity of the method is 16
Complex Method,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,GetBestAccessibleType,Cyclomatic complexity of the method is 9
Long Parameter List,Microsoft.CSharp.RuntimeBinder,Binder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Binder.cs,InvokeMember,The method has 5 parameters. Parameters: flags' name' typeArguments' context' argumentInfo
Long Parameter List,Microsoft.CSharp.RuntimeBinder,BinderHelper,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\BinderHelper.cs,Bind,The method has 5 parameters. Parameters: action' binder' args' arginfos' onBindingError
Long Parameter List,Microsoft.CSharp.RuntimeBinder,CSharpBinaryOperationBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\CSharpBinaryOperationBinder.cs,CSharpBinaryOperationBinder,The method has 5 parameters. Parameters: operation' isChecked' binaryOperationFlags' callingContext' argumentInfo
Long Parameter List,Microsoft.CSharp.RuntimeBinder,CSharpInvokeMemberBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\CSharpInvokeMemberBinder.cs,CSharpInvokeMemberBinder,The method has 5 parameters. Parameters: flags' name' callingContext' typeArguments' argumentInfo
Long Parameter List,Microsoft.CSharp.RuntimeBinder,CSharpSetMemberBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\CSharpSetMemberBinder.cs,CSharpSetMemberBinder,The method has 5 parameters. Parameters: name' isCompoundAssignment' isChecked' callingContext' argumentInfo
Long Parameter List,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,DeferBinding,The method has 5 parameters. Parameters: payload' arguments' args' locals' deferredBinding
Long Parameter List,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,GetArgumentType,The method has 5 parameters. Parameters: p' argInfo' param' arg' index
Long Parameter List,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindWinRTEventAccessor,The method has 5 parameters. Parameters: ewt' callingObject' arguments' locals' isAddAccessor
Long Parameter List,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,SymbolTable,The method has 5 parameters. Parameters: symTable' symFactory' typeManager' bsymmgr' semanticChecker
Long Parameter List,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,LookupMember,The method has 7 parameters. Parameters: name' callingObject' context' arity' mem' allowSpecialNames' requireInvocable
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,FindBestMethod,The method has 5 parameters. Parameters: list' pTypeThrough' args' methAmbig1' methAmbig2
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindImplicitConversion,The method has 5 parameters. Parameters: pSourceExpr' pSourceType' destinationType' ppDestinationExpr' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindImplicitConversion,The method has 6 parameters. Parameters: pSourceExpr' pSourceType' destinationType' needsExprDest' ppDestinationExpr' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindExplicitConversion,The method has 6 parameters. Parameters: pSourceExpr' pSourceType' destinationType' needsExprDest' ppDestinationExpr' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindExplicitConversion,The method has 5 parameters. Parameters: pSourceExpr' pSourceType' destinationType' ppDestinationExpr' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The method has 6 parameters. Parameters: exprSrc' typeSrc' typeDst' needExprDest' pexprDst' fImplicitOnly
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,HandleAmbiguity,The method has 5 parameters. Parameters: typeSrc' typeDst' prguci' iuciBestSrc' iuciBestDst
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUDConversionCore,The method has 5 parameters. Parameters: pFrom' pTypeFrom' pTypeTo' pTypeDestination' mwiBest
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUDConversionCore,The method has 6 parameters. Parameters: pFrom' pTypeFrom' pTypeTo' pTypeDestination' mwiBest' ppTransformedArgument
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindConstantCast,The method has 5 parameters. Parameters: exprSrc' typeDest' needExprDest' pexprDest' explicitConversion
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindToProperty,The method has 5 parameters. Parameters: pObject' pwt' bindFlags' args' pMemGroup
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindMethodGroupToArgumentsCore,The method has 5 parameters. Parameters: bindFlags' grp' args' carg' bHasNamedArgumentSpecifiers
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,AdjustCallArgumentsForParams,The method has 6 parameters. Parameters: callingObjectType' type' mp' pTypeArgs' argsPtr' newArgs
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConvInTable,The method has 5 parameters. Parameters: convTable' meth' ats' fSrc' fDst
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,LiftArgument,The method has 5 parameters. Parameters: pArgument' pParameterType' bConvertBeforeLift' ppLiftedArgument' ppNonLiftedArgument
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CanConvertArg1,The method has 5 parameters. Parameters: info' typeDst' pgrflt' ptypeSig1' ptypeSig2
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CanConvertArg2,The method has 5 parameters. Parameters: info' typeDst' pgrflt' ptypeSig1' ptypeSig2
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,PopulateSignatureList,The method has 7 parameters. Parameters: pArgument' unaryOpKind' unaryOpMask' exprKind' flags' pSignatures' ppResult
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,LScalar,The method has 6 parameters. Parameters: ek' flags' exprVal' type' cv' typeTmp
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindBoolBitwiseOp,The method has 5 parameters. Parameters: ek' flags' expr1' expr2' bofs
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindIntOp,The method has 5 parameters. Parameters: kind' flags' op1' op2' ptOp
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,UserDefinedBinaryOperatorIsApplicable,The method has 7 parameters. Parameters: candidateList' ek' method' ats' arg1' arg2' fDontLift
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetApplicableUserDefinedBinaryOperatorCandidates,The method has 6 parameters. Parameters: candidateList' ek' type' arg1' arg2' fDontLift
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetApplicableUserDefinedBinaryOperatorCandidatesInBaseTypes,The method has 7 parameters. Parameters: candidateList' ek' type' arg1' arg2' fDontLift' atsStop
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUDBinop,The method has 5 parameters. Parameters: ek' arg1' arg2' fDontLift' ppmpwi
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUDBinopCall,The method has 5 parameters. Parameters: arg1' arg2' Params' typeRet' mpwi
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindLiftedUDBinop,The method has 5 parameters. Parameters: ek' arg1' arg2' Params' mpwi
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CreateBinopForPredefMethodCall,The method has 5 parameters. Parameters: ek' predefMeth' RetType' arg1' arg2
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,BinOpSig,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\BinOpSig.cs,BinOpSig,The method has 7 parameters. Parameters: pt1' pt2' mask' cbosSkip' pfn' grfos' fnkind
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,BinOpFullSig,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\BinOpSig.cs,BinOpFullSig,The method has 6 parameters. Parameters: type1' type2' pfn' grfos' grflt' fnkind
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,ExplicitConversion,The method has 6 parameters. Parameters: binder' exprSrc' typeSrc' typeDest' needsExprDest' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprFactory,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExprFactory.cs,CreateCall,The method has 5 parameters. Parameters: flags' type' arguments' memberGroup' method
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprFactory,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExprFactory.cs,CreateArrayInit,The method has 5 parameters. Parameters: type' arguments' argumentDimensions' dimSizes' dimSize
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprFactory,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExprFactory.cs,CreateProperty,The method has 6 parameters. Parameters: type' optionalObjectThrough' arguments' memberGroup' property' setMethod
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprFactory,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExprFactory.cs,CreateMemGroup,The method has 8 parameters. Parameters: flags' name' typeArgs' symKind' parentType' memberSymbol' obj' memberLookupResults
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprFactory,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExprFactory.cs,CreateUserDefinedBinop,The method has 6 parameters. Parameters: exprKind' type' left' right' call' userMethod
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprFactory,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExprFactory.cs,CreateUserDefinedUnaryOperator,The method has 5 parameters. Parameters: exprKind' type' operand' call' userMethod
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,GroupToArgsBinder,The method has 6 parameters. Parameters: exprBinder' bindFlags' grp' args' originalArgs' bHasNamedArguments
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReOrderArgsForNamedArguments,The method has 8 parameters. Parameters: methprop' pCurrentParameters' pCurrentType' pGroup' pArguments' typeManager' exprFactory' symbolLoader
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,GenerateOptionalArgument,The method has 5 parameters. Parameters: symbolLoader' exprFactory' methprop' type' index
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,ImplicitConversion,The method has 6 parameters. Parameters: binder' exprSrc' typeSrc' typeDest' needsExprDest' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,Lookup,The method has 7 parameters. Parameters: checker' typeSrc' obj' symWhere' name' arity' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,CMemberLookupResults,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookupResults.cs,GetMethodIterator,The method has 10 parameters. Parameters: pChecker' pSymLoader' pObject' pQualifyingType' pContext' allowBogusAndInaccessible' allowExtensionMethods' arity' flags' mask
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,CMethodIterator,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookupResults.cs,CMethodIterator,The method has 12 parameters. Parameters: checker' symLoader' name' containingTypes' object' qualifyingType' context' allowBogusAndInaccessible' allowExtensionMethods' arity' flags' mask
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,Infer,The method has 6 parameters. Parameters: binder' symbolLoader' pMethod' pMethodFormalParameterTypes' pMethodArguments' ppInferredTypeArguments
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,MethodTypeInferrer,The method has 5 parameters. Parameters: exprBinder' symLoader' pMethodFormalParameterTypes' pMethodArguments' pMethodTypeParameters
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,PredefinedMethodInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\PredefinedMembers.cs,PredefinedMethodInfo,The method has 7 parameters. Parameters: method' type' name' callingConvention' access' cTypeVars' signature
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,PredefinedMembers,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\PredefinedMembers.cs,LoadMethod,The method has 7 parameters. Parameters: type' signature' cMethodTyVars' methodName' methodAccess' isStatic' isVirtual
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,PredefinedMembers,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\PredefinedMembers.cs,LookupMethodWhileLoading,The method has 8 parameters. Parameters: type' cMethodTyVars' methodName' methodAccess' isStatic' isVirtual' returnType' argumentTypes
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,SubstContext,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\SubstitutionContext.cs,SubstContext,The method has 5 parameters. Parameters: prgtypeCls' ctypeCls' prgtypeMeth' ctypeMeth' grfst
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprArrayInit,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\ArrayInitialization.cs,ExprArrayInit,The method has 5 parameters. Parameters: type' arguments' argumentDimensions' dimensionSizes' dimensionSize
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprBinOp,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\BinaryOperator.cs,ExprBinOp,The method has 6 parameters. Parameters: kind' type' left' right' call' userMethod
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprCall,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Call.cs,ExprCall,The method has 5 parameters. Parameters: type' flags' arguments' member' method
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprMemberGroup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\MemberGroup.cs,ExprMemberGroup,The method has 9 parameters. Parameters: type' flags' name' typeArgs' symKind' parentType' pMPS' optionalObject' memberLookupResults
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprProperty,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Property.cs,ExprProperty,The method has 6 parameters. Parameters: type' pOptionalObjectThrough' pOptionalArguments' pMemberGroup' pwtSlot' mwtSet
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExprUnaryOp,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\UnaryOperator.cs,ExprUnaryOp,The method has 5 parameters. Parameters: kind' type' operand' call' userMethod
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateCall,The method has 5 parameters. Parameters: pdm' arg1' arg2' arg3' arg4
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckConstraintsCore,The method has 8 parameters. Parameters: checker' errHandling' symErr' typeVars' typeArgs' typeArgsCls' typeArgsMeth' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckSingleConstraint,The method has 8 parameters. Parameters: checker' errHandling' symErr' var' arg' typeArgsCls' typeArgsMeth' flags
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,SubstEqualTypes,The method has 5 parameters. Parameters: typeDst' typeSrc' typeArgsCls' typeArgsMeth' grfst
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,SubstEqualTypeArrays,The method has 5 parameters. Parameters: taDst' taSrc' typeArgsCls' typeArgsMeth' grfst
Long Parameter List,Microsoft.CSharp.RuntimeBinder.Semantics,UnaOpSig,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\UnaOpSig.cs,UnaOpSig,The method has 5 parameters. Parameters: pt' grfuom' cuosSkip' pfn' fnkind
Long Identifier,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,mustCastCore,The length of the parameter simpleConstToSimpleDestination is 30.
Long Identifier,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,,The length of the parameter _pNameUsedInPositionalArgument is 30.
Long Identifier,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,,The length of the parameter _bArgumentsChangedForNamedOrOptionalArguments is 45.
Long Identifier,Microsoft.CSharp.RuntimeBinder.Semantics,CMethodIterator,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookupResults.cs,,The length of the parameter _bcanIncludeExtensionsInResults is 31.
Long Identifier,Microsoft.CSharp.RuntimeBinder.Semantics,MethodOrPropertySymbol,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\MethodOrPropertySymbol.cs,,The length of the parameter _defaultParameterConstValTypes is 30.
Long Identifier,Microsoft.CSharp.RuntimeBinder.Semantics,TypeTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeTable.cs,,The length of the parameter _pErrorWithNamespaceParentTable is 31.
Long Statement,Microsoft.CSharp.RuntimeBinder,CSharpConvertBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\CSharpConvertBinder.cs,DispatchPayload,The length of the statement  "                : runtimeBinder.BindImplicitConversion(arguments' Type' locals' ConversionKind == CSharpConversionKind.ArrayCreationConversion); " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder,ExpressionTreeCallRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\ExpressionTreeCallRewriter.cs,GetConstructorInfoFromExpr,The length of the statement  "            foreach (ConstructorInfo c in type.GetConstructors(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)) " is 143.
Long Statement,Microsoft.CSharp.RuntimeBinder,ExpressionTreeCallRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\ExpressionTreeCallRewriter.cs,GetPropertyInfoFromExpr,The length of the statement  "            foreach (PropertyInfo p in type.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.Static)) " is 138.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,DeferBinding,The length of the statement  "                    CSharpGetMemberBinder getMember = new CSharpGetMemberBinder(callPayload.Name' false' callPayload.CallingContext' new CSharpArgumentInfo[] { callPayload.GetArgumentInfo(0) }); " is 174.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,GetArgumentType,The length of the statement  "                bool res = _semanticChecker.GetTypeManager().GetBestAccessibleType(_semanticChecker' _bindingContext' actualType' out bestType); " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,GenerateBoundLambda,The length of the statement  "            LocalVariableSymbol thisLocal = _semanticChecker.GetGlobalSymbolFactory().CreateLocalVar(NameManager.Add("this")' pScope' _symbolTable.GetCTypeFromType(typeof(object))); " is 169.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindCall,The length of the statement  "            ExprMemberGroup memGroup = CreateMemberGroupEXPR(payload.Name' payload.TypeArguments' callingObject' swt.Sym.getKind()); " is 120.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindCall,The length of the statement  "                BindingFlag.BIND_RVALUEREQUIRED | BindingFlag.BIND_STMTEXPRONLY' memGroup' CreateArgumentListEXPR(arguments' locals' 1' arguments.Length)); " is 139.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindWinRTEventAccessor,The length of the statement  "            // WindowsRuntimeMarshal.AddEventHandler<delegType>(new Func<delegType' EventRegistrationToken>(x.add_foo)' new Action<EventRegistrationToken>(x.remove_foo)' value) " is 164.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindWinRTEventAccessor,The length of the statement  "            ExprMemberGroup addEventGrp = CreateMemberGroupEXPR(methodName' new [] { evtType }' marshalClass' SYMKIND.SK_MethodSymbol); " is 123.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindProperty,The length of the statement  "            SymWithType swt = _symbolTable.LookupMember(name' callingObject' _bindingContext.ContextForMemberLookup' 0' mem' false' false); " is 127.
Long Statement,Microsoft.CSharp.RuntimeBinder,RuntimeBinderExtensions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinderExtensions.cs,IsGenericallyEquivalentTo,The length of the statement  "                           Enumerable.All(Enumerable.Zip(args1' args2' (ta1' ta2) => ta1.IsGenericallyEquivalentTo(ta2' member1' member2))' x => x); " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,BuildDeclarationChain,The length of the statement  "                    foreach (MethodInfo methinfo in Enumerable.Where(t.DeclaringType.GetRuntimeMethods()' m => m.MetadataToken == methodBase.MetadataToken)) " is 136.
Long Statement,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,BuildDeclarationChain,The length of the statement  "                    foreach (MethodInfo methinfo in Enumerable.Where(t.DeclaringType.GetRuntimeMethods()' m => m.HasSameMetadataDefinitionAs(methodBase))) " is 134.
Long Statement,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddPropertyToSymbolTable,The length of the statement  "            prop.isStatic = property.GetGetMethod(true) != null ? property.GetGetMethod(true).IsStatic : property.GetSetMethod(true).IsStatic; " is 130.
Long Statement,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,FindMatchingMethod,The length of the statement  "            MethodSymbol meth = _bsymmgr.LookupAggMember(GetName(method.Name)' callingAggregate' symbmask_t.MASK_MethodSymbol) as MethodSymbol; " is 131.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CheckBetterTable,The length of the statement  "                        (!canConvert(GetPredefindType((PredefinedType)i)' GetPredefindType((PredefinedType)j)' CONVERTTYPE.NOUDC) || s_simpleTypeBetter[i][j] == left) && " is 145.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CheckBetterTable,The length of the statement  "                        (!canConvert(GetPredefindType((PredefinedType)j)' GetPredefindType((PredefinedType)i)' CONVERTTYPE.NOUDC) || s_simpleTypeBetter[j][i] == left)); " is 144.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,mustConvertCore,The length of the statement  "                throw ErrorContext.Error(canCast(expr.Type' dest' flags) ? ErrorCode.ERR_NoImplicitConvCast : ErrorCode.ERR_NoImplicitConv' new ErrArg(expr.Type' ErrArgFlags.Unique)' new ErrArg(dest' ErrArgFlags.Unique)); " is 205.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,mustCastCore,The length of the statement  "                        throw ErrorContext.Error(ErrorCode.ERR_ConstOutOfRange' ((ExprConstant)exprConst).Val.DecimalVal.ToString(CultureInfo.InvariantCulture)' dest); " is 143.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CantConvert,The length of the statement  "                throw ErrorContext.Error(ErrorCode.ERR_NoExplicitConv' new ErrArg(expr.Type' ErrArgFlags.Unique)' new ErrArg(dest' ErrArgFlags.Unique)); " is 136.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindImplicitConversion,The length of the statement  "            ImplicitConversion binder = new ImplicitConversion(this' pSourceExpr' pSourceType' destinationType' needsExprDest' flags); " is 122.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindExplicitConversion,The length of the statement  "            ExplicitConversion binder = new ExplicitConversion(this' pSourceExpr' pSourceType' destinationType' needsExprDest' flags); " is 122.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The length of the statement  "                fIntPtrOverride2 = atSrcBase.isPredefType(PredefinedType.PT_INTPTR) || atSrcBase.isPredefType(PredefinedType.PT_UINTPTR); " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The length of the statement  "                if (fIntPtrOverride2 && !typeDstBase.isPredefType(PredefinedType.PT_LONG) && !typeDstBase.isPredefType(PredefinedType.PT_ULONG)) " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The length of the statement  "                for (AggregateType atsCur = rgats[iats]; atsCur != null && atsCur.getAggregate().HasConversion(GetSymbolLoader()); atsCur = atsCur.GetBaseClass()) " is 146.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The length of the statement  "                        bool fFromImplicit = exprSrc != null ? canConvert(exprSrc' typeFrom' CONVERTTYPE.STANDARDANDNOUDC) : canConvert(typeSrc' typeFrom' CONVERTTYPE.STANDARDANDNOUDC); " is 161.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The length of the statement  "                                               (!fIntPtrStandard || typeSrc is PointerType || typeFrom is PointerType || !canCast(typeSrc' typeFrom' CONVERTTYPE.NOUDC)))) " is 123.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The length of the statement  "                                Debug.Assert((typeBestSrc == null) == (typeBestDst == null)); // If typeBestSrc is null then typeBestDst should be null. " is 120.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,HandleAmbiguity,The length of the statement  "            return ErrorContext.Error(ErrorCode.ERR_AmbigUDConv' prguci[iuciBestSrc].mwt' prguci[iuciBestDst].mwt' typeSrc' typeDst); " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindMethodGroupToArgumentsCore,The length of the statement  "            GroupToArgsBinder binder = new GroupToArgsBinder(this' bindFlags' grp' pargInfo' pOriginalArgInfo' bHasNamedArgumentSpecifiers); " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindMethodGroupToArguments,The length of the statement  "            Debug.Assert(grp.SymKind == SYMKIND.SK_MethodSymbol || grp.SymKind == SYMKIND.SK_PropertySymbol && ((grp.Flags & EXPRFLAG.EXF_INDEXER) != 0)); " is 142.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CheckPropertyAccess,The length of the statement  "                    throw ErrorContext.Error(mwt.Meth().isSetAccessor() ? ErrorCode.ERR_InaccessibleSetter : ErrorCode.ERR_InaccessibleGetter' pwtSlot); " is 132.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,AdjustCallArgumentsForParams,The length of the statement  "            MethodOrPropertySymbol mostDerivedMethod = GroupToArgsBinder.FindMostDerivedMethod(GetSymbolLoader()' mp' callingObjectType); " is 125.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUserDefinedBinOp,The length of the statement  "                        ExprCall call = BindUDBinop((ExpressionKind)(ek - ExpressionKind.LogicalAnd + ExpressionKind.BitwiseAnd)' info.arg1' info.arg2' true' out pmpwi); " is 145.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetDelBinOpSigs,The length of the statement  "                prgbofs.Add(new BinOpFullSig(info.type1' info.type2' BindDelBinOp' OpSigFlags.Reference' LiftFlags.None' BinOpFuncKind.DelBinOp)); " is 130.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetDelBinOpSigs,The length of the statement  "                prgbofs.Add(new BinOpFullSig(info.type2' info.type2' BindDelBinOp' OpSigFlags.Reference' LiftFlags.None' BinOpFuncKind.DelBinOp)); " is 130.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetDelBinOpSigs,The length of the statement  "                prgbofs.Add(new BinOpFullSig(info.type1' info.type1' BindDelBinOp' OpSigFlags.Reference' LiftFlags.None' BinOpFuncKind.DelBinOp)); " is 130.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetEnumBinOpSigs,The length of the statement  "                    info.ValidForEnumAndUnderlyingType() && CanConvertArg2(info' info.typeRaw1.underlyingEnumType()' out grflt' out typeSig1' out typeSig2); " is 136.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetEnumBinOpSigs,The length of the statement  "                    info.ValidForEnumAndUnderlyingType() && CanConvertArg1(info' info.typeRaw2.underlyingEnumType()' out grflt' out typeSig1' out typeSig2); " is 136.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindStandardUnaryOperator,The length of the statement  "            UnaryOperatorSignatureFindResult eResultOfSignatureFind = PopulateSignatureList(pArgument' unaryOpKind' unaryOpMask' ek' flags' pSignatures' out Expr pResult); " is 159.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindIntBinOp,The length of the statement  "            Debug.Assert(arg1.Type.isPredefined() && arg2.Type.isPredefined() && arg1.Type.getPredefType() == arg2.Type.getPredefType()); " is 125.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindRealBinOp,The length of the statement  "            Debug.Assert(arg1.Type.isPredefined() && arg2.Type.isPredefined() && arg1.Type.getPredefType() == arg2.Type.getPredefType()); " is 125.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,LScalar,The length of the statement  "            ExprBinOp pExprResult = GetExprFactory().CreateBinop(ek' typeTmp' exprVal' GetExprFactory().CreateConstant(typeOne' cv)); " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindLiftedIncOp,The length of the statement  "            ExprUnaryOp exprRes = GetExprFactory().CreateUnaryOp((ek == ExpressionKind.Add) ? ExpressionKind.Inc : ExpressionKind.Dec' arg.Type/* type */' exprVal); " is 152.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindShiftOp,The length of the statement  "            Debug.Assert(ptOp == PredefinedType.PT_INT || ptOp == PredefinedType.PT_UINT || ptOp == PredefinedType.PT_LONG || ptOp == PredefinedType.PT_ULONG); " is 147.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindBoolBinOp,The length of the statement  "            Debug.Assert(arg1.Type.isPredefType(PredefinedType.PT_BOOL) || (arg1.Type is NullableType argNubType1 && argNubType1.GetUnderlyingType().isPredefType(PredefinedType.PT_BOOL))); " is 176.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindBoolBinOp,The length of the statement  "            Debug.Assert(arg2.Type.isPredefType(PredefinedType.PT_BOOL) || (arg2.Type is NullableType argNubType2 && argNubType2.GetUnderlyingType().isPredefType(PredefinedType.PT_BOOL))); " is 176.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindBoolBitwiseOp,The length of the statement  "            Debug.Assert(expr1.Type.isPredefType(PredefinedType.PT_BOOL) || expr1.Type is NullableType expNubType1 && expNubType1.GetUnderlyingType().isPredefType(PredefinedType.PT_BOOL)); " is 176.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindBoolBitwiseOp,The length of the statement  "            Debug.Assert(expr2.Type.isPredefType(PredefinedType.PT_BOOL) || expr2.Type is NullableType expNubType2 && expNubType2.GetUnderlyingType().isPredefType(PredefinedType.PT_BOOL)); " is 176.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindDelBinOp,The length of the statement  "            Debug.Assert(ek == ExpressionKind.Add || ek == ExpressionKind.Subtract || ek == ExpressionKind.Eq || ek == ExpressionKind.NotEq); " is 129.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindDelBinOp,The length of the statement  "            Debug.Assert(arg1.Type == arg2.Type && (arg1.Type.isDelegateType() || arg1.Type.isPredefType(PredefinedType.PT_DELEGATE))); " is 123.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindLiftedEnumArithmeticBinOp,The length of the statement  "            NullableType typeDst = GetTypes().GetNullable(GetEnumBinOpType(ek' nonNullableType1' nonNullableType2' out AggregateType typeEnum)); " is 132.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindIntOp,The length of the statement  "            Debug.Assert(ptOp == PredefinedType.PT_INT || ptOp == PredefinedType.PT_UINT || ptOp == PredefinedType.PT_LONG || ptOp == PredefinedType.PT_ULONG); " is 147.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindIntOp,The length of the statement  "            Debug.Assert((op2 == null) == (kind == ExpressionKind.Negate || kind == ExpressionKind.UnaryPlus || kind == ExpressionKind.BitwiseNot)); " is 136.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindIntegerNeg,The length of the statement  "            Debug.Assert(ptOp == PredefinedType.PT_INT || ptOp == PredefinedType.PT_UINT || ptOp == PredefinedType.PT_LONG || ptOp == PredefinedType.PT_ULONG); " is 147.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUserBoolOp,The length of the statement  "            SymbolLoader.RuntimeBinderSymbolTable.PopulateSymbolTableWithName(SpecialNames.CLR_True' null' pExprWrap.Type.AssociatedSystemType); " is 132.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUserBoolOp,The length of the statement  "            SymbolLoader.RuntimeBinderSymbolTable.PopulateSymbolTableWithName(SpecialNames.CLR_False' null' pExprWrap.Type.AssociatedSystemType); " is 133.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetApplicableUserDefinedBinaryOperatorCandidates,The length of the statement  "            for (MethodSymbol methCur = GetSymbolLoader().LookupAggMember(name' type.getAggregate()' symbmask_t.MASK_MethodSymbol) as MethodSymbol; " is 135.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The length of the statement  "                // For a type-parameter T that is known to be a reference type (§25.7)' the following explicit reference conversions exist: " is 123.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The length of the statement  "                    // *    From an array-type S with an element type SE to an array-type T with an element type TE' provided all of the following are true: " is 136.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The length of the statement  "                    // *    From a one-dimensional array-type S[] to System.Collections.Generic.IList<T>' System.Collections.Generic.IReadOnlyList<T>  " is 129.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The length of the statement  "                    // *    From System.Collections.Generic.IList<T>' System.Collections.Generic.IReadOnlyList<T> and their base interfaces to a  " is 124.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The length of the statement  "                    //      System.Collections.Generic.IList<T> or System.Collections.Generic.IReadOnlyList<T>. This is precisely when either S and T " is 129.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,Bind,The length of the statement  "                if (_binder.BindImplicitConversion(_exprSrc' _typeSrc' _typeDest' _needsExprDest' out _exprDest' _flags | CONVERTTYPE.ISEXPLICIT)) " is 130.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromNub,The length of the statement  "                if (_typeDest.IsValType() && _binder.BindExplicitConversion(null' _typeSrc.StripNubs()' _typeDest' _flags | CONVERTTYPE.NOUDC)) " is 127.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromNub,The length of the statement  "                        if (!_binder.BindExplicitConversion(valueSrc' valueSrc.Type' _typeDest' _needsExprDest' out _exprDest' _flags | CONVERTTYPE.NOUDC)) " is 131.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromArrayToIList,The length of the statement  "                // * From a one-dimensional array-type S[] to System.Collections.Generic.IList<T>' System.Collections.Generic.IReadOnlyList<T> and " is 130.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromIListToArray,The length of the statement  "                //   S[] to System.Collections.Generic.IList<T> or System.Collections.Generic.IReadOnlyList<T>. This is precisely when either S and T " is 133.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromDecimalToEnum,The length of the statement  "                    bIsConversionOK = _binder.bindUserDefinedConversion(_exprSrc' _typeSrc' underlyingType' _needsExprDest' out _exprDest' false); " is 126.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromEnumToDecimal,The length of the statement  "                    bool ok = _binder.bindUserDefinedConversion(exprCast' underlyingType' aggTypeDest' _needsExprDest' out _exprDest' false); " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionToEnum,The length of the statement  "                         (_typeSrc.isPredefType(PredefinedType.PT_OBJECT) || _typeSrc.isPredefType(PredefinedType.PT_VALUE) || _typeSrc.isPredefType(PredefinedType.PT_ENUM))) " is 149.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionBetweenSimpleTypes,The length of the statement  "                        bConversionOk = _binder.bindUserDefinedConversion(_exprSrc' _typeSrc' aggTypeDest' _needsExprDest' out _exprDest' false); " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionBetweenSimpleTypes,The length of the statement  "                        _binder.bindSimpleCast(_exprSrc' _typeDest' out _exprDest' (_flags & CONVERTTYPE.CHECKOVERFLOW) != 0 ? EXPRFLAG.EXF_CHECKOVERFLOW : 0); " is 135.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionBetweenAggregates,The length of the statement  "                            _binder.bindSimpleCast(_exprSrc' _typeDest' out _exprDest' EXPRFLAG.EXF_REFCHECK | (_exprSrc?.Flags & EXPRFLAG.EXF_CANTBENULL ?? 0)); " is 133.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionBetweenAggregates,The length of the statement  "                        _binder.bindSimpleCast(_exprSrc' _typeDest' out _exprDest' EXPRFLAG.EXF_REFCHECK | (_exprSrc?.Flags & EXPRFLAG.EXF_CANTBENULL ?? 0)); " is 133.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,EXPRExtensions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\EXPRExtensions.cs,isNull,The length of the statement  "            return expr is ExprConstant constant && constant.IsOK && (expr.Type.fundType() == FUNDTYPE.FT_REF) && constant.Val.IsNullRef; " is 125.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExprFactory,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExprFactory.cs,CreateMethodInfo,The length of the statement  "                Types.GetPredefAgg(method.IsConstructor() ? PredefinedType.PT_CONSTRUCTORINFO : PredefinedType.PT_METHODINFO).getThisType()' " is 124.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,Bind,The length of the statement  "                Debug.Assert(_pGroup.SymKind == SYMKIND.SK_MethodSymbol || _pGroup.SymKind == SYMKIND.SK_PropertySymbol && 0 != (_pGroup.Flags & EXPRFLAG.EXF_INDEXER)); " is 152.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,LookForCandidates,The length of the statement  "                CMemberLookupResults.CMethodIterator iterator = _pGroup.MemberLookupResults.GetMethodIterator(GetSemanticChecker()' GetSymbolLoader()' pTypeThrough' GetTypeQualifier(_pGroup)' _pExprBinder.ContextForMemberLookup()' true' // AllowBogusAndInaccessible " is 249.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,GetResultOfBind,The length of the statement  "                        pmethBest = _pExprBinder.FindBestMethod(_methList' pTypeThrough' _pArguments' out CandidateFunctionMember pAmbig1' out CandidateFunctionMember pAmbig2); " is 152.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,GenerateOptionalArgument,The length of the statement  "                        (pRawParamType.isPredefType(PredefinedType.PT_DATETIME) || pRawParamType.isPredefType(PredefinedType.PT_OBJECT) || pRawParamType.isPredefType(PredefinedType.PT_VALUE))) " is 168.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,FindMostDerivedMethod,The length of the statement  "                    for (MethodOrPropertySymbol meth = symbolLoader.LookupAggMember(method.name' pAggregate' symbmask_t.MASK_MethodSymbol | symbmask_t.MASK_PropertySymbol) as MethodOrPropertySymbol; " is 178.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,FindMostDerivedMethod,The length of the statement  "                            meth = SymbolLoader.LookupNextSym(meth' pAggregate' symbmask_t.MASK_MethodSymbol | symbmask_t.MASK_PropertySymbol) as MethodOrPropertySymbol) " is 141.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,AddArgumentsForOptionalParameters,The length of the statement  "                    pArguments[index] = GenerateOptionalArgument(GetSymbolLoader()' _pExprBinder.GetExprFactory()' methprop' @params[i]' i); " is 120.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ArgumentsAreConvertible,The length of the statement  "                        bool constraintErrors = !TypeBind.CheckConstraints(GetSemanticChecker()' GetErrorContext()' var' CheckConstraintsFlags.NoErrors); " is 129.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,UpdateArguments,The length of the statement  "                    Expr pArgumentNew = GenerateOptionalArgument(GetSymbolLoader()' _pExprBinder.GetExprFactory()' pMethod' _pCurrentParameters[iParam]' iParam); " is 141.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReportErrorsOnSuccess,The length of the statement  "                Debug.Assert(_pGroup.SymKind == SYMKIND.SK_MethodSymbol || _pGroup.SymKind == SYMKIND.SK_PropertySymbol && 0 != (_pGroup.Flags & EXPRFLAG.EXF_INDEXER)); " is 152.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReportErrorsOnFailure,The length of the statement  "                    return GetSemanticChecker().ReportAccessError(_results.GetInaccessibleResult()' _pExprBinder.ContextForMemberLookup()' GetTypeQualifier(_pGroup)); " is 146.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReportErrorsOnFailure,The length of the statement  "                        _results.GetUninferableResult().Set(_mpwiCantInferInstArg.Sym as MethodSymbol' _mpwiCantInferInstArg.GetType()' _mpwiCantInferInstArg.TypeArgs); " is 144.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReportErrorsOnFailure,The length of the statement  "                    return GetErrorContext().Error(cvar > 0 ? ErrorCode.ERR_BadArity : ErrorCode.ERR_HasNoTypeVars' _mwtBadArity' new ErrArgSymKind(_mwtBadArity.Meth())' _pArguments.carg); " is 168.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,Bind,The length of the statement  "                    ((_flags & CONVERTTYPE.ISEXPLICIT) == 0 || (!_typeSrc.isPredefType(PredefinedType.PT_FLOAT) && !_typeSrc.isPredefType(PredefinedType.PT_DOUBLE)))) " is 146.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,BindNubConversion,The length of the statement  "                if (GetSymbolLoader().HasBaseConversion(nubDst.GetUnderlyingType()' _typeSrc) && !CConversions.FWrappingConv(_typeSrc' nubDst)) " is 127.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,BindNubConversion,The length of the statement  "                    if (_typeSrc == typeDstBase || pfn(_exprSrc' _typeSrc' typeDstBase' _needsExprDest' out exprTmp' _flags | CONVERTTYPE.NOUDC)) " is 125.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,BindNubConversion,The length of the statement  "                    return 0 == (_flags & CONVERTTYPE.NOUDC) && _binder.bindUserDefinedConversion(_exprSrc' _typeSrc' nubDst' _needsExprDest' out _exprDest' 0 == (_flags & CONVERTTYPE.ISEXPLICIT)); " is 177.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,BindNubConversion,The length of the statement  "                if (typeSrcBase != typeDstBase && !pfn(null' typeSrcBase' typeDstBase' false' out _exprDest' _flags | CONVERTTYPE.NOUDC)) " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,BindNubConversion,The length of the statement  "                    return 0 == (_flags & CONVERTTYPE.NOUDC) && _binder.bindUserDefinedConversion(_exprSrc' _typeSrc' nubDst' _needsExprDest' out _exprDest' 0 == (_flags & CONVERTTYPE.ISEXPLICIT)); " is 177.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,bindImplicitConversionFromNullable,The length of the statement  "                if (GetSymbolLoader().HasBaseConversion(nubSrc.GetUnderlyingType()' _typeDest) && !CConversions.FUnwrappingConv(nubSrc' _typeDest)) " is 131.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,bindImplicitConversionFromNullable,The length of the statement  "                return 0 == (_flags & CONVERTTYPE.NOUDC) && _binder.bindUserDefinedConversion(_exprSrc' nubSrc' _typeDest' _needsExprDest' out _exprDest' true); " is 144.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,bindImplicitConversionFromArray,The length of the statement  "                // *   From a one-dimensional array-type S[] to System.Collections.Generic.IList<T>' System.Collections.Generic.IReadOnlyList<T> " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,IsDynamicMember,The length of the statement  "                var o = field.AssociatedFieldInfo.GetCustomAttributes(typeof(System.Runtime.CompilerServices.DynamicAttribute)' false).ToArray(); " is 129.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,IsDynamicMember,The length of the statement  "                var o = prop.AssociatedPropertyInfo.GetCustomAttributes(typeof(System.Runtime.CompilerServices.DynamicAttribute)' false).ToArray(); " is 131.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,Lookup,The length of the statement  "                Debug.Assert((_flags & (MemLookFlags.Ctor | MemLookFlags.NewObj | MemLookFlags.Operator | MemLookFlags.BaseCall)) == 0); " is 120.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,ReportErrors,The length of the statement  "                return GetErrorContext().Error((_flags & MemLookFlags.MustBeInvocable) != 0 ? ErrorCode.ERR_NonInvocableMemberCalled : ErrorCode.ERR_CantCallSpecialMethod' _swtBad); " is 165.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,ReportErrors,The length of the statement  "                        return GetErrorContext().Error(cvar > 0 ? ErrorCode.ERR_BadArity : ErrorCode.ERR_HasNoTypeVars' _swtBadArity' new ErrArgSymKind(_swtBadArity.Sym)' cvar); " is 153.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,ReportErrors,The length of the statement  "                        return GetErrorContext().Error(cvar > 0 ? ErrorCode.ERR_BadArity : ErrorCode.ERR_HasNoTypeVars' _swtBadArity' new ErrArgSymKind(_swtBadArity.Sym)' cvar); " is 153.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CMemberLookupResults,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookupResults.cs,GetMethodIterator,The length of the statement  "            CMethodIterator iterator = new CMethodIterator(pChecker' pSymLoader' _pName' ContainingTypes' pObject' pQualifyingType' pContext' allowBogusAndInaccessible' allowExtensionMethods' arity' flags' mask); " is 200.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,Fix,The length of the statement  "            if (GetTypeManager().GetBestAccessibleType(_binder.GetSemanticChecker()' _binder.GetContext()' pBest' out pBestAccessible)) " is 123.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CNullable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Nullable.cs,BindNew,The length of the statement  "            return GetExprFactory().CreateCall(EXPRFLAG.EXF_NEWOBJCALL | EXPRFLAG.EXF_CANTBENULL' pNubSourceType' pExprSrc' memgroup' methwithinst); " is 136.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,PredefinedMembers,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\PredefinedMembers.cs,LoadMethod,The length of the statement  "            MethodSymbol ret = LookupMethodWhileLoading(type' cMethodTyVars' methodName' methodAccess' isStatic' isVirtual' returnType' argumentTypes); " is 139.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,PredefinedMembers,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\PredefinedMembers.cs,LoadMethod,The length of the statement  "                ret = LookupMethodWhileLoading(type' cMethodTyVars' methodName' methodAccess' isStatic' isVirtual' returnType' argumentTypes); " is 126.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,LookupInvokeMeth,The length of the statement  "            for (Symbol pSym = LookupAggMember(NameManager.GetPredefinedName(PredefinedName.PN_INVOKE)' pAggDel' symbmask_t.MASK_ALL); " is 122.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,VisitASSIGNMENT,The length of the statement  "            //Debug.Assert(assignment.GetLHS().isPROP() || assignment.GetLHS().isFIELD() || assignment.GetLHS().isARRAYINDEX() || assignment.GetLHS().isLOCAL()); " is 149.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,VisitCONCAT,The length of the statement  "            if (expr.FirstArgument.Type.isPredefType(PredefinedType.PT_STRING) && expr.SecondArgument.Type.isPredefType(PredefinedType.PT_STRING)) " is 134.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,VisitCONCAT,The length of the statement  "            Expr methodInfo = GetExprFactory().CreateMethodInfo(method' GetSymbolLoader().GetPredefindType(PredefinedType.PT_STRING)' null); " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateUserDefinedBinaryOperator,The length of the statement  "                    pdm = expr.isChecked() ? PREDEFMETH.PM_EXPRESSION_SUBTRACTCHECKED_USER_DEFINED : PREDEFMETH.PM_EXPRESSION_SUBTRACT_USER_DEFINED; " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateUserDefinedBinaryOperator,The length of the statement  "                    pdm = expr.isChecked() ? PREDEFMETH.PM_EXPRESSION_MULTIPLYCHECKED_USER_DEFINED : PREDEFMETH.PM_EXPRESSION_MULTIPLY_USER_DEFINED; " is 128.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateUserDefinedUnaryOperator,The length of the statement  "                    pdm = expr.isChecked() ? PREDEFMETH.PM_EXPRESSION_NEGATECHECKED_USER_DEFINED : PREDEFMETH.PM_EXPRESSION_NEGATE_USER_DEFINED; " is 124.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateUserDefinedConversion,The length of the statement  "            bool fDontLiftReturnType = (pMethodReturnType == CType || (IsNullableValueType(arg.Type) && IsNullableValueType(CType))); " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateUserDefinedConversion,The length of the statement  "            PREDEFMETH pdmInner = arg.isChecked() ? PREDEFMETH.PM_EXPRESSION_CONVERTCHECKED_USER_DEFINED : PREDEFMETH.PM_EXPRESSION_CONVERT_USER_DEFINED; " is 141.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateParamsArray,The length of the statement  "            return GetExprFactory().CreateArrayInit(paramsArrayType' args' paramsArrayArg' new int[] { parameterCount }' parameterCount); " is 125.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckConstraints,The length of the statement  "                ats.fConstraintError |= !CheckConstraintsCore(checker' errHandling' ats.getAggregate()' typeVars' typeArgsThis' typeArgsAll' null' (flags & CheckConstraintsFlags.NoErrors)); " is 173.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckMethConstraints,The length of the statement  "                CheckConstraintsCore(checker' errCtx' mwi.Meth()' mwi.Meth().typeVars' mwi.TypeArgs' mwi.GetType().GetTypeArgsAll()' mwi.TypeArgs' CheckConstraintsFlags.None); " is 159.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckSingleConstraint,The length of the statement  "                        else if (arg is NullableType nubArg && checker.SymbolLoader.HasBaseConversion(nubArg.GetUnderlyingType()' typeBnd))    // This is inlining FBoxingConv " is 150.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeBind,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\TypeBind.cs,CheckSingleConstraint,The length of the statement  "                        throw errHandling.Error(error' new ErrArg(symErr)' new ErrArg(typeBnd' ErrArgFlags.Unique)' var' new ErrArg(arg' ErrArgFlags.Unique)); " is 134.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,PredefinedTypes,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\PredefinedTypes.cs,InitializePredefinedType,The length of the statement  "            sym.SetSkipUDOps(pt <= PredefinedType.PT_ENUM && pt != PredefinedType.PT_INTPTR && pt != PredefinedType.PT_UINTPTR && pt != PredefinedType.PT_TYPE); " is 148.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CType,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\Type.cs,constValKind,The length of the statement  "                    Debug.Assert((getAggregate().IsEnum() && getAggregate().GetUnderlyingType().getPredefType() == PredefinedType.PT_DECIMAL) " is 121.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,CType,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\Type.cs,isUnsigned,The length of the statement  "                    return pt == PredefinedType.PT_UINTPTR || pt == PredefinedType.PT_BYTE || (pt >= PredefinedType.PT_USHORT && pt <= PredefinedType.PT_ULONG); " is 140.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,SubstEqualTypes,The length of the statement  "            return SubstEqualTypes(typeDst' typeSrc' (typeCls as AggregateType)?.GetTypeArgsAll()' typeArgsMeth' SubstTypeFlags.NormNone); " is 126.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,GetBestAccessibleType,The length of the statement  "            if (typeSrc is AggregateType aggSrc && (aggSrc.isInterfaceType() || aggSrc.isDelegateType()) && TryVarianceAdjustmentToGetAccessibleType(semanticChecker' bindingContext' aggSrc' out intermediateType)) " is 200.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,GetBestAccessibleType,The length of the statement  "            if (typeSrc is ArrayType arrSrc && TryArrayVarianceAdjustmentToGetAccessibleType(semanticChecker' bindingContext' arrSrc' out intermediateType)) " is 144.
Long Statement,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,TryVarianceAdjustmentToGetAccessibleType,The length of the statement  "            if (!TypeBind.CheckConstraints(semanticChecker' null/*ErrorHandling*/' intermediateType' CheckConstraintsFlags.NoErrors)) " is 121.
Complex Conditional,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindCall,The conditional expression  "(payload.Name.StartsWith("set_"' StringComparison.Ordinal) && ((MethodSymbol)swt.Sym).Params.Count > 1) ||                  (payload.Name.StartsWith("get_"' StringComparison.Ordinal) && ((MethodSymbol)swt.Sym).Params.Count > 0)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder,RuntimeBinderExtensions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinderExtensions.cs,IsGenericallyEquivalentTo,The conditional expression  "(t1.IsByRef && t2.IsByRef) ||                  (t1.IsPointer && t2.IsPointer)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddAggregateToSymbolTable,The conditional expression  "type.BaseType != null &&                      (type.BaseType.FullName == "System.MulticastDelegate" ||                      type.BaseType.FullName == "System.Delegate") &&                      type.FullName != "System.MulticastDelegate""  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddEventToSymbolTable,The conditional expression  "(object)eventRegistrationTokenType != null && (object)WindowsRuntimeMarshalType != null &&                  ev.methAdd.RetType.AssociatedSystemType == eventRegistrationTokenType &&                  ev.methRemove.Params[0].AssociatedSystemType == eventRegistrationTokenType"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddMethodToSymbolTable,The conditional expression  "kind == MethodKindEnum.Actual && // MethKindEnum.Actual                  (method == null || // Not a ConstructorInfo                      (!method.IsStatic && method.IsSpecialName))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,AddConversionsForOneType,The conditional expression  "conversion.IsPublic && conversion.IsStatic && conversion.DeclaringType == type                      && conversion.IsSpecialName && !conversion.IsGenericMethod"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Errors,UserStringBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Errors\UserStringBuilder.cs,ErrAppendParentCore,The conditional expression  "pctx != null && !pctx.FNop() && parent is AggregateSymbol agg && 0 != agg.GetTypeVarsAll().Count"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,TryReportLvalueFailure,The conditional expression  "pObject != null && !pObject.isLvalue() && (expr is ExprField || !isNested)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,WhichTypeIsBetter,The conditional expression  "!(type1 is NullableType nub1) || !(type2 is NullableType nub2) ||                  !nub1.UnderlyingType.isPredefined() ||                  !nub2.UnderlyingType.isPredefined()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,mustConvertCore,The conditional expression  "expr is ExprConstant constant && constant.IsOK &&                      expr.Type.isSimpleType() && dest.isSimpleType()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,mustConvertCore,The conditional expression  "(ftSrc == FUNDTYPE.FT_I4 && (ftDest <= FUNDTYPE.FT_LASTNONLONG || ftDest == FUNDTYPE.FT_U8)) ||                          (ftSrc == FUNDTYPE.FT_I8 && ftDest == FUNDTYPE.FT_U8)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The conditional expression  "typeSrc == null || typeDst == null || typeSrc.isInterfaceType() || typeDst.isInterfaceType()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The conditional expression  "(ftTo = typeTo.fundType()) <= FUNDTYPE.FT_LASTNUMERIC && ftTo > FUNDTYPE.FT_NONE &&                                  (ftFrom = typeFrom.fundType()) <= FUNDTYPE.FT_LASTNUMERIC && ftFrom > FUNDTYPE.FT_NONE"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The conditional expression  "fLiftSrc && (fDstHasNull || !fNeedImplicit) && typeFrom.IsNonNubValType()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The conditional expression  "!fFromImplicit && (fNeedImplicit ||                                                 !canConvert(typeFrom' typeSrc' CONVERTTYPE.STANDARDANDNOUDC) &&                                                 // We allow IntPtr and UIntPtr to use non-standard explicit casts as long as they don't involve pointer types.                                                 // This is because the framework uses it and RTM allowed it.                                                 (!fIntPtrStandard || typeSrc is PointerType || typeFrom is PointerType || !canCast(typeSrc' typeFrom' CONVERTTYPE.NOUDC)))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The conditional expression  "!fToImplicit && (fNeedImplicit ||                                               !canConvert(typeDst' typeTo' CONVERTTYPE.STANDARDANDNOUDC) &&                                               // We allow IntPtr and UIntPtr to use non-standard explicit casts as long as they don't involve pointer types.                                               // This is because the framework uses it and RTM allowed it.                                               (!fIntPtrStandard || typeDst is PointerType || typeTo is PointerType || !canCast(typeTo' typeDst' CONVERTTYPE.NOUDC)))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindSimpleCast,The conditional expression  "exprConst is ExprConstant constant && exprFlags == 0 &&                  exprSrc.Type.fundType() == typeDest.fundType() &&                  (!exprSrc.Type.isPredefType(PredefinedType.PT_STRING) || constant.Val.IsNullRef)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindToProperty,The conditional expression  "mwtGet &&                      (!mwtSet ||                       mwtSet.GetType() == mwtGet.GetType() ||                       GetSymbolLoader().HasBaseConversion(mwtGet.GetType()' mwtSet.GetType())                       )"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,AdjustMemberObject,The conditional expression  "pObject is ExprField field && !field.FieldWithType.Field().isAssigned && !(swt.Sym is FieldSymbol) &&                      typeObj.isStructType() && !typeObj.isPredefined()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,AdjustMemberObject,The conditional expression  "pfConstrained &&                      (typeObj is TypeParameterType ||                       typeObj.isStructType() && swt.GetType().IsRefType() && swt.Sym.IsVirtual())"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConvInTable,The conditional expression  "conv.mwt.Meth() == meth &&                      conv.mwt.GetType() == ats &&                      conv.fSrcImplicit == fSrc &&                      conv.fDstImplicit == fDst"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetRefEqualSigs,The conditional expression  "canConvert(info.arg1' typeDel) && canConvert(info.arg2' typeDel) && !type1.isDelegateType()                      && !type2.isDelegateType()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The conditional expression  "(aggSrc.IsClass() && !aggSrc.IsSealed() && aggDest.IsInterface()) ||                          (aggSrc.IsInterface() && aggDest.IsClass() && !aggDest.IsSealed()) ||                          (aggSrc.IsInterface() && aggDest.IsInterface())"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The conditional expression  "(aggIList == null ||                          !SymbolLoader.IsBaseAggregate(aggIList' aggDst.getAggregate())) &&                          (aggIReadOnlyList == null ||                          !SymbolLoader.IsBaseAggregate(aggIReadOnlyList' aggDst.getAggregate()))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,FExpRefConv,The conditional expression  "(aggIList == null ||                          !SymbolLoader.IsBaseAggregate(aggIList' aggtypeSrc.getAggregate())) &&                          (aggIReadOnlyList == null ||                          !SymbolLoader.IsBaseAggregate(aggIReadOnlyList' aggtypeSrc.getAggregate()))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,CConversions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Conversions.cs,HasGenericDelegateExplicitReferenceConversion,The conditional expression  "!pSource.isDelegateType() ||                  !pTarget.isDelegateType() ||                  pSource.getAggregate() != pTarget.getAggregate() ||                  loader.HasIdentityOrImplicitReferenceConversion(pSource' pTarget)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,Bind,The conditional expression  "_typeSrc == null || _typeDest == null || _typeSrc is ErrorType ||                      _typeDest is ErrorType || _typeDest.IsNeverSameType()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromArrayToIList,The conditional expression  "!(_typeSrc is ArrayType arrSrc) || !arrSrc.IsSZArray || !(_typeDest is AggregateType aggDest)                      || !aggDest.isInterfaceType() || aggDest.GetTypeArgsAll().Count != 1"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromArrayToIList,The conditional expression  "(aggIList == null ||                      !SymbolLoader.IsBaseAggregate(aggIList' aggDest.getAggregate())) &&                      (aggIReadOnlyList == null ||                      !SymbolLoader.IsBaseAggregate(aggIReadOnlyList' aggDest.getAggregate()))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromIListToArray,The conditional expression  "!arrayDest.IsSZArray || !(_typeSrc is AggregateType aggSrc) || !aggSrc.isInterfaceType() ||                      aggSrc.GetTypeArgsAll().Count != 1"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromIListToArray,The conditional expression  "(aggIList == null ||                      !SymbolLoader.IsBaseAggregate(aggIList' aggSrc.getAggregate())) &&                      (aggIReadOnlyList == null ||                      !SymbolLoader.IsBaseAggregate(aggIReadOnlyList' aggSrc.getAggregate()))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionFromEnumToAggregate,The conditional expression  "!aggDest.getThisType().isNumericType() &&                      !aggDest.IsEnum() &&                      !(aggDest.IsPredefined() && aggDest.GetPredefType() == PredefinedType.PT_CHAR)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionToEnum,The conditional expression  "_typeSrc.isPredefined() &&                           (_typeSrc.isPredefType(PredefinedType.PT_OBJECT) || _typeSrc.isPredefType(PredefinedType.PT_VALUE) || _typeSrc.isPredefType(PredefinedType.PT_ENUM))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExplicitConversion.cs,bindExplicitConversionBetweenAggregates,The conditional expression  "(aggSrc.IsClass() && !aggSrc.IsSealed() && aggDest.IsInterface()) ||                      (aggSrc.IsInterface() && aggDest.IsClass() && !aggDest.IsSealed()) ||                      (aggSrc.IsInterface() && aggDest.IsInterface()) ||                      CConversions.HasGenericDelegateExplicitReferenceConversion(GetSymbolLoader()' _typeSrc' aggTypeDest)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,LookForCandidates,The conditional expression  "fBogus && (!_methList.IsEmpty() || _results.GetInaccessibleResult() || _mpwiBogus)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,GetResultOfBind,The conditional expression  "pAmbig1.@params != pAmbig2.@params ||                                  pAmbig1.mpwi.MethProp().Params.Count != pAmbig2.mpwi.MethProp().Params.Count ||                                  pAmbig1.mpwi.TypeArgs != pAmbig2.mpwi.TypeArgs ||                                  pAmbig1.mpwi.GetType() != pAmbig2.mpwi.GetType() ||                                  pAmbig1.mpwi.MethProp().Params == pAmbig2.mpwi.MethProp().Params"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReOrderArgsForNamedArguments,The conditional expression  "methprop.isParamArray &&                          index < pArguments.carg &&                          pArguments.prgexpr[index] is ExprArrayInit arrayInit && arrayInit.GeneratedForParamArray"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReOrderArgsForNamedArguments,The conditional expression  "index < pArguments.carg &&                          !(pArguments.prgexpr[index] is ExprNamedArgumentSpecification) &&                          !(pArguments.prgexpr[index] is ExprArrayInit arrayInitPos && arrayInitPos.GeneratedForParamArray)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,GenerateOptionalArgument,The conditional expression  "pConstValType.isPredefType(PredefinedType.PT_DATETIME) &&                          (pRawParamType.isPredefType(PredefinedType.PT_DATETIME) || pRawParamType.isPredefType(PredefinedType.PT_OBJECT) || pRawParamType.isPredefType(PredefinedType.PT_VALUE))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,GetNextSym,The conditional expression  "_pCurrentType != type &&                          _pCurrentType != null &&                          !_methList.IsEmpty() &&                          !_methList.Head().mpwi.GetType().isInterfaceType()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,GroupToArgsBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\GroupToArgsBinder.cs,ReportErrorsOnFailure,The conditional expression  "_pGroup.OptionalObject != null &&                          _pGroup.OptionalObject.Type != null &&                          _pGroup.OptionalObject.Type.isDelegateType() &&                          _pGroup.Name == NameManager.GetPredefinedName(PredefinedName.PN_INVOKE)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,Bind,The conditional expression  "_typeSrc == _typeDest &&                      ((_flags & CONVERTTYPE.ISEXPLICIT) == 0 || (!_typeSrc.isPredefType(PredefinedType.PT_FLOAT) && !_typeSrc.isPredefType(PredefinedType.PT_DOUBLE)))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,bindImplicitConversionFromArray,The conditional expression  "(_typeDest is ArrayType ||                       (_typeDest is AggregateType aggDest && aggDest.isInterfaceType() &&                        aggDest.GetTypeArgsAll().Count == 1 &&                        ((aggDest.GetTypeArgsAll()[0] != ((ArrayType)_typeSrc).GetElementType()) ||                         0 != (_flags & CONVERTTYPE.FORCECAST))))                      &&                      (0 != (_flags & CONVERTTYPE.FORCECAST) ||                       TypeManager.TypeContainsTyVars(_typeSrc' null) ||                       TypeManager.TypeContainsTyVars(_typeDest' null))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,bindImplicitConversionToEnum,The conditional expression  "aggTypeSrc.getAggregate().GetPredefType() != PredefinedType.PT_BOOL &&                      _exprSrc != null &&                      _exprSrc.IsZero() &&                      _exprSrc.Type.isNumericType() &&                      /*(exprSrc.flags & EXF_LITERALCONST) &&*/                      0 == (_flags & CONVERTTYPE.STANDARD)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ImplicitConversion,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ImplicitConversion.cs,bindImplicitConversionBetweenSimpleTypes,The conditional expression  "_exprSrc is ExprConstant constant && _exprSrc.IsOK &&                      ((ptSrc == PredefinedType.PT_INT && ptDest != PredefinedType.PT_BOOL && ptDest != PredefinedType.PT_CHAR) ||                      (ptSrc == PredefinedType.PT_LONG && ptDest == PredefinedType.PT_ULONG)) &&                      isConstantInRange(constant' _typeDest)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,SearchSingleType,The conditional expression  "meth != null &&                          meth.isPropertyAccessor() &&                          ((symCur.name.Text.StartsWith("set_"' StringComparison.Ordinal) && meth.Params.Count > 1) ||                          (symCur.name.Text.StartsWith("get_"' StringComparison.Ordinal) && meth.Params.Count > 0))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,SearchSingleType,The conditional expression  "((_flags & MemLookFlags.Ctor) == 0) != (meth == null || !meth.IsConstructor()) ||                      ((_flags & MemLookFlags.Operator) == 0) != (meth == null || !meth.isOperator) ||                      ((_flags & MemLookFlags.Indexer) == 0) != !(prop is IndexerSymbol)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,SearchSingleType,The conditional expression  "(symCur is FieldSymbol field && !IsDelegateType(field.GetType()' typeCur) && !IsDynamicMember(symCur)) ||                          (prop != null && !IsDelegateType(prop.RetType' typeCur) && !IsDynamicMember(symCur))"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,MemberLookup,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookup.cs,Lookup,The conditional expression  "(typeIface != null || ifaces.Count > 0) && LookupInInterfaces(typeIface' ifaces) && typeCls2 != null"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,CMethodIterator,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MemberLookupResults.cs,CanUseCurrentSymbol,The conditional expression  "_mask == symbmask_t.MASK_MethodSymbol && (                          0 == (_flags & EXPRFLAG.EXF_CTOR) != !((MethodSymbol)_pCurrentSym).IsConstructor() ||                          0 == (_flags & EXPRFLAG.EXF_OPERATOR) != !((MethodSymbol)_pCurrentSym).isOperator) ||                      _mask == symbmask_t.MASK_PropertySymbol && !(_pCurrentSym is IndexerSymbol)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,LowerBoundArrayInference,The conditional expression  "pDest.isPredefType(PredefinedType.PT_G_IENUMERABLE) ||                  pDest.isPredefType(PredefinedType.PT_G_ICOLLECTION) ||                  pDest.isPredefType(PredefinedType.PT_G_ILIST) ||                  pDest.isPredefType(PredefinedType.PT_G_IREADONLYCOLLECTION) ||                  pDest.isPredefType(PredefinedType.PT_G_IREADONLYLIST)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,LowerBoundInterfaceInference,The conditional expression  "!pSource.isStructType() && !pSource.isClassType() &&                  !pSource.isInterfaceType() && !(pSource is TypeParameterType)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,UpperBoundArrayInference,The conditional expression  "pSource.isPredefType(PredefinedType.PT_G_IENUMERABLE) ||                  pSource.isPredefType(PredefinedType.PT_G_ICOLLECTION) ||                  pSource.isPredefType(PredefinedType.PT_G_ILIST) ||                  pSource.isPredefType(PredefinedType.PT_G_IREADONLYLIST) ||                  pSource.isPredefType(PredefinedType.PT_G_IREADONLYCOLLECTION)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,PredefinedMembers,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\PredefinedMembers.cs,LookupMethodWhileLoading,The conditional expression  "(methsym.GetAccess() == methodAccess || methodAccess == ACCESS.ACC_UNKNOWN) &&                          methsym.isStatic == isStatic &&                          methsym.isVirtual == isVirtual &&                          methsym.typeVars.Count == cMethodTyVars &&                          GetTypeManager().SubstEqualTypes(methsym.RetType' returnType' null' methsym.typeVars' SubstTypeFlags.DenormMeth) &&                          GetTypeManager().SubstEqualTypeArrays(methsym.Params' argumentTypes' (TypeArray)null'                              methsym.typeVars' SubstTypeFlags.DenormMeth)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,HasArrayConversionToInterface,The conditional expression  "!aggDest.isPredefAgg(PredefinedType.PT_G_ILIST) &&                  !aggDest.isPredefAgg(PredefinedType.PT_G_ICOLLECTION) &&                  !aggDest.isPredefAgg(PredefinedType.PT_G_IENUMERABLE) &&                  !aggDest.isPredefAgg(PredefinedType.PT_G_IREADONLYCOLLECTION) &&                  !aggDest.isPredefAgg(PredefinedType.PT_G_IREADONLYLIST)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,GenerateUserDefinedUnaryOperator,The conditional expression  "expr.Kind == ExpressionKind.Inc || expr.Kind == ExpressionKind.Dec ||                  expr.Kind == ExpressionKind.DecimalInc || expr.Kind == ExpressionKind.DecimalDec"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,FixLiftedUserDefinedBinaryOperators,The conditional expression  "!(fptype1 is AggregateType fat1)                  || !fat1.getAggregate().IsValueType()                  || !(fptype2 is AggregateType fat2)                  || !fat2.getAggregate().IsValueType()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,FixLiftedUserDefinedBinaryOperators,The conditional expression  "aatype1 is NullType || aatype1 == fptype1 && (aatype2 == nubfptype2 || aatype2 is NullType)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionTreeRewriter,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Tree\Visitors\ExpressionTreeRewriter.cs,FixLiftedUserDefinedBinaryOperators,The conditional expression  "aatype2 is NullType || aatype2 == fptype2 && (aatype1 == nubfptype1 || aatype1 is NullType)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,CType,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\Type.cs,IsCollectionType,The conditional expression  "(AssociatedSystemType.IsGenericType &&                   (AssociatedSystemType.GetGenericTypeDefinition() == typeof(IList<>) ||                    AssociatedSystemType.GetGenericTypeDefinition() == typeof(ICollection<>) ||                    AssociatedSystemType.GetGenericTypeDefinition() == typeof(IEnumerable<>) ||                    AssociatedSystemType.GetGenericTypeDefinition() == typeof(IReadOnlyList<>) ||                    AssociatedSystemType.GetGenericTypeDefinition() == typeof(IReadOnlyCollection<>) ||                    AssociatedSystemType.GetGenericTypeDefinition() == typeof(IDictionary<'>) ||                    AssociatedSystemType.GetGenericTypeDefinition() == typeof(IReadOnlyDictionary<'>))) ||                  AssociatedSystemType == typeof(System.Collections.IList) ||                  AssociatedSystemType == typeof(System.Collections.ICollection) ||                  AssociatedSystemType == typeof(System.Collections.IEnumerable) ||                  AssociatedSystemType == typeof(System.Collections.Specialized.INotifyCollectionChanged) ||                  AssociatedSystemType == typeof(System.ComponentModel.INotifyPropertyChanged)"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,SubstTypeArray,The conditional expression  "taSrc != null && taSrc.Count != 0 && ctx != null && !ctx.FNop()"  is complex.
Complex Conditional,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,GetBestAccessibleType,The conditional expression  "typeSrc is AggregateType aggSrc && (aggSrc.isInterfaceType() || aggSrc.isDelegateType()) && TryVarianceAdjustmentToGetAccessibleType(semanticChecker' bindingContext' aggSrc' out intermediateType)"  is complex.
Virtual Method Call from Constructor,Microsoft.CSharp.RuntimeBinder.Semantics,BinOpArgInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\BinOpArgInfo.cs,BinOpArgInfo,The constructor "BinOpArgInfo" calls a virtual method "StripNubs".
Virtual Method Call from Constructor,Microsoft.CSharp.RuntimeBinder.Semantics,BinOpArgInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\BinOpArgInfo.cs,BinOpArgInfo,The constructor "BinOpArgInfo" calls a virtual method "StripNubs".
Magic Number,Microsoft.CSharp.RuntimeBinder,BinderHelper,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\BinderHelper.cs,Cons,The following statement contains a magic number: if (sourceMiddle?.Length != 0)              {                  T[] array = new T[sourceMiddle.Length + 2];                  array[0] = sourceHead;                  array[array.Length - 1] = sourceLast;                  sourceMiddle.CopyTo(array' 1);                  return array;              }
Magic Number,Microsoft.CSharp.RuntimeBinder,CSharpBinaryOperationBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\CSharpBinaryOperationBinder.cs,CSharpBinaryOperationBinder,The following statement contains a magic number: Debug.Assert(_argumentInfo.Length == 2);
Magic Number,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,PopulateSymbolTableWithPayloadInformation,The following statement contains a magic number: if (callOrInvoke.Name.StartsWith("set_"' StringComparison.Ordinal) ||                  callOrInvoke.Name.StartsWith("get_"' StringComparison.Ordinal))              {                  symbolTable.PopulateSymbolTableWithName(                      callOrInvoke.Name.Substring(4)' //remove prefix                      callOrInvoke.TypeArguments'                      type);              }
Magic Number,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindBinaryOperation,The following statement contains a magic number: Debug.Assert(arguments.Length == 2);
Magic Number,Microsoft.CSharp.RuntimeBinder,RuntimeBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\RuntimeBinder.cs,BindAssignment,The following statement contains a magic number: Debug.Assert(arguments.Length >= 2);
Magic Number,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,CreateInheritanceHierarchyList,The following statement contains a magic number: if (type.IsInterface)              {                  Type[] ifaces = type.GetInterfaces();                    // Since IsWindowsRuntimeType() is rare' this is probably the final size                  list = new List<Type>(ifaces.Length + 2)                  {                      type                  };                  foreach (Type iface in type.GetInterfaces())                  {                      LoadSymbolsFromType(iface);                      list.Add(iface);                  }                    Type obj = typeof(object);                  LoadSymbolsFromType(obj);                  list.Add(obj);              }              else              {                  list = new List<Type> { type };                  for (Type parent = type.BaseType; parent != null; parent = parent.BaseType)                  {                      // Load it in the symbol table.                      LoadSymbolsFromType(parent);                        // Insert into our list of Types.                      list.Add(parent);                  }              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The following statement contains a magic number: AggregateType[] rgats = new AggregateType[2];
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The following statement contains a magic number: int ctypeLiftBest = 3;
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindUserDefinedConversion,The following statement contains a magic number: Debug.Assert(ctypeLiftBest <= 2);
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindConstantCast,The following statement contains a magic number: switch (ftDest)              {                  case FUNDTYPE.FT_I1:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = unchecked((sbyte)(valueInt & 0xFF));                      break;                  case FUNDTYPE.FT_I2:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = unchecked((short)(valueInt & 0xFFFF));                      break;                  case FUNDTYPE.FT_I4:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = unchecked((int)(valueInt & 0xFFFFFFFF));                      break;                  case FUNDTYPE.FT_I8:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      break;                  case FUNDTYPE.FT_U1:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = (byte)(valueInt & 0xFF);                      break;                  case FUNDTYPE.FT_U2:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = (ushort)(valueInt & 0xFFFF);                      break;                  case FUNDTYPE.FT_U4:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = (uint)(valueInt & 0xFFFFFFFF);                      break;                  case FUNDTYPE.FT_U8:                      if (!srcIntegral)                      {                          valueInt = (long)(ulong)valueFlt;                          const double two63 = 2147483648.0 * 4294967296.0;                          if (valueFlt < two63)                          {                              valueInt = (long)valueFlt;                          }                          else                          {                              valueInt = ((long)(valueFlt - two63)) + I64(0x8000000000000000);                          }                      }                      break;                  case FUNDTYPE.FT_R4:                  case FUNDTYPE.FT_R8:                      if (srcIntegral)                      {                          if (ftSrc == FUNDTYPE.FT_U8)                          {                              valueFlt = (double)(ulong)valueInt;                          }                          else                          {                              valueFlt = (double)valueInt;                          }                      }                      if (ftDest == FUNDTYPE.FT_R4)                      {                          // Force to R4 precision/range.                          float f;                          RoundToFloat(valueFlt' out f);                          valueFlt = f;                      }                      break;                  default:                      // We got here because of LAF or Refactoring. We must have had a parser                      // error here' because the user is not allowed to have a non-value type                      // being cast' but we need to bind for errors anyway.                      break;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,bindConstantCast,The following statement contains a magic number: switch (ftDest)              {                  case FUNDTYPE.FT_I1:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = unchecked((sbyte)(valueInt & 0xFF));                      break;                  case FUNDTYPE.FT_I2:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = unchecked((short)(valueInt & 0xFFFF));                      break;                  case FUNDTYPE.FT_I4:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = unchecked((int)(valueInt & 0xFFFFFFFF));                      break;                  case FUNDTYPE.FT_I8:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      break;                  case FUNDTYPE.FT_U1:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = (byte)(valueInt & 0xFF);                      break;                  case FUNDTYPE.FT_U2:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = (ushort)(valueInt & 0xFFFF);                      break;                  case FUNDTYPE.FT_U4:                      if (!srcIntegral)                      {                          valueInt = (long)valueFlt;                      }                      valueInt = (uint)(valueInt & 0xFFFFFFFF);                      break;                  case FUNDTYPE.FT_U8:                      if (!srcIntegral)                      {                          valueInt = (long)(ulong)valueFlt;                          const double two63 = 2147483648.0 * 4294967296.0;                          if (valueFlt < two63)                          {                              valueInt = (long)valueFlt;                          }                          else                          {                              valueInt = ((long)(valueFlt - two63)) + I64(0x8000000000000000);                          }                      }                      break;                  case FUNDTYPE.FT_R4:                  case FUNDTYPE.FT_R8:                      if (srcIntegral)                      {                          if (ftSrc == FUNDTYPE.FT_U8)                          {                              valueFlt = (double)(ulong)valueInt;                          }                          else                          {                              valueFlt = (double)valueInt;                          }                      }                      if (ftDest == FUNDTYPE.FT_R4)                      {                          // Force to R4 precision/range.                          float f;                          RoundToFloat(valueFlt' out f);                          valueFlt = f;                      }                      break;                  default:                      // We got here because of LAF or Refactoring. We must have had a parser                      // error here' because the user is not allowed to have a non-value type                      // being cast' but we need to bind for errors anyway.                      break;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_binopSignatures = new BinOpSig[]              {                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Integer'  8' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_UINT'     BinOpMask.Integer'  7' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_LONG'     BinOpMask.Integer'  6' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_ULONG'    BinOpMask.Integer'  5' BindIntBinOp'            OpSigFlags.Value'       BinOpFuncKind.IntBinOp      )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_LONG'     BinOpMask.Integer'  4' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  /* ERROR */                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_ULONG'    BinOpMask.Integer'  3' null'                    OpSigFlags.Value'       BinOpFuncKind.None          )'                  new BinOpSig (PredefinedType.PT_FLOAT'      PredefinedType.PT_FLOAT'    BinOpMask.Real'     1' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DOUBLE'     PredefinedType.PT_DOUBLE'   BinOpMask.Real'     0' BindRealBinOp'           OpSigFlags.Value'       BinOpFuncKind.RealBinOp     )'                  new BinOpSig (PredefinedType.PT_DECIMAL'    PredefinedType.PT_DECIMAL'  BinOpMask.Real'     0' BindDecBinOp'            OpSigFlags.Value'       BinOpFuncKind.DecBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Equal'    0' BindStrCmpOp'            OpSigFlags.Reference'   BinOpFuncKind.StrCmpOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_STRING'   BinOpMask.Add'      2' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_STRING'     PredefinedType.PT_OBJECT'   BinOpMask.Add'      1' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_OBJECT'     PredefinedType.PT_STRING'   BinOpMask.Add'      0' BindStrBinOp'            OpSigFlags.Reference'   BinOpFuncKind.StrBinOp      )'                  new BinOpSig (PredefinedType.PT_INT'        PredefinedType.PT_INT'      BinOpMask.Shift'    3' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_UINT'       PredefinedType.PT_INT'      BinOpMask.Shift'    2' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_LONG'       PredefinedType.PT_INT'      BinOpMask.Shift'    1' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_ULONG'      PredefinedType.PT_INT'      BinOpMask.Shift'    0' BindShiftOp'             OpSigFlags.Value'       BinOpFuncKind.ShiftOp       )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.BoolNorm' 0' BindBoolBinOp'           OpSigFlags.Value'       BinOpFuncKind.BoolBinOp     )'                  // Make boolean logical operators liftable so that they don't give funny short circuiting semantics.                  // This is for DDBugs 677075.                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Logical'  0' BindBoolBinOp'           OpSigFlags.BoolBit'     BinOpFuncKind.BoolBinOp     )'                  new BinOpSig (PredefinedType.PT_BOOL'       PredefinedType.PT_BOOL'     BinOpMask.Bitwise'  0' BindLiftedBoolBitwiseOp' OpSigFlags.BoolBit'     BinOpFuncKind.BoolBitwiseOp )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,ExpressionBinder,The following statement contains a magic number: g_rguos = new UnaOpSig[]              {                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.Signed'   7' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.Unsigned' 6' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.Signed'   5' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Unsigned' 4' BindIntUnaOp'    UnaOpFuncKind.IntUnaOp  )'                  /* ERROR */                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.Minus'    3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.Real'     1' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.Real'     0' BindRealUnaOp'   UnaOpFuncKind.RealUnaOp )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.Real'     0' BindDecUnaOp'    UnaOpFuncKind.DecUnaOp  )'                  new UnaOpSig( PredefinedType.PT_BOOL'       UnaOpMask.Bool'     0' BindBoolUnaOp'   UnaOpFuncKind.BoolUnaOp )'                  new UnaOpSig( PredefinedType.PT_INT'        UnaOpMask.IncDec'   6' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_UINT'       UnaOpMask.IncDec'   5' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_LONG'       UnaOpMask.IncDec'   4' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_ULONG'      UnaOpMask.IncDec'   3' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_FLOAT'      UnaOpMask.IncDec'   1' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DOUBLE'     UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'                  new UnaOpSig( PredefinedType.PT_DECIMAL'    UnaOpMask.IncDec'   0' null'            UnaOpFuncKind.None      )'              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConstantInRange,The following statement contains a magic number: if (ftSrc > FUNDTYPE.FT_LASTINTEGRAL)              {                  double dvalue = exprSrc.Val.DoubleVal;                    switch (ftDest)                  {                      case FUNDTYPE.FT_I1:                          if (dvalue > -0x81 && dvalue < 0x80)                              return true;                          break;                      case FUNDTYPE.FT_I2:                          if (dvalue > -0x8001 && dvalue < 0x8000)                              return true;                          break;                      case FUNDTYPE.FT_I4:                          if (dvalue > I64(-0x80000001) && dvalue < I64(0x80000000))                              return true;                          break;                      case FUNDTYPE.FT_I8:                          // 0x7FFFFFFFFFFFFFFFFFFF is rounded to 0x800000000000000000000 in 64 bit double precision                          // floating point representation. The conversion back to ulong is not possible.                          if (dvalue >= -9223372036854775808.0 && dvalue < 9223372036854775808.0)                          {                              return true;                          }                          break;                      case FUNDTYPE.FT_U1:                          if (dvalue > -1 && dvalue < 0x100)                              return true;                          break;                      case FUNDTYPE.FT_U2:                          if (dvalue > -1 && dvalue < 0x10000)                              return true;                          break;                      case FUNDTYPE.FT_U4:                          if (dvalue > -1 && dvalue < I64(0x100000000))                              return true;                          break;                      case FUNDTYPE.FT_U8:                          // 0xFFFFFFFFFFFFFFFFFFFF is rounded to 0x100000000000000000000 in 64 bit double precision                          // floating point representation. The conversion back to ulong is not possible.                          if (dvalue > -1.0 && dvalue < 18446744073709551616.0)                          {                              return true;                          }                          break;                      default:                          break;                  }                  return false;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConstantInRange,The following statement contains a magic number: if (ftSrc > FUNDTYPE.FT_LASTINTEGRAL)              {                  double dvalue = exprSrc.Val.DoubleVal;                    switch (ftDest)                  {                      case FUNDTYPE.FT_I1:                          if (dvalue > -0x81 && dvalue < 0x80)                              return true;                          break;                      case FUNDTYPE.FT_I2:                          if (dvalue > -0x8001 && dvalue < 0x8000)                              return true;                          break;                      case FUNDTYPE.FT_I4:                          if (dvalue > I64(-0x80000001) && dvalue < I64(0x80000000))                              return true;                          break;                      case FUNDTYPE.FT_I8:                          // 0x7FFFFFFFFFFFFFFFFFFF is rounded to 0x800000000000000000000 in 64 bit double precision                          // floating point representation. The conversion back to ulong is not possible.                          if (dvalue >= -9223372036854775808.0 && dvalue < 9223372036854775808.0)                          {                              return true;                          }                          break;                      case FUNDTYPE.FT_U1:                          if (dvalue > -1 && dvalue < 0x100)                              return true;                          break;                      case FUNDTYPE.FT_U2:                          if (dvalue > -1 && dvalue < 0x10000)                              return true;                          break;                      case FUNDTYPE.FT_U4:                          if (dvalue > -1 && dvalue < I64(0x100000000))                              return true;                          break;                      case FUNDTYPE.FT_U8:                          // 0xFFFFFFFFFFFFFFFFFFFF is rounded to 0x100000000000000000000 in 64 bit double precision                          // floating point representation. The conversion back to ulong is not possible.                          if (dvalue > -1.0 && dvalue < 18446744073709551616.0)                          {                              return true;                          }                          break;                      default:                          break;                  }                  return false;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConstantInRange,The following statement contains a magic number: if (ftSrc > FUNDTYPE.FT_LASTINTEGRAL)              {                  double dvalue = exprSrc.Val.DoubleVal;                    switch (ftDest)                  {                      case FUNDTYPE.FT_I1:                          if (dvalue > -0x81 && dvalue < 0x80)                              return true;                          break;                      case FUNDTYPE.FT_I2:                          if (dvalue > -0x8001 && dvalue < 0x8000)                              return true;                          break;                      case FUNDTYPE.FT_I4:                          if (dvalue > I64(-0x80000001) && dvalue < I64(0x80000000))                              return true;                          break;                      case FUNDTYPE.FT_I8:                          // 0x7FFFFFFFFFFFFFFFFFFF is rounded to 0x800000000000000000000 in 64 bit double precision                          // floating point representation. The conversion back to ulong is not possible.                          if (dvalue >= -9223372036854775808.0 && dvalue < 9223372036854775808.0)                          {                              return true;                          }                          break;                      case FUNDTYPE.FT_U1:                          if (dvalue > -1 && dvalue < 0x100)                              return true;                          break;                      case FUNDTYPE.FT_U2:                          if (dvalue > -1 && dvalue < 0x10000)                              return true;                          break;                      case FUNDTYPE.FT_U4:                          if (dvalue > -1 && dvalue < I64(0x100000000))                              return true;                          break;                      case FUNDTYPE.FT_U8:                          // 0xFFFFFFFFFFFFFFFFFFFF is rounded to 0x100000000000000000000 in 64 bit double precision                          // floating point representation. The conversion back to ulong is not possible.                          if (dvalue > -1.0 && dvalue < 18446744073709551616.0)                          {                              return true;                          }                          break;                      default:                          break;                  }                  return false;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConstantInRange,The following statement contains a magic number: if (ftSrc == FUNDTYPE.FT_U8)              {                  ulong value = exprSrc.UInt64Value;                    switch (ftDest)                  {                      case FUNDTYPE.FT_I1:                          if (value <= (ulong)sbyte.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_I2:                          if (value <= (ulong)short.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_I4:                          if (value <= int.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_I8:                          if (value <= long.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U1:                          if (value <= byte.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U2:                          if (value <= ushort.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U4:                          if (value <= uint.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U8:                          return true;                      default:                          break;                  }              }              else              {                  long value = exprSrc.Int64Value;                    switch (ftDest)                  {                      case FUNDTYPE.FT_I1:                          if (value >= -128 && value <= 127)                              return true;                          break;                      case FUNDTYPE.FT_I2:                          if (value >= -0x8000 && value <= 0x7fff)                              return true;                          break;                      case FUNDTYPE.FT_I4:                          if (value >= I64(-0x80000000) && value <= I64(0x7fffffff))                              return true;                          break;                      case FUNDTYPE.FT_I8:                          return true;                      case FUNDTYPE.FT_U1:                          if (value >= 0 && value <= 0xff)                              return true;                          break;                      case FUNDTYPE.FT_U2:                          if (value >= 0 && value <= 0xffff)                              return true;                          break;                      case FUNDTYPE.FT_U4:                          if (value >= 0 && value <= I64(0xffffffff))                              return true;                          break;                      case FUNDTYPE.FT_U8:                          if (value >= 0)                              return true;                          break;                      default:                          break;                  }              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,isConstantInRange,The following statement contains a magic number: if (ftSrc == FUNDTYPE.FT_U8)              {                  ulong value = exprSrc.UInt64Value;                    switch (ftDest)                  {                      case FUNDTYPE.FT_I1:                          if (value <= (ulong)sbyte.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_I2:                          if (value <= (ulong)short.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_I4:                          if (value <= int.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_I8:                          if (value <= long.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U1:                          if (value <= byte.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U2:                          if (value <= ushort.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U4:                          if (value <= uint.MaxValue)                              return true;                          break;                      case FUNDTYPE.FT_U8:                          return true;                      default:                          break;                  }              }              else              {                  long value = exprSrc.Int64Value;                    switch (ftDest)                  {                      case FUNDTYPE.FT_I1:                          if (value >= -128 && value <= 127)                              return true;                          break;                      case FUNDTYPE.FT_I2:                          if (value >= -0x8000 && value <= 0x7fff)                              return true;                          break;                      case FUNDTYPE.FT_I4:                          if (value >= I64(-0x80000000) && value <= I64(0x7fffffff))                              return true;                          break;                      case FUNDTYPE.FT_I8:                          return true;                      case FUNDTYPE.FT_U1:                          if (value >= 0 && value <= 0xff)                              return true;                          break;                      case FUNDTYPE.FT_U2:                          if (value >= 0 && value <= 0xffff)                              return true;                          break;                      case FUNDTYPE.FT_U4:                          if (value >= 0 && value <= I64(0xffffffff))                              return true;                          break;                      case FUNDTYPE.FT_U8:                          if (value >= 0)                              return true;                          break;                      default:                          break;                  }              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUserBoolOp,The following statement contains a magic number: Debug.Assert(pCall.MethWithInst.Meth().Params.Count == 2);
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetUserDefinedBinopArgumentTypes,The following statement contains a magic number: if (cats == 2 && rgats[0] == rgats[1])              {                  // Common case: they're the same.                  cats = 1;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,UserDefinedBinaryOperatorIsApplicable,The following statement contains a magic number: if (!method.isOperator || method.Params.Count != 2)              {                  return false;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,UserDefinedBinaryOperatorIsApplicable,The following statement contains a magic number: CType[] rgtype = new CType[2];
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,UserDefinedBinaryOperatorIsApplicable,The following statement contains a magic number: candidateList.Add(new CandidateFunctionMember(                  new MethPropWithInst(method' ats' BSYMMGR.EmptyTypeArray())'                  GetGlobalSymbols().AllocParams(2' rgtype)'                  2' // two lifted arguments                  false));
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,UserDefinedBinaryOperatorIsApplicable,The following statement contains a magic number: candidateList.Add(new CandidateFunctionMember(                  new MethPropWithInst(method' ats' BSYMMGR.EmptyTypeArray())'                  GetGlobalSymbols().AllocParams(2' rgtype)'                  2' // two lifted arguments                  false));
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUDBinop,The following statement contains a magic number: if (cats == 0)              {                  return null;              }              else if (cats == 1)              {                  GetApplicableUserDefinedBinaryOperatorCandidatesInBaseTypes(methFirst' ek'                      rgats[0]' arg1' arg2' fDontLift' null);              }              else              {                  Debug.Assert(cats == 2);                  AggregateType atsStop = GetApplicableUserDefinedBinaryOperatorCandidatesInBaseTypes(methFirst' ek'                      rgats[0]' arg1' arg2' fDontLift' null);                  GetApplicableUserDefinedBinaryOperatorCandidatesInBaseTypes(methFirst' ek'                      rgats[1]' arg1' arg2' fDontLift' atsStop);              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUDBinop,The following statement contains a magic number: info.carg = 2;
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindUDBinop,The following statement contains a magic number: if (pmethBest.ctypeLift != 0)              {                  Debug.Assert(pmethBest.ctypeLift == 2);                    return BindLiftedUDBinop(ek' arg1' arg2' pmethBest.@params' pmethBest.mpwi);              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,Operators,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\COperators.cs,GetOperatorByName,The following statement contains a magic number: Dictionary<Name' string> dict = new Dictionary<Name' string>(28)              {                  {NameManager.GetPredefinedName(PredefinedName.PN_OPEQUALS)' "equals"}'                  {NameManager.GetPredefinedName(PredefinedName.PN_OPCOMPARE)' "compare" }              };
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,MethodTypeInferrer,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\MethodTypeInferrer.cs,Fix,The following statement contains a magic number: if (_pExactBounds[iParam].Count >= 2)              {                  return false;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,ParentSymbol,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\ParentSymbol.cs,AddToChildList,The following statement contains a magic number: if (_lastChild == null)              {                  Debug.Assert(firstChild == null);                  firstChild = _lastChild = sym;              }              else              {                  _lastChild.nextChild = sym;                  _lastChild = sym;                  sym.nextChild = null;    #if DEBUG                  // Validate our chain.                  Symbol psym;                  int count = 400; // Limited the length of chain that we'll run - so debug perf isn't too bad.                  for (psym = this.firstChild; psym?.nextChild != null && --count > 0;)                      psym = psym.nextChild;                  Debug.Assert(_lastChild == psym || count == 0);  #endif              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,GetArray,The following statement contains a magic number: Debug.Assert(args > 0 && args < 32767);
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,GetArray,The following statement contains a magic number: switch (args)              {                  case 1:                      if (isSZArray)                      {                          goto case 2;                      }                      else                      {                          goto default;                      }                  case 2:                      name = NameManager.GetPredefinedName(PredefinedName.PN_ARRAY0 + args);                      break;                  default:                      name = NameManager.Add("[X" + args + 1);                      break;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,TypeManager,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeManager.cs,GetArray,The following statement contains a magic number: switch (args)              {                  case 1:                      if (isSZArray)                      {                          goto case 2;                      }                      else                      {                          goto default;                      }                  case 2:                      name = NameManager.GetPredefinedName(PredefinedName.PN_ARRAY0 + args);                      break;                  default:                      name = NameManager.Add("[X" + args + 1);                      break;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Semantics,KeyPair,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\TypeTable.cs,GetHashCode,The following statement contains a magic number: return (hash << 5) - hash + (_pKey2 == null ? 0 : _pKey2.GetHashCode());
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,NameTable,The following statement contains a magic number: _mask = 31;
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = key.Length;                  // use key.Length to eliminate the range check                  for (int i = 0; i < key.Length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = key.Length;                  // use key.Length to eliminate the range check                  for (int i = 0; i < key.Length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = key.Length;                  // use key.Length to eliminate the range check                  for (int i = 0; i < key.Length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = key.Length;                  // use key.Length to eliminate the range check                  for (int i = 0; i < key.Length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = length;                  for (int i = 0; i < length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = length;                  for (int i = 0; i < length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = length;                  for (int i = 0; i < length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,ComputeHashCode,The following statement contains a magic number: unchecked              {                  int hashCode = length;                  for (int i = 0; i < length; i++)                  {                      hashCode += (hashCode << 7) ^ key[i];                  }                    // mix it a bit more                  hashCode -= hashCode >> 17;                  hashCode -= hashCode >> 11;                  hashCode -= hashCode >> 5;                    return hashCode;              }
Magic Number,Microsoft.CSharp.RuntimeBinder.Syntax,NameTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Syntax\NameTable.cs,Grow,The following statement contains a magic number: int newMask = _mask * 2 + 1;
Duplicate Code,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetStandardAndLiftedBinopSignatures,The method contains a code clone-set at the following line numbers (starting from the method definition): ((36' 61)' (63' 88))
Duplicate Code,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,GetStandardAndLiftedBinopSignatures,The method contains a code clone-set at the following line numbers (starting from the method definition): ((118' 143)' (145' 170))
Missing Default,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,SetParameterAttributes,The following switch statement is missing a default case: switch (Type.GetTypeCode(defValue.GetType()))                          {                                case TypeCode.Byte:                                  cv = ConstVal.Get((byte)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_BYTE);                                  break;                                case TypeCode.Int16:                                  cv = ConstVal.Get((short)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_SHORT);                                  break;                                case TypeCode.Int32:                                  cv = ConstVal.Get((int)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_INT);                                  break;                                case TypeCode.Int64:                                  cv = ConstVal.Get((long)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_LONG);                                  break;                                case TypeCode.Single:                                  cv = ConstVal.Get((float)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_FLOAT);                                  break;                                case TypeCode.Double:                                  cv = ConstVal.Get((double)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_DOUBLE);                                  break;                                case TypeCode.Decimal:                                  cv = ConstVal.Get((decimal)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_DECIMAL);                                  break;                                case TypeCode.Char:                                  cv = ConstVal.Get((char)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_CHAR);                                  break;                                case TypeCode.Boolean:                                  cv = ConstVal.Get((bool)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_BOOL);                                  break;                                case TypeCode.SByte:                                  cv = ConstVal.Get((sbyte)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_SBYTE);                                  break;                                case TypeCode.UInt16:                                  cv = ConstVal.Get((ushort)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_USHORT);                                  break;                                case TypeCode.UInt32:                                  cv = ConstVal.Get((uint)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_UINT);                                  break;                                case TypeCode.UInt64:                                  cv = ConstVal.Get((ulong)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_ULONG);                                  break;                                case TypeCode.String:                                  cv = ConstVal.Get((string)defValue);                                  cvType = _semanticChecker.SymbolLoader.GetPredefindType(PredefinedType.PT_STRING);                                  break;                          }
Missing Default,Microsoft.CSharp.RuntimeBinder,SymbolTable,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\SymbolTable.cs,IsOperator,The following switch statement is missing a default case: switch (method.Name)                  {                      case SpecialNames.ImplicitConversion:                      case SpecialNames.ExplicitConversion:                      case SpecialNames.CLR_Add:                      case SpecialNames.CLR_Subtract:                      case SpecialNames.CLR_Multiply:                      case SpecialNames.CLR_Division:                      case SpecialNames.CLR_Modulus:                      case SpecialNames.CLR_LShift:                      case SpecialNames.CLR_RShift:                      case SpecialNames.CLR_LT:                      case SpecialNames.CLR_GT:                      case SpecialNames.CLR_LTE:                      case SpecialNames.CLR_GTE:                      case SpecialNames.CLR_Equality:                      case SpecialNames.CLR_Inequality:                      case SpecialNames.CLR_BitwiseAnd:                      case SpecialNames.CLR_ExclusiveOr:                      case SpecialNames.CLR_BitwiseOr:                      case SpecialNames.CLR_LogicalNot:                      case SpecialNames.CLR_UnaryNegation:                      case SpecialNames.CLR_UnaryPlus:                      case SpecialNames.CLR_OnesComplement:                      case SpecialNames.CLR_True:                      case SpecialNames.CLR_False:                      case SpecialNames.CLR_PreIncrement:                      case SpecialNames.CLR_PreDecrement:                          return true;                  }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,FindBestMethod,The following switch statement is missing a default case: switch (WhichMethodIsBetter(contender' candidate' pTypeThrough' args))                      {                          case BetterType.Right:                                // meaning m2 is better                              continue;                          case BetterType.Same:                          case BetterType.Neither:                              ambig1 = candidate;                              ambig2 = contender;                              break;                      }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,MarkAsIntermediateConversion,The following switch statement is missing a default case: switch (call.NullableCallLiftKind)                      {                          case NullableCallLiftKind.NotLifted:                              call.NullableCallLiftKind = NullableCallLiftKind.NotLiftedIntermediateConversion;                              break;                          case NullableCallLiftKind.NullableConversion:                              call.NullableCallLiftKind = NullableCallLiftKind.NullableIntermediateConversion;                              break;                          case NullableCallLiftKind.NullableConversionConstructor:                              pExpr = call.OptionalArguments;                              continue;                      }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,CheckPropertyAccess,The following switch statement is missing a default case: switch (SemanticChecker.CheckAccess2(mwt.Meth()' mwt.GetType()' ContextForMemberLookup()' type))              {                  case ACCESSERROR.ACCESSERROR_NOACCESSTHRU:                      throw ErrorContext.Error(ErrorCode.ERR_BadProtectedAccess' pwtSlot' type' ContextForMemberLookup());                  case ACCESSERROR.ACCESSERROR_NOACCESS:                      throw ErrorContext.Error(mwt.Meth().isSetAccessor() ? ErrorCode.ERR_InaccessibleSetter : ErrorCode.ERR_InaccessibleGetter' pwtSlot);              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,checkLvalue,The following switch statement is missing a default case: switch (expr.Kind)              {                  case ExpressionKind.Property:                      ExprProperty prop = (ExprProperty)expr;                      if (!prop.MethWithTypeSet)                      {                          // Assigning to a property without a setter.                          // If we have                          // bool? b = true; (bool)b = false;                          // then this is realized immediately as                           // b.Value = false;                           // and no ExpressionKind.EK_CAST is generated. We'd rather not give a "you're writing                          // to a read-only property" error in the case where the property access                          // is not explicit in the source code.  Fortunately in this case the                          // cast is still hanging around in the parse tree' so we can look for it.                            // POSSIBLE ERROR: It would be nice to also give this error for other situations                          // POSSIBLE ERROR: in which the user is attempting to assign to a value' such as                          // POSSIBLE ERROR: an explicit (bool)b.Value = false;                          // POSSIBLE ERROR: Unfortunately we cannot use this trick in that situation because                          // POSSIBLE ERROR: we've already discarded the OperatorKind.OP_CAST node.  (This is an SyntaxKind.Dot).                            // SPEC VIOLATION: More generally:                          // SPEC VIOLATION: The spec states that the result of any cast is a value' not a                          // SPEC VIOLATION: variable. Unfortunately we do not correctly implement this                          // SPEC VIOLATION: and we probably should not start implementing it because this                          // SPEC VIOLATION: would be a breaking change.  We currently discard "no op" casts                          // SPEC VIOLATION: very aggressively rather than generating an ExpressionKind.EK_CAST node.                            throw ErrorContext.Error(ErrorCode.ERR_AssgReadonlyProp' prop.PropWithTypeSlot);                      }                      break;                    case ExpressionKind.BoundLambda:                  case ExpressionKind.Constant:                      throw ErrorContext.Error(GetStandardLvalueError(kind));              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,IsEnumArithmeticBinOp,The following switch statement is missing a default case: switch (ek)              {                  case ExpressionKind.Add:                      return info.typeRaw1.isEnumType() ^ info.typeRaw2.isEnumType();                  case ExpressionKind.Subtract:                      return info.typeRaw1.isEnumType() | info.typeRaw2.isEnumType();              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,WhichBofsIsBetter,The following switch statement is missing a default case: switch (bt2)              {                  case BetterType.Left:                      res--;                      break;                    case BetterType.Right:                      res++;                      break;              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionBinder,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Binding\Better.cs,BindDelBinOp,The following switch statement is missing a default case: switch (ek)              {                  case ExpressionKind.Add:                      predefMeth = PREDEFMETH.PM_DELEGATE_COMBINE;                      RetType = arg1.Type;                      ek = ExpressionKind.DelegateAdd;                      break;                    case ExpressionKind.Subtract:                      predefMeth = PREDEFMETH.PM_DELEGATE_REMOVE;                      RetType = arg1.Type;                      ek = ExpressionKind.DelegateSubtract;                      break;                    case ExpressionKind.Eq:                      predefMeth = PREDEFMETH.PM_DELEGATE_OPEQUALITY;                      RetType = GetPredefindType(PredefinedType.PT_BOOL);                      ek = ExpressionKind.DelegateEq;                      break;                    case ExpressionKind.NotEq:                      predefMeth = PREDEFMETH.PM_DELEGATE_OPINEQUALITY;                      RetType = GetPredefindType(PredefinedType.PT_BOOL);                      ek = ExpressionKind.DelegateNotEq;                      break;              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ConstVal,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ConstVal.cs,IsDefault,The following switch statement is missing a default case: switch (Type.GetTypeCode(o.GetType()))              {                  case TypeCode.Boolean:                      return default(bool).Equals(o);                  case TypeCode.SByte:                      return default(sbyte).Equals(o);                  case TypeCode.Byte:                      return default(byte).Equals(o);                  case TypeCode.Int16:                      return default(short).Equals(o);                  case TypeCode.UInt16:                      return default(ushort).Equals(o);                  case TypeCode.Int32:                      return default(int).Equals(o);                  case TypeCode.UInt32:                      return default(uint).Equals(o);                  case TypeCode.Int64:                      return default(long).Equals(o);                  case TypeCode.UInt64:                      return default(ulong).Equals(o);                  case TypeCode.Single:                      return default(float).Equals(o);                  case TypeCode.Double:                      return default(double).Equals(o);                  case TypeCode.Decimal:                      return default(decimal).Equals(o);                  case TypeCode.Char:                      return default(char).Equals(o);              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ConstVal,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ConstVal.cs,GetDefaultValue,The following switch statement is missing a default case: switch (kind)              {                  case ConstValKind.Int:                      return new ConstVal(s_zeroInt32);                    case ConstValKind.Double:                      return new ConstVal(0.0);                    case ConstValKind.Long:                      return new ConstVal(0L);                    case ConstValKind.Decimal:                      return new ConstVal(0M);                    case ConstValKind.Float:                      return new ConstVal(0F);                    case ConstValKind.Boolean:                      return new ConstVal(s_false);              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,ExpressionKindExtensions,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\ExpressionKind.cs,IsUnaryOperator,The following switch statement is missing a default case: switch (kind)              {                  case ExpressionKind.True:                  case ExpressionKind.False:                  case ExpressionKind.Inc:                  case ExpressionKind.Dec:                  case ExpressionKind.LogicalNot:                  case ExpressionKind.Negate:                  case ExpressionKind.UnaryPlus:                  case ExpressionKind.BitwiseNot:                  case ExpressionKind.Addr:                  case ExpressionKind.DecimalNegate:                  case ExpressionKind.DecimalInc:                  case ExpressionKind.DecimalDec:                      return true;              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,CSemanticChecker,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\SemanticChecker.cs,CheckAccess2,The following switch statement is missing a default case: switch (symCheck.getKind())              {                  case SYMKIND.SK_MethodSymbol:                  case SYMKIND.SK_PropertySymbol:                  case SYMKIND.SK_FieldSymbol:                  case SYMKIND.SK_EventSymbol:                      Debug.Assert(atsCheck != null);                      break;              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,GetAggTypeSym,The following switch statement is missing a default case: switch (typeSym.GetTypeKind())              {                  case TypeKind.TK_AggregateType:                      return (AggregateType)typeSym;                  case TypeKind.TK_ArrayType:                      return GetPredefindType(PredefinedType.PT_ARRAY);                  case TypeKind.TK_NullableType:                      return ((NullableType)typeSym).GetAts();              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,HasImplicitReferenceConversion,The following switch statement is missing a default case: switch (aggSource.GetOwningAggregate().AggKind())                      {                          case AggKindEnum.Class:                              switch (aggDest.GetOwningAggregate().AggKind())                              {                                  case AggKindEnum.Class:                                      // * From any class type S to any class type T provided S is derived from T.                                      return IsBaseClass(aggSource' aggDest);                                    case AggKindEnum.Interface:                                      // ORIGINAL RULES:                                      //    // * From any class type S to any interface type T provided S implements T.                                      //    if (pSource.isClassType() && pDest.isInterfaceType() && IsBaseInterface(pSource' pDest))                                      //    {                                      //        return true;                                      //    }                                      //    // * from any interface type S to any interface type T' provided S is derived from T.                                      //    if (pSource.isInterfaceType() && pDest.isInterfaceType() && IsBaseInterface(pSource' pDest))                                      //    {                                      //        return true;                                      //    }                                        // VARIANCE EXTENSIONS:                                      // * From any class type S to any interface type T provided S implements an interface                                      //   convertible to T.                                      // * From any interface type S to any interface type T provided S implements an interface                                      //   convertible to T.                                      // * From any interface type S to any interface type T provided S is not T and S is                                       //   an interface convertible to T.                                        return HasAnyBaseInterfaceConversion(aggSource' aggDest);                              }                                break;                            case AggKindEnum.Interface:                              if (aggDest.isInterfaceType())                              {                                  return HasAnyBaseInterfaceConversion(aggSource' aggDest)                                         || HasInterfaceConversion(aggSource' aggDest);                              }                                break;                            case AggKindEnum.Delegate:                              // * From any delegate type to System.Delegate                              //                               // SPEC OMISSION:                              //                               // The spec should actually say                              //                              // * From any delegate type to System.Delegate                               // * From any delegate type to System.MulticastDelegate                              // * From any delegate type to any interface implemented by System.MulticastDelegate                              if (aggDest.isPredefType(PredefinedType.PT_MULTIDEL)                                  || aggDest.isPredefType(PredefinedType.PT_DELEGATE) || IsBaseInterface(                                      GetPredefindType(PredefinedType.PT_MULTIDEL)' aggDest))                              {                                  return true;                              }                                // VARIANCE EXTENSION:                              // * From any delegate type S to a delegate type T provided S is not T and                              //   S is a delegate convertible to T                              return pDest.isDelegateType() && HasDelegateConversion(aggSource' aggDest);                      }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,SymbolLoader,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolLoader.cs,HasImplicitReferenceConversion,The following switch statement is missing a default case: switch (aggDest.GetOwningAggregate().AggKind())                              {                                  case AggKindEnum.Class:                                      // * From any class type S to any class type T provided S is derived from T.                                      return IsBaseClass(aggSource' aggDest);                                    case AggKindEnum.Interface:                                      // ORIGINAL RULES:                                      //    // * From any class type S to any interface type T provided S implements T.                                      //    if (pSource.isClassType() && pDest.isInterfaceType() && IsBaseInterface(pSource' pDest))                                      //    {                                      //        return true;                                      //    }                                      //    // * from any interface type S to any interface type T' provided S is derived from T.                                      //    if (pSource.isInterfaceType() && pDest.isInterfaceType() && IsBaseInterface(pSource' pDest))                                      //    {                                      //        return true;                                      //    }                                        // VARIANCE EXTENSIONS:                                      // * From any class type S to any interface type T provided S implements an interface                                      //   convertible to T.                                      // * From any interface type S to any interface type T provided S implements an interface                                      //   convertible to T.                                      // * From any interface type S to any interface type T provided S is not T and S is                                       //   an interface convertible to T.                                        return HasAnyBaseInterfaceConversion(aggSource' aggDest);                              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,SYMTBL,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Symbols\SymbolTable.cs,InsertChildNoGrow,The following switch statement is missing a default case: switch (child.getKind())              {                  case SYMKIND.SK_Scope:                  case SYMKIND.SK_LocalVariableSymbol:                      return;              }
Missing Default,Microsoft.CSharp.RuntimeBinder.Semantics,CType,C:\selectedRepos\dotnet_corefx\src\Microsoft.CSharp\src\Microsoft\CSharp\RuntimeBinder\Semantics\Types\Type.cs,CalculateAssociatedSystemType,The following switch statement is missing a default case: switch (src.GetTypeKind())              {                  case TypeKind.TK_ArrayType:                      ArrayType a = (ArrayType)src;                      Type elementType = a.GetElementType().AssociatedSystemType;                      result = a.IsSZArray ? elementType.MakeArrayType() : elementType.MakeArrayType(a.rank);                      break;                    case TypeKind.TK_NullableType:                      NullableType n = (NullableType)src;                      Type underlyingType = n.GetUnderlyingType().AssociatedSystemType;                      result = typeof(Nullable<>).MakeGenericType(underlyingType);                      break;                    case TypeKind.TK_PointerType:                      PointerType p = (PointerType)src;                      Type referentType = p.GetReferentType().AssociatedSystemType;                      result = referentType.MakePointerType();                      break;                    case TypeKind.TK_ParameterModifierType:                      ParameterModifierType r = (ParameterModifierType)src;                      Type parameterType = r.GetParameterType().AssociatedSystemType;                      result = parameterType.MakeByRefType();                      break;                    case TypeKind.TK_AggregateType:                      result = CalculateAssociatedSystemTypeForAggregate((AggregateType)src);                      break;                    case TypeKind.TK_TypeParameterType:                      TypeParameterType t = (TypeParameterType)src;                      if (t.IsMethodTypeParameter())                      {                          MethodInfo meth = ((MethodSymbol)t.GetOwningSymbol()).AssociatedMemberInfo as MethodInfo;                          result = meth.GetGenericArguments()[t.GetIndexInOwnParameters()];                      }                      else                      {                          Type parentType = ((AggregateSymbol)t.GetOwningSymbol()).AssociatedSystemType;                          result = parentType.GetGenericArguments()[t.GetIndexInOwnParameters()];                      }                      break;              }
