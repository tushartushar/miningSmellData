Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,The method has 122 lines of code.
Long Method,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireReaderLock,The method has 179 lines of code.
Long Method,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireWriterLock,The method has 144 lines of code.
Long Method,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,ReleaseReaderLock,The method has 110 lines of code.
Long Method,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,DowngradeFromWriterLock,The method has 117 lines of code.
Complex Method,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,Cyclomatic complexity of the method is 8
Complex Method,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,RemoveParticipants,Cyclomatic complexity of the method is 8
Complex Method,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,Cyclomatic complexity of the method is 15
Complex Method,System.Threading,ThreadLocalLockEntry,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,GetOrCreateCurrentSlow,Cyclomatic complexity of the method is 9
Long Identifier,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,,The length of the parameter IncorrectButCompatibleNotOwnerExceptionHResult is 46.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH is 39.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW is 35.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT is 39.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_INSUFFICIENTEXECUTIONSTACK is 32.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_LOADING_REFERENCE_ASSEMBLY is 32.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_MISSINGSATELLITEASSEMBLY is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_MODULE_HASH_CHECK_FAILED is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_WAITHANDLECANNOTBEOPENED is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_CODE_DOWNLOAD_DISABLED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_HOST_GAC_ASM_MISMATCH is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_INVALID_PRIVATE_ASM_LOCATION is 37.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_PRIVATE_ASM_DISALLOWED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_SIGNATURE_CHECK_FAILED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter SECURITY_E_INCOMPATIBLE_EVIDENCE is 32.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // Calculating the first phase for that participant' if the current phase already finished return the next phase else return the current phase " is 142.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // phase odd even' so that means it didn't yet change the phase count' so currentPhase +1 is returned' otherwise currentPhase is returned " is 137.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // If this participant is going to join the next phase' which means the postPhaseAction is being running' this participants must wait until this done " is 149.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // Without that' if the postPhaseAction takes long time' this means the event that the current participant is going to wait on is still set " is 139.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    //This else to fix the racing where the current phase has been finished' m_currentPhase has been updated but the events have not been set/reset yet " is 147.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,The length of the statement  "                    // otherwise when this participant calls SignalAndWait it will wait on a set event however all other participants have not arrived yet. " is 135.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                // This can be detected if the current is zero which means all participants for that phase has arrived and the phase number is not changed yet " is 142.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "            catch (ObjectDisposedException)// in case a race happen where one of the thread returned from SignalAndWait and the current thread calls Wait on a disposed event " is 161.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                    // If the timeout expired and the phase has just finished' return true and this is considered as succeeded SignalAndWait " is 120.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                        // The current phase has been finished' but we shouldn't return before the events are set/reset otherwise this thread could start " is 129.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,The length of the statement  "                        // next phase and the appropriate event has not reset yet which could make it return immediately from the next phase SignalAndWait " is 130.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SetResetEvents,The length of the statement  "            // Increment the phase count using Volatile class because m_currentPhase is 64 bit long type' that could cause torn write on 32 bit machines " is 140.
Long Statement,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,DiscontinuousWait,The length of the statement  "                //if the maxwait exceeded 10 seconds then we will stop increasing the maxWait time and keep it 10 seconds' otherwise keep doubling it " is 133.
Long Statement,System.Threading,CountdownEvent,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\CountdownEvent.cs,Signal,The length of the statement  "                //if the count is decremented below zero' then throw' it's OK to keep the count negative' and we shouldn't set the event here " is 125.
Complex Conditional,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireReaderLock,The conditional expression  "knownState < LockStates.ReadersMask ||                          (                              (knownState & LockStates.ReaderSignaled) != 0 &&                              (knownState & LockStates.Writer) == 0 &&                              (                                  // A waiting reader' after successfully completing the wait' expects that it can become a                                  // reader' so ensure that there is enough room for waiting readers and this potential reader.                                  (                                      (knownState & LockStates.ReadersMask) +                                      ((knownState & LockStates.WaitingReadersMask) >> LockStates.WaitingReadersShift)                                  ) <= LockStates.ReadersMask - 2                              )                          )"  is complex.
Complex Conditional,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,DowngradeFromWriterLock,The conditional expression  "(flags & LockCookieFlags.Invalid) != 0 ||                  lockCookie._threadID != threadID ||                  (                      // Cannot downgrade to a writer level that is greater than or equal to the current                      (flags & (LockCookieFlags.OwnedWriter | LockCookieFlags.OwnedNone)) != 0 &&                      _writerLevel <= requestedWriterLevel                  )"  is complex.
Magic Number,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,GetCurrentTotal,The following statement contains a magic number: current = (int)((currentTotal & CURRENT_MASK) >> 16);
Magic Number,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SetCurrentTotal,The following statement contains a magic number: int newCurrentTotal = (current << 16) | total;
Magic Number,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,AddParticipants,The following statement contains a magic number: while (true)              {                  int currentTotal = _currentTotalCount;                  int total;                  int current;                  bool sense;                  GetCurrentTotal(currentTotal' out current' out total' out sense);                  if (participantCount + total > MAX_PARTICIPANTS) //overflow                  {                      throw new ArgumentOutOfRangeException(nameof(participantCount)'                          SR.Barrier_AddParticipants_Overflow_ArgumentOutOfRange);                  }                    if (SetCurrentTotal(currentTotal' current' total + participantCount' sense))                  {                      // Calculating the first phase for that participant' if the current phase already finished return the next phase else return the current phase                      // To know that the current phase is  the sense doesn't match the                       // phase odd even' so that means it didn't yet change the phase count' so currentPhase +1 is returned' otherwise currentPhase is returned                      long currPhase = CurrentPhaseNumber;                      newPhase = (sense != (currPhase % 2 == 0)) ? currPhase + 1 : currPhase;                        // If this participant is going to join the next phase' which means the postPhaseAction is being running' this participants must wait until this done                      // and its event is reset.                      // Without that' if the postPhaseAction takes long time' this means the event that the current participant is going to wait on is still set                      // (FinishPhase didn't reset it yet) so it should wait until it reset                      if (newPhase != currPhase)                      {                          // Wait on the opposite event                          if (sense)                          {                              _oddEvent.Wait();                          }                          else                          {                              _evenEvent.Wait();                          }                      }                        //This else to fix the racing where the current phase has been finished' m_currentPhase has been updated but the events have not been set/reset yet                      // otherwise when this participant calls SignalAndWait it will wait on a set event however all other participants have not arrived yet.                      else                      {                          if (sense && _evenEvent.IsSet)                              _evenEvent.Reset();                          else if (!sense && _oddEvent.IsSet)                              _oddEvent.Reset();                      }                      break;                  }                  spinner.SpinOnce();              }
Magic Number,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,SignalAndWait,The following statement contains a magic number: while (true)              {                  currentTotal = _currentTotalCount;                  GetCurrentTotal(currentTotal' out current' out total' out sense);                  phase = CurrentPhaseNumber;                  // throw if zero participants                  if (total == 0)                  {                      throw new InvalidOperationException(SR.Barrier_SignalAndWait_InvalidOperation_ZeroTotal);                  }                  // Try to detect if the number of threads for this phase exceeded the total number of participants or not                  // This can be detected if the current is zero which means all participants for that phase has arrived and the phase number is not changed yet                  if (current == 0 && sense != (CurrentPhaseNumber % 2 == 0))                  {                      throw new InvalidOperationException(SR.Barrier_SignalAndWait_InvalidOperation_ThreadsExceeded);                  }                  //This is the last thread' finish the phase                  if (current + 1 == total)                  {                      if (SetCurrentTotal(currentTotal' 0' total' !sense))                      {                          if (CdsSyncEtwBCLProvider.Log.IsEnabled())                          {                              CdsSyncEtwBCLProvider.Log.Barrier_PhaseFinished(sense' CurrentPhaseNumber);                          }                          FinishPhase(sense);                          return true;                      }                  }                  else if (SetCurrentTotal(currentTotal' current + 1' total' sense))                  {                      break;                  }                    spinner.SpinOnce();              }
Magic Number,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,DiscontinuousWait,The following statement contains a magic number: int maxWait = 100;
Magic Number,System.Threading,Barrier,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\Barrier.cs,DiscontinuousWait,The following statement contains a magic number: int waitTimeCeiling = 10000;
Magic Number,System.Threading,CdsSyncEtwBCLProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\CDSsyncETWBCLProvider.cs,Barrier_PhaseFinished,The following statement contains a magic number: if (IsEnabled(EventLevel.Verbose' ALL_KEYWORDS))              {                  // WriteEvent(BARRIER_PHASEFINISHED_ID' currentSense' phaseNum);                    // There is no explicit WriteEvent() overload matching this event's bool+long fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an                   // object allocation every time this event is fired. To prevent that problem we will                   // call WriteEventCore()' which works with a stack based EventData array populated with                   // the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[2];                        Int32 senseAsInt32 = currentSense ? 1 : 0; // write out Boolean as Int32                      eventPayload[0].Size = sizeof(int);                      eventPayload[0].DataPointer = ((IntPtr)(&senseAsInt32));                      eventPayload[1].Size = sizeof(long);                      eventPayload[1].DataPointer = ((IntPtr)(&phaseNum));                        WriteEventCore(BARRIER_PHASEFINISHED_ID' 2' eventPayload);                  }              }
Magic Number,System.Threading,CdsSyncEtwBCLProvider,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\CDSsyncETWBCLProvider.cs,Barrier_PhaseFinished,The following statement contains a magic number: if (IsEnabled(EventLevel.Verbose' ALL_KEYWORDS))              {                  // WriteEvent(BARRIER_PHASEFINISHED_ID' currentSense' phaseNum);                    // There is no explicit WriteEvent() overload matching this event's bool+long fields.                  // Therefore calling WriteEvent() would hit the "params" overload' which leads to an                   // object allocation every time this event is fired. To prevent that problem we will                   // call WriteEventCore()' which works with a stack based EventData array populated with                   // the event fields.                  unsafe                  {                      EventData* eventPayload = stackalloc EventData[2];                        Int32 senseAsInt32 = currentSense ? 1 : 0; // write out Boolean as Int32                      eventPayload[0].Size = sizeof(int);                      eventPayload[0].DataPointer = ((IntPtr)(&senseAsInt32));                      eventPayload[1].Size = sizeof(long);                      eventPayload[1].DataPointer = ((IntPtr)(&phaseNum));                        WriteEventCore(BARRIER_PHASEFINISHED_ID' 2' eventPayload);                  }              }
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireReaderLock,The following statement contains a magic number: if (Interlocked.CompareExchange(ref _state' LockStates.Reader' 0) == 0)              {                  Debug.Assert(threadLocalLockEntry._readerLevel == 0);              }              // Check for nested reader              else if (threadLocalLockEntry._readerLevel > 0)              {                  Debug.Assert((_state & LockStates.ReadersMask) != 0);                    if (threadLocalLockEntry._readerLevel == MaxAcquireCount)                  {                      throw new OverflowException(SR.Overflow_UInt16);                  }                  ++threadLocalLockEntry._readerLevel;                  return;              }              // Check if the thread already has writer lock              else if (_writerID == GetCurrentThreadID())              {                  AcquireWriterLock(millisecondsTimeout);                  Debug.Assert(threadLocalLockEntry.IsFree);                  return;              }              else              {                  int spinCount = 0;                  int currentState = _state;                  do                  {                      int knownState = currentState;                        // Reader need not wait if there are only readers and no writer                      if (knownState < LockStates.ReadersMask ||                          (                              (knownState & LockStates.ReaderSignaled) != 0 &&                              (knownState & LockStates.Writer) == 0 &&                              (                                  // A waiting reader' after successfully completing the wait' expects that it can become a                                  // reader' so ensure that there is enough room for waiting readers and this potential reader.                                  (                                      (knownState & LockStates.ReadersMask) +                                      ((knownState & LockStates.WaitingReadersMask) >> LockStates.WaitingReadersShift)                                  ) <= LockStates.ReadersMask - 2                              )                          ))                      {                          // Add to readers                          currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.Reader' knownState);                          if (currentState == knownState)                          {                              // One more reader                              break;                          }                          continue;                      }                        // Check for too many readers or waiting readers' or if signaling is in progress. The check for signaling                      // prevents new readers from starting to wait for a read lock while the previous set of waiting readers are                      // being granted their lock. This is necessary to guarantee thread safety for the 'finally' block below.                      if ((knownState & LockStates.ReadersMask) == LockStates.ReadersMask ||                          (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReadersMask ||                          (knownState & LockStates.CachingEvents) == LockStates.ReaderSignaled)                      {                          // Sleep for a while' then update to the latest state and try again                          int sleepDurationMilliseconds = 100;                          if ((knownState & LockStates.ReadersMask) == LockStates.ReadersMask ||                              (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReadersMask)                          {                              sleepDurationMilliseconds = 1000;                          }                          RuntimeThread.Sleep(sleepDurationMilliseconds);                          spinCount = 0;                          currentState = _state;                          continue;                      }                        ++spinCount;                        // Check if events are being cached. The purpose of this check is that "caching" events could involve                      // disposing one or both of {_readerEvent' _writerEvent}. This check prevents the waiting code below from                      // trying to use these events during this dangerous time' and instead causes the loop to spin until the                      // caching state is cleared and events can be recreated. See ReleaseEvents() and callers.                      if ((knownState & LockStates.CachingEvents) == LockStates.CachingEvents)                      {                          if (spinCount > DefaultSpinCount)                          {                              RuntimeThread.Sleep(1);                              spinCount = 0;                          }                          currentState = _state;                          continue;                      }                        // Check spin count                      if (spinCount <= DefaultSpinCount)                      {                          currentState = _state;                          continue;                      }                        // Add to waiting readers                      currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.WaitingReader' knownState);                      if (currentState != knownState)                      {                          continue;                      }                        int modifyState = -LockStates.WaitingReader;                      ManualResetEventSlim readerEvent = null;                      bool waitSucceeded = false;                      try                      {                          readerEvent = GetOrCreateReaderEvent();                          waitSucceeded = readerEvent.Wait(millisecondsTimeout);                            // AcquireReaderLock cannot have reentry via pumping while waiting for readerEvent' so                          // threadLocalLockEntry's state should not change from underneath us                          Debug.Assert(threadLocalLockEntry.HasLockID(_lockID));                            if (waitSucceeded)                          {                              // Become a reader                              Debug.Assert((_state & LockStates.ReaderSignaled) != 0);                              Debug.Assert((_state & LockStates.ReadersMask) < LockStates.ReadersMask);                              modifyState += LockStates.Reader;                          }                      }                      finally                      {                          // Make the state changes determined above                          knownState = Interlocked.Add(ref _state' modifyState) - modifyState;                            if (!waitSucceeded)                          {                              // Check for last signaled waiting reader. This is a rare case where the wait timed out' but shortly                              // afterwards' waiting readers got released' hence the ReaderSignaled bit is set. In that case'                              // remove the ReaderSignaled bit from the state' acquire a read lock' and release it. While the                              // ReaderSignaled bit is set' new requests for a write lock must spin or wait to acquire the lock'                              // so it is safe for this thread to acquire a read lock and call ReleaseReaderLock() as a shortcut                              // to do the work of releasing other waiters.                              if ((knownState & LockStates.ReaderSignaled) != 0 &&                                  (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReader)                              {                                  if (readerEvent == null)                                  {                                      readerEvent = _readerEvent;                                      Debug.Assert(readerEvent != null);                                  }                                    // Ensure the event is signaled before resetting it' since the ReaderSignaled state is set                                  // before the event is set.                                  readerEvent.Wait();                                  Debug.Assert((_state & LockStates.ReadersMask) < LockStates.ReadersMask);                                    // Reset the event and lower reader signaled flag                                  readerEvent.Reset();                                  Interlocked.Add(ref _state' LockStates.Reader - LockStates.ReaderSignaled);                                    // Honor the orginal status                                  ++threadLocalLockEntry._readerLevel;                                  ReleaseReaderLock();                              }                                Debug.Assert(threadLocalLockEntry.IsFree);                          }                      }                        if (!waitSucceeded)                      {                          throw GetTimeoutException();                      }                        // Check for last signaled waiting reader                      Debug.Assert((knownState & LockStates.ReaderSignaled) != 0);                      Debug.Assert((knownState & LockStates.ReadersMask) < LockStates.ReadersMask);                      if ((knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReader)                      {                          // Reset the event and the reader signaled flag                          readerEvent.Reset();                          Interlocked.Add(ref _state' -LockStates.ReaderSignaled);                      }                        break;                  } while (YieldProcessor());              }
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireReaderLock,The following statement contains a magic number: if (Interlocked.CompareExchange(ref _state' LockStates.Reader' 0) == 0)              {                  Debug.Assert(threadLocalLockEntry._readerLevel == 0);              }              // Check for nested reader              else if (threadLocalLockEntry._readerLevel > 0)              {                  Debug.Assert((_state & LockStates.ReadersMask) != 0);                    if (threadLocalLockEntry._readerLevel == MaxAcquireCount)                  {                      throw new OverflowException(SR.Overflow_UInt16);                  }                  ++threadLocalLockEntry._readerLevel;                  return;              }              // Check if the thread already has writer lock              else if (_writerID == GetCurrentThreadID())              {                  AcquireWriterLock(millisecondsTimeout);                  Debug.Assert(threadLocalLockEntry.IsFree);                  return;              }              else              {                  int spinCount = 0;                  int currentState = _state;                  do                  {                      int knownState = currentState;                        // Reader need not wait if there are only readers and no writer                      if (knownState < LockStates.ReadersMask ||                          (                              (knownState & LockStates.ReaderSignaled) != 0 &&                              (knownState & LockStates.Writer) == 0 &&                              (                                  // A waiting reader' after successfully completing the wait' expects that it can become a                                  // reader' so ensure that there is enough room for waiting readers and this potential reader.                                  (                                      (knownState & LockStates.ReadersMask) +                                      ((knownState & LockStates.WaitingReadersMask) >> LockStates.WaitingReadersShift)                                  ) <= LockStates.ReadersMask - 2                              )                          ))                      {                          // Add to readers                          currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.Reader' knownState);                          if (currentState == knownState)                          {                              // One more reader                              break;                          }                          continue;                      }                        // Check for too many readers or waiting readers' or if signaling is in progress. The check for signaling                      // prevents new readers from starting to wait for a read lock while the previous set of waiting readers are                      // being granted their lock. This is necessary to guarantee thread safety for the 'finally' block below.                      if ((knownState & LockStates.ReadersMask) == LockStates.ReadersMask ||                          (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReadersMask ||                          (knownState & LockStates.CachingEvents) == LockStates.ReaderSignaled)                      {                          // Sleep for a while' then update to the latest state and try again                          int sleepDurationMilliseconds = 100;                          if ((knownState & LockStates.ReadersMask) == LockStates.ReadersMask ||                              (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReadersMask)                          {                              sleepDurationMilliseconds = 1000;                          }                          RuntimeThread.Sleep(sleepDurationMilliseconds);                          spinCount = 0;                          currentState = _state;                          continue;                      }                        ++spinCount;                        // Check if events are being cached. The purpose of this check is that "caching" events could involve                      // disposing one or both of {_readerEvent' _writerEvent}. This check prevents the waiting code below from                      // trying to use these events during this dangerous time' and instead causes the loop to spin until the                      // caching state is cleared and events can be recreated. See ReleaseEvents() and callers.                      if ((knownState & LockStates.CachingEvents) == LockStates.CachingEvents)                      {                          if (spinCount > DefaultSpinCount)                          {                              RuntimeThread.Sleep(1);                              spinCount = 0;                          }                          currentState = _state;                          continue;                      }                        // Check spin count                      if (spinCount <= DefaultSpinCount)                      {                          currentState = _state;                          continue;                      }                        // Add to waiting readers                      currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.WaitingReader' knownState);                      if (currentState != knownState)                      {                          continue;                      }                        int modifyState = -LockStates.WaitingReader;                      ManualResetEventSlim readerEvent = null;                      bool waitSucceeded = false;                      try                      {                          readerEvent = GetOrCreateReaderEvent();                          waitSucceeded = readerEvent.Wait(millisecondsTimeout);                            // AcquireReaderLock cannot have reentry via pumping while waiting for readerEvent' so                          // threadLocalLockEntry's state should not change from underneath us                          Debug.Assert(threadLocalLockEntry.HasLockID(_lockID));                            if (waitSucceeded)                          {                              // Become a reader                              Debug.Assert((_state & LockStates.ReaderSignaled) != 0);                              Debug.Assert((_state & LockStates.ReadersMask) < LockStates.ReadersMask);                              modifyState += LockStates.Reader;                          }                      }                      finally                      {                          // Make the state changes determined above                          knownState = Interlocked.Add(ref _state' modifyState) - modifyState;                            if (!waitSucceeded)                          {                              // Check for last signaled waiting reader. This is a rare case where the wait timed out' but shortly                              // afterwards' waiting readers got released' hence the ReaderSignaled bit is set. In that case'                              // remove the ReaderSignaled bit from the state' acquire a read lock' and release it. While the                              // ReaderSignaled bit is set' new requests for a write lock must spin or wait to acquire the lock'                              // so it is safe for this thread to acquire a read lock and call ReleaseReaderLock() as a shortcut                              // to do the work of releasing other waiters.                              if ((knownState & LockStates.ReaderSignaled) != 0 &&                                  (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReader)                              {                                  if (readerEvent == null)                                  {                                      readerEvent = _readerEvent;                                      Debug.Assert(readerEvent != null);                                  }                                    // Ensure the event is signaled before resetting it' since the ReaderSignaled state is set                                  // before the event is set.                                  readerEvent.Wait();                                  Debug.Assert((_state & LockStates.ReadersMask) < LockStates.ReadersMask);                                    // Reset the event and lower reader signaled flag                                  readerEvent.Reset();                                  Interlocked.Add(ref _state' LockStates.Reader - LockStates.ReaderSignaled);                                    // Honor the orginal status                                  ++threadLocalLockEntry._readerLevel;                                  ReleaseReaderLock();                              }                                Debug.Assert(threadLocalLockEntry.IsFree);                          }                      }                        if (!waitSucceeded)                      {                          throw GetTimeoutException();                      }                        // Check for last signaled waiting reader                      Debug.Assert((knownState & LockStates.ReaderSignaled) != 0);                      Debug.Assert((knownState & LockStates.ReadersMask) < LockStates.ReadersMask);                      if ((knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReader)                      {                          // Reset the event and the reader signaled flag                          readerEvent.Reset();                          Interlocked.Add(ref _state' -LockStates.ReaderSignaled);                      }                        break;                  } while (YieldProcessor());              }
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireReaderLock,The following statement contains a magic number: if (Interlocked.CompareExchange(ref _state' LockStates.Reader' 0) == 0)              {                  Debug.Assert(threadLocalLockEntry._readerLevel == 0);              }              // Check for nested reader              else if (threadLocalLockEntry._readerLevel > 0)              {                  Debug.Assert((_state & LockStates.ReadersMask) != 0);                    if (threadLocalLockEntry._readerLevel == MaxAcquireCount)                  {                      throw new OverflowException(SR.Overflow_UInt16);                  }                  ++threadLocalLockEntry._readerLevel;                  return;              }              // Check if the thread already has writer lock              else if (_writerID == GetCurrentThreadID())              {                  AcquireWriterLock(millisecondsTimeout);                  Debug.Assert(threadLocalLockEntry.IsFree);                  return;              }              else              {                  int spinCount = 0;                  int currentState = _state;                  do                  {                      int knownState = currentState;                        // Reader need not wait if there are only readers and no writer                      if (knownState < LockStates.ReadersMask ||                          (                              (knownState & LockStates.ReaderSignaled) != 0 &&                              (knownState & LockStates.Writer) == 0 &&                              (                                  // A waiting reader' after successfully completing the wait' expects that it can become a                                  // reader' so ensure that there is enough room for waiting readers and this potential reader.                                  (                                      (knownState & LockStates.ReadersMask) +                                      ((knownState & LockStates.WaitingReadersMask) >> LockStates.WaitingReadersShift)                                  ) <= LockStates.ReadersMask - 2                              )                          ))                      {                          // Add to readers                          currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.Reader' knownState);                          if (currentState == knownState)                          {                              // One more reader                              break;                          }                          continue;                      }                        // Check for too many readers or waiting readers' or if signaling is in progress. The check for signaling                      // prevents new readers from starting to wait for a read lock while the previous set of waiting readers are                      // being granted their lock. This is necessary to guarantee thread safety for the 'finally' block below.                      if ((knownState & LockStates.ReadersMask) == LockStates.ReadersMask ||                          (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReadersMask ||                          (knownState & LockStates.CachingEvents) == LockStates.ReaderSignaled)                      {                          // Sleep for a while' then update to the latest state and try again                          int sleepDurationMilliseconds = 100;                          if ((knownState & LockStates.ReadersMask) == LockStates.ReadersMask ||                              (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReadersMask)                          {                              sleepDurationMilliseconds = 1000;                          }                          RuntimeThread.Sleep(sleepDurationMilliseconds);                          spinCount = 0;                          currentState = _state;                          continue;                      }                        ++spinCount;                        // Check if events are being cached. The purpose of this check is that "caching" events could involve                      // disposing one or both of {_readerEvent' _writerEvent}. This check prevents the waiting code below from                      // trying to use these events during this dangerous time' and instead causes the loop to spin until the                      // caching state is cleared and events can be recreated. See ReleaseEvents() and callers.                      if ((knownState & LockStates.CachingEvents) == LockStates.CachingEvents)                      {                          if (spinCount > DefaultSpinCount)                          {                              RuntimeThread.Sleep(1);                              spinCount = 0;                          }                          currentState = _state;                          continue;                      }                        // Check spin count                      if (spinCount <= DefaultSpinCount)                      {                          currentState = _state;                          continue;                      }                        // Add to waiting readers                      currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.WaitingReader' knownState);                      if (currentState != knownState)                      {                          continue;                      }                        int modifyState = -LockStates.WaitingReader;                      ManualResetEventSlim readerEvent = null;                      bool waitSucceeded = false;                      try                      {                          readerEvent = GetOrCreateReaderEvent();                          waitSucceeded = readerEvent.Wait(millisecondsTimeout);                            // AcquireReaderLock cannot have reentry via pumping while waiting for readerEvent' so                          // threadLocalLockEntry's state should not change from underneath us                          Debug.Assert(threadLocalLockEntry.HasLockID(_lockID));                            if (waitSucceeded)                          {                              // Become a reader                              Debug.Assert((_state & LockStates.ReaderSignaled) != 0);                              Debug.Assert((_state & LockStates.ReadersMask) < LockStates.ReadersMask);                              modifyState += LockStates.Reader;                          }                      }                      finally                      {                          // Make the state changes determined above                          knownState = Interlocked.Add(ref _state' modifyState) - modifyState;                            if (!waitSucceeded)                          {                              // Check for last signaled waiting reader. This is a rare case where the wait timed out' but shortly                              // afterwards' waiting readers got released' hence the ReaderSignaled bit is set. In that case'                              // remove the ReaderSignaled bit from the state' acquire a read lock' and release it. While the                              // ReaderSignaled bit is set' new requests for a write lock must spin or wait to acquire the lock'                              // so it is safe for this thread to acquire a read lock and call ReleaseReaderLock() as a shortcut                              // to do the work of releasing other waiters.                              if ((knownState & LockStates.ReaderSignaled) != 0 &&                                  (knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReader)                              {                                  if (readerEvent == null)                                  {                                      readerEvent = _readerEvent;                                      Debug.Assert(readerEvent != null);                                  }                                    // Ensure the event is signaled before resetting it' since the ReaderSignaled state is set                                  // before the event is set.                                  readerEvent.Wait();                                  Debug.Assert((_state & LockStates.ReadersMask) < LockStates.ReadersMask);                                    // Reset the event and lower reader signaled flag                                  readerEvent.Reset();                                  Interlocked.Add(ref _state' LockStates.Reader - LockStates.ReaderSignaled);                                    // Honor the orginal status                                  ++threadLocalLockEntry._readerLevel;                                  ReleaseReaderLock();                              }                                Debug.Assert(threadLocalLockEntry.IsFree);                          }                      }                        if (!waitSucceeded)                      {                          throw GetTimeoutException();                      }                        // Check for last signaled waiting reader                      Debug.Assert((knownState & LockStates.ReaderSignaled) != 0);                      Debug.Assert((knownState & LockStates.ReadersMask) < LockStates.ReadersMask);                      if ((knownState & LockStates.WaitingReadersMask) == LockStates.WaitingReader)                      {                          // Reset the event and the reader signaled flag                          readerEvent.Reset();                          Interlocked.Add(ref _state' -LockStates.ReaderSignaled);                      }                        break;                  } while (YieldProcessor());              }
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireWriterLock,The following statement contains a magic number: if (Interlocked.CompareExchange(ref _state' LockStates.Writer' 0) == 0)              {                  Debug.Assert((_state & LockStates.ReadersMask) == 0);              }              // Check if the thread already has writer lock              else if (_writerID == threadID)              {                  if (_writerLevel == MaxAcquireCount)                  {                      throw new OverflowException(SR.Overflow_UInt16);                  }                  ++_writerLevel;                  return;              }              else              {                  int spinCount = 0;                  int currentState = _state;                  do                  {                      int knownState = currentState;                        // Writer need not wait if there are no readers and writer                      if (knownState == 0 || knownState == LockStates.CachingEvents)                      {                          // Can be a writer                          currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.Writer' knownState);                          if (currentState == knownState)                          {                              // Only writer                              break;                          }                          continue;                      }                        // Check for too many waiting writers                      if ((knownState & LockStates.WaitingWritersMask) == LockStates.WaitingWritersMask)                      {                          RuntimeThread.Sleep(1000);                          spinCount = 0;                          currentState = _state;                          continue;                      }                        ++spinCount;                        // Check if events are being cached. The purpose of this check is that "caching" events could involve                      // disposing one or both of {_readerEvent' _writerEvent}. This check prevents the waiting code below from                      // trying to use these events during this dangerous time' and instead causes the loop to spin until the                      // caching state is cleared and events can be recreated. See ReleaseEvents() and callers.                      if ((knownState & LockStates.CachingEvents) == LockStates.CachingEvents)                      {                          if (spinCount > DefaultSpinCount)                          {                              RuntimeThread.Sleep(1);                              spinCount = 0;                          }                          currentState = _state;                          continue;                      }                        // Check spin count                      if (spinCount <= DefaultSpinCount)                      {                          currentState = _state;                          continue;                      }                        // Add to waiting writers                      currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.WaitingWriter' knownState);                      if (currentState != knownState)                      {                          continue;                      }                        int modifyState = -LockStates.WaitingWriter;                      AutoResetEvent writerEvent = null;                      bool waitSucceeded = false;                      try                      {                          writerEvent = GetOrCreateWriterEvent();                          waitSucceeded = writerEvent.WaitOne(millisecondsTimeout);                            if (waitSucceeded)                          {                              // Become a writer and remove the writer-signaled state                              Debug.Assert((_state & LockStates.WriterSignaled) != 0);                              modifyState += LockStates.Writer - LockStates.WriterSignaled;                          }                      }                      finally                      {                          // Make the state changes determined above                          knownState = Interlocked.Add(ref _state' modifyState) - modifyState;                            if (!waitSucceeded &&                              (knownState & LockStates.WriterSignaled) != 0 &&                              (knownState & LockStates.WaitingWritersMask) == LockStates.WaitingWriter)                          {                              if (writerEvent == null)                              {                                  writerEvent = _writerEvent;                                  Debug.Assert(writerEvent != null);                              }                                while (true)                              {                                  knownState = _state;                                  if ((knownState & LockStates.WriterSignaled) == 0 ||                                      (knownState & LockStates.WaitingWritersMask) != 0)                                  {                                      break;                                  }                                    if (!writerEvent.WaitOne(10))                                  {                                      continue;                                  }                                    modifyState = LockStates.Writer - LockStates.WriterSignaled;                                  knownState = Interlocked.Add(ref _state' modifyState) - modifyState;                                  Debug.Assert((knownState & LockStates.WriterSignaled) != 0);                                  Debug.Assert((knownState & LockStates.Writer) == 0);                                    // Honor the orginal status                                  _writerID = threadID;                                  Debug.Assert(_writerLevel == 0);                                  _writerLevel = 1;                                  ReleaseWriterLock();                                  break;                              }                          }                      }                        if (!waitSucceeded)                      {                          throw GetTimeoutException();                      }                      break;                  } while (YieldProcessor());              }
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,AcquireWriterLock,The following statement contains a magic number: if (Interlocked.CompareExchange(ref _state' LockStates.Writer' 0) == 0)              {                  Debug.Assert((_state & LockStates.ReadersMask) == 0);              }              // Check if the thread already has writer lock              else if (_writerID == threadID)              {                  if (_writerLevel == MaxAcquireCount)                  {                      throw new OverflowException(SR.Overflow_UInt16);                  }                  ++_writerLevel;                  return;              }              else              {                  int spinCount = 0;                  int currentState = _state;                  do                  {                      int knownState = currentState;                        // Writer need not wait if there are no readers and writer                      if (knownState == 0 || knownState == LockStates.CachingEvents)                      {                          // Can be a writer                          currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.Writer' knownState);                          if (currentState == knownState)                          {                              // Only writer                              break;                          }                          continue;                      }                        // Check for too many waiting writers                      if ((knownState & LockStates.WaitingWritersMask) == LockStates.WaitingWritersMask)                      {                          RuntimeThread.Sleep(1000);                          spinCount = 0;                          currentState = _state;                          continue;                      }                        ++spinCount;                        // Check if events are being cached. The purpose of this check is that "caching" events could involve                      // disposing one or both of {_readerEvent' _writerEvent}. This check prevents the waiting code below from                      // trying to use these events during this dangerous time' and instead causes the loop to spin until the                      // caching state is cleared and events can be recreated. See ReleaseEvents() and callers.                      if ((knownState & LockStates.CachingEvents) == LockStates.CachingEvents)                      {                          if (spinCount > DefaultSpinCount)                          {                              RuntimeThread.Sleep(1);                              spinCount = 0;                          }                          currentState = _state;                          continue;                      }                        // Check spin count                      if (spinCount <= DefaultSpinCount)                      {                          currentState = _state;                          continue;                      }                        // Add to waiting writers                      currentState = Interlocked.CompareExchange(ref _state' knownState + LockStates.WaitingWriter' knownState);                      if (currentState != knownState)                      {                          continue;                      }                        int modifyState = -LockStates.WaitingWriter;                      AutoResetEvent writerEvent = null;                      bool waitSucceeded = false;                      try                      {                          writerEvent = GetOrCreateWriterEvent();                          waitSucceeded = writerEvent.WaitOne(millisecondsTimeout);                            if (waitSucceeded)                          {                              // Become a writer and remove the writer-signaled state                              Debug.Assert((_state & LockStates.WriterSignaled) != 0);                              modifyState += LockStates.Writer - LockStates.WriterSignaled;                          }                      }                      finally                      {                          // Make the state changes determined above                          knownState = Interlocked.Add(ref _state' modifyState) - modifyState;                            if (!waitSucceeded &&                              (knownState & LockStates.WriterSignaled) != 0 &&                              (knownState & LockStates.WaitingWritersMask) == LockStates.WaitingWriter)                          {                              if (writerEvent == null)                              {                                  writerEvent = _writerEvent;                                  Debug.Assert(writerEvent != null);                              }                                while (true)                              {                                  knownState = _state;                                  if ((knownState & LockStates.WriterSignaled) == 0 ||                                      (knownState & LockStates.WaitingWritersMask) != 0)                                  {                                      break;                                  }                                    if (!writerEvent.WaitOne(10))                                  {                                      continue;                                  }                                    modifyState = LockStates.Writer - LockStates.WriterSignaled;                                  knownState = Interlocked.Add(ref _state' modifyState) - modifyState;                                  Debug.Assert((knownState & LockStates.WriterSignaled) != 0);                                  Debug.Assert((knownState & LockStates.Writer) == 0);                                    // Honor the orginal status                                  _writerID = threadID;                                  Debug.Assert(_writerLevel == 0);                                  _writerLevel = 1;                                  ReleaseWriterLock();                                  break;                              }                          }                      }                        if (!waitSucceeded)                      {                          throw GetTimeoutException();                      }                      break;                  } while (YieldProcessor());              }
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,ReleaseReaderLock,The following statement contains a magic number: do              {                  isLastReader = false;                  cacheEvents = false;                  knownState = currentState;                  int modifyState = -LockStates.Reader;                    if ((knownState & (LockStates.ReadersMask | LockStates.ReaderSignaled)) == LockStates.Reader)                  {                      isLastReader = true;                      if ((knownState & LockStates.WaitingWritersMask) != 0)                      {                          writerEvent = TryGetOrCreateWriterEvent();                          if (writerEvent == null)                          {                              // Similar to below' wait for some time and try again                              RuntimeThread.Sleep(100);                              currentState = _state;                              knownState = 0;                              Debug.Assert(currentState != knownState);                              continue;                          }                          modifyState += LockStates.WriterSignaled;                      }                      else if ((knownState & LockStates.WaitingReadersMask) != 0)                      {                          readerEvent = TryGetOrCreateReaderEvent();                          if (readerEvent == null)                          {                              // Wait for some time and try again. Since a WaitingReaders bit is set' the event would usually                              // already be created (if the waiting reader that called AcquireReaderLock is already waiting on the                              // event' it would have created the event). However' AcquireReaderLock adds WaitingReader to the                              // state before trying to create the event.                              //                              // This is such a situation' where the event has not yet been created' and likely due to the system                              // being low on resources' this thread failed to create the event. We don't want to throw here'                              // because it could potentially leave waiters waiting and cause a deadlock.                              //                              // Instead' we let the threads that set the WaitingReader bit throw' and here' just wait and try                              // again. In a low-resource situation' eventually' all such new waiting readers would throw' and the                              // WaitingReaders bits would not be set anymore' breaking the loop and releasing this thread.                              RuntimeThread.Sleep(100);                              currentState = _state;                              knownState = 0;                              Debug.Assert(currentState != knownState);                              continue;                          }                          modifyState += LockStates.ReaderSignaled;                      }                      else if (knownState == LockStates.Reader && (_readerEvent != null || _writerEvent != null))                      {                          cacheEvents = true;                          modifyState += LockStates.CachingEvents;                      }                  }                    Debug.Assert((knownState & LockStates.Writer) == 0);                  Debug.Assert((knownState & LockStates.ReadersMask) != 0);                  currentState = Interlocked.CompareExchange(ref _state' knownState + modifyState' knownState);              } while (currentState != knownState);
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,ReleaseReaderLock,The following statement contains a magic number: do              {                  isLastReader = false;                  cacheEvents = false;                  knownState = currentState;                  int modifyState = -LockStates.Reader;                    if ((knownState & (LockStates.ReadersMask | LockStates.ReaderSignaled)) == LockStates.Reader)                  {                      isLastReader = true;                      if ((knownState & LockStates.WaitingWritersMask) != 0)                      {                          writerEvent = TryGetOrCreateWriterEvent();                          if (writerEvent == null)                          {                              // Similar to below' wait for some time and try again                              RuntimeThread.Sleep(100);                              currentState = _state;                              knownState = 0;                              Debug.Assert(currentState != knownState);                              continue;                          }                          modifyState += LockStates.WriterSignaled;                      }                      else if ((knownState & LockStates.WaitingReadersMask) != 0)                      {                          readerEvent = TryGetOrCreateReaderEvent();                          if (readerEvent == null)                          {                              // Wait for some time and try again. Since a WaitingReaders bit is set' the event would usually                              // already be created (if the waiting reader that called AcquireReaderLock is already waiting on the                              // event' it would have created the event). However' AcquireReaderLock adds WaitingReader to the                              // state before trying to create the event.                              //                              // This is such a situation' where the event has not yet been created' and likely due to the system                              // being low on resources' this thread failed to create the event. We don't want to throw here'                              // because it could potentially leave waiters waiting and cause a deadlock.                              //                              // Instead' we let the threads that set the WaitingReader bit throw' and here' just wait and try                              // again. In a low-resource situation' eventually' all such new waiting readers would throw' and the                              // WaitingReaders bits would not be set anymore' breaking the loop and releasing this thread.                              RuntimeThread.Sleep(100);                              currentState = _state;                              knownState = 0;                              Debug.Assert(currentState != knownState);                              continue;                          }                          modifyState += LockStates.ReaderSignaled;                      }                      else if (knownState == LockStates.Reader && (_readerEvent != null || _writerEvent != null))                      {                          cacheEvents = true;                          modifyState += LockStates.CachingEvents;                      }                  }                    Debug.Assert((knownState & LockStates.Writer) == 0);                  Debug.Assert((knownState & LockStates.ReadersMask) != 0);                  currentState = Interlocked.CompareExchange(ref _state' knownState + modifyState' knownState);              } while (currentState != knownState);
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,ReleaseWriterLock,The following statement contains a magic number: do              {                  cacheEvents = false;                  knownState = currentState;                  int modifyState = -LockStates.Writer;                    if ((knownState & LockStates.WaitingReadersMask) != 0)                  {                      readerEvent = TryGetOrCreateReaderEvent();                      if (readerEvent == null)                      {                          // Wait for some time and try again. Since a WaitingReaders bit is set' the event would usually                          // already be created (if the waiting reader that called AcquireReaderLock is already waiting on the                          // event' it would have created the event). However' AcquireReaderLock adds WaitingReader to the                          // state before trying to create the event.                          //                          // This is such a situation' where the event has not yet been created' and likely due to the system                          // being low on resources' this thread failed to create the event. We don't want to throw here'                          // because it could potentially leave waiters waiting and cause a deadlock.                          //                          // Instead' we let the threads that set the WaitingReader bit throw' and here' just wait and try                          // again. In a low-resource situation' eventually' all such new waiting readers would throw' and the                          // WaitingReaders bits would not be set anymore' breaking the loop and releasing this thread.                          RuntimeThread.Sleep(100);                          currentState = _state;                          knownState = 0;                          Debug.Assert(currentState != knownState);                          continue;                      }                      modifyState += LockStates.ReaderSignaled;                  }                  else if ((knownState & LockStates.WaitingWritersMask) != 0)                  {                      writerEvent = TryGetOrCreateWriterEvent();                      if (writerEvent == null)                      {                          // Similar to above' wait for some time and try again                          RuntimeThread.Sleep(100);                          currentState = _state;                          knownState = 0;                          Debug.Assert(currentState != knownState);                          continue;                      }                      modifyState += LockStates.WriterSignaled;                  }                  else if (knownState == LockStates.Writer && (_readerEvent != null || _writerEvent != null))                  {                      cacheEvents = true;                      modifyState += LockStates.CachingEvents;                  }                    Debug.Assert((knownState & LockStates.ReadersMask) == 0);                  Debug.Assert((knownState & LockStates.Writer) != 0);                  currentState = Interlocked.CompareExchange(ref _state' knownState + modifyState' knownState);              } while (currentState != knownState);
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,ReleaseWriterLock,The following statement contains a magic number: do              {                  cacheEvents = false;                  knownState = currentState;                  int modifyState = -LockStates.Writer;                    if ((knownState & LockStates.WaitingReadersMask) != 0)                  {                      readerEvent = TryGetOrCreateReaderEvent();                      if (readerEvent == null)                      {                          // Wait for some time and try again. Since a WaitingReaders bit is set' the event would usually                          // already be created (if the waiting reader that called AcquireReaderLock is already waiting on the                          // event' it would have created the event). However' AcquireReaderLock adds WaitingReader to the                          // state before trying to create the event.                          //                          // This is such a situation' where the event has not yet been created' and likely due to the system                          // being low on resources' this thread failed to create the event. We don't want to throw here'                          // because it could potentially leave waiters waiting and cause a deadlock.                          //                          // Instead' we let the threads that set the WaitingReader bit throw' and here' just wait and try                          // again. In a low-resource situation' eventually' all such new waiting readers would throw' and the                          // WaitingReaders bits would not be set anymore' breaking the loop and releasing this thread.                          RuntimeThread.Sleep(100);                          currentState = _state;                          knownState = 0;                          Debug.Assert(currentState != knownState);                          continue;                      }                      modifyState += LockStates.ReaderSignaled;                  }                  else if ((knownState & LockStates.WaitingWritersMask) != 0)                  {                      writerEvent = TryGetOrCreateWriterEvent();                      if (writerEvent == null)                      {                          // Similar to above' wait for some time and try again                          RuntimeThread.Sleep(100);                          currentState = _state;                          knownState = 0;                          Debug.Assert(currentState != knownState);                          continue;                      }                      modifyState += LockStates.WriterSignaled;                  }                  else if (knownState == LockStates.Writer && (_readerEvent != null || _writerEvent != null))                  {                      cacheEvents = true;                      modifyState += LockStates.CachingEvents;                  }                    Debug.Assert((knownState & LockStates.ReadersMask) == 0);                  Debug.Assert((knownState & LockStates.Writer) != 0);                  currentState = Interlocked.CompareExchange(ref _state' knownState + modifyState' knownState);              } while (currentState != knownState);
Magic Number,System.Threading,ReaderWriterLock,C:\selectedRepos\dotnet_corefx\src\System.Threading\src\System\Threading\ReaderWriterLock.cs,DowngradeFromWriterLock,The following statement contains a magic number: if ((flags & LockCookieFlags.OwnedReader) != 0)              {                  Debug.Assert(_writerLevel > 0);                    ThreadLocalLockEntry threadLocalLockEntry = ThreadLocalLockEntry.GetOrCreateCurrent(_lockID);                    // Downgrade to a reader                  _writerID = InvalidThreadID;                  _writerLevel = 0;                  ManualResetEventSlim readerEvent = null;                  int currentState = _state;                  int knownState;                  do                  {                      knownState = currentState;                      int modifyState = LockStates.Reader - LockStates.Writer;                      if ((knownState & LockStates.WaitingReadersMask) != 0)                      {                          readerEvent = TryGetOrCreateReaderEvent();                          if (readerEvent == null)                          {                              // Wait for some time and try again. Since a WaitingReaders bit is set' the event would usually                              // already be created (if the waiting reader that called AcquireReaderLock is already waiting on the                              // event' it would have created the event). However' AcquireReaderLock adds WaitingReader to the                              // state before trying to create the event.                              //                              // This is such a situation' where the event has not yet been created' and likely due to the system                              // being low on resources' this thread failed to create the event. We don't want to throw here'                              // because it could potentially leave waiters waiting and cause a deadlock.                              //                              // Instead' we let the threads that set the WaitingReader bit throw' and here' just wait and try                              // again. In a low-resource situation' eventually' all such new waiting readers would throw' and the                              // WaitingReaders bits would not be set anymore' breaking the loop and releasing this thread.                              RuntimeThread.Sleep(100);                              currentState = _state;                              knownState = 0;                              Debug.Assert(currentState != knownState);                              continue;                          }                          modifyState += LockStates.ReaderSignaled;                      }                        Debug.Assert((knownState & LockStates.ReadersMask) == 0);                      currentState = Interlocked.CompareExchange(ref _state' knownState + modifyState' knownState);                  } while (currentState != knownState);                    // Check for waiting readers                  if ((knownState & LockStates.WaitingReadersMask) != 0)                  {                      Debug.Assert((_state & LockStates.ReaderSignaled) != 0);                      Debug.Assert(readerEvent != null);                      readerEvent.Set();                  }                    // Restore reader nesting level                  threadLocalLockEntry._readerLevel = lockCookie._readerLevel;              }              else if ((flags & (LockCookieFlags.OwnedWriter | LockCookieFlags.OwnedNone)) != 0)              {                  // Original code:                  //     ReleaseWriterLock();                  //     Debug.Assert((flags & LockCookieFlags.OwnedWriter) != 0 || _writerID != threadID);                  //                  // Previously' the lock cookie was ignored on this path. UpgradeToWriterLock allows upgrading from an unlocked                  // state or when the write lock is already held' where it just calls AcquireWriteLock. To compensate' I                  // DowngradeFromWriterLock intends to just behave as ReleaseWriterLock.                  //                  // However' the lock cookie could be several operations old. Consider:                  //   lockCookie = UpgradeToWriterLock()                  //   AcquireWriterLock()                  //   DowngradeFromWriterLock(ref lockCookie)                  //                  // Since the lock cookie indicates that no lock was held at the time of the upgrade' The ReleaseWriterLock in                  // the original code above does not result in releasing all writer locks as requested by the lock cookie and as                  // expected by the assertion. The code should respect the lock cookie (as it does in the case above where the                  // lock cookie indicates that a read lock was held)' and restore the writer level appropriately.                  //                  // Similarly' when the lock cookie does indicate that a write lock was held' the downgrade does not restore the                  // write lock recursion level to that indicated by the lock cookie. Consider:                  //   AcquireWriterLock()                  //   lockCookie = UpgradeToWriterLock()                  //   AcquireWriterLock()                  //   DowngradeFromWriterLock(ref lockCookie) // does not restore recursion level of write lock!                  Debug.Assert(_writerLevel > 0);                  Debug.Assert(_writerLevel > requestedWriterLevel);                  if (requestedWriterLevel > 0)                  {                      _writerLevel = requestedWriterLevel;                  }                  else                  {                      if (_writerLevel != 1)                      {                          _writerLevel = 1;                      }                      ReleaseWriterLock();                  }                  Debug.Assert((flags & LockCookieFlags.OwnedWriter) != 0 || _writerID != threadID);              }
