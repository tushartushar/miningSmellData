Implementation smell,Namespace,Class,File,Method,Description
Long Parameter List,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,IsolatedStorageFileStream,The method has 5 parameters. Parameters: path' mode' access' share' isf
Long Parameter List,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,IsolatedStorageFileStream,The method has 5 parameters. Parameters: path' mode' access' share' bufferSize
Long Parameter List,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,IsolatedStorageFileStream,The method has 6 parameters. Parameters: path' mode' access' share' bufferSize' isf
Long Parameter List,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,IsolatedStorageFileStream,The method has 6 parameters. Parameters: path' mode' access' share' bufferSize' initializationData
Long Parameter List,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,InitializeFileStream,The method has 6 parameters. Parameters: path' mode' access' share' bufferSize' isf
Long Parameter List,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,BeginRead,The method has 5 parameters. Parameters: array' offset' numBytes' userCallback' stateObject
Long Parameter List,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,BeginWrite,The method has 5 parameters. Parameters: array' offset' numBytes' userCallback' stateObject
Long Identifier,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,MoveDirectory,The length of the parameter destinationDirectoryNameFullPath is 32.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetDirectoryNames,The length of the statement  "                // FileSystem APIs return the complete path of the matching directories however Iso store only provided the directory name " is 122.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetDirectoryNames,The length of the statement  "                // and hid the IsoStore root. Hence we find all the matching directories from the fileSystem and simply return their names. " is 123.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetDirectoryNames,The length of the statement  "                return Directory.EnumerateDirectories(RootDirectory' searchPattern).Select(m => m.Substring(Path.GetDirectoryName(m).Length + 1)).ToArray(); " is 140.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetStore,The length of the statement  "            return (applicationEvidenceType == null) ? GetStore(scope) : throw new PlatformNotSupportedException(SR.PlatformNotSupported_CAS); // https://github.com/dotnet/corefx/issues/10935 " is 179.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetStore,The length of the statement  "            return (applicationIdentity == null) ? GetStore(scope) : throw new PlatformNotSupportedException(SR.PlatformNotSupported_CAS); // https://github.com/dotnet/corefx/issues/10935 " is 175.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetStore,The length of the statement  "            return (domainEvidenceType == null && assemblyEvidenceType == null) ? GetStore(scope) : throw new PlatformNotSupportedException(SR.PlatformNotSupported_CAS); // https://github.com/dotnet/corefx/issues/10935 " is 206.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetStore,The length of the statement  "            return (domainIdentity == null && assemblyIdentity == null) ? GetStore(scope) : throw new PlatformNotSupportedException(SR.PlatformNotSupported_CAS); // https://github.com/dotnet/corefx/issues/10935 " is 198.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,Remove,The length of the statement  "            // (e.g. @"C:\Users\jerem\AppData\Local\IsolatedStorage\10v31ho4.bo2\eeolfu22.f2w\Url.qgeirsoc3cznuklvq5xlalurh1m0unxl\AssemFiles\") " is 132.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,Remove,The length of the statement  "            // This matches NetFX logic. We want to try and clean as well as possible without being more aggressive with the identity folders. " is 130.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,Remove,The length of the statement  "            // (e.g. Url.qgeirsoc3cznuklvq5xlalurh1m0unxl' etc.) We don't want to inadvertently yank folders for a different scope under the same " is 133.
Long Statement,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,Remove,The length of the statement  "            // @"C:\Users\jerem\AppData\Local\IsolatedStorage\10v31ho4.bo2\eeolfu22.f2w\Url.qgeirsoc3cznuklvq5xlalurh1m0unxl\Url.qgeirsoc3cznuklvq5xlalurh1m0unxl\Files\" " is 157.
Long Statement,System.IO.IsolatedStorage,IsolatedStorage,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorage.cs,VerifyScope,The length of the statement  "                case IsolatedStorageScope.Roaming | IsolatedStorageScope.User | IsolatedStorageScope.Assembly | IsolatedStorageScope.Domain: " is 124.
Long Statement,System.IO.IsolatedStorage,Helper,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\Helper.cs,CreateMutexNotOwned,The length of the statement  "            return new Mutex(initiallyOwned: false' name: @"Global\" + IdentityHelper.GetStrongHashSuitableForObjectName(pathName)); " is 120.
Empty Catch Block,System.IO.IsolatedStorage,IsolatedStorageFileStream,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFileStream.cs,InitializeFileStream,The method has an empty catch block.
Magic Number,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetCreationTime,The following statement contains a magic number: try              {                  return new DateTimeOffset(File.GetCreationTime(GetFullPath(path)));              }              catch (UnauthorizedAccessException)              {                  return new DateTimeOffset(1601' 1' 1' 0' 0' 0' TimeSpan.Zero).ToLocalTime();              }
Magic Number,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetLastAccessTime,The following statement contains a magic number: try              {                  return new DateTimeOffset(File.GetLastAccessTime(GetFullPath(path)));              }              catch (UnauthorizedAccessException)              {                  return new DateTimeOffset(1601' 1' 1' 0' 0' 0' TimeSpan.Zero).ToLocalTime();              }
Magic Number,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,GetLastWriteTime,The following statement contains a magic number: try              {                  return new DateTimeOffset(File.GetLastWriteTime(GetFullPath(path)));              }              catch (UnauthorizedAccessException)              {                  return new DateTimeOffset(1601' 1' 1' 0' 0' 0' TimeSpan.Zero).ToLocalTime();              }
Magic Number,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,ContainsUnknownFiles,The following statement contains a magic number: return (files.Length > 2 ||                  (                      (!IsIdFile(files[0]) && !IsInfoFile(files[0]))) ||                      (files.Length == 2 && !IsIdFile(files[1]) && !IsInfoFile(files[1]))                  );
Magic Number,System.IO.IsolatedStorage,IsolatedStorageFile,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\IsolatedStorageFile.cs,ContainsUnknownFiles,The following statement contains a magic number: return (files.Length > 2 ||                  (                      (!IsIdFile(files[0]) && !IsInfoFile(files[0]))) ||                      (files.Length == 2 && !IsIdFile(files[1]) && !IsInfoFile(files[1]))                  );
Magic Number,System.IO.IsolatedStorage,Helper,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\Helper.cs,GetExistingRandomDirectory,The following statement contains a magic number: foreach (string directory in Directory.GetDirectories(rootDirectory))              {                  if (Path.GetFileName(directory)?.Length == 12)                  {                      foreach (string subdirectory in Directory.GetDirectories(directory))                      {                          if (Path.GetFileName(subdirectory)?.Length == 12)                          {                              return subdirectory;                          }                      }                  }              }
Magic Number,System.IO.IsolatedStorage,Helper,C:\selectedRepos\dotnet_corefx\src\System.IO.IsolatedStorage\src\System\IO\IsolatedStorage\Helper.cs,GetExistingRandomDirectory,The following statement contains a magic number: foreach (string directory in Directory.GetDirectories(rootDirectory))              {                  if (Path.GetFileName(directory)?.Length == 12)                  {                      foreach (string subdirectory in Directory.GetDirectories(directory))                      {                          if (Path.GetFileName(subdirectory)?.Length == 12)                          {                              return subdirectory;                          }                      }                  }              }
Magic Number,System.Security,IdentityHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\IdentityHelper.cs,ToBase32StringSuitableForDirName,The following statement contains a magic number: Debug.Assert(((buff.Length % 5) == 0)' "Unexpected hash length");
Magic Number,System.Security,IdentityHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\IdentityHelper.cs,ToBase32StringSuitableForDirName,The following statement contains a magic number: do              {                  byte b0 = (i < l) ? buff[i++] : (byte)0;                  byte b1 = (i < l) ? buff[i++] : (byte)0;                  byte b2 = (i < l) ? buff[i++] : (byte)0;                  byte b3 = (i < l) ? buff[i++] : (byte)0;                  byte b4 = (i < l) ? buff[i++] : (byte)0;                    // Consume the 5 Least significant bits of each byte                  sb.Append(s_base32Char[b0 & 0x1F]);                  sb.Append(s_base32Char[b1 & 0x1F]);                  sb.Append(s_base32Char[b2 & 0x1F]);                  sb.Append(s_base32Char[b3 & 0x1F]);                  sb.Append(s_base32Char[b4 & 0x1F]);                    // Consume 3 MSB of b0' b1' MSB bits 6' 7 of b3' b4                  sb.Append(s_base32Char[(                          ((b0 & 0xE0) >> 5) |                          ((b3 & 0x60) >> 2))]);                    sb.Append(s_base32Char[(                          ((b1 & 0xE0) >> 5) |                          ((b4 & 0x60) >> 2))]);                    // Consume 3 MSB bits of b2' 1 MSB bit of b3' b4                    b2 >>= 5;                    Debug.Assert(((b2 & 0xF8) == 0)' "Unexpected set bits");                    if ((b3 & 0x80) != 0)                      b2 |= 0x08;                  if ((b4 & 0x80) != 0)                      b2 |= 0x10;                    sb.Append(s_base32Char[b2]);                } while (i < l);
Magic Number,System.Security,IdentityHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\IdentityHelper.cs,ToBase32StringSuitableForDirName,The following statement contains a magic number: do              {                  byte b0 = (i < l) ? buff[i++] : (byte)0;                  byte b1 = (i < l) ? buff[i++] : (byte)0;                  byte b2 = (i < l) ? buff[i++] : (byte)0;                  byte b3 = (i < l) ? buff[i++] : (byte)0;                  byte b4 = (i < l) ? buff[i++] : (byte)0;                    // Consume the 5 Least significant bits of each byte                  sb.Append(s_base32Char[b0 & 0x1F]);                  sb.Append(s_base32Char[b1 & 0x1F]);                  sb.Append(s_base32Char[b2 & 0x1F]);                  sb.Append(s_base32Char[b3 & 0x1F]);                  sb.Append(s_base32Char[b4 & 0x1F]);                    // Consume 3 MSB of b0' b1' MSB bits 6' 7 of b3' b4                  sb.Append(s_base32Char[(                          ((b0 & 0xE0) >> 5) |                          ((b3 & 0x60) >> 2))]);                    sb.Append(s_base32Char[(                          ((b1 & 0xE0) >> 5) |                          ((b4 & 0x60) >> 2))]);                    // Consume 3 MSB bits of b2' 1 MSB bit of b3' b4                    b2 >>= 5;                    Debug.Assert(((b2 & 0xF8) == 0)' "Unexpected set bits");                    if ((b3 & 0x80) != 0)                      b2 |= 0x08;                  if ((b4 & 0x80) != 0)                      b2 |= 0x10;                    sb.Append(s_base32Char[b2]);                } while (i < l);
Magic Number,System.Security,IdentityHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\IdentityHelper.cs,ToBase32StringSuitableForDirName,The following statement contains a magic number: do              {                  byte b0 = (i < l) ? buff[i++] : (byte)0;                  byte b1 = (i < l) ? buff[i++] : (byte)0;                  byte b2 = (i < l) ? buff[i++] : (byte)0;                  byte b3 = (i < l) ? buff[i++] : (byte)0;                  byte b4 = (i < l) ? buff[i++] : (byte)0;                    // Consume the 5 Least significant bits of each byte                  sb.Append(s_base32Char[b0 & 0x1F]);                  sb.Append(s_base32Char[b1 & 0x1F]);                  sb.Append(s_base32Char[b2 & 0x1F]);                  sb.Append(s_base32Char[b3 & 0x1F]);                  sb.Append(s_base32Char[b4 & 0x1F]);                    // Consume 3 MSB of b0' b1' MSB bits 6' 7 of b3' b4                  sb.Append(s_base32Char[(                          ((b0 & 0xE0) >> 5) |                          ((b3 & 0x60) >> 2))]);                    sb.Append(s_base32Char[(                          ((b1 & 0xE0) >> 5) |                          ((b4 & 0x60) >> 2))]);                    // Consume 3 MSB bits of b2' 1 MSB bit of b3' b4                    b2 >>= 5;                    Debug.Assert(((b2 & 0xF8) == 0)' "Unexpected set bits");                    if ((b3 & 0x80) != 0)                      b2 |= 0x08;                  if ((b4 & 0x80) != 0)                      b2 |= 0x10;                    sb.Append(s_base32Char[b2]);                } while (i < l);
Magic Number,System.Security,IdentityHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\IdentityHelper.cs,ToBase32StringSuitableForDirName,The following statement contains a magic number: do              {                  byte b0 = (i < l) ? buff[i++] : (byte)0;                  byte b1 = (i < l) ? buff[i++] : (byte)0;                  byte b2 = (i < l) ? buff[i++] : (byte)0;                  byte b3 = (i < l) ? buff[i++] : (byte)0;                  byte b4 = (i < l) ? buff[i++] : (byte)0;                    // Consume the 5 Least significant bits of each byte                  sb.Append(s_base32Char[b0 & 0x1F]);                  sb.Append(s_base32Char[b1 & 0x1F]);                  sb.Append(s_base32Char[b2 & 0x1F]);                  sb.Append(s_base32Char[b3 & 0x1F]);                  sb.Append(s_base32Char[b4 & 0x1F]);                    // Consume 3 MSB of b0' b1' MSB bits 6' 7 of b3' b4                  sb.Append(s_base32Char[(                          ((b0 & 0xE0) >> 5) |                          ((b3 & 0x60) >> 2))]);                    sb.Append(s_base32Char[(                          ((b1 & 0xE0) >> 5) |                          ((b4 & 0x60) >> 2))]);                    // Consume 3 MSB bits of b2' 1 MSB bit of b3' b4                    b2 >>= 5;                    Debug.Assert(((b2 & 0xF8) == 0)' "Unexpected set bits");                    if ((b3 & 0x80) != 0)                      b2 |= 0x08;                  if ((b4 & 0x80) != 0)                      b2 |= 0x10;                    sb.Append(s_base32Char[b2]);                } while (i < l);
Magic Number,System.Security,IdentityHelper,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Security\IdentityHelper.cs,ToBase32StringSuitableForDirName,The following statement contains a magic number: do              {                  byte b0 = (i < l) ? buff[i++] : (byte)0;                  byte b1 = (i < l) ? buff[i++] : (byte)0;                  byte b2 = (i < l) ? buff[i++] : (byte)0;                  byte b3 = (i < l) ? buff[i++] : (byte)0;                  byte b4 = (i < l) ? buff[i++] : (byte)0;                    // Consume the 5 Least significant bits of each byte                  sb.Append(s_base32Char[b0 & 0x1F]);                  sb.Append(s_base32Char[b1 & 0x1F]);                  sb.Append(s_base32Char[b2 & 0x1F]);                  sb.Append(s_base32Char[b3 & 0x1F]);                  sb.Append(s_base32Char[b4 & 0x1F]);                    // Consume 3 MSB of b0' b1' MSB bits 6' 7 of b3' b4                  sb.Append(s_base32Char[(                          ((b0 & 0xE0) >> 5) |                          ((b3 & 0x60) >> 2))]);                    sb.Append(s_base32Char[(                          ((b1 & 0xE0) >> 5) |                          ((b4 & 0x60) >> 2))]);                    // Consume 3 MSB bits of b2' 1 MSB bit of b3' b4                    b2 >>= 5;                    Debug.Assert(((b2 & 0xF8) == 0)' "Unexpected set bits");                    if ((b3 & 0x80) != 0)                      b2 |= 0x08;                  if ((b4 & 0x80) != 0)                      b2 |= 0x10;                    sb.Append(s_base32Char[b2]);                } while (i < l);
