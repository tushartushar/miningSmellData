Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,The method has 134 lines of code.
Long Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DecodeObject,The method has 128 lines of code.
Long Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventVarargs,The method has 156 lines of code.
Long Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DoCommand,The method has 221 lines of code.
Long Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The method has 271 lines of code.
Long Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The method has 120 lines of code.
Long Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteImpl,The method has 101 lines of code.
Long Method,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestString,The method has 196 lines of code.
Long Method,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EncodeObject,The method has 184 lines of code.
Long Method,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The method has 155 lines of code.
Long Method,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,CreateDefaultTypeInfo,The method has 190 lines of code.
Complex Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,Cyclomatic complexity of the method is 8
Complex Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventVarargs,Cyclomatic complexity of the method is 10
Complex Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DoCommand,Cyclomatic complexity of the method is 19
Complex Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EnsureDescriptorsInitialized,Cyclomatic complexity of the method is 9
Complex Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetCustomAttributeHelper,Cyclomatic complexity of the method is 9
Complex Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,Cyclomatic complexity of the method is 33
Complex Method,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DebugCheckEvent,Cyclomatic complexity of the method is 12
Complex Method,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddEventParameter,Cyclomatic complexity of the method is 8
Complex Method,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestString,Cyclomatic complexity of the method is 16
Complex Method,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EtwEnableCallBack,Cyclomatic complexity of the method is 8
Complex Method,System.Diagnostics.Tracing,ActivityTracker,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,OnStart,Cyclomatic complexity of the method is 13
Complex Method,System.Diagnostics.Tracing,ActivityTracker,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,OnStop,Cyclomatic complexity of the method is 13
Complex Method,System.Diagnostics.Tracing,FieldMetadata,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\FieldMetadata.cs,FieldMetadata,Cyclomatic complexity of the method is 8
Complex Method,System.Diagnostics.Tracing,FieldMetadata,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\FieldMetadata.cs,Encode,Cyclomatic complexity of the method is 10
Complex Method,System.Diagnostics.Tracing,PropertyValue,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetFactory,Cyclomatic complexity of the method is 20
Complex Method,System.Diagnostics.Tracing,TypeAnalysis,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TypeAnalysis.cs,TypeAnalysis,Cyclomatic complexity of the method is 9
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventRaw,The method has 6 parameters. Parameters: eventName' eventDescriptor' activityID' relatedActivityID' dataCount' data
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,IsEnabledCommon,The method has 6 parameters. Parameters: enabled' currentLevel' currentMatchAnyKeyword' eventLevel' eventKeywords' eventChannel
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,SendCommand,The method has 8 parameters. Parameters: listener' perEventSourceSessionId' etwSessionId' command' enable' level' matchAnyKeyword' commandArguments
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddEventDescriptor,The method has 5 parameters. Parameters: eventData' eventName' eventAttribute' eventParameters' hasRelatedActivityID
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DebugCheckEvent,The method has 6 parameters. Parameters: eventsByName' eventData' method' eventAttribute' manifest' options
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,Write,The method has 5 parameters. Parameters: eventName' options' activityId' relatedActivityId' data
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteMultiMerge,The method has 6 parameters. Parameters: eventName' options' eventTypes' activityID' childActivityID' values
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteMultiMergeInner,The method has 6 parameters. Parameters: eventName' options' eventTypes' activityID' childActivityID' values
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteMultiMerge,The method has 6 parameters. Parameters: eventName' options' eventTypes' activityID' childActivityID' data
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteImpl,The method has 6 parameters. Parameters: eventName' options' data' pActivityId' pRelatedActivityId' eventTypes
Long Parameter List,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteToAllListeners,The method has 5 parameters. Parameters: eventName' eventDescriptor' tags' pActivityId' payload
Long Parameter List,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,ManifestBuilder,The method has 5 parameters. Parameters: providerName' providerGuid' dllName' resources' flags
Long Parameter List,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EtwEnableCallBack,The method has 7 parameters. Parameters: sourceId' controlCode' setLevel' anyKeyword' allKeyword' filterData' callbackContext
Long Parameter List,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetDataFromController,The method has 5 parameters. Parameters: etwSessionId' filterData' command' data' dataStart
Long Parameter List,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The method has 5 parameters. Parameters: eventDescriptor' eventHandle' activityID' childActivityID' eventPayload
Long Parameter List,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The method has 6 parameters. Parameters: eventDescriptor' eventHandle' activityID' childActivityID' dataCount' data
Long Parameter List,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventRaw,The method has 5 parameters. Parameters: eventDescriptor' activityID' relatedActivityID' dataCount' data
Long Parameter List,System.Diagnostics.Tracing,ActivityTracker,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,OnStart,The method has 6 parameters. Parameters: providerName' activityName' task' activityId' relatedActivityId' options
Long Parameter List,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,ActivityInfo,The method has 5 parameters. Parameters: name' uniqueId' creator' activityIDToRestore' options
Long Parameter List,System.Diagnostics.Tracing,EventDescriptor,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventDescriptor.cs,EventDescriptor,The method has 7 parameters. Parameters: id' version' channel' level' opcode' task' keywords
Long Parameter List,System.Diagnostics.Tracing,NoOpEventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventProvider.cs,EventWriteTransferWrapper,The method has 7 parameters. Parameters: registrationHandle' eventDescriptor' eventHandle' activityId' relatedActivityId' userDataCount' userData
Long Parameter List,System.Diagnostics.Tracing,NoOpEventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventProvider.cs,DefineEventHandle,The method has 7 parameters. Parameters: eventID' eventName' keywords' eventVersion' level' pMetadata' metadataLength
Long Parameter List,System.Diagnostics.Tracing,EventCommandEventArgs,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,EventCommandEventArgs,The method has 9 parameters. Parameters: command' arguments' eventSource' listener' perEventSourceSessionId' etwSessionId' enable' level' matchAnyKeyword
Long Parameter List,System.Diagnostics.Tracing,IEventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\IEventProvider.cs,EventWriteTransferWrapper,The method has 7 parameters. Parameters: registrationHandle' eventDescriptor' eventHandle' activityId' relatedActivityId' userDataCount' userData
Long Parameter List,System.Diagnostics.Tracing,IEventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\IEventProvider.cs,DefineEventHandle,The method has 7 parameters. Parameters: eventID' eventName' keywords' eventVersion' level' pMetadata' metadataLength
Long Parameter List,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,Enable,The method has 6 parameters. Parameters: scratch' scratchSize' datas' dataCount' pins' pinCount
Long Parameter List,System.Diagnostics.Tracing,FieldMetadata,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\FieldMetadata.cs,FieldMetadata,The method has 6 parameters. Parameters: name' dataType' tags' countFlags' fixedCount' custom
Long Parameter List,System.Diagnostics.Tracing,TraceLoggingTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingTypeInfo.cs,TraceLoggingTypeInfo,The method has 6 parameters. Parameters: dataType' name' level' opcode' keywords' tags
Long Parameter List,Microsoft.Win32,ManifestEtw,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\ManifestEtw.cs,EventWriteTransferWrapper,The method has 6 parameters. Parameters: registrationHandle' eventDescriptor' activityId' relatedActivityId' userDataCount' userData
Long Parameter List,Microsoft.Win32,ManifestEtw,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\ManifestEtw.cs,EventWriteTransfer,The method has 6 parameters. Parameters: registrationHandle' eventDescriptor' activityId' relatedActivityId' userDataCount' userData
Long Parameter List,Microsoft.Win32,ManifestEtw,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\ManifestEtw.cs,EnumerateTraceGuidsEx,The method has 6 parameters. Parameters: TraceQueryInfoClass' InBuffer' InBufferSize' OutBuffer' OutBufferSize' ReturnLength
Long Identifier,System.Diagnostics.Tracing,EventCounterGroup,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,,The length of the parameter _timeStampSinceCollectionStarted is 32.
Long Identifier,System.Diagnostics.Tracing,EventCounterGroup,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,,The length of the parameter _pollingIntervalInMilliseconds is 30.
Long Identifier,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GenerateManifest,The length of the parameter assemblyPathToIncludeInManifest is 31.
Long Identifier,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GenerateManifest,The length of the parameter assemblyPathToIncludeInManifest is 31.
Long Identifier,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,,The length of the parameter m_EventSourceExceptionRecurenceCount is 36.
Long Identifier,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,,The length of the parameter s_basicTypeAllocationBufferSize is 31.
Long Identifier,System.Diagnostics.Tracing,EventListener,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,,The length of the parameter s_EventSourceShutdownRegistered is 31.
Long Identifier,Microsoft.Win32,ManifestEtw,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\ManifestEtw.cs,,The length of the parameter EVENT_CONTROL_CODE_DISABLE_PROVIDER is 35.
Long Identifier,Microsoft.Win32,ManifestEtw,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\ManifestEtw.cs,,The length of the parameter EVENT_CONTROL_CODE_ENABLE_PROVIDER is 34.
Long Identifier,Microsoft.Win32,ManifestEtw,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\ManifestEtw.cs,,The length of the parameter EVENT_CONTROL_CODE_CAPTURE_STATE is 32.
Long Statement,System.Diagnostics.Tracing,EventCounter,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,Enqueue,The length of the statement  "            // It is possible that two threads read the same bufferedValuesIndex' but only one will be able to write the slot' so that is okay. " is 131.
Long Statement,System.Diagnostics.Tracing,EventCounter,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,Enqueue,The length of the statement  "                    // will eventually enter this code path and potentially calling Flushing on a buffer that is not full' and that's okay too. " is 123.
Long Statement,System.Diagnostics.Tracing,EventCounterGroup,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,RegisterCommandCallback,The length of the statement  "                string msg = "EventCounterError: Old Runtime that does not support EventSource.EventCommandExecuted.  EventCounters not Supported"; " is 131.
Long Statement,System.Diagnostics.Tracing,EventCounterGroup,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,EnsureEventSourceIndexAvailable,The length of the statement  "                Array.Copy(EventCounterGroup.s_eventCounterGroups' 0' newEventCounterGroups' 0' EventCounterGroup.s_eventCounterGroups.Length); " is 127.
Long Statement,System.Diagnostics.Tracing,EventCounterGroup,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,OnTimer,The length of the statement  "                        _eventSource.Write("EventCounters"' new EventSourceOptions() { Level = EventLevel.LogAlways }' new PayloadType(payload)); " is 121.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetGuid,The length of the statement  "            EventSourceAttribute attrib = (EventSourceAttribute)GetCustomAttributeHelper(eventSourceType' typeof(EventSourceAttribute)); " is 124.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GenerateManifest,The length of the statement  "            byte[] manifestBytes = EventSource.CreateManifestAndDescriptors(eventSourceType' assemblyPathToIncludeInManifest' null' flags); " is 127.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetMetadata,The length of the statement  "            // In ProjectN subclasses need to override this method' and return the data from their EventSourceAttribute and EventAttribute annotations. " is 139.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetMetadata,The length of the statement  "            // eventDescriptors needs to contain one EventDescriptor for each event; the event's ID should be the same as its index in this array. " is 134.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetMetadata,The length of the statement  "            // This will be implemented by an IL rewriter' so we can't make this method abstract or the initial build of the subclass would fail. " is 133.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,The length of the statement  "                            m_activityTracker.OnStart(m_name' m_eventData[eventId].Name' m_eventData[eventId].Descriptor.Task' ref activityId' ref relActivityId' m_eventData[eventId].ActivityOptions); " is 172.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,The length of the statement  "                                    if (!m_provider.WriteEvent(ref m_eventData[eventId].Descriptor' m_eventData[eventId].EventHandle' pActivityId' relatedActivityId' eventDataCount' (IntPtr)data)) " is 160.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,The length of the statement  "                                    long origKwd = unchecked((long)((ulong)m_eventData[eventId].Descriptor.Keywords & ~(SessionMask.All.ToEventKeywords()))); " is 121.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,The length of the statement  "                                    if (!m_provider.WriteEvent(ref desc' m_eventData[eventId].EventHandle' pActivityId' relatedActivityId' eventDataCount' (IntPtr)data)) " is 133.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,The length of the statement  "                                long origKwd = unchecked((long)((ulong)m_eventData[eventId].Descriptor.Keywords & ~(SessionMask.All.ToEventKeywords()))); " is 121.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventWithRelatedActivityIdCore,The length of the statement  "                            if (!m_provider.WriteEvent(ref m_eventData[eventId].Descriptor' m_eventData[eventId].EventHandle' pActivityId' relatedActivityId' eventDataCount' (IntPtr)data)) " is 160.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,Initialize,The length of the statement  "                        System.Runtime.InteropServices.GCHandle.Alloc(this.providerMetadata' System.Runtime.InteropServices.GCHandleType.Pinned); " is 121.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetName,The length of the statement  "            EventSourceAttribute attrib = (EventSourceAttribute)GetCustomAttributeHelper(eventSourceType' typeof(EventSourceAttribute)' flags); " is 131.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventVarargs,The length of the statement  "                            m_activityTracker.OnStart(m_name' m_eventData[eventId].Name' m_eventData[eventId].Descriptor.Task' ref activityId' ref relatedActivityId' m_eventData[eventId].ActivityOptions); " is 176.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventVarargs,The length of the statement  "                                    if (!m_provider.WriteEvent(ref m_eventData[eventId].Descriptor' m_eventData[eventId].EventHandle' pActivityId' childActivityID' args)) " is 134.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventVarargs,The length of the statement  "                                    long origKwd = unchecked((long)((ulong)m_eventData[eventId].Descriptor.Keywords & ~(SessionMask.All.ToEventKeywords()))); " is 121.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventVarargs,The length of the statement  "                                long origKwd = unchecked((long)((ulong)m_eventData[eventId].Descriptor.Keywords & ~(SessionMask.All.ToEventKeywords()))); " is 121.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventVarargs,The length of the statement  "                            if (!m_provider.WriteEvent(ref m_eventData[eventId].Descriptor' m_eventData[eventId].EventHandle' pActivityId' childActivityID' args)) " is 134.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteToAllListeners,The length of the statement  "            // We represent a byte[] as a integer denoting the length  and then a blob of bytes in the data pointer. This causes a spurious " is 127.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteToAllListeners,The length of the statement  "            // warning because eventDataCount is off by one for the byte[] case since a byte[] has 2 items associated it. So we want to check " is 129.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteToAllListeners,The length of the statement  "            // that the number of parameters is correct against the byte[] case' but also we the args array would be one too long if " is 120.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventString,The length of the statement  "                        manifestBuilder.StartEvent(eventName' new EventAttribute(0) { Level = EventLevel.LogAlways' Task = (EventTask)0xFFFE }); " is 120.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEventString,The length of the statement  "                    // We use this low level routine to to bypass the enabled checking' since the eventSource itself is only partially inited.  " is 122.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,IsEnabledByDefault,The length of the statement  "            EventKeywords eventKeywords = unchecked((EventKeywords)((ulong)m_eventData[eventNum].Descriptor.Keywords & (~(SessionMask.All.ToEventKeywords())))); " is 148.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,SendCommand,The length of the statement  "            var commandArgs = new EventCommandEventArgs(command' commandArguments' this' listener' perEventSourceSessionId' etwSessionId' enable' level' matchAnyKeyword); " is 158.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DoCommand,The length of the statement  "            bool shouldReport = (commandArgs.perEventSourceSessionId > 0) && (commandArgs.perEventSourceSessionId <= SessionMask.MAX); " is 122.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DoCommand,The length of the statement  "                        EnableEventForDispatcher(commandArgs.dispatcher' i' IsEnabledByDefault(i' commandArgs.enable' commandArgs.level' commandArgs.matchAnyKeyword)); " is 143.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DoCommand,The length of the statement  "                        if (commandArgs.listener == null && commandArgs.Arguments.Count > 0 && commandArgs.perEventSourceSessionId != sessionIdBit) " is 123.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DoCommand,The length of the statement  "                            UpdateEtwSession(commandArgs.perEventSourceSessionId' commandArgs.etwSessionId' true' activityFilters' participateInSampling); " is 126.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DoCommand,The length of the statement  "                            commandArgs.Arguments["EtwSessionKeyword"] = (commandArgs.perEventSourceSessionId + SessionMask.SHIFT_SESSION_TO_KEYWORD).ToString(CultureInfo.InvariantCulture); " is 161.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EnsureDescriptorsInitialized,The length of the statement  "                // Try the GetMetadata provided by the ILTransform in ProjectN. The default sets all to null' and in that case we fall back " is 123.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,SendManifest,The length of the statement  "                            // The smallest BufferSize is 1K so if we get to 256 (to account for envelope overhead)' we can give up making it smaller.  " is 122.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetCustomAttributeHelper,The length of the statement  "            // On ProjectN' ReflectionOnly() always equals false.  AllowEventSourceOverride is an option that allows either Microsoft.Diagnostics.Tracing or " is 144.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetCustomAttributeHelper,The length of the statement  "            // System.Diagnostics.Tracing EventSource to be considered valid.  This should not mattter anywhere but in Microsoft.Diagnostics.Tracing (nuget package). " is 153.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "            Exception exception = null; // exception that might get raised during validation b/c we couldn't/didn't recover from a previous error " is 133.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                MethodInfo[] methods = eventSourceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance); " is 148.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                EventSourceAttribute eventSourceAttrib = (EventSourceAttribute)GetCustomAttributeHelper(eventSourceType' typeof(EventSourceAttribute)' flags); " is 142.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                manifest.StartEvent("EventSourceMessage"' new EventAttribute(0) { Level = EventLevel.LogAlways' Task = (EventTask)0xFFFE }); " is 124.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                    bool typeMatch = GetEventSourceBaseType(eventSourceType' (flags & EventManifestOptions.AllowEventSourceOverride) != 0' eventSourceType.Assembly().ReflectionOnly()) != null; " is 172.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                            foreach (FieldInfo staticField in nestedType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static)) " is 151.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                                manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareEventMethods' method.Name' eventAttribute.EventId)); " is 122.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                            manifest.ManifestError(SR.Format(SR.EventSource_EventMustNotBeExplicitImplementation' method.Name' eventAttribute.EventId)); " is 124.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                                    string taskName = eventName.Substring(0' eventName.Length - s_ActivityStartSuffix.Length); // Remove the Stop suffix to get the task name " is 137.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                                        string.Compare(eventName' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(eventName.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0) " is 150.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                                        string taskName = eventName.Substring(0' eventName.Length - s_ActivityStopSuffix.Length); // Remove the Stop suffix to get the task name " is 136.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                                            string.Compare(startEventMetadata.Name' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(startEventMetadata.Name.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0) " is 178.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The length of the statement  "                                    eventAttribute.Keywords |= (EventKeywords)manifest.GetChannelKeyword(eventAttribute.Channel' (ulong)eventAttribute.Keywords); " is 125.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddProviderEnumKind,The length of the statement  "            if (!reflectionOnly && (staticFieldType == typeof(EventOpcode)) || AttributeTypeNamesMatch(staticFieldType' typeof(EventOpcode))) " is 129.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddProviderEnumKind,The length of the statement  "            else if (!reflectionOnly && (staticFieldType == typeof(EventTask)) || AttributeTypeNamesMatch(staticFieldType' typeof(EventTask))) " is 130.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddProviderEnumKind,The length of the statement  "            else if (!reflectionOnly && (staticFieldType == typeof(EventKeywords)) || AttributeTypeNamesMatch(staticFieldType' typeof(EventKeywords))) " is 138.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddProviderEnumKind,The length of the statement  "            else if (!reflectionOnly && (staticFieldType == typeof(EventChannel)) || AttributeTypeNamesMatch(staticFieldType' typeof(EventChannel))) " is 136.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddProviderEnumKind,The length of the statement  "            manifest.ManifestError(SR.Format(SR.EventSource_EnumKindMismatch' staticField.Name' staticField.FieldType.Name' providerEnumKind)); " is 131.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DebugCheckEvent,The length of the statement  "                if (eventData[idx].Descriptor.Task == (int)eventAttribute.Task && eventData[idx].Descriptor.Opcode == (int)eventAttribute.Opcode) " is 129.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DebugCheckEvent,The length of the statement  "                    // If we are not strict stop on first error.   We have had problems with really large providers taking forever.  because of many errors.   " is 136.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,DebugCheckEvent,The length of the statement  "                    if ((eventAttribute.Opcode != EventOpcode.Start && eventAttribute.Opcode != EventOpcode.Stop) && eventAttribute.Task == autoAssignedTask) " is 137.
Long Statement,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,InitializeProviderMetadata,The length of the statement  "                        var valueLen = AddValueToMetaData(traitMetaData' value) + 3;    // Emit the value bytes +3 accounts for 3 bytes we emited above.   " is 128.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddKeyword,The length of the statement  "                ManifestError(SR.Format(SR.EventSource_KeywordNeedPowerOfTwo' "0x" + value.ToString("x"' CultureInfo.CurrentCulture)' name)' true); " is 131.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddKeyword,The length of the statement  "                    ManifestError(SR.Format(SR.EventSource_IllegalKeywordsValue' name' "0x" + value.ToString("x"' CultureInfo.CurrentCulture))); " is 124.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddKeyword,The length of the statement  "                if (keywordTab != null && keywordTab.TryGetValue(value' out prevName) && !name.Equals(prevName' StringComparison.Ordinal)) " is 122.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddKeyword,The length of the statement  "                    ManifestError(SR.Format(SR.EventSource_KeywordCollision' name' prevName' "0x" + value.ToString("x"' CultureInfo.CurrentCulture))); " is 130.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,StartEvent,The length of the statement  "                events.Append(" channel=\"").Append(GetChannelName(eventAttribute.Channel' eventName' eventAttribute.Message)).Append("\""); " is 124.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestString,The length of the statement  "            // Avoid using public Array.Sort as that attempts to access BinaryCompatibility. Unfortunately FrameworkEventSource gets called  " is 127.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestString,The length of the statement  "            // very early in the app domain creation' when _FusionStore is not set up yet' resulting in a failure to run the static constructory " is 132.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestString,The length of the statement  "            // for BinaryCompatibility. This failure is then cached and a TypeInitializationException is thrown every time some code attampts to " is 132.
Long Statement,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetKeywords,The length of the statement  "                        ManifestError(SR.Format(SR.EventSource_UndefinedKeyword' "0x" + bit.ToString("x"' CultureInfo.CurrentCulture)' eventName)' true); " is 129.
Long Statement,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetSessionInfo,The length of the statement  "                    hr = UnsafeNativeMethods.ManifestEtw.EnumerateTraceGuidsEx(UnsafeNativeMethods.ManifestEtw.TRACE_QUERY_INFO_CLASS.TraceGuidQueryInfo' " is 133.
Long Statement,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetSessionInfo,The length of the statement  "                providerInstance = (UnsafeNativeMethods.ManifestEtw.TRACE_PROVIDER_INSTANCE_INFO*)&structBase[providerInstance->NextOffset]; " is 124.
Long Statement,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The length of the statement  "                    byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument " is 126.
Long Statement,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The length of the statement  "                        fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]' " is 124.
Long Statement,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The length of the statement  "                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData); " is 147.
Long Statement,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The length of the statement  "                        status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData); " is 147.
Long Statement,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The length of the statement  "            int status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' dataCount' (EventData*)data); " is 160.
Long Statement,System.Diagnostics.Tracing,ActivityTracker,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,OnStart,The length of the statement  "                // We  used to rely on the TPL provider turning us on' but that has the disadvantage that you don't get Start-Stop tracking " is 123.
Long Statement,System.Diagnostics.Tracing,ActivityTracker,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,OnStart,The length of the statement  "                // until you use Tasks for the first time (which you may never do).   Thus we change it to pull rather tan push for whether " is 123.
Long Statement,System.Diagnostics.Tracing,ActivityTracker,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,OnStop,The length of the statement  "                ActivityInfo newCurrentActivity = null;               // if we have seen any live activities (orphans)' at he first one we have seen.    " is 133.
Long Statement,System.Diagnostics.Tracing,ActivityTracker,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,Enable,The length of the statement  "                    System.Diagnostics.Debugger.Log(0' null' "Activity Enabled() called but AsyncLocals Not Supported (pre V4.6).  Ignoring Enable"); " is 129.
Long Statement,System.Diagnostics.Tracing,EventListener,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,CallBackForExistingEventSources,The length of the statement  "                    // Note that we DO have reentrancy here because 'AddListener' calls out to user code (via OnEventSourceCreated callback)  " is 120.
Long Statement,System.Diagnostics.Tracing,EventListener,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,CallBackForExistingEventSources,The length of the statement  "                    // We tolerate this by iterating over a copy of the list here. New event sources will take care of adding listeners themselves " is 126.
Long Statement,System.Diagnostics.Tracing,EventListener,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,CallBackForExistingEventSources,The length of the statement  "                    // EventSources are not guaranteed to be added at the end of the s_EventSource list -- We re-use slots when a new source " is 120.
Long Statement,System.Diagnostics.Tracing,EventSourceActivity,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\EventSourceActivity.cs,Start,The length of the statement  "                this.eventSource.Write(eventName' ref newActivity.startStopOptions' ref newActivity.activityId' ref relatedActivityId' ref data); " is 129.
Long Statement,System.Diagnostics.Tracing,PropertyValue,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetReferenceTypePropertyGetter,The length of the statement  "            var helper = (TypeHelper)Activator.CreateInstance(typeof(ReferenceTypeHelper<>).MakeGenericType(property.DeclaringType)); " is 121.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Boolean)) { var f = (Func<TContainer' Boolean>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 177.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Byte)) { var f = (Func<TContainer' Byte>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 171.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(SByte)) { var f = (Func<TContainer' SByte>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 173.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Char)) { var f = (Func<TContainer' Char>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 171.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Int16)) { var f = (Func<TContainer' Int16>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 173.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(UInt16)) { var f = (Func<TContainer' UInt16>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 175.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Int32)) { var f = (Func<TContainer' Int32>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 173.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(UInt32)) { var f = (Func<TContainer' UInt32>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 175.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Int64)) { var f = (Func<TContainer' Int64>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 173.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(UInt64)) { var f = (Func<TContainer' UInt64>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 175.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(IntPtr)) { var f = (Func<TContainer' IntPtr>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 175.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(UIntPtr)) { var f = (Func<TContainer' UIntPtr>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 177.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Single)) { var f = (Func<TContainer' Single>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 175.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Double)) { var f = (Func<TContainer' Double>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 175.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Guid)) { var f = (Func<TContainer' Guid>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 171.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(DateTime)) { var f = (Func<TContainer' DateTime>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 179.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(DateTimeOffset)) { var f = (Func<TContainer' DateTimeOffset>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 191.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(TimeSpan)) { var f = (Func<TContainer' TimeSpan>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 179.
Long Statement,System.Diagnostics.Tracing,ReferenceTypeHelper<TContainer>,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\PropertyValue.cs,GetPropertyGetter,The length of the statement  "                    if (type == typeof(Decimal)) { var f = (Func<TContainer' Decimal>)GetGetMethod(property' type); return container => new PropertyValue(f((TContainer)container.ReferenceValue)); } " is 177.
Long Statement,System.Diagnostics.Tracing,ScalarTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\SimpleTypeInfos.cs,Guid,The length of the statement  "{ return new ScalarTypeInfo(typeof(Guid)' (f' t) => Statics.MakeDataType(TraceLoggingDataType.Guid' f)' TraceLoggingDataType.Guid); }" is 133.
Long Statement,System.Diagnostics.Tracing,ScalarArrayTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\SimpleTypeInfos.cs,Guid,The length of the statement  "{ return new ScalarArrayTypeInfo(typeof(Guid)' (f' t) => Statics.MakeDataType(TraceLoggingDataType.Guid' f)' TraceLoggingDataType.Guid' sizeof(Guid)); }" is 152.
Long Statement,System.Diagnostics.Tracing,NullableTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\SimpleTypeInfos.cs,WriteData,The length of the statement  "            var val = hasValue.ScalarValue.AsBoolean ? valueGetter(value) : valueInfo.PropertyValueFactory(Activator.CreateInstance(valueInfo.DataType)); " is 141.
Long Statement,Microsoft.Win32,ManifestEtw,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\ManifestEtw.cs,EventWriteTransferWrapper,The length of the statement  "                int HResult = EventWriteTransfer(registrationHandle' ref eventDescriptor' activityId' relatedActivityId' userDataCount' userData); " is 130.
Complex Conditional,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,LogEventArgsMismatches,The conditional expression  "(args[i] != null && (args[i].GetType() != pType))                      || (args[i] == null && (!(pType.IsGenericType && pType.GetGenericTypeDefinition() == typeof(Nullable<>))))"  is complex.
Complex Conditional,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EnsureDescriptorsInitialized,The conditional expression  "eventSourceGuid.Equals(Guid.Empty) || eventSourceName == null || eventData == null || manifest == null"  is complex.
Complex Conditional,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetEventSourceBaseType,The conditional expression  "reflectionOnly && eventSourceType.FullName != typeof(EventSource).FullName ||                          !reflectionOnly && eventSourceType != typeof(EventSource)"  is complex.
Complex Conditional,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,TranslateToManifestConvention,The conditional expression  "i < eventMessage.Length - 1 &&                      (eventMessage[i] == '{' && eventMessage[i + 1] == '{' || eventMessage[i] == '}' && eventMessage[i + 1] == '}')"  is complex.
Complex Conditional,System.Diagnostics.Tracing,EventDescriptor,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventDescriptor.cs,Equals,The conditional expression  "(m_id != other.m_id) ||                  (m_version != other.m_version) ||                  (m_channel != other.m_channel) ||                  (m_level != other.m_level) ||                  (m_opcode != other.m_opcode) ||                  (m_task != other.m_task) ||                  (m_keywords != other.m_keywords)"  is complex.
Virtual Method Call from Constructor,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EventSource,The constructor "EventSource" calls a virtual method "GetMetadata".
Virtual Method Call from Constructor,System.Diagnostics.Tracing,TraceLoggingEventTypes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingEventTypes.cs,TraceLoggingEventTypes,The constructor "TraceLoggingEventTypes" calls a virtual method "WriteMetadata".
Virtual Method Call from Constructor,System.Diagnostics.Tracing,TraceLoggingEventTypes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingEventTypes.cs,TraceLoggingEventTypes,The constructor "TraceLoggingEventTypes" calls a virtual method "WriteMetadata".
Empty Catch Block,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteStringToAllListeners,The method has an empty catch block.
Empty Catch Block,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,ReportOutOfBandMessage,The method has an empty catch block.
Empty Catch Block,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EtwEnableCallBack,The method has an empty catch block.
Magic Number,System.Diagnostics.Tracing,EventCounterGroup,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,EnableTimer,The following statement contains a magic number: if (pollingIntervalInSeconds <= 0)              {                  DisposeTimer();                  _pollingIntervalInMilliseconds = 0;              }              else if (_pollingIntervalInMilliseconds == 0 || pollingIntervalInSeconds * 1000 < _pollingIntervalInMilliseconds)              {                  Debug.WriteLine("Polling interval changed at " + DateTime.UtcNow.ToString("mm.ss.ffffff"));                  _pollingIntervalInMilliseconds = (int)(pollingIntervalInSeconds * 1000);                  DisposeTimer();                  _timeStampSinceCollectionStarted = DateTime.UtcNow;                  _pollingTimer = new Timer(OnTimer' null' _pollingIntervalInMilliseconds' _pollingIntervalInMilliseconds);              }
Magic Number,System.Diagnostics.Tracing,EventCounterGroup,C:\selectedRepos\dotnet_corefx\src\System.Diagnostics.Tracing\src\System\Diagnostics\Tracing\EventCounter.cs,EnableTimer,The following statement contains a magic number: if (pollingIntervalInSeconds <= 0)              {                  DisposeTimer();                  _pollingIntervalInMilliseconds = 0;              }              else if (_pollingIntervalInMilliseconds == 0 || pollingIntervalInSeconds * 1000 < _pollingIntervalInMilliseconds)              {                  Debug.WriteLine("Polling interval changed at " + DateTime.UtcNow.ToString("mm.ss.ffffff"));                  _pollingIntervalInMilliseconds = (int)(pollingIntervalInSeconds * 1000);                  DisposeTimer();                  _timeStampSinceCollectionStarted = DateTime.UtcNow;                  _pollingTimer = new Timer(OnTimer' null' _pollingIntervalInMilliseconds' _pollingIntervalInMilliseconds);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetTrait,The following statement contains a magic number: if (m_traits != null)              {                  for (int i = 0; i < m_traits.Length - 1; i += 2)                  {                      if (m_traits[i] == key)                          return m_traits[i + 1];                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[1];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  WriteEventCore(eventId' 1' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 4;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 4;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 4;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 4;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 4;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 4;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 4;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 4;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 4;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[1];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  WriteEventCore(eventId' 1' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  WriteEventCore(eventId' 2' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 8;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 8;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 8;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 8;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 8;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 8;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  descrs[1].DataPointer = (IntPtr)(&arg2);                  descrs[1].Size = 8;                  descrs[2].DataPointer = (IntPtr)(&arg3);                  descrs[2].Size = 8;                  WriteEventCore(eventId' 3' descrs);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[1];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      WriteEventCore(eventId' 1' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  if (arg2 == null) arg2 = "";                  if (arg3 == null) arg3 = "";                  fixed (char* string1Bytes = arg1)                  fixed (char* string2Bytes = arg2)                  fixed (char* string3Bytes = arg3)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      descrs[2].DataPointer = (IntPtr)string3Bytes;                      descrs[2].Size = ((arg3.Length + 1) * 2);                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = 4;                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = 4;                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = 4;                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = 4;                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = 4;                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = 4;                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&arg3);                      descrs[2].Size = 4;                      WriteEventCore(eventId' 3' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 8;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 8;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 8;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg1 == null) arg1 = "";                  fixed (char* string1Bytes = arg1)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)string1Bytes;                      descrs[0].Size = ((arg1.Length + 1) * 2);                      descrs[1].DataPointer = (IntPtr)(&arg2);                      descrs[1].Size = 8;                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 8;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 8;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 8;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 8;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  if (arg2 == null) arg2 = "";                  fixed (char* string2Bytes = arg2)                  {                      EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                      descrs[0].DataPointer = (IntPtr)(&arg1);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)string2Bytes;                      descrs[1].Size = ((arg2.Length + 1) * 2);                      WriteEventCore(eventId' 2' descrs);                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  if (arg1 == null || arg1.Length == 0)                  {                      int blobSize = 0;                      descrs[0].DataPointer = (IntPtr)(&blobSize);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty content                       descrs[1].Size = 0;                      WriteEventCore(eventId' 2' descrs);                  }                  else                  {                      int blobSize = arg1.Length;                      fixed (byte* blob = &arg1[0])                      {                          descrs[0].DataPointer = (IntPtr)(&blobSize);                          descrs[0].Size = 4;                          descrs[1].DataPointer = (IntPtr)blob;                          descrs[1].Size = blobSize;                          WriteEventCore(eventId' 2' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  if (arg1 == null || arg1.Length == 0)                  {                      int blobSize = 0;                      descrs[0].DataPointer = (IntPtr)(&blobSize);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty content                       descrs[1].Size = 0;                      WriteEventCore(eventId' 2' descrs);                  }                  else                  {                      int blobSize = arg1.Length;                      fixed (byte* blob = &arg1[0])                      {                          descrs[0].DataPointer = (IntPtr)(&blobSize);                          descrs[0].Size = 4;                          descrs[1].DataPointer = (IntPtr)blob;                          descrs[1].Size = blobSize;                          WriteEventCore(eventId' 2' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  if (arg1 == null || arg1.Length == 0)                  {                      int blobSize = 0;                      descrs[0].DataPointer = (IntPtr)(&blobSize);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty content                       descrs[1].Size = 0;                      WriteEventCore(eventId' 2' descrs);                  }                  else                  {                      int blobSize = arg1.Length;                      fixed (byte* blob = &arg1[0])                      {                          descrs[0].DataPointer = (IntPtr)(&blobSize);                          descrs[0].Size = 4;                          descrs[1].DataPointer = (IntPtr)blob;                          descrs[1].Size = blobSize;                          WriteEventCore(eventId' 2' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  if (arg1 == null || arg1.Length == 0)                  {                      int blobSize = 0;                      descrs[0].DataPointer = (IntPtr)(&blobSize);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty content                       descrs[1].Size = 0;                      WriteEventCore(eventId' 2' descrs);                  }                  else                  {                      int blobSize = arg1.Length;                      fixed (byte* blob = &arg1[0])                      {                          descrs[0].DataPointer = (IntPtr)(&blobSize);                          descrs[0].Size = 4;                          descrs[1].DataPointer = (IntPtr)blob;                          descrs[1].Size = blobSize;                          WriteEventCore(eventId' 2' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[2];                  if (arg1 == null || arg1.Length == 0)                  {                      int blobSize = 0;                      descrs[0].DataPointer = (IntPtr)(&blobSize);                      descrs[0].Size = 4;                      descrs[1].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty content                       descrs[1].Size = 0;                      WriteEventCore(eventId' 2' descrs);                  }                  else                  {                      int blobSize = arg1.Length;                      fixed (byte* blob = &arg1[0])                      {                          descrs[0].DataPointer = (IntPtr)(&blobSize);                          descrs[0].Size = 4;                          descrs[1].DataPointer = (IntPtr)blob;                          descrs[1].Size = blobSize;                          WriteEventCore(eventId' 2' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (m_eventSourceEnabled)              {                  EventSource.EventData* descrs = stackalloc EventSource.EventData[3];                  descrs[0].DataPointer = (IntPtr)(&arg1);                  descrs[0].Size = 8;                  if (arg2 == null || arg2.Length == 0)                  {                      int blobSize = 0;                      descrs[1].DataPointer = (IntPtr)(&blobSize);                      descrs[1].Size = 4;                      descrs[2].DataPointer = (IntPtr)(&blobSize); // valid address instead of empty contents                       descrs[2].Size = 0;                      WriteEventCore(eventId' 3' descrs);                  }                  else                  {                      int blobSize = arg2.Length;                      fixed (byte* blob = &arg2[0])                      {                          descrs[1].DataPointer = (IntPtr)(&blobSize);                          descrs[1].Size = 4;                          descrs[2].DataPointer = (IntPtr)blob;                          descrs[2].Size = blobSize;                          WriteEventCore(eventId' 3' descrs);                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,Initialize,The following statement contains a magic number: try              {                  m_traits = traits;                  if (m_traits != null && m_traits.Length % 2 != 0)                  {                      throw new ArgumentException(SR.EventSource_TraitEven' nameof(traits));                  }                    if (eventSourceGuid == Guid.Empty)                  {                      throw new ArgumentException(SR.EventSource_NeedGuid);                  }                    if (eventSourceName == null)                  {                      throw new ArgumentException(SR.EventSource_NeedName);                  }                    m_name = eventSourceName;                  m_guid = eventSourceGuid;  #if FEATURE_ACTIVITYSAMPLING                  m_curLiveSessions = new SessionMask(0);                  m_etwSessionIdMap = new EtwSession[SessionMask.MAX];  #endif // FEATURE_ACTIVITYSAMPLING                    //Enable Implicit Activity tracker                  m_activityTracker = ActivityTracker.Instance;    #if FEATURE_MANAGED_ETW                  // Create and register our provider traits.  We do this early because it is needed to log errors                   // In the self-describing event case.                   this.InitializeProviderMetadata();                    // Register the provider with ETW                  var provider = new OverideEventProvider(this);                  provider.Register(this);  #endif                  // Add the eventSource to the global (weak) list.                    // This also sets m_id' which is the index in the list.                   EventListener.AddEventSource(this);    #if FEATURE_MANAGED_ETW                  // OK if we get this far without an exception' then we can at least write out error messages.                   // Set m_provider' which allows this.                    m_provider = provider;    #if PLATFORM_WINDOWS  #if (!ES_BUILD_STANDALONE && !ES_BUILD_PN)                  // API available on OS >= Win 8 and patched Win 7.                  // Disable only for FrameworkEventSource to avoid recursion inside exception handling.                  if (this.Name != "System.Diagnostics.Eventing.FrameworkEventSource" || Environment.IsWindows8OrAbove)  #endif                  {                      int setInformationResult;                      System.Runtime.InteropServices.GCHandle metadataHandle =                          System.Runtime.InteropServices.GCHandle.Alloc(this.providerMetadata' System.Runtime.InteropServices.GCHandleType.Pinned);                      IntPtr providerMetadata = metadataHandle.AddrOfPinnedObject();                        setInformationResult = m_provider.SetInformation(                          UnsafeNativeMethods.ManifestEtw.EVENT_INFO_CLASS.SetTraits'                          providerMetadata'                          (uint)this.providerMetadata.Length);                        metadataHandle.Free();                  }  #endif // PLATFORM_WINDOWS  #endif // FEATURE_MANAGED_ETW                  Debug.Assert(!m_eventSourceEnabled);     // We can't be enabled until we are completely initted.                    // We are logically completely initialized at this point.                    m_completelyInited = true;              }              catch (Exception e)              {                  if (m_constructionException == null)                      m_constructionException = e;                  ReportOutOfBandMessage("ERROR: Exception during construction of EventSource " + Name + ": " + e.Message' true);              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GenerateGuidFromName,The following statement contains a magic number: Array.Resize(ref bytes' 16);
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GenerateGuidFromName,The following statement contains a magic number: bytes[7] = unchecked((byte)((bytes[7] & 0x0F) | 0x50));
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GenerateGuidFromName,The following statement contains a magic number: bytes[7] = unchecked((byte)((bytes[7] & 0x0F) | 0x50));
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteToAllListeners,The following statement contains a magic number: for (int i = 0; i < paramCount; i++)              {                  Type parameterType = GetDataType(m_eventData[eventId]' i);                  if (parameterType == typeof(byte[]))                  {                      modifiedParamCount += 2;                  }                  else                  {                      modifiedParamCount++;                  }              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The following statement contains a magic number: try              {                  MethodInfo[] methods = eventSourceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);                  EventAttribute defaultEventAttribute;                  int eventId = 1;        // The number given to an event that does not have a explicitly given ID.                   EventMetadata[] eventData = null;                  Dictionary<string' string> eventsByName = null;                  if (source != null || (flags & EventManifestOptions.Strict) != 0)                  {                      eventData = new EventMetadata[methods.Length + 1];                      eventData[0].Name = "";         // Event 0 is the 'write messages string' event' and has an empty name.                  }                    // See if we have localization information.                    ResourceManager resources = null;                  EventSourceAttribute eventSourceAttrib = (EventSourceAttribute)GetCustomAttributeHelper(eventSourceType' typeof(EventSourceAttribute)' flags);                  if (eventSourceAttrib != null && eventSourceAttrib.LocalizationResources != null)                      resources = new ResourceManager(eventSourceAttrib.LocalizationResources' eventSourceType.Assembly());                    manifest = new ManifestBuilder(GetName(eventSourceType' flags)' GetGuid(eventSourceType)' eventSourceDllName'                                                 resources' flags);                    // Add an entry unconditionally for event ID 0 which will be for a string message.                    manifest.StartEvent("EventSourceMessage"' new EventAttribute(0) { Level = EventLevel.LogAlways' Task = (EventTask)0xFFFE });                  manifest.AddEventParameter(typeof(string)' "message");                  manifest.EndEvent();                    // eventSourceType must be sealed and must derive from this EventSource                  if ((flags & EventManifestOptions.Strict) != 0)                  {                      bool typeMatch = GetEventSourceBaseType(eventSourceType' (flags & EventManifestOptions.AllowEventSourceOverride) != 0' eventSourceType.Assembly().ReflectionOnly()) != null;                        if (!typeMatch)                      {                          manifest.ManifestError(SR.EventSource_TypeMustDeriveFromEventSource);                      }                      if (!eventSourceType.IsAbstract() && !eventSourceType.IsSealed())                      {                          manifest.ManifestError(SR.EventSource_TypeMustBeSealedOrAbstract);                      }                  }                    // Collect task' opcode' keyword and channel information  #if FEATURE_MANAGED_ETW_CHANNELS && FEATURE_ADVANCED_MANAGED_ETW_CHANNELS                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes"' "Channels" })  #else                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes" })  #endif                  {                      Type nestedType = eventSourceType.GetNestedType(providerEnumKind);                      if (nestedType != null)                      {                          if (eventSourceType.IsAbstract())                          {                              manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareKTOC' nestedType.Name));                          }                          else                          {                              foreach (FieldInfo staticField in nestedType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static))                              {                                  AddProviderEnumKind(manifest' staticField' providerEnumKind);                              }                          }                      }                  }                  // ensure we have keywords for the session-filtering reserved bits                  {                      manifest.AddKeyword("Session3"' (long)0x1000 << 32);                      manifest.AddKeyword("Session2"' (long)0x2000 << 32);                      manifest.AddKeyword("Session1"' (long)0x4000 << 32);                      manifest.AddKeyword("Session0"' (long)0x8000 << 32);                  }                    if (eventSourceType != typeof(EventSource))                  {                      for (int i = 0; i < methods.Length; i++)                      {                          MethodInfo method = methods[i];                          ParameterInfo[] args = method.GetParameters();                            // Get the EventDescriptor (from the Custom attributes)                          EventAttribute eventAttribute = (EventAttribute)GetCustomAttributeHelper(method' typeof(EventAttribute)' flags);                            // Compat: until v4.5.1 we ignored any non-void returning methods as well as virtual methods for                           // the only reason of limiting the number of methods considered to be events. This broke a common                           // design of having event sources implement specific interfaces. To fix this in a compatible way                          // we will now allow both non-void returning and virtual methods to be Event methods' as long                           // as they are marked with the [Event] attribute                          if (/* method.IsVirtual || */ method.IsStatic)                          {                              continue;                          }                            if (eventSourceType.IsAbstract())                          {                              if (eventAttribute != null)                              {                                  manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareEventMethods' method.Name' eventAttribute.EventId));                              }                              continue;                          }                          else if (eventAttribute == null)                          {                              // Methods that don't return void can't be events' if they're NOT marked with [Event].                              // (see Compat comment above)                              if (method.ReturnType != typeof(void))                              {                                  continue;                              }                                // Continue to ignore virtual methods if they do NOT have the [Event] attribute                              // (see Compat comment above)                              if (method.IsVirtual)                              {                                  continue;                              }                                // If we explicitly mark the method as not being an event' then honor that.                                if (GetCustomAttributeHelper(method' typeof(NonEventAttribute)' flags) != null)                                  continue;                                defaultEventAttribute = new EventAttribute(eventId);                              eventAttribute = defaultEventAttribute;                          }                          else if (eventAttribute.EventId <= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_NeedPositiveId' method.Name)' true);                              continue;   // don't validate anything else for this event                          }                          if (method.Name.LastIndexOf('.') >= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_EventMustNotBeExplicitImplementation' method.Name' eventAttribute.EventId));                          }                            eventId++;                          string eventName = method.Name;                            if (eventAttribute.Opcode == EventOpcode.Info)      // We are still using the default opcode.                           {                              // By default pick a task ID derived from the EventID' starting with the highest task number and working back                               bool noTask = (eventAttribute.Task == EventTask.None);                              if (noTask)                                  eventAttribute.Task = (EventTask)(0xFFFE - eventAttribute.EventId);                                // Unless we explicitly set the opcode to Info (to override the auto-generate of Start or Stop opcodes'                               // pick a default opcode based on the event name (either Info or start or stop if the name ends with that suffix).                                if (!eventAttribute.IsOpcodeSet)                                  eventAttribute.Opcode = GetOpcodeWithDefault(EventOpcode.Info' eventName);                                // Make the stop opcode have the same task as the start opcode.                              if (noTask)                              {                                  if (eventAttribute.Opcode == EventOpcode.Start)                                  {                                      string taskName = eventName.Substring(0' eventName.Length - s_ActivityStartSuffix.Length); // Remove the Stop suffix to get the task name                                      if (string.Compare(eventName' 0' taskName' 0' taskName.Length) == 0 &&                                          string.Compare(eventName' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(eventName.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                      {                                          // Add a task that is just the task name for the start event.   This suppress the auto-task generation                                          // That would otherwise happen (and create 'TaskName'Start as task name rather than just 'TaskName'                                          manifest.AddTask(taskName' (int)eventAttribute.Task);                                      }                                  }                                  else if (eventAttribute.Opcode == EventOpcode.Stop)                                  {                                      // Find the start associated with this stop event.  We require start to be immediately before the stop                                      int startEventId = eventAttribute.EventId - 1;                                      if (eventData != null && startEventId < eventData.Length)                                      {                                          Debug.Assert(0 <= startEventId);                // Since we reserve id 0' we know that id-1 is <= 0                                          EventMetadata startEventMetadata = eventData[startEventId];                                            // If you remove the Stop and add a Start does that name match the Start Event's Name?                                          // Ideally we would throw an error                                           string taskName = eventName.Substring(0' eventName.Length - s_ActivityStopSuffix.Length); // Remove the Stop suffix to get the task name                                          if (startEventMetadata.Descriptor.Opcode == (byte)EventOpcode.Start &&                                              string.Compare(startEventMetadata.Name' 0' taskName' 0' taskName.Length) == 0 &&                                              string.Compare(startEventMetadata.Name' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(startEventMetadata.Name.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                          {                                                // Make the stop event match the start event                                              eventAttribute.Task = (EventTask)startEventMetadata.Descriptor.Task;                                              noTask = false;                                          }                                      }                                      if (noTask && (flags & EventManifestOptions.Strict) != 0)        // Throw an error if we can compatibly.                                         {                                          throw new ArgumentException(SR.EventSource_StopsFollowStarts);                                      }                                  }                              }                          }                            bool hasRelatedActivityID = RemoveFirstArgIfRelatedActivityId(ref args);                          if (!(source != null && source.SelfDescribingEvents))                          {                              manifest.StartEvent(eventName' eventAttribute);                              for (int fieldIdx = 0; fieldIdx < args.Length; fieldIdx++)                              {                                  manifest.AddEventParameter(args[fieldIdx].ParameterType' args[fieldIdx].Name);                              }                              manifest.EndEvent();                          }                            if (source != null || (flags & EventManifestOptions.Strict) != 0)                          {                              // Do checking for user errors (optional' but not a big deal so we do it).                                DebugCheckEvent(ref eventsByName' eventData' method' eventAttribute' manifest' flags);    #if FEATURE_MANAGED_ETW_CHANNELS                              // add the channel keyword for Event Viewer channel based filters. This is added for creating the EventDescriptors only                              // and is not required for the manifest                              if (eventAttribute.Channel != EventChannel.None)                              {                                  unchecked                                  {                                      eventAttribute.Keywords |= (EventKeywords)manifest.GetChannelKeyword(eventAttribute.Channel' (ulong)eventAttribute.Keywords);                                  }                              }  #endif                              string eventKey = "event_" + eventName;                              string msg = manifest.GetLocalizedMessage(eventKey' CultureInfo.CurrentUICulture' etwFormat: false);                              // overwrite inline message with the localized message                              if (msg != null) eventAttribute.Message = msg;                                AddEventDescriptor(ref eventData' eventName' eventAttribute' args' hasRelatedActivityID);                          }                      }                  }                    // Tell the TraceLogging stuff where to start allocating its own IDs.                    NameInfo.ReserveEventIDsBelow(eventId);                    if (source != null)                  {                      TrimEventDescriptors(ref eventData);                      source.m_eventData = eventData;     // officially initialize it. We do this at most once (it is racy otherwise).   #if FEATURE_MANAGED_ETW_CHANNELS                      source.m_channelData = manifest.GetChannelData();  #endif                  }                    // if this is an abstract event source we've already performed all the validation we can                  if (!eventSourceType.IsAbstract() && (source == null || !source.SelfDescribingEvents))                  {                      bNeedsManifest = (flags & EventManifestOptions.OnlyIfNeededForRegistration) == 0  #if FEATURE_MANAGED_ETW_CHANNELS                                              || manifest.GetChannelData().Length > 0  #endif  ;                        // if the manifest is not needed and we're not requested to validate the event source return early                      if (!bNeedsManifest && (flags & EventManifestOptions.Strict) == 0)                          return null;                        res = manifest.CreateManifest();                  }              }              catch (Exception e)              {                  // if this is a runtime manifest generation let the exception propagate                  if ((flags & EventManifestOptions.Strict) == 0)                      throw;                  // else store it to include it in the Argument exception we raise below                  exception = e;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The following statement contains a magic number: try              {                  MethodInfo[] methods = eventSourceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);                  EventAttribute defaultEventAttribute;                  int eventId = 1;        // The number given to an event that does not have a explicitly given ID.                   EventMetadata[] eventData = null;                  Dictionary<string' string> eventsByName = null;                  if (source != null || (flags & EventManifestOptions.Strict) != 0)                  {                      eventData = new EventMetadata[methods.Length + 1];                      eventData[0].Name = "";         // Event 0 is the 'write messages string' event' and has an empty name.                  }                    // See if we have localization information.                    ResourceManager resources = null;                  EventSourceAttribute eventSourceAttrib = (EventSourceAttribute)GetCustomAttributeHelper(eventSourceType' typeof(EventSourceAttribute)' flags);                  if (eventSourceAttrib != null && eventSourceAttrib.LocalizationResources != null)                      resources = new ResourceManager(eventSourceAttrib.LocalizationResources' eventSourceType.Assembly());                    manifest = new ManifestBuilder(GetName(eventSourceType' flags)' GetGuid(eventSourceType)' eventSourceDllName'                                                 resources' flags);                    // Add an entry unconditionally for event ID 0 which will be for a string message.                    manifest.StartEvent("EventSourceMessage"' new EventAttribute(0) { Level = EventLevel.LogAlways' Task = (EventTask)0xFFFE });                  manifest.AddEventParameter(typeof(string)' "message");                  manifest.EndEvent();                    // eventSourceType must be sealed and must derive from this EventSource                  if ((flags & EventManifestOptions.Strict) != 0)                  {                      bool typeMatch = GetEventSourceBaseType(eventSourceType' (flags & EventManifestOptions.AllowEventSourceOverride) != 0' eventSourceType.Assembly().ReflectionOnly()) != null;                        if (!typeMatch)                      {                          manifest.ManifestError(SR.EventSource_TypeMustDeriveFromEventSource);                      }                      if (!eventSourceType.IsAbstract() && !eventSourceType.IsSealed())                      {                          manifest.ManifestError(SR.EventSource_TypeMustBeSealedOrAbstract);                      }                  }                    // Collect task' opcode' keyword and channel information  #if FEATURE_MANAGED_ETW_CHANNELS && FEATURE_ADVANCED_MANAGED_ETW_CHANNELS                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes"' "Channels" })  #else                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes" })  #endif                  {                      Type nestedType = eventSourceType.GetNestedType(providerEnumKind);                      if (nestedType != null)                      {                          if (eventSourceType.IsAbstract())                          {                              manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareKTOC' nestedType.Name));                          }                          else                          {                              foreach (FieldInfo staticField in nestedType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static))                              {                                  AddProviderEnumKind(manifest' staticField' providerEnumKind);                              }                          }                      }                  }                  // ensure we have keywords for the session-filtering reserved bits                  {                      manifest.AddKeyword("Session3"' (long)0x1000 << 32);                      manifest.AddKeyword("Session2"' (long)0x2000 << 32);                      manifest.AddKeyword("Session1"' (long)0x4000 << 32);                      manifest.AddKeyword("Session0"' (long)0x8000 << 32);                  }                    if (eventSourceType != typeof(EventSource))                  {                      for (int i = 0; i < methods.Length; i++)                      {                          MethodInfo method = methods[i];                          ParameterInfo[] args = method.GetParameters();                            // Get the EventDescriptor (from the Custom attributes)                          EventAttribute eventAttribute = (EventAttribute)GetCustomAttributeHelper(method' typeof(EventAttribute)' flags);                            // Compat: until v4.5.1 we ignored any non-void returning methods as well as virtual methods for                           // the only reason of limiting the number of methods considered to be events. This broke a common                           // design of having event sources implement specific interfaces. To fix this in a compatible way                          // we will now allow both non-void returning and virtual methods to be Event methods' as long                           // as they are marked with the [Event] attribute                          if (/* method.IsVirtual || */ method.IsStatic)                          {                              continue;                          }                            if (eventSourceType.IsAbstract())                          {                              if (eventAttribute != null)                              {                                  manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareEventMethods' method.Name' eventAttribute.EventId));                              }                              continue;                          }                          else if (eventAttribute == null)                          {                              // Methods that don't return void can't be events' if they're NOT marked with [Event].                              // (see Compat comment above)                              if (method.ReturnType != typeof(void))                              {                                  continue;                              }                                // Continue to ignore virtual methods if they do NOT have the [Event] attribute                              // (see Compat comment above)                              if (method.IsVirtual)                              {                                  continue;                              }                                // If we explicitly mark the method as not being an event' then honor that.                                if (GetCustomAttributeHelper(method' typeof(NonEventAttribute)' flags) != null)                                  continue;                                defaultEventAttribute = new EventAttribute(eventId);                              eventAttribute = defaultEventAttribute;                          }                          else if (eventAttribute.EventId <= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_NeedPositiveId' method.Name)' true);                              continue;   // don't validate anything else for this event                          }                          if (method.Name.LastIndexOf('.') >= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_EventMustNotBeExplicitImplementation' method.Name' eventAttribute.EventId));                          }                            eventId++;                          string eventName = method.Name;                            if (eventAttribute.Opcode == EventOpcode.Info)      // We are still using the default opcode.                           {                              // By default pick a task ID derived from the EventID' starting with the highest task number and working back                               bool noTask = (eventAttribute.Task == EventTask.None);                              if (noTask)                                  eventAttribute.Task = (EventTask)(0xFFFE - eventAttribute.EventId);                                // Unless we explicitly set the opcode to Info (to override the auto-generate of Start or Stop opcodes'                               // pick a default opcode based on the event name (either Info or start or stop if the name ends with that suffix).                                if (!eventAttribute.IsOpcodeSet)                                  eventAttribute.Opcode = GetOpcodeWithDefault(EventOpcode.Info' eventName);                                // Make the stop opcode have the same task as the start opcode.                              if (noTask)                              {                                  if (eventAttribute.Opcode == EventOpcode.Start)                                  {                                      string taskName = eventName.Substring(0' eventName.Length - s_ActivityStartSuffix.Length); // Remove the Stop suffix to get the task name                                      if (string.Compare(eventName' 0' taskName' 0' taskName.Length) == 0 &&                                          string.Compare(eventName' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(eventName.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                      {                                          // Add a task that is just the task name for the start event.   This suppress the auto-task generation                                          // That would otherwise happen (and create 'TaskName'Start as task name rather than just 'TaskName'                                          manifest.AddTask(taskName' (int)eventAttribute.Task);                                      }                                  }                                  else if (eventAttribute.Opcode == EventOpcode.Stop)                                  {                                      // Find the start associated with this stop event.  We require start to be immediately before the stop                                      int startEventId = eventAttribute.EventId - 1;                                      if (eventData != null && startEventId < eventData.Length)                                      {                                          Debug.Assert(0 <= startEventId);                // Since we reserve id 0' we know that id-1 is <= 0                                          EventMetadata startEventMetadata = eventData[startEventId];                                            // If you remove the Stop and add a Start does that name match the Start Event's Name?                                          // Ideally we would throw an error                                           string taskName = eventName.Substring(0' eventName.Length - s_ActivityStopSuffix.Length); // Remove the Stop suffix to get the task name                                          if (startEventMetadata.Descriptor.Opcode == (byte)EventOpcode.Start &&                                              string.Compare(startEventMetadata.Name' 0' taskName' 0' taskName.Length) == 0 &&                                              string.Compare(startEventMetadata.Name' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(startEventMetadata.Name.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                          {                                                // Make the stop event match the start event                                              eventAttribute.Task = (EventTask)startEventMetadata.Descriptor.Task;                                              noTask = false;                                          }                                      }                                      if (noTask && (flags & EventManifestOptions.Strict) != 0)        // Throw an error if we can compatibly.                                         {                                          throw new ArgumentException(SR.EventSource_StopsFollowStarts);                                      }                                  }                              }                          }                            bool hasRelatedActivityID = RemoveFirstArgIfRelatedActivityId(ref args);                          if (!(source != null && source.SelfDescribingEvents))                          {                              manifest.StartEvent(eventName' eventAttribute);                              for (int fieldIdx = 0; fieldIdx < args.Length; fieldIdx++)                              {                                  manifest.AddEventParameter(args[fieldIdx].ParameterType' args[fieldIdx].Name);                              }                              manifest.EndEvent();                          }                            if (source != null || (flags & EventManifestOptions.Strict) != 0)                          {                              // Do checking for user errors (optional' but not a big deal so we do it).                                DebugCheckEvent(ref eventsByName' eventData' method' eventAttribute' manifest' flags);    #if FEATURE_MANAGED_ETW_CHANNELS                              // add the channel keyword for Event Viewer channel based filters. This is added for creating the EventDescriptors only                              // and is not required for the manifest                              if (eventAttribute.Channel != EventChannel.None)                              {                                  unchecked                                  {                                      eventAttribute.Keywords |= (EventKeywords)manifest.GetChannelKeyword(eventAttribute.Channel' (ulong)eventAttribute.Keywords);                                  }                              }  #endif                              string eventKey = "event_" + eventName;                              string msg = manifest.GetLocalizedMessage(eventKey' CultureInfo.CurrentUICulture' etwFormat: false);                              // overwrite inline message with the localized message                              if (msg != null) eventAttribute.Message = msg;                                AddEventDescriptor(ref eventData' eventName' eventAttribute' args' hasRelatedActivityID);                          }                      }                  }                    // Tell the TraceLogging stuff where to start allocating its own IDs.                    NameInfo.ReserveEventIDsBelow(eventId);                    if (source != null)                  {                      TrimEventDescriptors(ref eventData);                      source.m_eventData = eventData;     // officially initialize it. We do this at most once (it is racy otherwise).   #if FEATURE_MANAGED_ETW_CHANNELS                      source.m_channelData = manifest.GetChannelData();  #endif                  }                    // if this is an abstract event source we've already performed all the validation we can                  if (!eventSourceType.IsAbstract() && (source == null || !source.SelfDescribingEvents))                  {                      bNeedsManifest = (flags & EventManifestOptions.OnlyIfNeededForRegistration) == 0  #if FEATURE_MANAGED_ETW_CHANNELS                                              || manifest.GetChannelData().Length > 0  #endif  ;                        // if the manifest is not needed and we're not requested to validate the event source return early                      if (!bNeedsManifest && (flags & EventManifestOptions.Strict) == 0)                          return null;                        res = manifest.CreateManifest();                  }              }              catch (Exception e)              {                  // if this is a runtime manifest generation let the exception propagate                  if ((flags & EventManifestOptions.Strict) == 0)                      throw;                  // else store it to include it in the Argument exception we raise below                  exception = e;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The following statement contains a magic number: try              {                  MethodInfo[] methods = eventSourceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);                  EventAttribute defaultEventAttribute;                  int eventId = 1;        // The number given to an event that does not have a explicitly given ID.                   EventMetadata[] eventData = null;                  Dictionary<string' string> eventsByName = null;                  if (source != null || (flags & EventManifestOptions.Strict) != 0)                  {                      eventData = new EventMetadata[methods.Length + 1];                      eventData[0].Name = "";         // Event 0 is the 'write messages string' event' and has an empty name.                  }                    // See if we have localization information.                    ResourceManager resources = null;                  EventSourceAttribute eventSourceAttrib = (EventSourceAttribute)GetCustomAttributeHelper(eventSourceType' typeof(EventSourceAttribute)' flags);                  if (eventSourceAttrib != null && eventSourceAttrib.LocalizationResources != null)                      resources = new ResourceManager(eventSourceAttrib.LocalizationResources' eventSourceType.Assembly());                    manifest = new ManifestBuilder(GetName(eventSourceType' flags)' GetGuid(eventSourceType)' eventSourceDllName'                                                 resources' flags);                    // Add an entry unconditionally for event ID 0 which will be for a string message.                    manifest.StartEvent("EventSourceMessage"' new EventAttribute(0) { Level = EventLevel.LogAlways' Task = (EventTask)0xFFFE });                  manifest.AddEventParameter(typeof(string)' "message");                  manifest.EndEvent();                    // eventSourceType must be sealed and must derive from this EventSource                  if ((flags & EventManifestOptions.Strict) != 0)                  {                      bool typeMatch = GetEventSourceBaseType(eventSourceType' (flags & EventManifestOptions.AllowEventSourceOverride) != 0' eventSourceType.Assembly().ReflectionOnly()) != null;                        if (!typeMatch)                      {                          manifest.ManifestError(SR.EventSource_TypeMustDeriveFromEventSource);                      }                      if (!eventSourceType.IsAbstract() && !eventSourceType.IsSealed())                      {                          manifest.ManifestError(SR.EventSource_TypeMustBeSealedOrAbstract);                      }                  }                    // Collect task' opcode' keyword and channel information  #if FEATURE_MANAGED_ETW_CHANNELS && FEATURE_ADVANCED_MANAGED_ETW_CHANNELS                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes"' "Channels" })  #else                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes" })  #endif                  {                      Type nestedType = eventSourceType.GetNestedType(providerEnumKind);                      if (nestedType != null)                      {                          if (eventSourceType.IsAbstract())                          {                              manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareKTOC' nestedType.Name));                          }                          else                          {                              foreach (FieldInfo staticField in nestedType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static))                              {                                  AddProviderEnumKind(manifest' staticField' providerEnumKind);                              }                          }                      }                  }                  // ensure we have keywords for the session-filtering reserved bits                  {                      manifest.AddKeyword("Session3"' (long)0x1000 << 32);                      manifest.AddKeyword("Session2"' (long)0x2000 << 32);                      manifest.AddKeyword("Session1"' (long)0x4000 << 32);                      manifest.AddKeyword("Session0"' (long)0x8000 << 32);                  }                    if (eventSourceType != typeof(EventSource))                  {                      for (int i = 0; i < methods.Length; i++)                      {                          MethodInfo method = methods[i];                          ParameterInfo[] args = method.GetParameters();                            // Get the EventDescriptor (from the Custom attributes)                          EventAttribute eventAttribute = (EventAttribute)GetCustomAttributeHelper(method' typeof(EventAttribute)' flags);                            // Compat: until v4.5.1 we ignored any non-void returning methods as well as virtual methods for                           // the only reason of limiting the number of methods considered to be events. This broke a common                           // design of having event sources implement specific interfaces. To fix this in a compatible way                          // we will now allow both non-void returning and virtual methods to be Event methods' as long                           // as they are marked with the [Event] attribute                          if (/* method.IsVirtual || */ method.IsStatic)                          {                              continue;                          }                            if (eventSourceType.IsAbstract())                          {                              if (eventAttribute != null)                              {                                  manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareEventMethods' method.Name' eventAttribute.EventId));                              }                              continue;                          }                          else if (eventAttribute == null)                          {                              // Methods that don't return void can't be events' if they're NOT marked with [Event].                              // (see Compat comment above)                              if (method.ReturnType != typeof(void))                              {                                  continue;                              }                                // Continue to ignore virtual methods if they do NOT have the [Event] attribute                              // (see Compat comment above)                              if (method.IsVirtual)                              {                                  continue;                              }                                // If we explicitly mark the method as not being an event' then honor that.                                if (GetCustomAttributeHelper(method' typeof(NonEventAttribute)' flags) != null)                                  continue;                                defaultEventAttribute = new EventAttribute(eventId);                              eventAttribute = defaultEventAttribute;                          }                          else if (eventAttribute.EventId <= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_NeedPositiveId' method.Name)' true);                              continue;   // don't validate anything else for this event                          }                          if (method.Name.LastIndexOf('.') >= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_EventMustNotBeExplicitImplementation' method.Name' eventAttribute.EventId));                          }                            eventId++;                          string eventName = method.Name;                            if (eventAttribute.Opcode == EventOpcode.Info)      // We are still using the default opcode.                           {                              // By default pick a task ID derived from the EventID' starting with the highest task number and working back                               bool noTask = (eventAttribute.Task == EventTask.None);                              if (noTask)                                  eventAttribute.Task = (EventTask)(0xFFFE - eventAttribute.EventId);                                // Unless we explicitly set the opcode to Info (to override the auto-generate of Start or Stop opcodes'                               // pick a default opcode based on the event name (either Info or start or stop if the name ends with that suffix).                                if (!eventAttribute.IsOpcodeSet)                                  eventAttribute.Opcode = GetOpcodeWithDefault(EventOpcode.Info' eventName);                                // Make the stop opcode have the same task as the start opcode.                              if (noTask)                              {                                  if (eventAttribute.Opcode == EventOpcode.Start)                                  {                                      string taskName = eventName.Substring(0' eventName.Length - s_ActivityStartSuffix.Length); // Remove the Stop suffix to get the task name                                      if (string.Compare(eventName' 0' taskName' 0' taskName.Length) == 0 &&                                          string.Compare(eventName' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(eventName.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                      {                                          // Add a task that is just the task name for the start event.   This suppress the auto-task generation                                          // That would otherwise happen (and create 'TaskName'Start as task name rather than just 'TaskName'                                          manifest.AddTask(taskName' (int)eventAttribute.Task);                                      }                                  }                                  else if (eventAttribute.Opcode == EventOpcode.Stop)                                  {                                      // Find the start associated with this stop event.  We require start to be immediately before the stop                                      int startEventId = eventAttribute.EventId - 1;                                      if (eventData != null && startEventId < eventData.Length)                                      {                                          Debug.Assert(0 <= startEventId);                // Since we reserve id 0' we know that id-1 is <= 0                                          EventMetadata startEventMetadata = eventData[startEventId];                                            // If you remove the Stop and add a Start does that name match the Start Event's Name?                                          // Ideally we would throw an error                                           string taskName = eventName.Substring(0' eventName.Length - s_ActivityStopSuffix.Length); // Remove the Stop suffix to get the task name                                          if (startEventMetadata.Descriptor.Opcode == (byte)EventOpcode.Start &&                                              string.Compare(startEventMetadata.Name' 0' taskName' 0' taskName.Length) == 0 &&                                              string.Compare(startEventMetadata.Name' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(startEventMetadata.Name.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                          {                                                // Make the stop event match the start event                                              eventAttribute.Task = (EventTask)startEventMetadata.Descriptor.Task;                                              noTask = false;                                          }                                      }                                      if (noTask && (flags & EventManifestOptions.Strict) != 0)        // Throw an error if we can compatibly.                                         {                                          throw new ArgumentException(SR.EventSource_StopsFollowStarts);                                      }                                  }                              }                          }                            bool hasRelatedActivityID = RemoveFirstArgIfRelatedActivityId(ref args);                          if (!(source != null && source.SelfDescribingEvents))                          {                              manifest.StartEvent(eventName' eventAttribute);                              for (int fieldIdx = 0; fieldIdx < args.Length; fieldIdx++)                              {                                  manifest.AddEventParameter(args[fieldIdx].ParameterType' args[fieldIdx].Name);                              }                              manifest.EndEvent();                          }                            if (source != null || (flags & EventManifestOptions.Strict) != 0)                          {                              // Do checking for user errors (optional' but not a big deal so we do it).                                DebugCheckEvent(ref eventsByName' eventData' method' eventAttribute' manifest' flags);    #if FEATURE_MANAGED_ETW_CHANNELS                              // add the channel keyword for Event Viewer channel based filters. This is added for creating the EventDescriptors only                              // and is not required for the manifest                              if (eventAttribute.Channel != EventChannel.None)                              {                                  unchecked                                  {                                      eventAttribute.Keywords |= (EventKeywords)manifest.GetChannelKeyword(eventAttribute.Channel' (ulong)eventAttribute.Keywords);                                  }                              }  #endif                              string eventKey = "event_" + eventName;                              string msg = manifest.GetLocalizedMessage(eventKey' CultureInfo.CurrentUICulture' etwFormat: false);                              // overwrite inline message with the localized message                              if (msg != null) eventAttribute.Message = msg;                                AddEventDescriptor(ref eventData' eventName' eventAttribute' args' hasRelatedActivityID);                          }                      }                  }                    // Tell the TraceLogging stuff where to start allocating its own IDs.                    NameInfo.ReserveEventIDsBelow(eventId);                    if (source != null)                  {                      TrimEventDescriptors(ref eventData);                      source.m_eventData = eventData;     // officially initialize it. We do this at most once (it is racy otherwise).   #if FEATURE_MANAGED_ETW_CHANNELS                      source.m_channelData = manifest.GetChannelData();  #endif                  }                    // if this is an abstract event source we've already performed all the validation we can                  if (!eventSourceType.IsAbstract() && (source == null || !source.SelfDescribingEvents))                  {                      bNeedsManifest = (flags & EventManifestOptions.OnlyIfNeededForRegistration) == 0  #if FEATURE_MANAGED_ETW_CHANNELS                                              || manifest.GetChannelData().Length > 0  #endif  ;                        // if the manifest is not needed and we're not requested to validate the event source return early                      if (!bNeedsManifest && (flags & EventManifestOptions.Strict) == 0)                          return null;                        res = manifest.CreateManifest();                  }              }              catch (Exception e)              {                  // if this is a runtime manifest generation let the exception propagate                  if ((flags & EventManifestOptions.Strict) == 0)                      throw;                  // else store it to include it in the Argument exception we raise below                  exception = e;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,CreateManifestAndDescriptors,The following statement contains a magic number: try              {                  MethodInfo[] methods = eventSourceType.GetMethods(BindingFlags.DeclaredOnly | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Instance);                  EventAttribute defaultEventAttribute;                  int eventId = 1;        // The number given to an event that does not have a explicitly given ID.                   EventMetadata[] eventData = null;                  Dictionary<string' string> eventsByName = null;                  if (source != null || (flags & EventManifestOptions.Strict) != 0)                  {                      eventData = new EventMetadata[methods.Length + 1];                      eventData[0].Name = "";         // Event 0 is the 'write messages string' event' and has an empty name.                  }                    // See if we have localization information.                    ResourceManager resources = null;                  EventSourceAttribute eventSourceAttrib = (EventSourceAttribute)GetCustomAttributeHelper(eventSourceType' typeof(EventSourceAttribute)' flags);                  if (eventSourceAttrib != null && eventSourceAttrib.LocalizationResources != null)                      resources = new ResourceManager(eventSourceAttrib.LocalizationResources' eventSourceType.Assembly());                    manifest = new ManifestBuilder(GetName(eventSourceType' flags)' GetGuid(eventSourceType)' eventSourceDllName'                                                 resources' flags);                    // Add an entry unconditionally for event ID 0 which will be for a string message.                    manifest.StartEvent("EventSourceMessage"' new EventAttribute(0) { Level = EventLevel.LogAlways' Task = (EventTask)0xFFFE });                  manifest.AddEventParameter(typeof(string)' "message");                  manifest.EndEvent();                    // eventSourceType must be sealed and must derive from this EventSource                  if ((flags & EventManifestOptions.Strict) != 0)                  {                      bool typeMatch = GetEventSourceBaseType(eventSourceType' (flags & EventManifestOptions.AllowEventSourceOverride) != 0' eventSourceType.Assembly().ReflectionOnly()) != null;                        if (!typeMatch)                      {                          manifest.ManifestError(SR.EventSource_TypeMustDeriveFromEventSource);                      }                      if (!eventSourceType.IsAbstract() && !eventSourceType.IsSealed())                      {                          manifest.ManifestError(SR.EventSource_TypeMustBeSealedOrAbstract);                      }                  }                    // Collect task' opcode' keyword and channel information  #if FEATURE_MANAGED_ETW_CHANNELS && FEATURE_ADVANCED_MANAGED_ETW_CHANNELS                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes"' "Channels" })  #else                  foreach (var providerEnumKind in new string[] { "Keywords"' "Tasks"' "Opcodes" })  #endif                  {                      Type nestedType = eventSourceType.GetNestedType(providerEnumKind);                      if (nestedType != null)                      {                          if (eventSourceType.IsAbstract())                          {                              manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareKTOC' nestedType.Name));                          }                          else                          {                              foreach (FieldInfo staticField in nestedType.GetFields(BindingFlags.DeclaredOnly | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static))                              {                                  AddProviderEnumKind(manifest' staticField' providerEnumKind);                              }                          }                      }                  }                  // ensure we have keywords for the session-filtering reserved bits                  {                      manifest.AddKeyword("Session3"' (long)0x1000 << 32);                      manifest.AddKeyword("Session2"' (long)0x2000 << 32);                      manifest.AddKeyword("Session1"' (long)0x4000 << 32);                      manifest.AddKeyword("Session0"' (long)0x8000 << 32);                  }                    if (eventSourceType != typeof(EventSource))                  {                      for (int i = 0; i < methods.Length; i++)                      {                          MethodInfo method = methods[i];                          ParameterInfo[] args = method.GetParameters();                            // Get the EventDescriptor (from the Custom attributes)                          EventAttribute eventAttribute = (EventAttribute)GetCustomAttributeHelper(method' typeof(EventAttribute)' flags);                            // Compat: until v4.5.1 we ignored any non-void returning methods as well as virtual methods for                           // the only reason of limiting the number of methods considered to be events. This broke a common                           // design of having event sources implement specific interfaces. To fix this in a compatible way                          // we will now allow both non-void returning and virtual methods to be Event methods' as long                           // as they are marked with the [Event] attribute                          if (/* method.IsVirtual || */ method.IsStatic)                          {                              continue;                          }                            if (eventSourceType.IsAbstract())                          {                              if (eventAttribute != null)                              {                                  manifest.ManifestError(SR.Format(SR.EventSource_AbstractMustNotDeclareEventMethods' method.Name' eventAttribute.EventId));                              }                              continue;                          }                          else if (eventAttribute == null)                          {                              // Methods that don't return void can't be events' if they're NOT marked with [Event].                              // (see Compat comment above)                              if (method.ReturnType != typeof(void))                              {                                  continue;                              }                                // Continue to ignore virtual methods if they do NOT have the [Event] attribute                              // (see Compat comment above)                              if (method.IsVirtual)                              {                                  continue;                              }                                // If we explicitly mark the method as not being an event' then honor that.                                if (GetCustomAttributeHelper(method' typeof(NonEventAttribute)' flags) != null)                                  continue;                                defaultEventAttribute = new EventAttribute(eventId);                              eventAttribute = defaultEventAttribute;                          }                          else if (eventAttribute.EventId <= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_NeedPositiveId' method.Name)' true);                              continue;   // don't validate anything else for this event                          }                          if (method.Name.LastIndexOf('.') >= 0)                          {                              manifest.ManifestError(SR.Format(SR.EventSource_EventMustNotBeExplicitImplementation' method.Name' eventAttribute.EventId));                          }                            eventId++;                          string eventName = method.Name;                            if (eventAttribute.Opcode == EventOpcode.Info)      // We are still using the default opcode.                           {                              // By default pick a task ID derived from the EventID' starting with the highest task number and working back                               bool noTask = (eventAttribute.Task == EventTask.None);                              if (noTask)                                  eventAttribute.Task = (EventTask)(0xFFFE - eventAttribute.EventId);                                // Unless we explicitly set the opcode to Info (to override the auto-generate of Start or Stop opcodes'                               // pick a default opcode based on the event name (either Info or start or stop if the name ends with that suffix).                                if (!eventAttribute.IsOpcodeSet)                                  eventAttribute.Opcode = GetOpcodeWithDefault(EventOpcode.Info' eventName);                                // Make the stop opcode have the same task as the start opcode.                              if (noTask)                              {                                  if (eventAttribute.Opcode == EventOpcode.Start)                                  {                                      string taskName = eventName.Substring(0' eventName.Length - s_ActivityStartSuffix.Length); // Remove the Stop suffix to get the task name                                      if (string.Compare(eventName' 0' taskName' 0' taskName.Length) == 0 &&                                          string.Compare(eventName' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(eventName.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                      {                                          // Add a task that is just the task name for the start event.   This suppress the auto-task generation                                          // That would otherwise happen (and create 'TaskName'Start as task name rather than just 'TaskName'                                          manifest.AddTask(taskName' (int)eventAttribute.Task);                                      }                                  }                                  else if (eventAttribute.Opcode == EventOpcode.Stop)                                  {                                      // Find the start associated with this stop event.  We require start to be immediately before the stop                                      int startEventId = eventAttribute.EventId - 1;                                      if (eventData != null && startEventId < eventData.Length)                                      {                                          Debug.Assert(0 <= startEventId);                // Since we reserve id 0' we know that id-1 is <= 0                                          EventMetadata startEventMetadata = eventData[startEventId];                                            // If you remove the Stop and add a Start does that name match the Start Event's Name?                                          // Ideally we would throw an error                                           string taskName = eventName.Substring(0' eventName.Length - s_ActivityStopSuffix.Length); // Remove the Stop suffix to get the task name                                          if (startEventMetadata.Descriptor.Opcode == (byte)EventOpcode.Start &&                                              string.Compare(startEventMetadata.Name' 0' taskName' 0' taskName.Length) == 0 &&                                              string.Compare(startEventMetadata.Name' taskName.Length' s_ActivityStartSuffix' 0' Math.Max(startEventMetadata.Name.Length - taskName.Length' s_ActivityStartSuffix.Length)) == 0)                                          {                                                // Make the stop event match the start event                                              eventAttribute.Task = (EventTask)startEventMetadata.Descriptor.Task;                                              noTask = false;                                          }                                      }                                      if (noTask && (flags & EventManifestOptions.Strict) != 0)        // Throw an error if we can compatibly.                                         {                                          throw new ArgumentException(SR.EventSource_StopsFollowStarts);                                      }                                  }                              }                          }                            bool hasRelatedActivityID = RemoveFirstArgIfRelatedActivityId(ref args);                          if (!(source != null && source.SelfDescribingEvents))                          {                              manifest.StartEvent(eventName' eventAttribute);                              for (int fieldIdx = 0; fieldIdx < args.Length; fieldIdx++)                              {                                  manifest.AddEventParameter(args[fieldIdx].ParameterType' args[fieldIdx].Name);                              }                              manifest.EndEvent();                          }                            if (source != null || (flags & EventManifestOptions.Strict) != 0)                          {                              // Do checking for user errors (optional' but not a big deal so we do it).                                DebugCheckEvent(ref eventsByName' eventData' method' eventAttribute' manifest' flags);    #if FEATURE_MANAGED_ETW_CHANNELS                              // add the channel keyword for Event Viewer channel based filters. This is added for creating the EventDescriptors only                              // and is not required for the manifest                              if (eventAttribute.Channel != EventChannel.None)                              {                                  unchecked                                  {                                      eventAttribute.Keywords |= (EventKeywords)manifest.GetChannelKeyword(eventAttribute.Channel' (ulong)eventAttribute.Keywords);                                  }                              }  #endif                              string eventKey = "event_" + eventName;                              string msg = manifest.GetLocalizedMessage(eventKey' CultureInfo.CurrentUICulture' etwFormat: false);                              // overwrite inline message with the localized message                              if (msg != null) eventAttribute.Message = msg;                                AddEventDescriptor(ref eventData' eventName' eventAttribute' args' hasRelatedActivityID);                          }                      }                  }                    // Tell the TraceLogging stuff where to start allocating its own IDs.                    NameInfo.ReserveEventIDsBelow(eventId);                    if (source != null)                  {                      TrimEventDescriptors(ref eventData);                      source.m_eventData = eventData;     // officially initialize it. We do this at most once (it is racy otherwise).   #if FEATURE_MANAGED_ETW_CHANNELS                      source.m_channelData = manifest.GetChannelData();  #endif                  }                    // if this is an abstract event source we've already performed all the validation we can                  if (!eventSourceType.IsAbstract() && (source == null || !source.SelfDescribingEvents))                  {                      bNeedsManifest = (flags & EventManifestOptions.OnlyIfNeededForRegistration) == 0  #if FEATURE_MANAGED_ETW_CHANNELS                                              || manifest.GetChannelData().Length > 0  #endif  ;                        // if the manifest is not needed and we're not requested to validate the event source return early                      if (!bNeedsManifest && (flags & EventManifestOptions.Strict) == 0)                          return null;                        res = manifest.CreateManifest();                  }              }              catch (Exception e)              {                  // if this is a runtime manifest generation let the exception propagate                  if ((flags & EventManifestOptions.Strict) == 0)                      throw;                  // else store it to include it in the Argument exception we raise below                  exception = e;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddEventDescriptor,The following statement contains a magic number: if (eventData == null || eventData.Length <= eventAttribute.EventId)              {                  EventMetadata[] newValues = new EventMetadata[Math.Max(eventData.Length + 16' eventAttribute.EventId + 1)];                  Array.Copy(eventData' 0' newValues' 0' eventData.Length);                  eventData = newValues;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,TrimEventDescriptors,The following statement contains a magic number: if (eventData.Length - idx > 2)      // allow one wasted slot.               {                  EventMetadata[] newValues = new EventMetadata[idx + 1];                  Array.Copy(eventData' 0' newValues' 0' newValues.Length);                  eventData = newValues;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetHelperCallFirstArg,The following statement contains a magic number: for (int idx = 0; idx < instrs.Length;)              {                  switch (instrs[idx])                  {                      case 0: // NOP                      case 1: // BREAK                      case 2: // LDARG_0                      case 3: // LDARG_1                      case 4: // LDARG_2                      case 5: // LDARG_3                      case 6: // LDLOC_0                      case 7: // LDLOC_1                      case 8: // LDLOC_2                      case 9: // LDLOC_3                      case 10: // STLOC_0                      case 11: // STLOC_1                      case 12: // STLOC_2                      case 13: // STLOC_3                          break;                      case 14: // LDARG_S                      case 16: // STARG_S                          idx++;                          break;                      case 20: // LDNULL                          break;                      case 21: // LDC_I4_M1                      case 22: // LDC_I4_0                      case 23: // LDC_I4_1                      case 24: // LDC_I4_2                      case 25: // LDC_I4_3                      case 26: // LDC_I4_4                      case 27: // LDC_I4_5                      case 28: // LDC_I4_6                      case 29: // LDC_I4_7                      case 30: // LDC_I4_8                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx] - 22;                          break;                      case 31: // LDC_I4_S                          if (idx > 0 && instrs[idx - 1] == 2)  // preceeded by LDARG0                              retVal = instrs[idx + 1];                          idx++;                          break;                      case 32: // LDC_I4                          idx += 4;                          break;                      case 37: // DUP                          break;                      case 40: // CALL                          idx += 4;                            if (retVal >= 0)                          {                              // Is this call just before return?                                for (int search = idx + 1; search < instrs.Length; search++)                              {                                  if (instrs[search] == 42)  // RET                                      return retVal;                                  if (instrs[search] != 0)   // NOP                                      break;                              }                          }                          retVal = -1;                          break;                      case 44: // BRFALSE_S                      case 45: // BRTRUE_S                          retVal = -1;                          idx++;                          break;                      case 57: // BRFALSE                      case 58: // BRTRUE                          retVal = -1;                          idx += 4;                          break;                      case 103: // CONV_I1                      case 104: // CONV_I2                      case 105: // CONV_I4                      case 106: // CONV_I8                      case 109: // CONV_U4                      case 110: // CONV_U8                          break;                      case 140: // BOX                      case 141: // NEWARR                          idx += 4;                          break;                      case 162: // STELEM_REF                          break;                      case 254: // PREFIX                          idx++;                          // Covers the CEQ instructions used in debug code for some reason.                          if (idx >= instrs.Length || instrs[idx] >= 6)                              goto default;                          break;                      default:                          /* Debug.Assert(false' "Warning: User validation code sub-optimial: Unsuported opcode " + instrs[idx] +                              " at " + idx + " in method " + method.Name); */                          return -1;                  }                  idx++;              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,ReportOutOfBandMessage,The following statement contains a magic number: try              {  #if (!ES_BUILD_PCL && !ES_BUILD_PN)                  // send message to debugger without delay                  System.Diagnostics.Debugger.Log(0' null' String.Format("EventSource Error: {0}{1}"' msg' Environment.NewLine));  #endif                    // Send it to all listeners.                  if (m_outOfBandMessageCount < 16 - 1)     // Note this is only if size byte                      m_outOfBandMessageCount++;                  else                  {                      if (m_outOfBandMessageCount == 16)                          return;                      m_outOfBandMessageCount = 16;    // Mark that we hit the limit.  Notify them that this is the case.                       msg = "Reached message limit.   End of EventSource error messages.";                  }                    WriteEventString(EventLevel.LogAlways' -1' msg);                  WriteStringToAllListeners("EventSourceMessage"' msg);              }              catch (Exception) { }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,ReportOutOfBandMessage,The following statement contains a magic number: try              {  #if (!ES_BUILD_PCL && !ES_BUILD_PN)                  // send message to debugger without delay                  System.Diagnostics.Debugger.Log(0' null' String.Format("EventSource Error: {0}{1}"' msg' Environment.NewLine));  #endif                    // Send it to all listeners.                  if (m_outOfBandMessageCount < 16 - 1)     // Note this is only if size byte                      m_outOfBandMessageCount++;                  else                  {                      if (m_outOfBandMessageCount == 16)                          return;                      m_outOfBandMessageCount = 16;    // Mark that we hit the limit.  Notify them that this is the case.                       msg = "Reached message limit.   End of EventSource error messages.";                  }                    WriteEventString(EventLevel.LogAlways' -1' msg);                  WriteStringToAllListeners("EventSourceMessage"' msg);              }              catch (Exception) { }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,ReportOutOfBandMessage,The following statement contains a magic number: try              {  #if (!ES_BUILD_PCL && !ES_BUILD_PN)                  // send message to debugger without delay                  System.Diagnostics.Debugger.Log(0' null' String.Format("EventSource Error: {0}{1}"' msg' Environment.NewLine));  #endif                    // Send it to all listeners.                  if (m_outOfBandMessageCount < 16 - 1)     // Note this is only if size byte                      m_outOfBandMessageCount++;                  else                  {                      if (m_outOfBandMessageCount == 16)                          return;                      m_outOfBandMessageCount = 16;    // Mark that we hit the limit.  Notify them that this is the case.                       msg = "Reached message limit.   End of EventSource error messages.";                  }                    WriteEventString(EventLevel.LogAlways' -1' msg);                  WriteStringToAllListeners("EventSourceMessage"' msg);              }              catch (Exception) { }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddValueToMetaData,The following statement contains a magic number: if (firstChar == '@')                  metaData.AddRange(Encoding.UTF8.GetBytes(value.Substring(1)));              else if (firstChar == '{')                  metaData.AddRange(new Guid(value).ToByteArray());              else if (firstChar == '#')              {                  for (int i = 1; i < value.Length; i++)                  {                      if (value[i] != ' ')        // Skip spaces between bytes.                        {                          if (!(i + 1 < value.Length))                          {                              throw new ArgumentException(SR.EventSource_EvenHexDigits' "traits");                          }                          metaData.Add((byte)(HexDigit(value[i]) * 16 + HexDigit(value[i + 1])));                          i++;                      }                  }              }              else if ('A' <= firstChar || ' ' == firstChar)  // Is it alphabetic or space (excludes digits and most punctuation).               {                  metaData.AddRange(Encoding.UTF8.GetBytes(value));              }              else              {                  throw new ArgumentException(SR.Format(SR.EventSource_IllegalValue' value)' "traits");              }
Magic Number,System.Diagnostics.Tracing,EventSource,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,HexDigit,The following statement contains a magic number: if ('A' <= c && c <= 'F')              {                  return (c - 'A' + 10);              }
Magic Number,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddOpcode,The following statement contains a magic number: if ((flags & EventManifestOptions.Strict) != 0)              {                  if (value <= 10 || value >= 239)                  {                      ManifestError(SR.Format(SR.EventSource_IllegalOpcodeValue' name' value));                  }                  string prevName;                  if (opcodeTab.TryGetValue(value' out prevName) && !name.Equals(prevName' StringComparison.Ordinal))                  {                      ManifestError(SR.Format(SR.EventSource_OpcodeCollision' name' prevName' value));                  }              }
Magic Number,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddOpcode,The following statement contains a magic number: if ((flags & EventManifestOptions.Strict) != 0)              {                  if (value <= 10 || value >= 239)                  {                      ManifestError(SR.Format(SR.EventSource_IllegalOpcodeValue' name' value));                  }                  string prevName;                  if (opcodeTab.TryGetValue(value' out prevName) && !name.Equals(prevName' StringComparison.Ordinal))                  {                      ManifestError(SR.Format(SR.EventSource_OpcodeCollision' name' prevName' value));                  }              }
Magic Number,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddTask,The following statement contains a magic number: if ((flags & EventManifestOptions.Strict) != 0)              {                  if (value <= 0 || value >= 65535)                  {                      ManifestError(SR.Format(SR.EventSource_IllegalTaskValue' name' value));                  }                  string prevName;                  if (taskTab != null && taskTab.TryGetValue(value' out prevName) && !name.Equals(prevName' StringComparison.Ordinal))                  {                      ManifestError(SR.Format(SR.EventSource_TaskCollision' name' prevName' value));                  }              }
Magic Number,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,AddEventParameter,The following statement contains a magic number: if (type == typeof(byte[]))              {                  // mark this index as "extraneous" (it has no parallel in the managed signature)                  // we use these values in TranslateToManifestConvention()                  if (byteArrArgIndices == null)                      byteArrArgIndices = new List<int>(4);                  byteArrArgIndices.Add(numParams);                    // add an extra field to the template representing the length of the binary blob                  numParams++;                  templates.Append("   <data name=\"").Append(name).Append("Size\" inType=\"win:UInt32\"/>").AppendLine();              }
Magic Number,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetLevelName,The following statement contains a magic number: return (((int)level >= 16) ? "" : "win:") + level.ToString();
Magic Number,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,TranslateToManifestConvention,The following statement contains a magic number: for (int i = 0; ;)              {                  if (i >= eventMessage.Length)                  {                      if (stringBuilder == null)                          return eventMessage;                      UpdateStringBuilder(ref stringBuilder' eventMessage' writtenSoFar' i - writtenSoFar);                      return stringBuilder.ToString();                  }                    if (eventMessage[i] == '%')                  {                      // handle format message escaping character '%' by escaping it                      UpdateStringBuilder(ref stringBuilder' eventMessage' writtenSoFar' i - writtenSoFar);                      stringBuilder.Append("%%");                      i++;                      writtenSoFar = i;                  }                  else if (i < eventMessage.Length - 1 &&                      (eventMessage[i] == '{' && eventMessage[i + 1] == '{' || eventMessage[i] == '}' && eventMessage[i + 1] == '}'))                  {                      // handle C# escaped '{" and '}'                      UpdateStringBuilder(ref stringBuilder' eventMessage' writtenSoFar' i - writtenSoFar);                      stringBuilder.Append(eventMessage[i]);                      i++; i++;                      writtenSoFar = i;                  }                  else if (eventMessage[i] == '{')                  {                      int leftBracket = i;                      i++;                      int argNum = 0;                      while (i < eventMessage.Length && Char.IsDigit(eventMessage[i]))                      {                          argNum = argNum * 10 + eventMessage[i] - '0';                          i++;                      }                      if (i < eventMessage.Length && eventMessage[i] == '}')                      {                          i++;                          UpdateStringBuilder(ref stringBuilder' eventMessage' writtenSoFar' leftBracket - writtenSoFar);                          int manIndex = TranslateIndexToManifestConvention(argNum' evtName);                          stringBuilder.Append('%').Append(manIndex);                          // An '!' after the insert specifier {n} will be interpreted as a literal.                          // We'll escape it so that mc.exe does not attempt to consider it the                           // beginning of a format string.                          if (i < eventMessage.Length && eventMessage[i] == '!')                          {                              i++;                              stringBuilder.Append("%!");                          }                          writtenSoFar = i;                      }                      else                      {                          ManifestError(SR.Format(SR.EventSource_UnsupportedMessageProperty' evtName' eventMessage));                      }                  }                  else if ((chIdx = "&<>'\"\r\n\t".IndexOf(eventMessage[i])) >= 0)                  {                      UpdateStringBuilder(ref stringBuilder' eventMessage' writtenSoFar' i - writtenSoFar);                      i++;                      stringBuilder.Append(s_escapes[chIdx]);                      writtenSoFar = i;                  }                  else                      i++;              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EtwEnableCallBack,The following statement contains a magic number: try              {                  ControllerCommand command = ControllerCommand.Update;                  IDictionary<string' string> args = null;                  bool skipFinalOnControllerCommand = false;                  if (controlCode == UnsafeNativeMethods.ManifestEtw.EVENT_CONTROL_CODE_ENABLE_PROVIDER)                  {                      m_enabled = true;                      m_level = setLevel;                      m_anyKeywordMask = anyKeyword;                      m_allKeywordMask = allKeyword;                        // ES_SESSION_INFO is a marker for additional places we #ifdeffed out to remove                      // references to EnumerateTraceGuidsEx.  This symbol is actually not used because                      // today we use FEATURE_ACTIVITYSAMPLING to determine if this code is there or not.                      // However we put it in the #if so that we don't lose the fact that this feature                      // switch is at least partially independent of FEATURE_ACTIVITYSAMPLING                        List<Tuple<SessionInfo' bool>> sessionsChanged = GetSessions();                      foreach (var session in sessionsChanged)                      {                          int sessionChanged = session.Item1.sessionIdBit;                          int etwSessionId = session.Item1.etwSessionId;                          bool bEnabling = session.Item2;                            skipFinalOnControllerCommand = true;                          args = null;                                // reinitialize args for every session...                            // if we get more than one session changed we have no way                          // of knowing which one "filterData" belongs to                          if (sessionsChanged.Count > 1)                              filterData = null;                            // read filter data only when a session is being *added*                          byte[] data;                          int keyIndex;                          if (bEnabling &&                              GetDataFromController(etwSessionId' filterData' out command' out data' out keyIndex))                          {                              args = new Dictionary<string' string>(4);                              while (keyIndex < data.Length)                              {                                  int keyEnd = FindNull(data' keyIndex);                                  int valueIdx = keyEnd + 1;                                  int valueEnd = FindNull(data' valueIdx);                                  if (valueEnd < data.Length)                                  {                                      string key = System.Text.Encoding.UTF8.GetString(data' keyIndex' keyEnd - keyIndex);                                      string value = System.Text.Encoding.UTF8.GetString(data' valueIdx' valueEnd - valueIdx);                                      args[key] = value;                                  }                                  keyIndex = valueEnd + 1;                              }                          }                            // execute OnControllerCommand once for every session that has changed.                          OnControllerCommand(command' args' (bEnabling ? sessionChanged : -sessionChanged)' etwSessionId);                      }                  }                  else if (controlCode == UnsafeNativeMethods.ManifestEtw.EVENT_CONTROL_CODE_DISABLE_PROVIDER)                  {                      m_enabled = false;                      m_level = 0;                      m_anyKeywordMask = 0;                      m_allKeywordMask = 0;                      m_liveSessions = null;                  }                  else if (controlCode == UnsafeNativeMethods.ManifestEtw.EVENT_CONTROL_CODE_CAPTURE_STATE)                  {                      command = ControllerCommand.SendManifest;                  }                  else                      return;     // per spec you ignore commands you don't recognize.                      if (!skipFinalOnControllerCommand)                      OnControllerCommand(command' args' 0' 0);              }              catch (Exception)              {                  // We want to ignore any failures that happen as a result of turning on this provider as to                  // not crash the app.              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetSessionInfoCallback,The following statement contains a magic number: if (sessionList == null)                  sessionList = new List<SessionInfo>(8);
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetDataFromController,The following statement contains a magic number: if (filterData == null)              {  #if (!ES_BUILD_PCL && !ES_BUILD_PN && PLATFORM_WINDOWS)                  string regKey = @"\Microsoft\Windows\CurrentVersion\Winevt\Publishers\{" + m_providerName + "}";                  if (System.Runtime.InteropServices.Marshal.SizeOf(typeof(IntPtr)) == 8)                      regKey = @"HKEY_LOCAL_MACHINE\Software" + @"\Wow6432Node" + regKey;                  else                      regKey = @"HKEY_LOCAL_MACHINE\Software" + regKey;                    string valueName = "ControllerData_Session_" + etwSessionId.ToString(CultureInfo.InvariantCulture);                    // we need to assert this permission for partial trust scenarios  #if !CORECLR                  (new RegistryPermission(RegistryPermissionAccess.Read' regKey)).Assert();  #endif                  data = Microsoft.Win32.Registry.GetValue(regKey' valueName' null) as byte[];                  if (data != null)                  {                      // We only used the persisted data from the registry for updates.                         command = ControllerCommand.Update;                      return true;                  }  #endif              }              else              {                  if (filterData->Ptr != 0 && 0 < filterData->Size && filterData->Size <= 1024)                  {                      data = new byte[filterData->Size];                      Marshal.Copy((IntPtr)filterData->Ptr' data' 0' data.Length);                  }                  command = (ControllerCommand)filterData->Type;                  return true;              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EncodeObject,The following statement contains a magic number: if (sRet != null)              {                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }              else if ((blobRet = data as byte[]) != null)              {                  // first store array length                  *(int*)dataBuffer = blobRet.Length;                  dataDescriptor->Ptr = (ulong)dataBuffer;                  dataDescriptor->Size = 4;                  totalEventSize += dataDescriptor->Size;                    // then the array parameters                  dataDescriptor++;                  dataBuffer += s_basicTypeAllocationBufferSize;                  dataDescriptor->Size = (uint)blobRet.Length;              }              else if (data is IntPtr)              {                  dataDescriptor->Size = (uint)sizeof(IntPtr);                  IntPtr* intptrPtr = (IntPtr*)dataBuffer;                  *intptrPtr = (IntPtr)data;                  dataDescriptor->Ptr = (ulong)intptrPtr;              }              else if (data is int)              {                  dataDescriptor->Size = (uint)sizeof(int);                  int* intptr = (int*)dataBuffer;                  *intptr = (int)data;                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is long)              {                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = (long)data;                  dataDescriptor->Ptr = (ulong)longptr;              }              else if (data is uint)              {                  dataDescriptor->Size = (uint)sizeof(uint);                  uint* uintptr = (uint*)dataBuffer;                  *uintptr = (uint)data;                  dataDescriptor->Ptr = (ulong)uintptr;              }              else if (data is UInt64)              {                  dataDescriptor->Size = (uint)sizeof(ulong);                  UInt64* ulongptr = (ulong*)dataBuffer;                  *ulongptr = (ulong)data;                  dataDescriptor->Ptr = (ulong)ulongptr;              }              else if (data is char)              {                  dataDescriptor->Size = (uint)sizeof(char);                  char* charptr = (char*)dataBuffer;                  *charptr = (char)data;                  dataDescriptor->Ptr = (ulong)charptr;              }              else if (data is byte)              {                  dataDescriptor->Size = (uint)sizeof(byte);                  byte* byteptr = (byte*)dataBuffer;                  *byteptr = (byte)data;                  dataDescriptor->Ptr = (ulong)byteptr;              }              else if (data is short)              {                  dataDescriptor->Size = (uint)sizeof(short);                  short* shortptr = (short*)dataBuffer;                  *shortptr = (short)data;                  dataDescriptor->Ptr = (ulong)shortptr;              }              else if (data is sbyte)              {                  dataDescriptor->Size = (uint)sizeof(sbyte);                  sbyte* sbyteptr = (sbyte*)dataBuffer;                  *sbyteptr = (sbyte)data;                  dataDescriptor->Ptr = (ulong)sbyteptr;              }              else if (data is ushort)              {                  dataDescriptor->Size = (uint)sizeof(ushort);                  ushort* ushortptr = (ushort*)dataBuffer;                  *ushortptr = (ushort)data;                  dataDescriptor->Ptr = (ulong)ushortptr;              }              else if (data is float)              {                  dataDescriptor->Size = (uint)sizeof(float);                  float* floatptr = (float*)dataBuffer;                  *floatptr = (float)data;                  dataDescriptor->Ptr = (ulong)floatptr;              }              else if (data is double)              {                  dataDescriptor->Size = (uint)sizeof(double);                  double* doubleptr = (double*)dataBuffer;                  *doubleptr = (double)data;                  dataDescriptor->Ptr = (ulong)doubleptr;              }              else if (data is bool)              {                  // WIN32 Bool is 4 bytes                  dataDescriptor->Size = 4;                  int* intptr = (int*)dataBuffer;                  if (((bool)data))                  {                      *intptr = 1;                  }                  else                  {                      *intptr = 0;                  }                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is Guid)              {                  dataDescriptor->Size = (uint)sizeof(Guid);                  Guid* guidptr = (Guid*)dataBuffer;                  *guidptr = (Guid)data;                  dataDescriptor->Ptr = (ulong)guidptr;              }              else if (data is decimal)              {                  dataDescriptor->Size = (uint)sizeof(decimal);                  decimal* decimalptr = (decimal*)dataBuffer;                  *decimalptr = (decimal)data;                  dataDescriptor->Ptr = (ulong)decimalptr;              }              else if (data is DateTime)              {                  const long UTCMinTicks = 504911232000000000;                  long dateTimeTicks = 0;                  // We cannot translate dates sooner than 1/1/1601 in UTC.                   // To avoid getting an ArgumentOutOfRangeException we compare with 1/1/1601 DateTime ticks                  if (((DateTime)data).Ticks > UTCMinTicks)                      dateTimeTicks = ((DateTime)data).ToFileTimeUtc();                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = dateTimeTicks;                  dataDescriptor->Ptr = (ulong)longptr;              }              else              {                  if (data is System.Enum)                  {                      Type underlyingType = Enum.GetUnderlyingType(data.GetType());                      if (underlyingType == typeof(int))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt32(null);  #else                          data = (int)data;  #endif                          goto Again;                      }                      else if (underlyingType == typeof(long))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt64(null);  #else                          data = (long)data;  #endif                          goto Again;                      }                  }                    // To our eyes' everything else is a just a string                  if (data == null)                      sRet = "";                  else                      sRet = data.ToString();                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EncodeObject,The following statement contains a magic number: if (sRet != null)              {                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }              else if ((blobRet = data as byte[]) != null)              {                  // first store array length                  *(int*)dataBuffer = blobRet.Length;                  dataDescriptor->Ptr = (ulong)dataBuffer;                  dataDescriptor->Size = 4;                  totalEventSize += dataDescriptor->Size;                    // then the array parameters                  dataDescriptor++;                  dataBuffer += s_basicTypeAllocationBufferSize;                  dataDescriptor->Size = (uint)blobRet.Length;              }              else if (data is IntPtr)              {                  dataDescriptor->Size = (uint)sizeof(IntPtr);                  IntPtr* intptrPtr = (IntPtr*)dataBuffer;                  *intptrPtr = (IntPtr)data;                  dataDescriptor->Ptr = (ulong)intptrPtr;              }              else if (data is int)              {                  dataDescriptor->Size = (uint)sizeof(int);                  int* intptr = (int*)dataBuffer;                  *intptr = (int)data;                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is long)              {                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = (long)data;                  dataDescriptor->Ptr = (ulong)longptr;              }              else if (data is uint)              {                  dataDescriptor->Size = (uint)sizeof(uint);                  uint* uintptr = (uint*)dataBuffer;                  *uintptr = (uint)data;                  dataDescriptor->Ptr = (ulong)uintptr;              }              else if (data is UInt64)              {                  dataDescriptor->Size = (uint)sizeof(ulong);                  UInt64* ulongptr = (ulong*)dataBuffer;                  *ulongptr = (ulong)data;                  dataDescriptor->Ptr = (ulong)ulongptr;              }              else if (data is char)              {                  dataDescriptor->Size = (uint)sizeof(char);                  char* charptr = (char*)dataBuffer;                  *charptr = (char)data;                  dataDescriptor->Ptr = (ulong)charptr;              }              else if (data is byte)              {                  dataDescriptor->Size = (uint)sizeof(byte);                  byte* byteptr = (byte*)dataBuffer;                  *byteptr = (byte)data;                  dataDescriptor->Ptr = (ulong)byteptr;              }              else if (data is short)              {                  dataDescriptor->Size = (uint)sizeof(short);                  short* shortptr = (short*)dataBuffer;                  *shortptr = (short)data;                  dataDescriptor->Ptr = (ulong)shortptr;              }              else if (data is sbyte)              {                  dataDescriptor->Size = (uint)sizeof(sbyte);                  sbyte* sbyteptr = (sbyte*)dataBuffer;                  *sbyteptr = (sbyte)data;                  dataDescriptor->Ptr = (ulong)sbyteptr;              }              else if (data is ushort)              {                  dataDescriptor->Size = (uint)sizeof(ushort);                  ushort* ushortptr = (ushort*)dataBuffer;                  *ushortptr = (ushort)data;                  dataDescriptor->Ptr = (ulong)ushortptr;              }              else if (data is float)              {                  dataDescriptor->Size = (uint)sizeof(float);                  float* floatptr = (float*)dataBuffer;                  *floatptr = (float)data;                  dataDescriptor->Ptr = (ulong)floatptr;              }              else if (data is double)              {                  dataDescriptor->Size = (uint)sizeof(double);                  double* doubleptr = (double*)dataBuffer;                  *doubleptr = (double)data;                  dataDescriptor->Ptr = (ulong)doubleptr;              }              else if (data is bool)              {                  // WIN32 Bool is 4 bytes                  dataDescriptor->Size = 4;                  int* intptr = (int*)dataBuffer;                  if (((bool)data))                  {                      *intptr = 1;                  }                  else                  {                      *intptr = 0;                  }                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is Guid)              {                  dataDescriptor->Size = (uint)sizeof(Guid);                  Guid* guidptr = (Guid*)dataBuffer;                  *guidptr = (Guid)data;                  dataDescriptor->Ptr = (ulong)guidptr;              }              else if (data is decimal)              {                  dataDescriptor->Size = (uint)sizeof(decimal);                  decimal* decimalptr = (decimal*)dataBuffer;                  *decimalptr = (decimal)data;                  dataDescriptor->Ptr = (ulong)decimalptr;              }              else if (data is DateTime)              {                  const long UTCMinTicks = 504911232000000000;                  long dateTimeTicks = 0;                  // We cannot translate dates sooner than 1/1/1601 in UTC.                   // To avoid getting an ArgumentOutOfRangeException we compare with 1/1/1601 DateTime ticks                  if (((DateTime)data).Ticks > UTCMinTicks)                      dateTimeTicks = ((DateTime)data).ToFileTimeUtc();                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = dateTimeTicks;                  dataDescriptor->Ptr = (ulong)longptr;              }              else              {                  if (data is System.Enum)                  {                      Type underlyingType = Enum.GetUnderlyingType(data.GetType());                      if (underlyingType == typeof(int))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt32(null);  #else                          data = (int)data;  #endif                          goto Again;                      }                      else if (underlyingType == typeof(long))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt64(null);  #else                          data = (long)data;  #endif                          goto Again;                      }                  }                    // To our eyes' everything else is a just a string                  if (data == null)                      sRet = "";                  else                      sRet = data.ToString();                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EncodeObject,The following statement contains a magic number: if (sRet != null)              {                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }              else if ((blobRet = data as byte[]) != null)              {                  // first store array length                  *(int*)dataBuffer = blobRet.Length;                  dataDescriptor->Ptr = (ulong)dataBuffer;                  dataDescriptor->Size = 4;                  totalEventSize += dataDescriptor->Size;                    // then the array parameters                  dataDescriptor++;                  dataBuffer += s_basicTypeAllocationBufferSize;                  dataDescriptor->Size = (uint)blobRet.Length;              }              else if (data is IntPtr)              {                  dataDescriptor->Size = (uint)sizeof(IntPtr);                  IntPtr* intptrPtr = (IntPtr*)dataBuffer;                  *intptrPtr = (IntPtr)data;                  dataDescriptor->Ptr = (ulong)intptrPtr;              }              else if (data is int)              {                  dataDescriptor->Size = (uint)sizeof(int);                  int* intptr = (int*)dataBuffer;                  *intptr = (int)data;                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is long)              {                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = (long)data;                  dataDescriptor->Ptr = (ulong)longptr;              }              else if (data is uint)              {                  dataDescriptor->Size = (uint)sizeof(uint);                  uint* uintptr = (uint*)dataBuffer;                  *uintptr = (uint)data;                  dataDescriptor->Ptr = (ulong)uintptr;              }              else if (data is UInt64)              {                  dataDescriptor->Size = (uint)sizeof(ulong);                  UInt64* ulongptr = (ulong*)dataBuffer;                  *ulongptr = (ulong)data;                  dataDescriptor->Ptr = (ulong)ulongptr;              }              else if (data is char)              {                  dataDescriptor->Size = (uint)sizeof(char);                  char* charptr = (char*)dataBuffer;                  *charptr = (char)data;                  dataDescriptor->Ptr = (ulong)charptr;              }              else if (data is byte)              {                  dataDescriptor->Size = (uint)sizeof(byte);                  byte* byteptr = (byte*)dataBuffer;                  *byteptr = (byte)data;                  dataDescriptor->Ptr = (ulong)byteptr;              }              else if (data is short)              {                  dataDescriptor->Size = (uint)sizeof(short);                  short* shortptr = (short*)dataBuffer;                  *shortptr = (short)data;                  dataDescriptor->Ptr = (ulong)shortptr;              }              else if (data is sbyte)              {                  dataDescriptor->Size = (uint)sizeof(sbyte);                  sbyte* sbyteptr = (sbyte*)dataBuffer;                  *sbyteptr = (sbyte)data;                  dataDescriptor->Ptr = (ulong)sbyteptr;              }              else if (data is ushort)              {                  dataDescriptor->Size = (uint)sizeof(ushort);                  ushort* ushortptr = (ushort*)dataBuffer;                  *ushortptr = (ushort)data;                  dataDescriptor->Ptr = (ulong)ushortptr;              }              else if (data is float)              {                  dataDescriptor->Size = (uint)sizeof(float);                  float* floatptr = (float*)dataBuffer;                  *floatptr = (float)data;                  dataDescriptor->Ptr = (ulong)floatptr;              }              else if (data is double)              {                  dataDescriptor->Size = (uint)sizeof(double);                  double* doubleptr = (double*)dataBuffer;                  *doubleptr = (double)data;                  dataDescriptor->Ptr = (ulong)doubleptr;              }              else if (data is bool)              {                  // WIN32 Bool is 4 bytes                  dataDescriptor->Size = 4;                  int* intptr = (int*)dataBuffer;                  if (((bool)data))                  {                      *intptr = 1;                  }                  else                  {                      *intptr = 0;                  }                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is Guid)              {                  dataDescriptor->Size = (uint)sizeof(Guid);                  Guid* guidptr = (Guid*)dataBuffer;                  *guidptr = (Guid)data;                  dataDescriptor->Ptr = (ulong)guidptr;              }              else if (data is decimal)              {                  dataDescriptor->Size = (uint)sizeof(decimal);                  decimal* decimalptr = (decimal*)dataBuffer;                  *decimalptr = (decimal)data;                  dataDescriptor->Ptr = (ulong)decimalptr;              }              else if (data is DateTime)              {                  const long UTCMinTicks = 504911232000000000;                  long dateTimeTicks = 0;                  // We cannot translate dates sooner than 1/1/1601 in UTC.                   // To avoid getting an ArgumentOutOfRangeException we compare with 1/1/1601 DateTime ticks                  if (((DateTime)data).Ticks > UTCMinTicks)                      dateTimeTicks = ((DateTime)data).ToFileTimeUtc();                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = dateTimeTicks;                  dataDescriptor->Ptr = (ulong)longptr;              }              else              {                  if (data is System.Enum)                  {                      Type underlyingType = Enum.GetUnderlyingType(data.GetType());                      if (underlyingType == typeof(int))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt32(null);  #else                          data = (int)data;  #endif                          goto Again;                      }                      else if (underlyingType == typeof(long))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt64(null);  #else                          data = (long)data;  #endif                          goto Again;                      }                  }                    // To our eyes' everything else is a just a string                  if (data == null)                      sRet = "";                  else                      sRet = data.ToString();                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EncodeObject,The following statement contains a magic number: if (sRet != null)              {                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }              else if ((blobRet = data as byte[]) != null)              {                  // first store array length                  *(int*)dataBuffer = blobRet.Length;                  dataDescriptor->Ptr = (ulong)dataBuffer;                  dataDescriptor->Size = 4;                  totalEventSize += dataDescriptor->Size;                    // then the array parameters                  dataDescriptor++;                  dataBuffer += s_basicTypeAllocationBufferSize;                  dataDescriptor->Size = (uint)blobRet.Length;              }              else if (data is IntPtr)              {                  dataDescriptor->Size = (uint)sizeof(IntPtr);                  IntPtr* intptrPtr = (IntPtr*)dataBuffer;                  *intptrPtr = (IntPtr)data;                  dataDescriptor->Ptr = (ulong)intptrPtr;              }              else if (data is int)              {                  dataDescriptor->Size = (uint)sizeof(int);                  int* intptr = (int*)dataBuffer;                  *intptr = (int)data;                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is long)              {                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = (long)data;                  dataDescriptor->Ptr = (ulong)longptr;              }              else if (data is uint)              {                  dataDescriptor->Size = (uint)sizeof(uint);                  uint* uintptr = (uint*)dataBuffer;                  *uintptr = (uint)data;                  dataDescriptor->Ptr = (ulong)uintptr;              }              else if (data is UInt64)              {                  dataDescriptor->Size = (uint)sizeof(ulong);                  UInt64* ulongptr = (ulong*)dataBuffer;                  *ulongptr = (ulong)data;                  dataDescriptor->Ptr = (ulong)ulongptr;              }              else if (data is char)              {                  dataDescriptor->Size = (uint)sizeof(char);                  char* charptr = (char*)dataBuffer;                  *charptr = (char)data;                  dataDescriptor->Ptr = (ulong)charptr;              }              else if (data is byte)              {                  dataDescriptor->Size = (uint)sizeof(byte);                  byte* byteptr = (byte*)dataBuffer;                  *byteptr = (byte)data;                  dataDescriptor->Ptr = (ulong)byteptr;              }              else if (data is short)              {                  dataDescriptor->Size = (uint)sizeof(short);                  short* shortptr = (short*)dataBuffer;                  *shortptr = (short)data;                  dataDescriptor->Ptr = (ulong)shortptr;              }              else if (data is sbyte)              {                  dataDescriptor->Size = (uint)sizeof(sbyte);                  sbyte* sbyteptr = (sbyte*)dataBuffer;                  *sbyteptr = (sbyte)data;                  dataDescriptor->Ptr = (ulong)sbyteptr;              }              else if (data is ushort)              {                  dataDescriptor->Size = (uint)sizeof(ushort);                  ushort* ushortptr = (ushort*)dataBuffer;                  *ushortptr = (ushort)data;                  dataDescriptor->Ptr = (ulong)ushortptr;              }              else if (data is float)              {                  dataDescriptor->Size = (uint)sizeof(float);                  float* floatptr = (float*)dataBuffer;                  *floatptr = (float)data;                  dataDescriptor->Ptr = (ulong)floatptr;              }              else if (data is double)              {                  dataDescriptor->Size = (uint)sizeof(double);                  double* doubleptr = (double*)dataBuffer;                  *doubleptr = (double)data;                  dataDescriptor->Ptr = (ulong)doubleptr;              }              else if (data is bool)              {                  // WIN32 Bool is 4 bytes                  dataDescriptor->Size = 4;                  int* intptr = (int*)dataBuffer;                  if (((bool)data))                  {                      *intptr = 1;                  }                  else                  {                      *intptr = 0;                  }                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is Guid)              {                  dataDescriptor->Size = (uint)sizeof(Guid);                  Guid* guidptr = (Guid*)dataBuffer;                  *guidptr = (Guid)data;                  dataDescriptor->Ptr = (ulong)guidptr;              }              else if (data is decimal)              {                  dataDescriptor->Size = (uint)sizeof(decimal);                  decimal* decimalptr = (decimal*)dataBuffer;                  *decimalptr = (decimal)data;                  dataDescriptor->Ptr = (ulong)decimalptr;              }              else if (data is DateTime)              {                  const long UTCMinTicks = 504911232000000000;                  long dateTimeTicks = 0;                  // We cannot translate dates sooner than 1/1/1601 in UTC.                   // To avoid getting an ArgumentOutOfRangeException we compare with 1/1/1601 DateTime ticks                  if (((DateTime)data).Ticks > UTCMinTicks)                      dateTimeTicks = ((DateTime)data).ToFileTimeUtc();                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = dateTimeTicks;                  dataDescriptor->Ptr = (ulong)longptr;              }              else              {                  if (data is System.Enum)                  {                      Type underlyingType = Enum.GetUnderlyingType(data.GetType());                      if (underlyingType == typeof(int))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt32(null);  #else                          data = (int)data;  #endif                          goto Again;                      }                      else if (underlyingType == typeof(long))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt64(null);  #else                          data = (long)data;  #endif                          goto Again;                      }                  }                    // To our eyes' everything else is a just a string                  if (data == null)                      sRet = "";                  else                      sRet = data.ToString();                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,EncodeObject,The following statement contains a magic number: if (sRet != null)              {                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }              else if ((blobRet = data as byte[]) != null)              {                  // first store array length                  *(int*)dataBuffer = blobRet.Length;                  dataDescriptor->Ptr = (ulong)dataBuffer;                  dataDescriptor->Size = 4;                  totalEventSize += dataDescriptor->Size;                    // then the array parameters                  dataDescriptor++;                  dataBuffer += s_basicTypeAllocationBufferSize;                  dataDescriptor->Size = (uint)blobRet.Length;              }              else if (data is IntPtr)              {                  dataDescriptor->Size = (uint)sizeof(IntPtr);                  IntPtr* intptrPtr = (IntPtr*)dataBuffer;                  *intptrPtr = (IntPtr)data;                  dataDescriptor->Ptr = (ulong)intptrPtr;              }              else if (data is int)              {                  dataDescriptor->Size = (uint)sizeof(int);                  int* intptr = (int*)dataBuffer;                  *intptr = (int)data;                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is long)              {                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = (long)data;                  dataDescriptor->Ptr = (ulong)longptr;              }              else if (data is uint)              {                  dataDescriptor->Size = (uint)sizeof(uint);                  uint* uintptr = (uint*)dataBuffer;                  *uintptr = (uint)data;                  dataDescriptor->Ptr = (ulong)uintptr;              }              else if (data is UInt64)              {                  dataDescriptor->Size = (uint)sizeof(ulong);                  UInt64* ulongptr = (ulong*)dataBuffer;                  *ulongptr = (ulong)data;                  dataDescriptor->Ptr = (ulong)ulongptr;              }              else if (data is char)              {                  dataDescriptor->Size = (uint)sizeof(char);                  char* charptr = (char*)dataBuffer;                  *charptr = (char)data;                  dataDescriptor->Ptr = (ulong)charptr;              }              else if (data is byte)              {                  dataDescriptor->Size = (uint)sizeof(byte);                  byte* byteptr = (byte*)dataBuffer;                  *byteptr = (byte)data;                  dataDescriptor->Ptr = (ulong)byteptr;              }              else if (data is short)              {                  dataDescriptor->Size = (uint)sizeof(short);                  short* shortptr = (short*)dataBuffer;                  *shortptr = (short)data;                  dataDescriptor->Ptr = (ulong)shortptr;              }              else if (data is sbyte)              {                  dataDescriptor->Size = (uint)sizeof(sbyte);                  sbyte* sbyteptr = (sbyte*)dataBuffer;                  *sbyteptr = (sbyte)data;                  dataDescriptor->Ptr = (ulong)sbyteptr;              }              else if (data is ushort)              {                  dataDescriptor->Size = (uint)sizeof(ushort);                  ushort* ushortptr = (ushort*)dataBuffer;                  *ushortptr = (ushort)data;                  dataDescriptor->Ptr = (ulong)ushortptr;              }              else if (data is float)              {                  dataDescriptor->Size = (uint)sizeof(float);                  float* floatptr = (float*)dataBuffer;                  *floatptr = (float)data;                  dataDescriptor->Ptr = (ulong)floatptr;              }              else if (data is double)              {                  dataDescriptor->Size = (uint)sizeof(double);                  double* doubleptr = (double*)dataBuffer;                  *doubleptr = (double)data;                  dataDescriptor->Ptr = (ulong)doubleptr;              }              else if (data is bool)              {                  // WIN32 Bool is 4 bytes                  dataDescriptor->Size = 4;                  int* intptr = (int*)dataBuffer;                  if (((bool)data))                  {                      *intptr = 1;                  }                  else                  {                      *intptr = 0;                  }                  dataDescriptor->Ptr = (ulong)intptr;              }              else if (data is Guid)              {                  dataDescriptor->Size = (uint)sizeof(Guid);                  Guid* guidptr = (Guid*)dataBuffer;                  *guidptr = (Guid)data;                  dataDescriptor->Ptr = (ulong)guidptr;              }              else if (data is decimal)              {                  dataDescriptor->Size = (uint)sizeof(decimal);                  decimal* decimalptr = (decimal*)dataBuffer;                  *decimalptr = (decimal)data;                  dataDescriptor->Ptr = (ulong)decimalptr;              }              else if (data is DateTime)              {                  const long UTCMinTicks = 504911232000000000;                  long dateTimeTicks = 0;                  // We cannot translate dates sooner than 1/1/1601 in UTC.                   // To avoid getting an ArgumentOutOfRangeException we compare with 1/1/1601 DateTime ticks                  if (((DateTime)data).Ticks > UTCMinTicks)                      dateTimeTicks = ((DateTime)data).ToFileTimeUtc();                  dataDescriptor->Size = (uint)sizeof(long);                  long* longptr = (long*)dataBuffer;                  *longptr = dateTimeTicks;                  dataDescriptor->Ptr = (ulong)longptr;              }              else              {                  if (data is System.Enum)                  {                      Type underlyingType = Enum.GetUnderlyingType(data.GetType());                      if (underlyingType == typeof(int))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt32(null);  #else                          data = (int)data;  #endif                          goto Again;                      }                      else if (underlyingType == typeof(long))                      {  #if !ES_BUILD_PCL                          data = ((IConvertible)data).ToInt64(null);  #else                          data = (long)data;  #endif                          goto Again;                      }                  }                    // To our eyes' everything else is a just a string                  if (data == null)                      sRet = "";                  else                      sRet = data.ToString();                  dataDescriptor->Size = ((uint)sRet.Length + 1) * 2;              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,WriteEvent,The following statement contains a magic number: if (IsEnabled(eventDescriptor.Level' eventDescriptor.Keywords))              {                  int argCount = 0;                  unsafe                  {                      argCount = eventPayload.Length;                        if (argCount > s_etwMaxNumberArguments)                      {                          s_returnCode = WriteEventErrorCode.TooManyArgs;                          return false;                      }                        uint totalEventSize = 0;                      int index;                      int refObjIndex = 0;                      List<int> refObjPosition = new List<int>(s_etwAPIMaxRefObjCount);                      List<object> dataRefObj = new List<object>(s_etwAPIMaxRefObjCount);                      EventData* userData = stackalloc EventData[2 * argCount];                      EventData* userDataPtr = (EventData*)userData;                      byte* dataBuffer = stackalloc byte[s_basicTypeAllocationBufferSize * 2 * argCount]; // Assume 16 chars for non-string argument                      byte* currentBuffer = dataBuffer;                        //                      // The loop below goes through all the arguments and fills in the data                       // descriptors. For strings save the location in the dataString array.                      // Calculates the total size of the event by adding the data descriptor                      // size value set in EncodeObject method.                      //                      bool hasNonStringRefArgs = false;                      for (index = 0; index < eventPayload.Length; index++)                      {                          if (eventPayload[index] != null)                          {                              object supportedRefObj;                              supportedRefObj = EncodeObject(ref eventPayload[index]' ref userDataPtr' ref currentBuffer' ref totalEventSize);                                if (supportedRefObj != null)                              {                                  // EncodeObject advanced userDataPtr to the next empty slot                                  int idx = (int)(userDataPtr - userData - 1);                                  if (!(supportedRefObj is string))                                  {                                      if (eventPayload.Length + idx + 1 - index > s_etwMaxNumberArguments)                                      {                                          s_returnCode = WriteEventErrorCode.TooManyArgs;                                          return false;                                      }                                      hasNonStringRefArgs = true;                                  }                                  dataRefObj.Add(supportedRefObj);                                  refObjPosition.Add(idx);                                  refObjIndex++;                              }                          }                          else                          {                              s_returnCode = WriteEventErrorCode.NullInput;                              return false;                          }                      }                        // update argCount based on actual number of arguments written to 'userData'                      argCount = (int)(userDataPtr - userData);                        if (totalEventSize > s_traceEventMaximumSize)                      {                          s_returnCode = WriteEventErrorCode.EventTooBig;                          return false;                      }                        // the optimized path (using "fixed" instead of allocating pinned GCHandles                      if (!hasNonStringRefArgs && (refObjIndex < s_etwAPIMaxRefObjCount))                      {                          // Fast path: at most 8 string arguments                            // ensure we have at least s_etwAPIMaxStringCount in dataString' so that                          // the "fixed" statement below works                          while (refObjIndex < s_etwAPIMaxRefObjCount)                          {                              dataRefObj.Add(null);                              ++refObjIndex;                          }                            //                          // now fix any string arguments and set the pointer on the data descriptor                           //                          fixed (char* v0 = (string)dataRefObj[0]' v1 = (string)dataRefObj[1]' v2 = (string)dataRefObj[2]' v3 = (string)dataRefObj[3]'                                  v4 = (string)dataRefObj[4]' v5 = (string)dataRefObj[5]' v6 = (string)dataRefObj[6]' v7 = (string)dataRefObj[7])                          {                              userDataPtr = (EventData*)userData;                              if (dataRefObj[0] != null)                              {                                  userDataPtr[refObjPosition[0]].Ptr = (ulong)v0;                              }                              if (dataRefObj[1] != null)                              {                                  userDataPtr[refObjPosition[1]].Ptr = (ulong)v1;                              }                              if (dataRefObj[2] != null)                              {                                  userDataPtr[refObjPosition[2]].Ptr = (ulong)v2;                              }                              if (dataRefObj[3] != null)                              {                                  userDataPtr[refObjPosition[3]].Ptr = (ulong)v3;                              }                              if (dataRefObj[4] != null)                              {                                  userDataPtr[refObjPosition[4]].Ptr = (ulong)v4;                              }                              if (dataRefObj[5] != null)                              {                                  userDataPtr[refObjPosition[5]].Ptr = (ulong)v5;                              }                              if (dataRefObj[6] != null)                              {                                  userDataPtr[refObjPosition[6]].Ptr = (ulong)v6;                              }                              if (dataRefObj[7] != null)                              {                                  userDataPtr[refObjPosition[7]].Ptr = (ulong)v7;                              }                                status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                          }                      }                      else                      {                          // Slow path: use pinned handles                          userDataPtr = (EventData*)userData;                            GCHandle[] rgGCHandle = new GCHandle[refObjIndex];                          for (int i = 0; i < refObjIndex; ++i)                          {                              // below we still use "fixed" to avoid taking dependency on the offset of the first field                              // in the object (the way we would need to if we used GCHandle.AddrOfPinnedObject)                              rgGCHandle[i] = GCHandle.Alloc(dataRefObj[i]' GCHandleType.Pinned);                              if (dataRefObj[i] is string)                              {                                  fixed (char* p = (string)dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                              else                              {                                  fixed (byte* p = (byte[])dataRefObj[i])                                      userDataPtr[refObjPosition[i]].Ptr = (ulong)p;                              }                          }                            status = m_eventProvider.EventWriteTransferWrapper(m_regHandle' ref eventDescriptor' eventHandle' activityID' childActivityID' argCount' userData);                            for (int i = 0; i < refObjIndex; ++i)                          {                              rgGCHandle[i].Free();                          }                      }                  }              }
Magic Number,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,bitcount,The following statement contains a magic number: for (; n != 0; n = n >> 4)                  count += nibblebits[n & 0x0f];
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,CreateActivityPathGuid,The following statement contains a magic number: fixed (Guid* outPtr = &idRet)                  {                      int activityPathGuidOffsetStart = 0;                      if (m_creator != null)                      {                          activityPathGuidOffsetStart = m_creator.m_activityPathGuidOffset;                          idRet = m_creator.m_guid;                      }                      else                      {                          // TODO FIXME - differentiate between AD inside PCL                          int appDomainID = 0;  #if (!ES_BUILD_STANDALONE && !ES_BUILD_PN)                          appDomainID = System.Threading.Thread.GetDomainID();  #endif                          // We start with the appdomain number to make this unique among appdomains.                          activityPathGuidOffsetStart = AddIdToGuid(outPtr' activityPathGuidOffsetStart' (uint)appDomainID);                      }                        activityPathGuidOffset = AddIdToGuid(outPtr' activityPathGuidOffsetStart' (uint)m_uniqueId);                          // If the path does not fit' Make a GUID by incrementing rather than as a path' keeping as much of the path as possible                      if (12 < activityPathGuidOffset)                          CreateOverflowGuid(outPtr);                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,CreateOverflowGuid,The following statement contains a magic number: for (ActivityInfo ancestor = m_creator; ancestor != null; ancestor = ancestor.m_creator)                  {                      if (ancestor.m_activityPathGuidOffset <= 10)  // we need at least 2 bytes.                        {                          uint id = unchecked((uint)Interlocked.Increment(ref ancestor.m_lastChildID));        // Get a unique ID                           // Try to put the ID into the GUID                          *outPtr = ancestor.m_guid;                          int endId = AddIdToGuid(outPtr' ancestor.m_activityPathGuidOffset' id' true);                            // Does it fit?                          if (endId <= 12)                              break;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,CreateOverflowGuid,The following statement contains a magic number: for (ActivityInfo ancestor = m_creator; ancestor != null; ancestor = ancestor.m_creator)                  {                      if (ancestor.m_activityPathGuidOffset <= 10)  // we need at least 2 bytes.                        {                          uint id = unchecked((uint)Interlocked.Increment(ref ancestor.m_lastChildID));        // Get a unique ID                           // Try to put the ID into the GUID                          *outPtr = ancestor.m_guid;                          int endId = AddIdToGuid(outPtr' ancestor.m_activityPathGuidOffset' id' true);                            // Does it fit?                          if (endId <= 12)                              break;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: byte* endPtr = ptr + 12;
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (endPtr <= ptr)                      return 13;
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: if (0 < id && id <= (uint)NumberListCodes.LastImmediateValue && !overflow)                      WriteNibble(ref ptr' endPtr' id);                  else                  {                      uint len = 4;                      if (id <= 0xFF)                          len = 1;                      else if (id <= 0xFFFF)                          len = 2;                      else if (id <= 0xFFFFFF)                          len = 3;                        if (overflow)                      {                          if (endPtr <= ptr + 2)        // I need at least 2 bytes                              return 13;                            // Write out the prefix code nibble and the length nibble                           WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.PrefixCode);                      }                      // The rest is the same for overflow and non-overflow case                      WriteNibble(ref ptr' endPtr' (uint)NumberListCodes.MultiByte1 + (len - 1));                        // Do we have an odd nibble?   If so flush it or use it for the 12 byte case.                         if (ptr < endPtr && *ptr != 0)                      {                          // If the value < 4096 we can use the nibble we are otherwise just outputting as padding.                           if (id < 4096)                          {                              // Indicate this is a 1 byte multicode with 4 high order bits in the lower nibble.                                *ptr = (byte)(((uint)NumberListCodes.MultiByte1 << 4) + (id >> 8));                              id &= 0xFF;     // Now we only want the low order bits.                            }                          ptr++;                      }                        // Write out the bytes.                      while (0 < len)                      {                          if (endPtr <= ptr)                          {                              ptr++;        // Indicate that we have overflowed                              break;                          }                          *ptr++ = (byte)id;                          id = (id >> 8);                          --len;                      }                  }
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: sumPtr[3] = (sumPtr[0] + sumPtr[1] + sumPtr[2] + 0x599D99AD) ^ EventSource.s_currentPid;
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,AddIdToGuid,The following statement contains a magic number: sumPtr[3] = (sumPtr[0] + sumPtr[1] + sumPtr[2] + 0x599D99AD) ^ EventSource.s_currentPid;
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,WriteNibble,The following statement contains a magic number: Debug.Assert(0 <= value && value < 16);
Magic Number,System.Diagnostics.Tracing,ActivityInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\ActivityTracker.cs,WriteNibble,The following statement contains a magic number: if (*ptr != 0)                      *ptr++ |= (byte)value;                  else                      *ptr = (byte)(value << 4);
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Start,The following statement contains a magic number: if (this.w == null)                  {                      this.w = new uint[85];                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Start,The following statement contains a magic number: this.w[80] = 0x67452301;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Start,The following statement contains a magic number: this.w[81] = 0xEFCDAB89;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Start,The following statement contains a magic number: this.w[82] = 0x98BADCFE;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Start,The following statement contains a magic number: this.w[83] = 0x10325476;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Start,The following statement contains a magic number: this.w[84] = 0xC3D2E1F0;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Append,The following statement contains a magic number: this.w[this.pos / 4] = (this.w[this.pos / 4] << 8) | input;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Append,The following statement contains a magic number: this.w[this.pos / 4] = (this.w[this.pos / 4] << 8) | input;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Append,The following statement contains a magic number: this.w[this.pos / 4] = (this.w[this.pos / 4] << 8) | input;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Append,The following statement contains a magic number: if (64 == ++this.pos)                  {                      this.Drain();                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: long l = this.length + 8 * this.pos;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: while (this.pos != 56)                  {                      this.Append(0x00);                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Finish,The following statement contains a magic number: unchecked                  {                      this.Append((byte)(l >> 56));                      this.Append((byte)(l >> 48));                      this.Append((byte)(l >> 40));                      this.Append((byte)(l >> 32));                      this.Append((byte)(l >> 24));                      this.Append((byte)(l >> 16));                      this.Append((byte)(l >> 8));                      this.Append((byte)l);                        int end = output.Length < 20 ? output.Length : 20;                      for (int i = 0; i != end; i++)                      {                          uint temp = this.w[80 + i / 4];                          output[i] = (byte)(temp >> 24);                          this.w[80 + i / 4] = temp << 8;                      }                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: for (int i = 16; i != 80; i++)                  {                      this.w[i] = Rol1((this.w[i - 3] ^ this.w[i - 8] ^ this.w[i - 14] ^ this.w[i - 16]));                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: for (int i = 16; i != 80; i++)                  {                      this.w[i] = Rol1((this.w[i - 3] ^ this.w[i - 8] ^ this.w[i - 14] ^ this.w[i - 16]));                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: for (int i = 16; i != 80; i++)                  {                      this.w[i] = Rol1((this.w[i - 3] ^ this.w[i - 8] ^ this.w[i - 14] ^ this.w[i - 16]));                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: for (int i = 16; i != 80; i++)                  {                      this.w[i] = Rol1((this.w[i - 3] ^ this.w[i - 8] ^ this.w[i - 14] ^ this.w[i - 16]));                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: for (int i = 16; i != 80; i++)                  {                      this.w[i] = Rol1((this.w[i - 3] ^ this.w[i - 8] ^ this.w[i - 14] ^ this.w[i - 16]));                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: for (int i = 16; i != 80; i++)                  {                      this.w[i] = Rol1((this.w[i - 3] ^ this.w[i - 8] ^ this.w[i - 14] ^ this.w[i - 16]));                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: unchecked                  {                      uint a = this.w[80];                      uint b = this.w[81];                      uint c = this.w[82];                      uint d = this.w[83];                      uint e = this.w[84];                        for (int i = 0; i != 20; i++)                      {                          const uint k = 0x5A827999;                          uint f = (b & c) | ((~b) & d);                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 20; i != 40; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0x6ED9EBA1;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 40; i != 60; i++)                      {                          uint f = (b & c) | (b & d) | (c & d);                          const uint k = 0x8F1BBCDC;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        for (int i = 60; i != 80; i++)                      {                          uint f = b ^ c ^ d;                          const uint k = 0xCA62C1D6;                          uint temp = Rol5(a) + f + e + k + this.w[i]; e = d; d = c; c = Rol30(b); b = a; a = temp;                      }                        this.w[80] += a;                      this.w[81] += b;                      this.w[82] += c;                      this.w[83] += d;                      this.w[84] += e;                  }
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Drain,The following statement contains a magic number: this.length += 512;
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Rol1,The following statement contains a magic number: return (input << 1) | (input >> 31);
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Rol5,The following statement contains a magic number: return (input << 5) | (input >> 27);
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Rol5,The following statement contains a magic number: return (input << 5) | (input >> 27);
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Rol30,The following statement contains a magic number: return (input << 30) | (input >> 2);
Magic Number,System.Diagnostics.Tracing,Sha1ForNonSecretPurposes,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,Rol30,The following statement contains a magic number: return (input << 30) | (input >> 2);
Magic Number,System.Diagnostics.Tracing,EventListener,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,AddEventSource,The following statement contains a magic number: lock (EventListenersLock)              {                  if (s_EventSources == null)                      s_EventSources = new List<WeakReference>(2);                    if (!s_EventSourceShutdownRegistered)                  {                      s_EventSourceShutdownRegistered = true;                  }                      // Periodically search the list for existing entries to reuse' this avoids                  // unbounded memory use if we keep recycling eventSources (an unlikely thing).                   int newIndex = -1;                  if (s_EventSources.Count % 64 == 63)   // on every block of 64' fill up the block before continuing                  {                      int i = s_EventSources.Count;      // Work from the top down.                       while (0 < i)                      {                          --i;                          WeakReference weakRef = s_EventSources[i];                          if (!weakRef.IsAlive)                          {                              newIndex = i;                              weakRef.Target = newEventSource;                              break;                          }                      }                  }                  if (newIndex < 0)                  {                      newIndex = s_EventSources.Count;                      s_EventSources.Add(new WeakReference(newEventSource));                  }                  newEventSource.m_id = newIndex;                    // Add every existing dispatcher to the new EventSource                  for (EventListener listener = s_Listeners; listener != null; listener = listener.m_Next)                      newEventSource.AddListener(listener);                    Validate();              }
Magic Number,System.Diagnostics.Tracing,EventListener,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,AddEventSource,The following statement contains a magic number: lock (EventListenersLock)              {                  if (s_EventSources == null)                      s_EventSources = new List<WeakReference>(2);                    if (!s_EventSourceShutdownRegistered)                  {                      s_EventSourceShutdownRegistered = true;                  }                      // Periodically search the list for existing entries to reuse' this avoids                  // unbounded memory use if we keep recycling eventSources (an unlikely thing).                   int newIndex = -1;                  if (s_EventSources.Count % 64 == 63)   // on every block of 64' fill up the block before continuing                  {                      int i = s_EventSources.Count;      // Work from the top down.                       while (0 < i)                      {                          --i;                          WeakReference weakRef = s_EventSources[i];                          if (!weakRef.IsAlive)                          {                              newIndex = i;                              weakRef.Target = newEventSource;                              break;                          }                      }                  }                  if (newIndex < 0)                  {                      newIndex = s_EventSources.Count;                      s_EventSources.Add(new WeakReference(newEventSource));                  }                  newEventSource.m_id = newIndex;                    // Add every existing dispatcher to the new EventSource                  for (EventListener listener = s_Listeners; listener != null; listener = listener.m_Next)                      newEventSource.AddListener(listener);                    Validate();              }
Magic Number,System.Diagnostics.Tracing,EventListener,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\EventSource.cs,AddEventSource,The following statement contains a magic number: lock (EventListenersLock)              {                  if (s_EventSources == null)                      s_EventSources = new List<WeakReference>(2);                    if (!s_EventSourceShutdownRegistered)                  {                      s_EventSourceShutdownRegistered = true;                  }                      // Periodically search the list for existing entries to reuse' this avoids                  // unbounded memory use if we keep recycling eventSources (an unlikely thing).                   int newIndex = -1;                  if (s_EventSources.Count % 64 == 63)   // on every block of 64' fill up the block before continuing                  {                      int i = s_EventSources.Count;      // Work from the top down.                       while (0 < i)                      {                          --i;                          WeakReference weakRef = s_EventSources[i];                          if (!weakRef.IsAlive)                          {                              newIndex = i;                              weakRef.Target = newEventSource;                              break;                          }                      }                  }                  if (newIndex < 0)                  {                      newIndex = s_EventSources.Count;                      s_EventSources.Add(new WeakReference(newEventSource));                  }                  newEventSource.m_id = newIndex;                    // Add every existing dispatcher to the new EventSource                  for (EventListener listener = s_Listeners; listener != null; listener = listener.m_Next)                      newEventSource.AddListener(listener);                    Validate();              }
Magic Number,System.Diagnostics.Tracing,ConcurrentSet,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\ConcurrentSet.cs,TryGet,The following statement contains a magic number: if (oldItems != null)              {                  var lo = 0;                  var hi = oldItems.Length;                  do                  {                      int i = (lo + hi) / 2;                      item = oldItems[i];                        int cmp = item.Compare(key);                      if (cmp == 0)                      {                          goto Done;                      }                      else if (cmp < 0)                      {                          lo = i + 1;                      }                      else                      {                          hi = i;                      }                  }                  while (lo != hi);              }
Magic Number,System.Diagnostics.Tracing,ConcurrentSet,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\ConcurrentSet.cs,GetOrAdd,The following statement contains a magic number: Retry:                if (oldItems == null)              {                  newItems = new ItemType[] { newItem };              }              else              {                  var lo = 0;                  var hi = oldItems.Length;                  do                  {                      int i = (lo + hi) / 2;                      item = oldItems[i];                        int cmp = item.Compare(newItem);                      if (cmp == 0)                      {                          goto Done;                      }                      else if (cmp < 0)                      {                          lo = i + 1;                      }                      else                      {                          hi = i;                      }                  }                  while (lo != hi);                    int oldLength = oldItems.Length;                  newItems = new ItemType[oldLength + 1];                  Array.Copy(oldItems' 0' newItems' 0' lo);                  newItems[lo] = newItem;                  Array.Copy(oldItems' lo' newItems' lo + 1' oldLength - lo);              }
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,AddBinary,The following statement contains a magic number: if (this.bufferNesting != 0)              {                  this.EnsureBuffer(size + 2);              }
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,AddBinary,The following statement contains a magic number: this.AddScalar(&size' 2);
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,AddArray,The following statement contains a magic number: if (this.bufferNesting != 0)              {                  this.EnsureBuffer(size + 2);              }
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,AddArray,The following statement contains a magic number: this.AddScalar(&length' 2);
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,BeginBufferedArray,The following statement contains a magic number: this.bufferPos += 2;
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,EndBufferedArray,The following statement contains a magic number: this.buffer[bookmark - 2] = unchecked((byte)count);
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,EndBufferedArray,The following statement contains a magic number: this.buffer[bookmark - 1] = unchecked((byte)(count >> 8));
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,GrowBuffer,The following statement contains a magic number: var newSize = this.buffer == null ? 64 : this.buffer.Length;
Magic Number,System.Diagnostics.Tracing,DataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\DataCollector.cs,GrowBuffer,The following statement contains a magic number: do              {                  newSize *= 2;              }              while (newSize < required);
Magic Number,System.Diagnostics.Tracing,EventSourceActivity,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\EventSourceActivity.cs,Stop,The following statement contains a magic number: if (eventName == null)              {                  eventName = this.eventName;                  if (eventName.EndsWith("Start"))                      eventName = eventName.Substring(0' eventName.Length - 5);                  eventName = eventName + "Stop";              }
Magic Number,System.Diagnostics.Tracing,FieldMetadata,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\FieldMetadata.cs,FieldMetadata,The following statement contains a magic number: this.outType = (byte)(((int)dataType >> 8) & Statics.OutTypeMask);
Magic Number,System.Diagnostics.Tracing,FieldMetadata,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\FieldMetadata.cs,Encode,The following statement contains a magic number: if (0 != (this.inType & Statics.InTypeFixedCountFlag))              {                  if (metadata != null)                  {                      metadata[pos + 0] = unchecked((byte)this.fixedCount);                      metadata[pos + 1] = (byte)(this.fixedCount >> 8);                  }                  pos += 2;                    // If InTypeCustomCountFlag set' write out the blob of custom meta-data.                    if (Statics.InTypeCustomCountFlag == (this.inType & Statics.InTypeCountMask) &&                      this.fixedCount != 0)                  {                      if (metadata != null)                      {                          Buffer.BlockCopy(this.custom' 0' metadata' pos' this.fixedCount);                      }                      pos += this.fixedCount;                  }              }
Magic Number,System.Diagnostics.Tracing,FieldMetadata,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\FieldMetadata.cs,Encode,The following statement contains a magic number: if (0 != (this.inType & Statics.InTypeFixedCountFlag))              {                  if (metadata != null)                  {                      metadata[pos + 0] = unchecked((byte)this.fixedCount);                      metadata[pos + 1] = (byte)(this.fixedCount >> 8);                  }                  pos += 2;                    // If InTypeCustomCountFlag set' write out the blob of custom meta-data.                    if (Statics.InTypeCustomCountFlag == (this.inType & Statics.InTypeCountMask) &&                      this.fixedCount != 0)                  {                      if (metadata != null)                      {                          Buffer.BlockCopy(this.custom' 0' metadata' pos' this.fixedCount);                      }                      pos += this.fixedCount;                  }              }
Magic Number,System.Diagnostics.Tracing,NameInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\NameInfo.cs,NameInfo,The following statement contains a magic number: tagsPos = 2;
Magic Number,System.Diagnostics.Tracing,DateTimeTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\SimpleTypeInfos.cs,WriteData,The following statement contains a magic number: collector.AddScalar(ticks < 504911232000000000 ? 0 : ticks - 504911232000000000);
Magic Number,System.Diagnostics.Tracing,DateTimeTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\SimpleTypeInfos.cs,WriteData,The following statement contains a magic number: collector.AddScalar(ticks < 504911232000000000 ? 0 : ticks - 504911232000000000);
Magic Number,System.Diagnostics.Tracing,DateTimeOffsetTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\SimpleTypeInfos.cs,WriteData,The following statement contains a magic number: collector.AddScalar(ticks < 504911232000000000 ? 0 : ticks - 504911232000000000);
Magic Number,System.Diagnostics.Tracing,DateTimeOffsetTypeInfo,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\SimpleTypeInfos.cs,WriteData,The following statement contains a magic number: collector.AddScalar(ticks < 504911232000000000 ? 0 : ticks - 504911232000000000);
Magic Number,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,MetadataForString,The following statement contains a magic number: int metadataSize = Encoding.UTF8.GetByteCount(name) + 3 + prefixSize + suffixSize;
Magic Number,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,MetadataForString,The following statement contains a magic number: metadata[1] = unchecked((byte)(totalSize >> 8));
Magic Number,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,MetadataForString,The following statement contains a magic number: Encoding.UTF8.GetBytes(name' 0' name.Length' metadata' 2 + prefixSize);
Magic Number,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,EncodeTags,The following statement contains a magic number: do              {                  byte current = (byte)((tagsLeft >> 21) & 0x7f);                  more = (tagsLeft & 0x1fffff) != 0;                  current |= (byte)(more ? 0x80 : 0x00);                  tagsLeft = tagsLeft << 7;                    if (metadata != null)                  {                      metadata[pos] = current;                  }                  pos += 1;              }              while (more);
Magic Number,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,EncodeTags,The following statement contains a magic number: do              {                  byte current = (byte)((tagsLeft >> 21) & 0x7f);                  more = (tagsLeft & 0x1fffff) != 0;                  current |= (byte)(more ? 0x80 : 0x00);                  tagsLeft = tagsLeft << 7;                    if (metadata != null)                  {                      metadata[pos] = current;                  }                  pos += 1;              }              while (more);
Magic Number,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,ShouldOverrideFieldName,The following statement contains a magic number: return (fieldName.Length <= 2 && fieldName[0] == '_');
Magic Number,System.Diagnostics.Tracing,Statics,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\Statics.cs,MakeDataType,The following statement contains a magic number: return (TraceLoggingDataType)(((int)baseType & 0x1f) | ((int)format << 8));
Magic Number,System.Diagnostics.Tracing,TraceLoggingDataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingDataCollector.cs,AddBinary,The following statement contains a magic number: DataCollector.ThreadInstance.AddBinary(value' value == null ? 0 : value.Length * 2);
Magic Number,System.Diagnostics.Tracing,TraceLoggingMetadataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingMetadataCollector.cs,AddScalar,The following statement contains a magic number: switch ((TraceLoggingDataType)((int)type & Statics.InTypeMask))              {                  case TraceLoggingDataType.Int8:                  case TraceLoggingDataType.UInt8:                  case TraceLoggingDataType.Char8:                      size = 1;                      break;                  case TraceLoggingDataType.Int16:                  case TraceLoggingDataType.UInt16:                  case TraceLoggingDataType.Char16:                      size = 2;                      break;                  case TraceLoggingDataType.Int32:                  case TraceLoggingDataType.UInt32:                  case TraceLoggingDataType.HexInt32:                  case TraceLoggingDataType.Float:                  case TraceLoggingDataType.Boolean32:                      size = 4;                      break;                  case TraceLoggingDataType.Int64:                  case TraceLoggingDataType.UInt64:                  case TraceLoggingDataType.HexInt64:                  case TraceLoggingDataType.Double:                  case TraceLoggingDataType.FileTime:                      size = 8;                      break;                  case TraceLoggingDataType.Guid:                  case TraceLoggingDataType.SystemTime:                      size = 16;                      break;                  default:                      throw new ArgumentOutOfRangeException(nameof(type));              }
Magic Number,System.Diagnostics.Tracing,TraceLoggingMetadataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingMetadataCollector.cs,AddScalar,The following statement contains a magic number: switch ((TraceLoggingDataType)((int)type & Statics.InTypeMask))              {                  case TraceLoggingDataType.Int8:                  case TraceLoggingDataType.UInt8:                  case TraceLoggingDataType.Char8:                      size = 1;                      break;                  case TraceLoggingDataType.Int16:                  case TraceLoggingDataType.UInt16:                  case TraceLoggingDataType.Char16:                      size = 2;                      break;                  case TraceLoggingDataType.Int32:                  case TraceLoggingDataType.UInt32:                  case TraceLoggingDataType.HexInt32:                  case TraceLoggingDataType.Float:                  case TraceLoggingDataType.Boolean32:                      size = 4;                      break;                  case TraceLoggingDataType.Int64:                  case TraceLoggingDataType.UInt64:                  case TraceLoggingDataType.HexInt64:                  case TraceLoggingDataType.Double:                  case TraceLoggingDataType.FileTime:                      size = 8;                      break;                  case TraceLoggingDataType.Guid:                  case TraceLoggingDataType.SystemTime:                      size = 16;                      break;                  default:                      throw new ArgumentOutOfRangeException(nameof(type));              }
Magic Number,System.Diagnostics.Tracing,TraceLoggingMetadataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingMetadataCollector.cs,AddScalar,The following statement contains a magic number: switch ((TraceLoggingDataType)((int)type & Statics.InTypeMask))              {                  case TraceLoggingDataType.Int8:                  case TraceLoggingDataType.UInt8:                  case TraceLoggingDataType.Char8:                      size = 1;                      break;                  case TraceLoggingDataType.Int16:                  case TraceLoggingDataType.UInt16:                  case TraceLoggingDataType.Char16:                      size = 2;                      break;                  case TraceLoggingDataType.Int32:                  case TraceLoggingDataType.UInt32:                  case TraceLoggingDataType.HexInt32:                  case TraceLoggingDataType.Float:                  case TraceLoggingDataType.Boolean32:                      size = 4;                      break;                  case TraceLoggingDataType.Int64:                  case TraceLoggingDataType.UInt64:                  case TraceLoggingDataType.HexInt64:                  case TraceLoggingDataType.Double:                  case TraceLoggingDataType.FileTime:                      size = 8;                      break;                  case TraceLoggingDataType.Guid:                  case TraceLoggingDataType.SystemTime:                      size = 16;                      break;                  default:                      throw new ArgumentOutOfRangeException(nameof(type));              }
Magic Number,System.Diagnostics.Tracing,TraceLoggingMetadataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingMetadataCollector.cs,AddScalar,The following statement contains a magic number: switch ((TraceLoggingDataType)((int)type & Statics.InTypeMask))              {                  case TraceLoggingDataType.Int8:                  case TraceLoggingDataType.UInt8:                  case TraceLoggingDataType.Char8:                      size = 1;                      break;                  case TraceLoggingDataType.Int16:                  case TraceLoggingDataType.UInt16:                  case TraceLoggingDataType.Char16:                      size = 2;                      break;                  case TraceLoggingDataType.Int32:                  case TraceLoggingDataType.UInt32:                  case TraceLoggingDataType.HexInt32:                  case TraceLoggingDataType.Float:                  case TraceLoggingDataType.Boolean32:                      size = 4;                      break;                  case TraceLoggingDataType.Int64:                  case TraceLoggingDataType.UInt64:                  case TraceLoggingDataType.HexInt64:                  case TraceLoggingDataType.Double:                  case TraceLoggingDataType.FileTime:                      size = 8;                      break;                  case TraceLoggingDataType.Guid:                  case TraceLoggingDataType.SystemTime:                      size = 16;                      break;                  default:                      throw new ArgumentOutOfRangeException(nameof(type));              }
Magic Number,System.Diagnostics.Tracing,TraceLoggingMetadataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingMetadataCollector.cs,AddBinary,The following statement contains a magic number: this.impl.AddScalar(2);
Magic Number,System.Diagnostics.Tracing,TraceLoggingMetadataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingMetadataCollector.cs,AddArray,The following statement contains a magic number: this.impl.AddScalar(2);
Magic Number,System.Diagnostics.Tracing,TraceLoggingMetadataCollector,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\shared\TraceLogging\TraceLoggingMetadataCollector.cs,AddCustom,The following statement contains a magic number: this.impl.AddScalar(2);
Missing Default,System.Diagnostics.Tracing,ManifestBuilder,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,GetOpcodeName,The following switch statement is missing a default case: switch (opcode)              {                  case EventOpcode.Info:                      return "win:Info";                  case EventOpcode.Start:                      return "win:Start";                  case EventOpcode.Stop:                      return "win:Stop";                  case EventOpcode.DataCollectionStart:                      return "win:DC_Start";                  case EventOpcode.DataCollectionStop:                      return "win:DC_Stop";                  case EventOpcode.Extension:                      return "win:Extension";                  case EventOpcode.Reply:                      return "win:Reply";                  case EventOpcode.Resume:                      return "win:Resume";                  case EventOpcode.Suspend:                      return "win:Suspend";                  case EventOpcode.Send:                      return "win:Send";                  case EventOpcode.Receive:                      return "win:Receive";              }
Missing Default,System.Diagnostics.Tracing,EventProvider,C:\selectedRepos\dotnet_corefx\src\Microsoft.Diagnostics.Tracing.EventSource.Redist\src\RuntimeSpecific.cs,SetLastError,The following switch statement is missing a default case: switch (error)              {                  case UnsafeNativeMethods.ManifestEtw.ERROR_ARITHMETIC_OVERFLOW:                  case UnsafeNativeMethods.ManifestEtw.ERROR_MORE_DATA:                      s_returnCode = WriteEventErrorCode.EventTooBig;                      break;                  case UnsafeNativeMethods.ManifestEtw.ERROR_NOT_ENOUGH_MEMORY:                      s_returnCode = WriteEventErrorCode.NoFreeBuffers;                      break;              }
