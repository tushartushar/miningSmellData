Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The method has 118 lines of code.
Complex Method,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,Cyclomatic complexity of the method is 13
Complex Method,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryValidateUtf8,Cyclomatic complexity of the method is 11
Long Parameter List,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,CreateFromConnectedStream,The method has 5 parameters. Parameters: stream' isServer' subprotocol' keepAliveInterval' buffer
Long Parameter List,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ManagedWebSocket,The method has 5 parameters. Parameters: stream' isServer' subprotocol' keepAliveInterval' buffer
Long Parameter List,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The method has 5 parameters. Parameters: opcode' sendBuffer' payload' endOfMessage' useMask
Long Parameter List,System.Net.WebSockets,IWebSocketReceiveResultGetter,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,GetResult,The method has 5 parameters. Parameters: count' messageType' endOfMessage' closeStatus' closeDescription
Long Parameter List,System.Net.WebSockets,WebSocketReceiveResultGetter,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,GetResult,The method has 5 parameters. Parameters: count' messageType' endOfMessage' closeStatus' closeDescription
Long Parameter List,System.Net.WebSockets,ValueWebSocketReceiveResultGetter,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,GetResult,The method has 5 parameters. Parameters: count' messageType' endOfMessage' closeStatus' closeDescription
Long Parameter List,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,CreateFromStream,The method has 5 parameters. Parameters: stream' isServer' subProtocol' keepAliveInterval' buffer
Long Parameter List,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,CreateClientWebSocket,The method has 7 parameters. Parameters: innerStream' subProtocol' receiveBufferSize' sendBufferSize' keepAliveInterval' useZeroMaskingKey' internalBuffer
Long Parameter List,System.Net.WebSockets,WebSocketReceiveResult,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocketReceiveResult.cs,WebSocketReceiveResult,The method has 5 parameters. Parameters: count' messageType' endOfMessage' closeStatus' closeStatusDescription
Long Identifier,System.Net.WebSockets,WebSocketValidate,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\WebSockets\WebSocketValidate.cs,,The length of the parameter CloseStatusCodeFailedTLSHandshake is 33.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendAsync,The length of the statement  "                    nameof(WebSocketMessageType.Close)' nameof(SendAsync)' nameof(WebSocketMessageType.Binary)' nameof(WebSocketMessageType.Text)' nameof(CloseOutputAsync))' " is 153.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendAsync,The length of the statement  "                    nameof(WebSocketMessageType.Close)' nameof(SendAsync)' nameof(WebSocketMessageType.Binary)' nameof(WebSocketMessageType.Text)' nameof(CloseOutputAsync))' " is 153.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsync,The length of the statement  "                Debug.Assert(!Monitor.IsEntered(StateUpdateLock)' $"{nameof(StateUpdateLock)} must never be held when acquiring {nameof(ReceiveAsyncLock)}"); " is 141.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsync,The length of the statement  "                    Task<WebSocketReceiveResult> t = ReceiveAsyncPrivate<WebSocketReceiveResultGetter'WebSocketReceiveResult>(buffer' cancellationToken).AsTask(); " is 142.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsync,The length of the statement  "                Debug.Assert(!Monitor.IsEntered(StateUpdateLock)' $"{nameof(StateUpdateLock)} must never be held when acquiring {nameof(ReceiveAsyncLock)}"); " is 141.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsync,The length of the statement  "                    ValueTask<ValueWebSocketReceiveResult> t = ReceiveAsyncPrivate<ValueWebSocketReceiveResultGetter' ValueWebSocketReceiveResult>(buffer' cancellationToken); " is 154.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsync,The length of the statement  "                        t.IsCompletedSuccessfully ? (t.Result.MessageType == WebSocketMessageType.Close ? s_cachedCloseTask : Task.CompletedTask) : " is 123.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendFrameAsync,The length of the statement  "            // common that the awaited operation completes so fast after the await that we may end up allocating an AwaitTaskContinuation " is 125.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendFrameAsync,The length of the statement  "            // optimizations in place to avoid a few of those expenses' at the expense of more complicated code; for the common case' " is 121.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendFrameAsync,The length of the statement  "            // this code has fewer than half the number and size of allocations.  If/when that issue is fixed' this method should be deleted " is 128.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendFrameAsync,The length of the statement  "            // If a cancelable cancellation token was provided' that would require registering with it' which means more state we have to " is 125.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteFrameToSendBuffer,The length of the statement  "                // If we added a mask to the header' XOR the payload with the mask.  We do the manipulation in the send buffer so as to avoid " is 125.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The length of the statement  "            Debug.Assert(sendBuffer.Length >= MaxMessageHeaderLength' $"Expected sendBuffer to be at least {MaxMessageHeaderLength}' got {sendBuffer.Length}"); " is 147.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The length of the statement  "                                    (payloadLength <= 125 ? 0 : payloadLength == 126 ? sizeof(ushort) : sizeof(ulong)); // additional 2 or 8 bytes for 16-bit or 64-bit length " is 138.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The length of the statement  "                            await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false); " is 142.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The length of the statement  "                    Debug.Assert(header.Opcode == MessageOpcode.Binary || header.Opcode == MessageOpcode.Text' $"Unexpected opcode {header.Opcode}"); " is 129.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The length of the statement  "                        _receivedMaskOffsetOffset = ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy)' header.Mask' _receivedMaskOffsetOffset); " is 140.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The length of the statement  "                        await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.InvalidPayloadData' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false); " is 147.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The length of the statement  "                await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false); " is 142.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The length of the statement  "                closeStatus = (WebSocketCloseStatus)(_receiveBuffer.Span[_receiveBufferOffset] << 8 | _receiveBuffer.Span[_receiveBufferOffset + 1]); " is 133.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The length of the statement  "                    await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false); " is 142.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The length of the statement  "                        closeStatusDescription = s_textEncoding.GetString(_receiveBuffer.Span.Slice(_receiveBufferOffset + 2' (int)header.PayloadLength - 2)); " is 134.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The length of the statement  "                        await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken' exc).ConfigureAwait(false); " is 147.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,CloseAsyncPrivate,The length of the statement  "                    Debug.Assert(!Monitor.IsEntered(StateUpdateLock)' $"{nameof(StateUpdateLock)} must never be held when acquiring {nameof(ReceiveAsyncLock)}"); " is 141.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,CloseAsyncPrivate,The length of the statement  "                            ValueTask<ValueWebSocketReceiveResult> vt = ReceiveAsyncPrivate<ValueWebSocketReceiveResultGetter' ValueWebSocketReceiveResult>(closeBuffer' cancellationToken); " is 160.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,CloseAsyncPrivate,The length of the statement  "                                vt.IsCompletedSuccessfully ? (vt.Result.MessageType == WebSocketMessageType.Close ? s_cachedCloseTask : Task.CompletedTask) : " is 125.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendCloseFrameAsync,The length of the statement  "            // Close payload is two bytes containing the close status followed by a UTF8-encoding of the status description' if it exists. " is 126.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendCloseFrameAsync,The length of the statement  "                await SendFrameAsync(MessageOpcode.Close' true' new Memory<byte>(buffer' 0' count)' cancellationToken).ConfigureAwait(false); " is 125.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ConsumeFromBuffer,The length of the statement  "            Debug.Assert(count <= _receiveBufferCount' $"Trying to consume {count}' which is more than exists {_receiveBufferCount}"); " is 122.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,EnsureBufferContainsAsync,The length of the statement  "            Debug.Assert(minimumRequiredBytes <= _receiveBuffer.Length' $"Requested number of bytes {minimumRequiredBytes} must not exceed {_receiveBuffer.Length}"); " is 153.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,EnsureBufferContainsAsync,The length of the statement  "                    int numRead = await _stream.ReadAsync(_receiveBuffer.Slice(_receiveBufferCount' _receiveBuffer.Length - _receiveBufferCount)' cancellationToken).ConfigureAwait(false); " is 167.
Long Statement,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,AllocateSendBuffer,The length of the statement  "            Debug.Assert(_sendBuffer == null); // would only fail if had some catastrophic error previously that prevented cleaning up " is 122.
Long Statement,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,ReceiveAsync,The length of the statement  "                    WebSocketReceiveResult r = await ReceiveAsync(new ArraySegment<byte>(array' 0' buffer.Length)' cancellationToken).ConfigureAwait(false); " is 136.
Long Statement,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,SendWithArrayPoolAsync,The length of the statement  "                await SendAsync(new ArraySegment<byte>(array' 0' buffer.Length)' messageType' endOfMessage' cancellationToken).ConfigureAwait(false); " is 133.
Long Statement,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,CreateClientBuffer,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(receiveBufferSize)' receiveBufferSize' SR.Format(SR.net_WebSockets_ArgumentOutOfRange_TooSmall' 1)); " is 145.
Long Statement,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,CreateClientBuffer,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(sendBufferSize)' sendBufferSize' SR.Format(SR.net_WebSockets_ArgumentOutOfRange_TooSmall' 1)); " is 139.
Long Statement,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,CreateServerBuffer,The length of the statement  "                throw new ArgumentOutOfRangeException(nameof(receiveBufferSize)' receiveBufferSize' SR.Format(SR.net_WebSockets_ArgumentOutOfRange_TooSmall' 1)); " is 145.
Long Statement,System.Net.WebSockets,WebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\WebSocket.cs,CreateClientWebSocket,The length of the statement  "            return ManagedWebSocket.CreateFromConnectedStream(innerStream' false' subProtocol' keepAliveInterval' internalMemoryBuffer); " is 124.
Long Statement,System.Net.WebSockets,WebSocketValidate,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\WebSockets\WebSocketValidate.cs,ValidateSubprotocol,The length of the statement  "                throw new ArgumentException(SR.Format(SR.net_WebSockets_InvalidCharInProtocolString' subProtocol' invalidChar)' nameof(subProtocol)); " is 133.
Complex Conditional,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,CloseAsyncPrivate,The conditional expression  "receiveTask == null ||                              (receiveTask.Status == TaskStatus.RanToCompletion &&                                !(receiveTask is Task<WebSocketReceiveResult> wsrr && wsrr.Result.MessageType == WebSocketMessageType.Close) &&                               !(receiveTask is Task<ValueWebSocketReceiveResult> vwsrr && vwsrr.Result.MessageType == WebSocketMessageType.Close))"  is complex.
Complex Conditional,System.Net.WebSockets,WebSocketValidate,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Net\WebSockets\WebSocketValidate.cs,ValidateCloseStatus,The conditional expression  "(closeStatusCode >= InvalidCloseStatusCodesFrom &&                  closeStatusCode <= InvalidCloseStatusCodesTo) ||                  closeStatusCode == CloseStatusCodeAbort ||                  closeStatusCode == CloseStatusCodeFailedTLSHandshake"  is complex.
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,WriteHeader,The following statement contains a magic number: if (payload.Length <= 125)              {                  sendBuffer[1] = (byte)payload.Length;                  maskOffset = 2; // no additional payload length              }              else if (payload.Length <= ushort.MaxValue)              {                  sendBuffer[1] = 126;                  sendBuffer[2] = (byte)(payload.Length / 256);                  sendBuffer[3] = unchecked((byte)payload.Length);                  maskOffset = 2 + sizeof(ushort); // additional 2 bytes for 16-bit length              }              else              {                  sendBuffer[1] = 127;                  int length = payload.Length;                  for (int i = 9; i >= 2; i--)                  {                      sendBuffer[i] = unchecked((byte)length);                      length = length / 256;                  }                  maskOffset = 2 + sizeof(ulong); // additional 8 bytes for 64-bit length              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The following statement contains a magic number: try              {                  while (true) // in case we get control frames that should be ignored from the user's perspective                  {                      // Get the last received header.  If its payload length is non-zero' that means we previously                      // received the header but were only able to read a part of the fragment' so we should skip                      // reading another header and just proceed to use that same header and read more data associated                      // with it.  If instead its payload length is zero' then we've completed the processing of                      // thta message' and we should read the next header.                      MessageHeader header = _lastReceiveHeader;                      if (header.PayloadLength == 0)                      {                          if (_receiveBufferCount < (_isServer ? (MaxMessageHeaderLength - MaskLength) : MaxMessageHeaderLength))                          {                              // Make sure we have the first two bytes' which includes the start of the payload length.                              if (_receiveBufferCount < 2)                              {                                  await EnsureBufferContainsAsync(2' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                              }                                // Then make sure we have the full header based on the payload length.                              // If this is the server' we also need room for the received mask.                              long payloadLength = _receiveBuffer.Span[_receiveBufferOffset + 1] & 0x7F;                              if (_isServer || payloadLength > 125)                              {                                  int minNeeded =                                      2 +                                      (_isServer ? MaskLength : 0) +                                      (payloadLength <= 125 ? 0 : payloadLength == 126 ? sizeof(ushort) : sizeof(ulong)); // additional 2 or 8 bytes for 16-bit or 64-bit length                                  await EnsureBufferContainsAsync(minNeeded' cancellationToken).ConfigureAwait(false);                              }                          }                            if (!TryParseMessageHeaderFromReceiveBuffer(out header))                          {                              await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                          }                          _receivedMaskOffsetOffset = 0;                      }                        // If the header represents a ping or a pong' it's a control message meant                      // to be transparent to the user' so handle it and then loop around to read again.                      // Alternatively' if it's a close message' handle it and exit.                      if (header.Opcode == MessageOpcode.Ping || header.Opcode == MessageOpcode.Pong)                      {                          await HandleReceivedPingPongAsync(header' cancellationToken).ConfigureAwait(false);                          continue;                      }                      else if (header.Opcode == MessageOpcode.Close)                      {                          await HandleReceivedCloseAsync(header' cancellationToken).ConfigureAwait(false);                          return resultGetter.GetResult(0' WebSocketMessageType.Close' true' _closeStatus' _closeStatusDescription);                      }                        // If this is a continuation' replace the opcode with the one of the message it's continuing                      if (header.Opcode == MessageOpcode.Continuation)                      {                          header.Opcode = _lastReceiveHeader.Opcode;                      }                        // The message should now be a binary or text message.  Handle it by reading the payload and returning the contents.                      Debug.Assert(header.Opcode == MessageOpcode.Binary || header.Opcode == MessageOpcode.Text' $"Unexpected opcode {header.Opcode}");                        // If there's no data to read' return an appropriate result.                      if (header.PayloadLength == 0 || payloadBuffer.Length == 0)                      {                          _lastReceiveHeader = header;                          return resultGetter.GetResult(                              0'                              header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                              header.Fin && header.PayloadLength == 0'                              null' null);                      }                        // Otherwise' read as much of the payload as we can efficiently' and upate the header to reflect how much data                      // remains for future reads.                      int bytesToCopy = Math.Min(payloadBuffer.Length' (int)Math.Min(header.PayloadLength' _receiveBuffer.Length));                      Debug.Assert(bytesToCopy > 0' $"Expected {nameof(bytesToCopy)} > 0");                      if (_receiveBufferCount < bytesToCopy)                      {                          await EnsureBufferContainsAsync(bytesToCopy' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                      }                        if (_isServer)                      {                          _receivedMaskOffsetOffset = ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy)' header.Mask' _receivedMaskOffsetOffset);                      }                      _receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy).CopyTo(payloadBuffer.Span.Slice(0' bytesToCopy));                      ConsumeFromBuffer(bytesToCopy);                      header.PayloadLength -= bytesToCopy;                        // If this a text message' validate that it contains valid UTF8.                      if (header.Opcode == MessageOpcode.Text &&                          !TryValidateUtf8(payloadBuffer.Span.Slice(0' bytesToCopy)' header.Fin' _utf8TextState))                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.InvalidPayloadData' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                      }                        _lastReceiveHeader = header;                      return resultGetter.GetResult(                          bytesToCopy'                          header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                          header.Fin && header.PayloadLength == 0'                          null' null);                  }              }              catch (Exception exc)              {                  if (_state == WebSocketState.Aborted)                  {                      throw new OperationCanceledException(nameof(WebSocketState.Aborted)' exc);                  }                  throw new WebSocketException(WebSocketError.ConnectionClosedPrematurely' exc);              }              finally              {                  registration.Dispose();              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The following statement contains a magic number: try              {                  while (true) // in case we get control frames that should be ignored from the user's perspective                  {                      // Get the last received header.  If its payload length is non-zero' that means we previously                      // received the header but were only able to read a part of the fragment' so we should skip                      // reading another header and just proceed to use that same header and read more data associated                      // with it.  If instead its payload length is zero' then we've completed the processing of                      // thta message' and we should read the next header.                      MessageHeader header = _lastReceiveHeader;                      if (header.PayloadLength == 0)                      {                          if (_receiveBufferCount < (_isServer ? (MaxMessageHeaderLength - MaskLength) : MaxMessageHeaderLength))                          {                              // Make sure we have the first two bytes' which includes the start of the payload length.                              if (_receiveBufferCount < 2)                              {                                  await EnsureBufferContainsAsync(2' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                              }                                // Then make sure we have the full header based on the payload length.                              // If this is the server' we also need room for the received mask.                              long payloadLength = _receiveBuffer.Span[_receiveBufferOffset + 1] & 0x7F;                              if (_isServer || payloadLength > 125)                              {                                  int minNeeded =                                      2 +                                      (_isServer ? MaskLength : 0) +                                      (payloadLength <= 125 ? 0 : payloadLength == 126 ? sizeof(ushort) : sizeof(ulong)); // additional 2 or 8 bytes for 16-bit or 64-bit length                                  await EnsureBufferContainsAsync(minNeeded' cancellationToken).ConfigureAwait(false);                              }                          }                            if (!TryParseMessageHeaderFromReceiveBuffer(out header))                          {                              await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                          }                          _receivedMaskOffsetOffset = 0;                      }                        // If the header represents a ping or a pong' it's a control message meant                      // to be transparent to the user' so handle it and then loop around to read again.                      // Alternatively' if it's a close message' handle it and exit.                      if (header.Opcode == MessageOpcode.Ping || header.Opcode == MessageOpcode.Pong)                      {                          await HandleReceivedPingPongAsync(header' cancellationToken).ConfigureAwait(false);                          continue;                      }                      else if (header.Opcode == MessageOpcode.Close)                      {                          await HandleReceivedCloseAsync(header' cancellationToken).ConfigureAwait(false);                          return resultGetter.GetResult(0' WebSocketMessageType.Close' true' _closeStatus' _closeStatusDescription);                      }                        // If this is a continuation' replace the opcode with the one of the message it's continuing                      if (header.Opcode == MessageOpcode.Continuation)                      {                          header.Opcode = _lastReceiveHeader.Opcode;                      }                        // The message should now be a binary or text message.  Handle it by reading the payload and returning the contents.                      Debug.Assert(header.Opcode == MessageOpcode.Binary || header.Opcode == MessageOpcode.Text' $"Unexpected opcode {header.Opcode}");                        // If there's no data to read' return an appropriate result.                      if (header.PayloadLength == 0 || payloadBuffer.Length == 0)                      {                          _lastReceiveHeader = header;                          return resultGetter.GetResult(                              0'                              header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                              header.Fin && header.PayloadLength == 0'                              null' null);                      }                        // Otherwise' read as much of the payload as we can efficiently' and upate the header to reflect how much data                      // remains for future reads.                      int bytesToCopy = Math.Min(payloadBuffer.Length' (int)Math.Min(header.PayloadLength' _receiveBuffer.Length));                      Debug.Assert(bytesToCopy > 0' $"Expected {nameof(bytesToCopy)} > 0");                      if (_receiveBufferCount < bytesToCopy)                      {                          await EnsureBufferContainsAsync(bytesToCopy' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                      }                        if (_isServer)                      {                          _receivedMaskOffsetOffset = ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy)' header.Mask' _receivedMaskOffsetOffset);                      }                      _receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy).CopyTo(payloadBuffer.Span.Slice(0' bytesToCopy));                      ConsumeFromBuffer(bytesToCopy);                      header.PayloadLength -= bytesToCopy;                        // If this a text message' validate that it contains valid UTF8.                      if (header.Opcode == MessageOpcode.Text &&                          !TryValidateUtf8(payloadBuffer.Span.Slice(0' bytesToCopy)' header.Fin' _utf8TextState))                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.InvalidPayloadData' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                      }                        _lastReceiveHeader = header;                      return resultGetter.GetResult(                          bytesToCopy'                          header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                          header.Fin && header.PayloadLength == 0'                          null' null);                  }              }              catch (Exception exc)              {                  if (_state == WebSocketState.Aborted)                  {                      throw new OperationCanceledException(nameof(WebSocketState.Aborted)' exc);                  }                  throw new WebSocketException(WebSocketError.ConnectionClosedPrematurely' exc);              }              finally              {                  registration.Dispose();              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The following statement contains a magic number: try              {                  while (true) // in case we get control frames that should be ignored from the user's perspective                  {                      // Get the last received header.  If its payload length is non-zero' that means we previously                      // received the header but were only able to read a part of the fragment' so we should skip                      // reading another header and just proceed to use that same header and read more data associated                      // with it.  If instead its payload length is zero' then we've completed the processing of                      // thta message' and we should read the next header.                      MessageHeader header = _lastReceiveHeader;                      if (header.PayloadLength == 0)                      {                          if (_receiveBufferCount < (_isServer ? (MaxMessageHeaderLength - MaskLength) : MaxMessageHeaderLength))                          {                              // Make sure we have the first two bytes' which includes the start of the payload length.                              if (_receiveBufferCount < 2)                              {                                  await EnsureBufferContainsAsync(2' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                              }                                // Then make sure we have the full header based on the payload length.                              // If this is the server' we also need room for the received mask.                              long payloadLength = _receiveBuffer.Span[_receiveBufferOffset + 1] & 0x7F;                              if (_isServer || payloadLength > 125)                              {                                  int minNeeded =                                      2 +                                      (_isServer ? MaskLength : 0) +                                      (payloadLength <= 125 ? 0 : payloadLength == 126 ? sizeof(ushort) : sizeof(ulong)); // additional 2 or 8 bytes for 16-bit or 64-bit length                                  await EnsureBufferContainsAsync(minNeeded' cancellationToken).ConfigureAwait(false);                              }                          }                            if (!TryParseMessageHeaderFromReceiveBuffer(out header))                          {                              await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                          }                          _receivedMaskOffsetOffset = 0;                      }                        // If the header represents a ping or a pong' it's a control message meant                      // to be transparent to the user' so handle it and then loop around to read again.                      // Alternatively' if it's a close message' handle it and exit.                      if (header.Opcode == MessageOpcode.Ping || header.Opcode == MessageOpcode.Pong)                      {                          await HandleReceivedPingPongAsync(header' cancellationToken).ConfigureAwait(false);                          continue;                      }                      else if (header.Opcode == MessageOpcode.Close)                      {                          await HandleReceivedCloseAsync(header' cancellationToken).ConfigureAwait(false);                          return resultGetter.GetResult(0' WebSocketMessageType.Close' true' _closeStatus' _closeStatusDescription);                      }                        // If this is a continuation' replace the opcode with the one of the message it's continuing                      if (header.Opcode == MessageOpcode.Continuation)                      {                          header.Opcode = _lastReceiveHeader.Opcode;                      }                        // The message should now be a binary or text message.  Handle it by reading the payload and returning the contents.                      Debug.Assert(header.Opcode == MessageOpcode.Binary || header.Opcode == MessageOpcode.Text' $"Unexpected opcode {header.Opcode}");                        // If there's no data to read' return an appropriate result.                      if (header.PayloadLength == 0 || payloadBuffer.Length == 0)                      {                          _lastReceiveHeader = header;                          return resultGetter.GetResult(                              0'                              header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                              header.Fin && header.PayloadLength == 0'                              null' null);                      }                        // Otherwise' read as much of the payload as we can efficiently' and upate the header to reflect how much data                      // remains for future reads.                      int bytesToCopy = Math.Min(payloadBuffer.Length' (int)Math.Min(header.PayloadLength' _receiveBuffer.Length));                      Debug.Assert(bytesToCopy > 0' $"Expected {nameof(bytesToCopy)} > 0");                      if (_receiveBufferCount < bytesToCopy)                      {                          await EnsureBufferContainsAsync(bytesToCopy' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                      }                        if (_isServer)                      {                          _receivedMaskOffsetOffset = ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy)' header.Mask' _receivedMaskOffsetOffset);                      }                      _receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy).CopyTo(payloadBuffer.Span.Slice(0' bytesToCopy));                      ConsumeFromBuffer(bytesToCopy);                      header.PayloadLength -= bytesToCopy;                        // If this a text message' validate that it contains valid UTF8.                      if (header.Opcode == MessageOpcode.Text &&                          !TryValidateUtf8(payloadBuffer.Span.Slice(0' bytesToCopy)' header.Fin' _utf8TextState))                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.InvalidPayloadData' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                      }                        _lastReceiveHeader = header;                      return resultGetter.GetResult(                          bytesToCopy'                          header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                          header.Fin && header.PayloadLength == 0'                          null' null);                  }              }              catch (Exception exc)              {                  if (_state == WebSocketState.Aborted)                  {                      throw new OperationCanceledException(nameof(WebSocketState.Aborted)' exc);                  }                  throw new WebSocketException(WebSocketError.ConnectionClosedPrematurely' exc);              }              finally              {                  registration.Dispose();              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The following statement contains a magic number: try              {                  while (true) // in case we get control frames that should be ignored from the user's perspective                  {                      // Get the last received header.  If its payload length is non-zero' that means we previously                      // received the header but were only able to read a part of the fragment' so we should skip                      // reading another header and just proceed to use that same header and read more data associated                      // with it.  If instead its payload length is zero' then we've completed the processing of                      // thta message' and we should read the next header.                      MessageHeader header = _lastReceiveHeader;                      if (header.PayloadLength == 0)                      {                          if (_receiveBufferCount < (_isServer ? (MaxMessageHeaderLength - MaskLength) : MaxMessageHeaderLength))                          {                              // Make sure we have the first two bytes' which includes the start of the payload length.                              if (_receiveBufferCount < 2)                              {                                  await EnsureBufferContainsAsync(2' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                              }                                // Then make sure we have the full header based on the payload length.                              // If this is the server' we also need room for the received mask.                              long payloadLength = _receiveBuffer.Span[_receiveBufferOffset + 1] & 0x7F;                              if (_isServer || payloadLength > 125)                              {                                  int minNeeded =                                      2 +                                      (_isServer ? MaskLength : 0) +                                      (payloadLength <= 125 ? 0 : payloadLength == 126 ? sizeof(ushort) : sizeof(ulong)); // additional 2 or 8 bytes for 16-bit or 64-bit length                                  await EnsureBufferContainsAsync(minNeeded' cancellationToken).ConfigureAwait(false);                              }                          }                            if (!TryParseMessageHeaderFromReceiveBuffer(out header))                          {                              await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                          }                          _receivedMaskOffsetOffset = 0;                      }                        // If the header represents a ping or a pong' it's a control message meant                      // to be transparent to the user' so handle it and then loop around to read again.                      // Alternatively' if it's a close message' handle it and exit.                      if (header.Opcode == MessageOpcode.Ping || header.Opcode == MessageOpcode.Pong)                      {                          await HandleReceivedPingPongAsync(header' cancellationToken).ConfigureAwait(false);                          continue;                      }                      else if (header.Opcode == MessageOpcode.Close)                      {                          await HandleReceivedCloseAsync(header' cancellationToken).ConfigureAwait(false);                          return resultGetter.GetResult(0' WebSocketMessageType.Close' true' _closeStatus' _closeStatusDescription);                      }                        // If this is a continuation' replace the opcode with the one of the message it's continuing                      if (header.Opcode == MessageOpcode.Continuation)                      {                          header.Opcode = _lastReceiveHeader.Opcode;                      }                        // The message should now be a binary or text message.  Handle it by reading the payload and returning the contents.                      Debug.Assert(header.Opcode == MessageOpcode.Binary || header.Opcode == MessageOpcode.Text' $"Unexpected opcode {header.Opcode}");                        // If there's no data to read' return an appropriate result.                      if (header.PayloadLength == 0 || payloadBuffer.Length == 0)                      {                          _lastReceiveHeader = header;                          return resultGetter.GetResult(                              0'                              header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                              header.Fin && header.PayloadLength == 0'                              null' null);                      }                        // Otherwise' read as much of the payload as we can efficiently' and upate the header to reflect how much data                      // remains for future reads.                      int bytesToCopy = Math.Min(payloadBuffer.Length' (int)Math.Min(header.PayloadLength' _receiveBuffer.Length));                      Debug.Assert(bytesToCopy > 0' $"Expected {nameof(bytesToCopy)} > 0");                      if (_receiveBufferCount < bytesToCopy)                      {                          await EnsureBufferContainsAsync(bytesToCopy' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                      }                        if (_isServer)                      {                          _receivedMaskOffsetOffset = ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy)' header.Mask' _receivedMaskOffsetOffset);                      }                      _receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy).CopyTo(payloadBuffer.Span.Slice(0' bytesToCopy));                      ConsumeFromBuffer(bytesToCopy);                      header.PayloadLength -= bytesToCopy;                        // If this a text message' validate that it contains valid UTF8.                      if (header.Opcode == MessageOpcode.Text &&                          !TryValidateUtf8(payloadBuffer.Span.Slice(0' bytesToCopy)' header.Fin' _utf8TextState))                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.InvalidPayloadData' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                      }                        _lastReceiveHeader = header;                      return resultGetter.GetResult(                          bytesToCopy'                          header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                          header.Fin && header.PayloadLength == 0'                          null' null);                  }              }              catch (Exception exc)              {                  if (_state == WebSocketState.Aborted)                  {                      throw new OperationCanceledException(nameof(WebSocketState.Aborted)' exc);                  }                  throw new WebSocketException(WebSocketError.ConnectionClosedPrematurely' exc);              }              finally              {                  registration.Dispose();              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The following statement contains a magic number: try              {                  while (true) // in case we get control frames that should be ignored from the user's perspective                  {                      // Get the last received header.  If its payload length is non-zero' that means we previously                      // received the header but were only able to read a part of the fragment' so we should skip                      // reading another header and just proceed to use that same header and read more data associated                      // with it.  If instead its payload length is zero' then we've completed the processing of                      // thta message' and we should read the next header.                      MessageHeader header = _lastReceiveHeader;                      if (header.PayloadLength == 0)                      {                          if (_receiveBufferCount < (_isServer ? (MaxMessageHeaderLength - MaskLength) : MaxMessageHeaderLength))                          {                              // Make sure we have the first two bytes' which includes the start of the payload length.                              if (_receiveBufferCount < 2)                              {                                  await EnsureBufferContainsAsync(2' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                              }                                // Then make sure we have the full header based on the payload length.                              // If this is the server' we also need room for the received mask.                              long payloadLength = _receiveBuffer.Span[_receiveBufferOffset + 1] & 0x7F;                              if (_isServer || payloadLength > 125)                              {                                  int minNeeded =                                      2 +                                      (_isServer ? MaskLength : 0) +                                      (payloadLength <= 125 ? 0 : payloadLength == 126 ? sizeof(ushort) : sizeof(ulong)); // additional 2 or 8 bytes for 16-bit or 64-bit length                                  await EnsureBufferContainsAsync(minNeeded' cancellationToken).ConfigureAwait(false);                              }                          }                            if (!TryParseMessageHeaderFromReceiveBuffer(out header))                          {                              await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                          }                          _receivedMaskOffsetOffset = 0;                      }                        // If the header represents a ping or a pong' it's a control message meant                      // to be transparent to the user' so handle it and then loop around to read again.                      // Alternatively' if it's a close message' handle it and exit.                      if (header.Opcode == MessageOpcode.Ping || header.Opcode == MessageOpcode.Pong)                      {                          await HandleReceivedPingPongAsync(header' cancellationToken).ConfigureAwait(false);                          continue;                      }                      else if (header.Opcode == MessageOpcode.Close)                      {                          await HandleReceivedCloseAsync(header' cancellationToken).ConfigureAwait(false);                          return resultGetter.GetResult(0' WebSocketMessageType.Close' true' _closeStatus' _closeStatusDescription);                      }                        // If this is a continuation' replace the opcode with the one of the message it's continuing                      if (header.Opcode == MessageOpcode.Continuation)                      {                          header.Opcode = _lastReceiveHeader.Opcode;                      }                        // The message should now be a binary or text message.  Handle it by reading the payload and returning the contents.                      Debug.Assert(header.Opcode == MessageOpcode.Binary || header.Opcode == MessageOpcode.Text' $"Unexpected opcode {header.Opcode}");                        // If there's no data to read' return an appropriate result.                      if (header.PayloadLength == 0 || payloadBuffer.Length == 0)                      {                          _lastReceiveHeader = header;                          return resultGetter.GetResult(                              0'                              header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                              header.Fin && header.PayloadLength == 0'                              null' null);                      }                        // Otherwise' read as much of the payload as we can efficiently' and upate the header to reflect how much data                      // remains for future reads.                      int bytesToCopy = Math.Min(payloadBuffer.Length' (int)Math.Min(header.PayloadLength' _receiveBuffer.Length));                      Debug.Assert(bytesToCopy > 0' $"Expected {nameof(bytesToCopy)} > 0");                      if (_receiveBufferCount < bytesToCopy)                      {                          await EnsureBufferContainsAsync(bytesToCopy' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                      }                        if (_isServer)                      {                          _receivedMaskOffsetOffset = ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy)' header.Mask' _receivedMaskOffsetOffset);                      }                      _receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy).CopyTo(payloadBuffer.Span.Slice(0' bytesToCopy));                      ConsumeFromBuffer(bytesToCopy);                      header.PayloadLength -= bytesToCopy;                        // If this a text message' validate that it contains valid UTF8.                      if (header.Opcode == MessageOpcode.Text &&                          !TryValidateUtf8(payloadBuffer.Span.Slice(0' bytesToCopy)' header.Fin' _utf8TextState))                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.InvalidPayloadData' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                      }                        _lastReceiveHeader = header;                      return resultGetter.GetResult(                          bytesToCopy'                          header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                          header.Fin && header.PayloadLength == 0'                          null' null);                  }              }              catch (Exception exc)              {                  if (_state == WebSocketState.Aborted)                  {                      throw new OperationCanceledException(nameof(WebSocketState.Aborted)' exc);                  }                  throw new WebSocketException(WebSocketError.ConnectionClosedPrematurely' exc);              }              finally              {                  registration.Dispose();              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ReceiveAsyncPrivate,The following statement contains a magic number: try              {                  while (true) // in case we get control frames that should be ignored from the user's perspective                  {                      // Get the last received header.  If its payload length is non-zero' that means we previously                      // received the header but were only able to read a part of the fragment' so we should skip                      // reading another header and just proceed to use that same header and read more data associated                      // with it.  If instead its payload length is zero' then we've completed the processing of                      // thta message' and we should read the next header.                      MessageHeader header = _lastReceiveHeader;                      if (header.PayloadLength == 0)                      {                          if (_receiveBufferCount < (_isServer ? (MaxMessageHeaderLength - MaskLength) : MaxMessageHeaderLength))                          {                              // Make sure we have the first two bytes' which includes the start of the payload length.                              if (_receiveBufferCount < 2)                              {                                  await EnsureBufferContainsAsync(2' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                              }                                // Then make sure we have the full header based on the payload length.                              // If this is the server' we also need room for the received mask.                              long payloadLength = _receiveBuffer.Span[_receiveBufferOffset + 1] & 0x7F;                              if (_isServer || payloadLength > 125)                              {                                  int minNeeded =                                      2 +                                      (_isServer ? MaskLength : 0) +                                      (payloadLength <= 125 ? 0 : payloadLength == 126 ? sizeof(ushort) : sizeof(ulong)); // additional 2 or 8 bytes for 16-bit or 64-bit length                                  await EnsureBufferContainsAsync(minNeeded' cancellationToken).ConfigureAwait(false);                              }                          }                            if (!TryParseMessageHeaderFromReceiveBuffer(out header))                          {                              await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                          }                          _receivedMaskOffsetOffset = 0;                      }                        // If the header represents a ping or a pong' it's a control message meant                      // to be transparent to the user' so handle it and then loop around to read again.                      // Alternatively' if it's a close message' handle it and exit.                      if (header.Opcode == MessageOpcode.Ping || header.Opcode == MessageOpcode.Pong)                      {                          await HandleReceivedPingPongAsync(header' cancellationToken).ConfigureAwait(false);                          continue;                      }                      else if (header.Opcode == MessageOpcode.Close)                      {                          await HandleReceivedCloseAsync(header' cancellationToken).ConfigureAwait(false);                          return resultGetter.GetResult(0' WebSocketMessageType.Close' true' _closeStatus' _closeStatusDescription);                      }                        // If this is a continuation' replace the opcode with the one of the message it's continuing                      if (header.Opcode == MessageOpcode.Continuation)                      {                          header.Opcode = _lastReceiveHeader.Opcode;                      }                        // The message should now be a binary or text message.  Handle it by reading the payload and returning the contents.                      Debug.Assert(header.Opcode == MessageOpcode.Binary || header.Opcode == MessageOpcode.Text' $"Unexpected opcode {header.Opcode}");                        // If there's no data to read' return an appropriate result.                      if (header.PayloadLength == 0 || payloadBuffer.Length == 0)                      {                          _lastReceiveHeader = header;                          return resultGetter.GetResult(                              0'                              header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                              header.Fin && header.PayloadLength == 0'                              null' null);                      }                        // Otherwise' read as much of the payload as we can efficiently' and upate the header to reflect how much data                      // remains for future reads.                      int bytesToCopy = Math.Min(payloadBuffer.Length' (int)Math.Min(header.PayloadLength' _receiveBuffer.Length));                      Debug.Assert(bytesToCopy > 0' $"Expected {nameof(bytesToCopy)} > 0");                      if (_receiveBufferCount < bytesToCopy)                      {                          await EnsureBufferContainsAsync(bytesToCopy' cancellationToken' throwOnPrematureClosure: true).ConfigureAwait(false);                      }                        if (_isServer)                      {                          _receivedMaskOffsetOffset = ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy)' header.Mask' _receivedMaskOffsetOffset);                      }                      _receiveBuffer.Span.Slice(_receiveBufferOffset' bytesToCopy).CopyTo(payloadBuffer.Span.Slice(0' bytesToCopy));                      ConsumeFromBuffer(bytesToCopy);                      header.PayloadLength -= bytesToCopy;                        // If this a text message' validate that it contains valid UTF8.                      if (header.Opcode == MessageOpcode.Text &&                          !TryValidateUtf8(payloadBuffer.Span.Slice(0' bytesToCopy)' header.Fin' _utf8TextState))                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.InvalidPayloadData' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                      }                        _lastReceiveHeader = header;                      return resultGetter.GetResult(                          bytesToCopy'                          header.Opcode == MessageOpcode.Text ? WebSocketMessageType.Text : WebSocketMessageType.Binary'                          header.Fin && header.PayloadLength == 0'                          null' null);                  }              }              catch (Exception exc)              {                  if (_state == WebSocketState.Aborted)                  {                      throw new OperationCanceledException(nameof(WebSocketState.Aborted)' exc);                  }                  throw new WebSocketException(WebSocketError.ConnectionClosedPrematurely' exc);              }              finally              {                  registration.Dispose();              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The following statement contains a magic number: if (header.PayloadLength == 1)              {                  // The close payload length can be 0 or >= 2' but not 1.                  await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);              }              else if (header.PayloadLength >= 2)              {                  if (_receiveBufferCount < header.PayloadLength)                  {                      await EnsureBufferContainsAsync((int)header.PayloadLength' cancellationToken).ConfigureAwait(false);                  }                    if (_isServer)                  {                      ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' (int)header.PayloadLength)' header.Mask' 0);                  }                    closeStatus = (WebSocketCloseStatus)(_receiveBuffer.Span[_receiveBufferOffset] << 8 | _receiveBuffer.Span[_receiveBufferOffset + 1]);                  if (!IsValidCloseStatus(closeStatus))                  {                      await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                  }                    if (header.PayloadLength > 2)                  {                      try                      {                          closeStatusDescription = s_textEncoding.GetString(_receiveBuffer.Span.Slice(_receiveBufferOffset + 2' (int)header.PayloadLength - 2));                      }                      catch (DecoderFallbackException exc)                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken' exc).ConfigureAwait(false);                      }                  }                  ConsumeFromBuffer((int)header.PayloadLength);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The following statement contains a magic number: if (header.PayloadLength == 1)              {                  // The close payload length can be 0 or >= 2' but not 1.                  await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);              }              else if (header.PayloadLength >= 2)              {                  if (_receiveBufferCount < header.PayloadLength)                  {                      await EnsureBufferContainsAsync((int)header.PayloadLength' cancellationToken).ConfigureAwait(false);                  }                    if (_isServer)                  {                      ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' (int)header.PayloadLength)' header.Mask' 0);                  }                    closeStatus = (WebSocketCloseStatus)(_receiveBuffer.Span[_receiveBufferOffset] << 8 | _receiveBuffer.Span[_receiveBufferOffset + 1]);                  if (!IsValidCloseStatus(closeStatus))                  {                      await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                  }                    if (header.PayloadLength > 2)                  {                      try                      {                          closeStatusDescription = s_textEncoding.GetString(_receiveBuffer.Span.Slice(_receiveBufferOffset + 2' (int)header.PayloadLength - 2));                      }                      catch (DecoderFallbackException exc)                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken' exc).ConfigureAwait(false);                      }                  }                  ConsumeFromBuffer((int)header.PayloadLength);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The following statement contains a magic number: if (header.PayloadLength == 1)              {                  // The close payload length can be 0 or >= 2' but not 1.                  await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);              }              else if (header.PayloadLength >= 2)              {                  if (_receiveBufferCount < header.PayloadLength)                  {                      await EnsureBufferContainsAsync((int)header.PayloadLength' cancellationToken).ConfigureAwait(false);                  }                    if (_isServer)                  {                      ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' (int)header.PayloadLength)' header.Mask' 0);                  }                    closeStatus = (WebSocketCloseStatus)(_receiveBuffer.Span[_receiveBufferOffset] << 8 | _receiveBuffer.Span[_receiveBufferOffset + 1]);                  if (!IsValidCloseStatus(closeStatus))                  {                      await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                  }                    if (header.PayloadLength > 2)                  {                      try                      {                          closeStatusDescription = s_textEncoding.GetString(_receiveBuffer.Span.Slice(_receiveBufferOffset + 2' (int)header.PayloadLength - 2));                      }                      catch (DecoderFallbackException exc)                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken' exc).ConfigureAwait(false);                      }                  }                  ConsumeFromBuffer((int)header.PayloadLength);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The following statement contains a magic number: if (header.PayloadLength == 1)              {                  // The close payload length can be 0 or >= 2' but not 1.                  await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);              }              else if (header.PayloadLength >= 2)              {                  if (_receiveBufferCount < header.PayloadLength)                  {                      await EnsureBufferContainsAsync((int)header.PayloadLength' cancellationToken).ConfigureAwait(false);                  }                    if (_isServer)                  {                      ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' (int)header.PayloadLength)' header.Mask' 0);                  }                    closeStatus = (WebSocketCloseStatus)(_receiveBuffer.Span[_receiveBufferOffset] << 8 | _receiveBuffer.Span[_receiveBufferOffset + 1]);                  if (!IsValidCloseStatus(closeStatus))                  {                      await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                  }                    if (header.PayloadLength > 2)                  {                      try                      {                          closeStatusDescription = s_textEncoding.GetString(_receiveBuffer.Span.Slice(_receiveBufferOffset + 2' (int)header.PayloadLength - 2));                      }                      catch (DecoderFallbackException exc)                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken' exc).ConfigureAwait(false);                      }                  }                  ConsumeFromBuffer((int)header.PayloadLength);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,HandleReceivedCloseAsync,The following statement contains a magic number: if (header.PayloadLength == 1)              {                  // The close payload length can be 0 or >= 2' but not 1.                  await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);              }              else if (header.PayloadLength >= 2)              {                  if (_receiveBufferCount < header.PayloadLength)                  {                      await EnsureBufferContainsAsync((int)header.PayloadLength' cancellationToken).ConfigureAwait(false);                  }                    if (_isServer)                  {                      ApplyMask(_receiveBuffer.Span.Slice(_receiveBufferOffset' (int)header.PayloadLength)' header.Mask' 0);                  }                    closeStatus = (WebSocketCloseStatus)(_receiveBuffer.Span[_receiveBufferOffset] << 8 | _receiveBuffer.Span[_receiveBufferOffset + 1]);                  if (!IsValidCloseStatus(closeStatus))                  {                      await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken).ConfigureAwait(false);                  }                    if (header.PayloadLength > 2)                  {                      try                      {                          closeStatusDescription = s_textEncoding.GetString(_receiveBuffer.Span.Slice(_receiveBufferOffset + 2' (int)header.PayloadLength - 2));                      }                      catch (DecoderFallbackException exc)                      {                          await CloseWithReceiveErrorAndThrowAsync(WebSocketCloseStatus.ProtocolError' WebSocketError.Faulted' cancellationToken' exc).ConfigureAwait(false);                      }                  }                  ConsumeFromBuffer((int)header.PayloadLength);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,IsValidCloseStatus,The following statement contains a magic number: if (closeStatus < (WebSocketCloseStatus)1000 || closeStatus >= (WebSocketCloseStatus)5000)              {                  return false;              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,IsValidCloseStatus,The following statement contains a magic number: if (closeStatus < (WebSocketCloseStatus)1000 || closeStatus >= (WebSocketCloseStatus)5000)              {                  return false;              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,IsValidCloseStatus,The following statement contains a magic number: if (closeStatus >= (WebSocketCloseStatus)3000)              {                  return true;              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: Debug.Assert(_receiveBufferCount >= 2' $"Expected to at least have the first two bytes of the header.");
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: ConsumeFromBuffer(2);
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (header.PayloadLength == 126)              {                  Debug.Assert(_receiveBufferCount >= 2' $"Expected to have two bytes for the payload length.");                  header.PayloadLength = (receiveBufferSpan[_receiveBufferOffset] << 8) | receiveBufferSpan[_receiveBufferOffset + 1];                  ConsumeFromBuffer(2);              }              else if (header.PayloadLength == 127)              {                  Debug.Assert(_receiveBufferCount >= 8' $"Expected to have eight bytes for the payload length.");                  header.PayloadLength = 0;                  for (int i = 0; i < 8; i++)                  {                      header.PayloadLength = (header.PayloadLength << 8) | receiveBufferSpan[_receiveBufferOffset + i];                  }                  ConsumeFromBuffer(8);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryParseMessageHeaderFromReceiveBuffer,The following statement contains a magic number: if (masked)              {                  if (!_isServer)                  {                      shouldFail = true;                  }                  header.Mask = CombineMaskBytes(receiveBufferSpan' _receiveBufferOffset);                    // Consume the mask bytes                  ConsumeFromBuffer(4);              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendCloseFrameAsync,The following statement contains a magic number: try              {                  int count = 2;                  if (string.IsNullOrEmpty(closeStatusDescription))                  {                      buffer = ArrayPool<byte>.Shared.Rent(count);                  }                  else                  {                      count += s_textEncoding.GetByteCount(closeStatusDescription);                      buffer = ArrayPool<byte>.Shared.Rent(count);                      int encodedLength = s_textEncoding.GetBytes(closeStatusDescription' 0' closeStatusDescription.Length' buffer' 2);                      Debug.Assert(count - 2 == encodedLength' $"GetByteCount and GetBytes encoded count didn't match");                  }                    ushort closeStatusValue = (ushort)closeStatus;                  buffer[0] = (byte)(closeStatusValue >> 8);                  buffer[1] = (byte)(closeStatusValue & 0xFF);                    await SendFrameAsync(MessageOpcode.Close' true' new Memory<byte>(buffer' 0' count)' cancellationToken).ConfigureAwait(false);              }              finally              {                  if (buffer != null)                  {                      ArrayPool<byte>.Shared.Return(buffer);                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendCloseFrameAsync,The following statement contains a magic number: try              {                  int count = 2;                  if (string.IsNullOrEmpty(closeStatusDescription))                  {                      buffer = ArrayPool<byte>.Shared.Rent(count);                  }                  else                  {                      count += s_textEncoding.GetByteCount(closeStatusDescription);                      buffer = ArrayPool<byte>.Shared.Rent(count);                      int encodedLength = s_textEncoding.GetBytes(closeStatusDescription' 0' closeStatusDescription.Length' buffer' 2);                      Debug.Assert(count - 2 == encodedLength' $"GetByteCount and GetBytes encoded count didn't match");                  }                    ushort closeStatusValue = (ushort)closeStatus;                  buffer[0] = (byte)(closeStatusValue >> 8);                  buffer[1] = (byte)(closeStatusValue & 0xFF);                    await SendFrameAsync(MessageOpcode.Close' true' new Memory<byte>(buffer' 0' count)' cancellationToken).ConfigureAwait(false);              }              finally              {                  if (buffer != null)                  {                      ArrayPool<byte>.Shared.Return(buffer);                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendCloseFrameAsync,The following statement contains a magic number: try              {                  int count = 2;                  if (string.IsNullOrEmpty(closeStatusDescription))                  {                      buffer = ArrayPool<byte>.Shared.Rent(count);                  }                  else                  {                      count += s_textEncoding.GetByteCount(closeStatusDescription);                      buffer = ArrayPool<byte>.Shared.Rent(count);                      int encodedLength = s_textEncoding.GetBytes(closeStatusDescription' 0' closeStatusDescription.Length' buffer' 2);                      Debug.Assert(count - 2 == encodedLength' $"GetByteCount and GetBytes encoded count didn't match");                  }                    ushort closeStatusValue = (ushort)closeStatus;                  buffer[0] = (byte)(closeStatusValue >> 8);                  buffer[1] = (byte)(closeStatusValue & 0xFF);                    await SendFrameAsync(MessageOpcode.Close' true' new Memory<byte>(buffer' 0' count)' cancellationToken).ConfigureAwait(false);              }              finally              {                  if (buffer != null)                  {                      ArrayPool<byte>.Shared.Return(buffer);                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,SendCloseFrameAsync,The following statement contains a magic number: try              {                  int count = 2;                  if (string.IsNullOrEmpty(closeStatusDescription))                  {                      buffer = ArrayPool<byte>.Shared.Rent(count);                  }                  else                  {                      count += s_textEncoding.GetByteCount(closeStatusDescription);                      buffer = ArrayPool<byte>.Shared.Rent(count);                      int encodedLength = s_textEncoding.GetBytes(closeStatusDescription' 0' closeStatusDescription.Length' buffer' 2);                      Debug.Assert(count - 2 == encodedLength' $"GetByteCount and GetBytes encoded count didn't match");                  }                    ushort closeStatusValue = (ushort)closeStatus;                  buffer[0] = (byte)(closeStatusValue >> 8);                  buffer[1] = (byte)(closeStatusValue & 0xFF);                    await SendFrameAsync(MessageOpcode.Close' true' new Memory<byte>(buffer' 0' count)' cancellationToken).ConfigureAwait(false);              }              finally              {                  if (buffer != null)                  {                      ArrayPool<byte>.Shared.Return(buffer);                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ApplyMask,The following statement contains a magic number: int maskShift = maskIndex * 8;
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ApplyMask,The following statement contains a magic number: int shiftedMask = (int)(((uint)mask >> maskShift) | ((uint)mask << (32 - maskShift)));
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,ApplyMask,The following statement contains a magic number: if (count > 0)              {                  fixed (byte* toMaskPtr = &toMask.DangerousGetPinnableReference())                  {                      byte* p = toMaskPtr;                        // Try to go an int at a time if the remaining data is 4-byte aligned and there's enough remaining.                      if (((long)p % sizeof(int)) == 0)                      {                          while (count >= sizeof(int))                          {                              count -= sizeof(int);                              *((int*)p) ^= shiftedMask;                              p += sizeof(int);                          }                            // We don't need to update the maskIndex' as its mod-4 value won't have changed.                          // `p` points to the remainder.                      }                        // Process any remaining data a byte at a time.                      if (count > 0)                      {                          byte* maskPtr = (byte*)&mask;                          byte* end = p + count;                          while (p < end)                          {                              *p++ ^= maskPtr[maskIndex];                              maskIndex = (maskIndex + 1) & 3;                          }                      }                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryValidateUtf8,The following statement contains a magic number: for (int i = 0; i < span.Length;)              {                  // Have we started a character sequence yet?                  if (!state.SequenceInProgress)                  {                      // The first byte tells us how many bytes are in the sequence.                      state.SequenceInProgress = true;                      byte b = span[i];                      i++;                      if ((b & 0x80) == 0) // 0bbbbbbb' single byte                      {                          state.AdditionalBytesExpected = 0;                          state.CurrentDecodeBits = b & 0x7F;                          state.ExpectedValueMin = 0;                      }                      else if ((b & 0xC0) == 0x80)                      {                          // Misplaced 10bbbbbb continuation byte. This cannot be the first byte.                          return false;                      }                      else if ((b & 0xE0) == 0xC0) // 110bbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 1;                          state.CurrentDecodeBits = b & 0x1F;                          state.ExpectedValueMin = 0x80;                      }                      else if ((b & 0xF0) == 0xE0) // 1110bbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 2;                          state.CurrentDecodeBits = b & 0xF;                          state.ExpectedValueMin = 0x800;                      }                      else if ((b & 0xF8) == 0xF0) // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 3;                          state.CurrentDecodeBits = b & 0x7;                          state.ExpectedValueMin = 0x10000;                      }                      else // 111110bb & 1111110b & 11111110 && 11111111 are not valid                      {                          return false;                      }                  }                  while (state.AdditionalBytesExpected > 0 && i < span.Length)                  {                      byte b = span[i];                      if ((b & 0xC0) != 0x80)                      {                          return false;                      }                        i++;                      state.AdditionalBytesExpected--;                        // Each continuation byte carries 6 bits of data 0x10bbbbbb.                      state.CurrentDecodeBits = (state.CurrentDecodeBits << 6) | (b & 0x3F);                        if (state.AdditionalBytesExpected == 1 && state.CurrentDecodeBits >= 0x360 && state.CurrentDecodeBits <= 0x37F)                      {                          // This is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that are not allowed in UTF-8;                          return false;                      }                      if (state.AdditionalBytesExpected == 2 && state.CurrentDecodeBits >= 0x110)                      {                          // This is going to be out of the upper Unicode bound 0x10FFFF.                          return false;                      }                  }                  if (state.AdditionalBytesExpected == 0)                  {                      state.SequenceInProgress = false;                      if (state.CurrentDecodeBits < state.ExpectedValueMin)                      {                          // Overlong encoding (e.g. using 2 bytes to encode something that only needed 1).                          return false;                      }                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryValidateUtf8,The following statement contains a magic number: for (int i = 0; i < span.Length;)              {                  // Have we started a character sequence yet?                  if (!state.SequenceInProgress)                  {                      // The first byte tells us how many bytes are in the sequence.                      state.SequenceInProgress = true;                      byte b = span[i];                      i++;                      if ((b & 0x80) == 0) // 0bbbbbbb' single byte                      {                          state.AdditionalBytesExpected = 0;                          state.CurrentDecodeBits = b & 0x7F;                          state.ExpectedValueMin = 0;                      }                      else if ((b & 0xC0) == 0x80)                      {                          // Misplaced 10bbbbbb continuation byte. This cannot be the first byte.                          return false;                      }                      else if ((b & 0xE0) == 0xC0) // 110bbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 1;                          state.CurrentDecodeBits = b & 0x1F;                          state.ExpectedValueMin = 0x80;                      }                      else if ((b & 0xF0) == 0xE0) // 1110bbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 2;                          state.CurrentDecodeBits = b & 0xF;                          state.ExpectedValueMin = 0x800;                      }                      else if ((b & 0xF8) == 0xF0) // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 3;                          state.CurrentDecodeBits = b & 0x7;                          state.ExpectedValueMin = 0x10000;                      }                      else // 111110bb & 1111110b & 11111110 && 11111111 are not valid                      {                          return false;                      }                  }                  while (state.AdditionalBytesExpected > 0 && i < span.Length)                  {                      byte b = span[i];                      if ((b & 0xC0) != 0x80)                      {                          return false;                      }                        i++;                      state.AdditionalBytesExpected--;                        // Each continuation byte carries 6 bits of data 0x10bbbbbb.                      state.CurrentDecodeBits = (state.CurrentDecodeBits << 6) | (b & 0x3F);                        if (state.AdditionalBytesExpected == 1 && state.CurrentDecodeBits >= 0x360 && state.CurrentDecodeBits <= 0x37F)                      {                          // This is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that are not allowed in UTF-8;                          return false;                      }                      if (state.AdditionalBytesExpected == 2 && state.CurrentDecodeBits >= 0x110)                      {                          // This is going to be out of the upper Unicode bound 0x10FFFF.                          return false;                      }                  }                  if (state.AdditionalBytesExpected == 0)                  {                      state.SequenceInProgress = false;                      if (state.CurrentDecodeBits < state.ExpectedValueMin)                      {                          // Overlong encoding (e.g. using 2 bytes to encode something that only needed 1).                          return false;                      }                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryValidateUtf8,The following statement contains a magic number: for (int i = 0; i < span.Length;)              {                  // Have we started a character sequence yet?                  if (!state.SequenceInProgress)                  {                      // The first byte tells us how many bytes are in the sequence.                      state.SequenceInProgress = true;                      byte b = span[i];                      i++;                      if ((b & 0x80) == 0) // 0bbbbbbb' single byte                      {                          state.AdditionalBytesExpected = 0;                          state.CurrentDecodeBits = b & 0x7F;                          state.ExpectedValueMin = 0;                      }                      else if ((b & 0xC0) == 0x80)                      {                          // Misplaced 10bbbbbb continuation byte. This cannot be the first byte.                          return false;                      }                      else if ((b & 0xE0) == 0xC0) // 110bbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 1;                          state.CurrentDecodeBits = b & 0x1F;                          state.ExpectedValueMin = 0x80;                      }                      else if ((b & 0xF0) == 0xE0) // 1110bbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 2;                          state.CurrentDecodeBits = b & 0xF;                          state.ExpectedValueMin = 0x800;                      }                      else if ((b & 0xF8) == 0xF0) // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 3;                          state.CurrentDecodeBits = b & 0x7;                          state.ExpectedValueMin = 0x10000;                      }                      else // 111110bb & 1111110b & 11111110 && 11111111 are not valid                      {                          return false;                      }                  }                  while (state.AdditionalBytesExpected > 0 && i < span.Length)                  {                      byte b = span[i];                      if ((b & 0xC0) != 0x80)                      {                          return false;                      }                        i++;                      state.AdditionalBytesExpected--;                        // Each continuation byte carries 6 bits of data 0x10bbbbbb.                      state.CurrentDecodeBits = (state.CurrentDecodeBits << 6) | (b & 0x3F);                        if (state.AdditionalBytesExpected == 1 && state.CurrentDecodeBits >= 0x360 && state.CurrentDecodeBits <= 0x37F)                      {                          // This is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that are not allowed in UTF-8;                          return false;                      }                      if (state.AdditionalBytesExpected == 2 && state.CurrentDecodeBits >= 0x110)                      {                          // This is going to be out of the upper Unicode bound 0x10FFFF.                          return false;                      }                  }                  if (state.AdditionalBytesExpected == 0)                  {                      state.SequenceInProgress = false;                      if (state.CurrentDecodeBits < state.ExpectedValueMin)                      {                          // Overlong encoding (e.g. using 2 bytes to encode something that only needed 1).                          return false;                      }                  }              }
Magic Number,System.Net.WebSockets,ManagedWebSocket,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ManagedWebSocket.cs,TryValidateUtf8,The following statement contains a magic number: for (int i = 0; i < span.Length;)              {                  // Have we started a character sequence yet?                  if (!state.SequenceInProgress)                  {                      // The first byte tells us how many bytes are in the sequence.                      state.SequenceInProgress = true;                      byte b = span[i];                      i++;                      if ((b & 0x80) == 0) // 0bbbbbbb' single byte                      {                          state.AdditionalBytesExpected = 0;                          state.CurrentDecodeBits = b & 0x7F;                          state.ExpectedValueMin = 0;                      }                      else if ((b & 0xC0) == 0x80)                      {                          // Misplaced 10bbbbbb continuation byte. This cannot be the first byte.                          return false;                      }                      else if ((b & 0xE0) == 0xC0) // 110bbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 1;                          state.CurrentDecodeBits = b & 0x1F;                          state.ExpectedValueMin = 0x80;                      }                      else if ((b & 0xF0) == 0xE0) // 1110bbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 2;                          state.CurrentDecodeBits = b & 0xF;                          state.ExpectedValueMin = 0x800;                      }                      else if ((b & 0xF8) == 0xF0) // 11110bbb 10bbbbbb 10bbbbbb 10bbbbbb                      {                          state.AdditionalBytesExpected = 3;                          state.CurrentDecodeBits = b & 0x7;                          state.ExpectedValueMin = 0x10000;                      }                      else // 111110bb & 1111110b & 11111110 && 11111111 are not valid                      {                          return false;                      }                  }                  while (state.AdditionalBytesExpected > 0 && i < span.Length)                  {                      byte b = span[i];                      if ((b & 0xC0) != 0x80)                      {                          return false;                      }                        i++;                      state.AdditionalBytesExpected--;                        // Each continuation byte carries 6 bits of data 0x10bbbbbb.                      state.CurrentDecodeBits = (state.CurrentDecodeBits << 6) | (b & 0x3F);                        if (state.AdditionalBytesExpected == 1 && state.CurrentDecodeBits >= 0x360 && state.CurrentDecodeBits <= 0x37F)                      {                          // This is going to end up in the range of 0xD800-0xDFFF UTF-16 surrogates that are not allowed in UTF-8;                          return false;                      }                      if (state.AdditionalBytesExpected == 2 && state.CurrentDecodeBits >= 0x110)                      {                          // This is going to be out of the upper Unicode bound 0x10FFFF.                          return false;                      }                  }                  if (state.AdditionalBytesExpected == 0)                  {                      state.SequenceInProgress = false;                      if (state.CurrentDecodeBits < state.ExpectedValueMin)                      {                          // Overlong encoding (e.g. using 2 bytes to encode something that only needed 1).                          return false;                      }                  }              }
Magic Number,System.Net.WebSockets,ValueWebSocketReceiveResult,C:\selectedRepos\dotnet_corefx\src\System.Net.WebSockets\src\System\Net\WebSockets\ValueWebSocketReceiveResult.cs,ValueWebSocketReceiveResult,The following statement contains a magic number: _countAndEndOfMessage = (uint)count | (uint)(endOfMessage ? 1 << 31 : 0);
