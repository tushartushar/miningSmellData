Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadAsyncInternal,The method has 139 lines of code.
Long Method,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,Write,The method has 120 lines of code.
Long Method,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Insert,The method has 100 lines of code.
Complex Method,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadSpan,Cyclomatic complexity of the method is 8
Complex Method,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadAsyncInternal,Cyclomatic complexity of the method is 9
Complex Method,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsyncInternal,Cyclomatic complexity of the method is 8
Complex Method,System.IO,StringReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StringReader.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,ReadAsync,Cyclomatic complexity of the method is 8
Complex Method,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,Write,Cyclomatic complexity of the method is 8
Complex Method,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlDecode,Cyclomatic complexity of the method is 9
Complex Method,System.Runtime.Versioning,FrameworkName,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Runtime\Versioning\FrameworkName.cs,FrameworkName,Cyclomatic complexity of the method is 10
Complex Method,System.Runtime.Versioning,VersioningHelper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Runtime\Versioning\VersioningHelper.cs,MakeVersionSafeName,Cyclomatic complexity of the method is 8
Complex Method,System.Collections,IListWrapper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,CopyTo,Cyclomatic complexity of the method is 8
Complex Method,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,OnDeserialization,Cyclomatic complexity of the method is 11
Complex Method,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,Equal,Cyclomatic complexity of the method is 8
Long Parameter List,System,ApplicationId,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\ApplicationId.cs,ApplicationId,The method has 5 parameters. Parameters: publicKeyToken' name' version' processorArchitecture' culture
Long Parameter List,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The method has 5 parameters. Parameters: stream' encoding' detectEncodingFromByteOrderMarks' bufferSize' leaveOpen
Long Parameter List,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,Init,The method has 5 parameters. Parameters: stream' encoding' detectEncodingFromByteOrderMarks' bufferSize' leaveOpen
Long Parameter List,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsyncInternal,The method has 8 parameters. Parameters: _this' value' charBuffer' charPos' charLen' coreNewLine' autoFlush' appendNewLine
Long Parameter List,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsyncInternal,The method has 8 parameters. Parameters: _this' value' charBuffer' charPos' charLen' coreNewLine' autoFlush' appendNewLine
Long Parameter List,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsyncInternal,The method has 9 parameters. Parameters: _this' source' charBuffer' charPos' charLen' coreNewLine' autoFlush' appendNewLine' cancellationToken
Long Parameter List,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,FlushAsyncInternal,The method has 5 parameters. Parameters: flushStream' flushEncoder' sCharBuffer' sCharPos' cancellationToken
Long Parameter List,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,FlushAsyncInternal,The method has 11 parameters. Parameters: _this' flushStream' flushEncoder' charBuffer' charPos' haveWrittenPreamble' encoding' encoder' byteBuffer' stream' cancellationToken
Long Parameter List,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,BeginRead,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Parameter List,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,BeginWrite,The method has 5 parameters. Parameters: buffer' offset' count' callback' state
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_ASSEMBLY_PUBLIC_KEY_MISMATCH is 39.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_ASSEMBLY_VERSION_TOO_LOW is 35.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter CLR_E_BIND_UNRECOGNIZED_IDENTITY_FORMAT is 39.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_INSUFFICIENTEXECUTIONSTACK is 32.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_LOADING_REFERENCE_ASSEMBLY is 32.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_MISSINGSATELLITEASSEMBLY is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_MODULE_HASH_CHECK_FAILED is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter COR_E_WAITHANDLECANNOTBEOPENED is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_CODE_DOWNLOAD_DISABLED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_HOST_GAC_ASM_MISMATCH is 30.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_INVALID_PRIVATE_ASM_LOCATION is 37.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_PRIVATE_ASM_DISALLOWED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter FUSION_E_SIGNATURE_CHECK_FAILED is 31.
Long Identifier,System,HResults,C:\selectedRepos\dotnet_corefx\src\Common\src\System\HResults.cs,,The length of the parameter SECURITY_E_INCOMPATIBLE_EVIDENCE is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,StreamReader,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Identifier,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,Init,The length of the parameter detectEncodingFromByteOrderMarks is 32.
Long Statement,System,AppDomain,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\AppDomain.cs,ExecuteAssembly,The length of the statement  "            throw new PlatformNotSupportedException(SR.PlatformNotSupported_CAS); // This api is only meaningful for very specific partial trust/CAS scenarios " is 146.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,CompressBuffer,The length of the statement  "            Debug.Assert(_byteLen >= n' "CompressBuffer was called with a number of bytes greater than the current buffer length.  Are two threads using this StreamReader at the same time?"); " is 179.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,IsPreamble,The length of the statement  "            Debug.Assert(_bytePos <= preamble.Length' "_compressPreamble was called with the current bytePos greater than the preamble buffer length.  Are two threads using this StreamReader at the same time?"); " is 199.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,IsPreamble,The length of the statement  "            Debug.Assert(_bytePos <= preamble.Length' "possible bug in _compressPreamble.  Are two threads using this StreamReader at the same time?"); " is 139.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The length of the statement  "                    Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble.  Are two threads using this StreamReader at the same time?"); " is 149.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The length of the statement  "                    Debug.Assert(_bytePos == 0' "bytePos can be non zero only when we are trying to _checkPreamble.  Are two threads using this StreamReader at the same time?"); " is 157.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The length of the statement  "                    Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble.  Are two threads using this StreamReader at the same time?"); " is 149.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The length of the statement  "                                charsRead = _decoder.GetChars(new ReadOnlySpan<byte>(_byteBuffer' 0' _byteLen)' userBuffer.Slice(charsRead)' flush: false); " is 123.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The length of the statement  "                    Debug.Assert(_bytePos == 0' "bytePos can be non zero only when we are trying to _checkPreamble.  Are two threads using this StreamReader at the same time?"); " is 157.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The length of the statement  "                    charsRead += _decoder.GetChars(new ReadOnlySpan<byte>(_byteBuffer' 0' _byteLen)' userBuffer.Slice(charsRead)' flush:false); " is 123.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadAsyncInternal,The length of the statement  "                            Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble.  Are two threads using this StreamReader at the same time?"); " is 149.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadAsyncInternal,The length of the statement  "                            int len = await tmpStream.ReadAsync(tmpByteBuffer' tmpBytePos' tmpByteBuffer.Length - tmpBytePos' cancellationToken).ConfigureAwait(false); " is 139.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadAsyncInternal,The length of the statement  "                            Debug.Assert(_bytePos == 0' "_bytePos can be non zero only when we are trying to _checkPreamble.  Are two threads using this StreamReader at the same time?"); " is 158.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBufferAsync,The length of the statement  "                    Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble. Are two threads using this StreamReader at the same time?"); " is 148.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBufferAsync,The length of the statement  "                    int len = await tmpStream.ReadAsync(tmpByteBuffer' tmpBytePos' tmpByteBuffer.Length - tmpBytePos).ConfigureAwait(false); " is 120.
Long Statement,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBufferAsync,The length of the statement  "                    Debug.Assert(_bytePos == 0' "_bytePos can be non zero only when we are trying to _checkPreamble. Are two threads using this StreamReader at the same time?"); " is 157.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' value' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: false); " is 124.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsync,The length of the statement  "                Task task = WriteAsyncInternal(this' value' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: false); " is 124.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsyncInternal,The length of the statement  "                Debug.Assert(n > 0' "StreamWriter::Write(String) isn't making progress!  This is most likely a race condition in user code."); " is 126.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' new ReadOnlyMemory<char>(buffer' index' count)' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: false' cancellationToken: default); " is 193.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' buffer' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: false' cancellationToken: cancellationToken); " is 163.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteAsyncInternal,The length of the statement  "                Debug.Assert(n > 0' "StreamWriter::Write(char[]' int' int) isn't making progress!  This is most likely a race condition in user code."); " is 136.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteLineAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' ReadOnlyMemory<char>.Empty' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: true' cancellationToken: default); " is 172.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteLineAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' value' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: true); " is 123.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteLineAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' value' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: true); " is 123.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteLineAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' new ReadOnlyMemory<char>(buffer' index' count)' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: true' cancellationToken: default); " is 192.
Long Statement,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteLineAsync,The length of the statement  "            Task task = WriteAsyncInternal(this' buffer' _charBuffer' _charPos' _charLen' CoreNewLine' _autoFlush' appendNewLine: true' cancellationToken: cancellationToken); " is 162.
Long Statement,System.IO,SyncTextReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\TextReader.cs,ReadBlockAsync,The length of the statement  "                    throw new ArgumentOutOfRangeException((index < 0 ? nameof(index) : nameof(count))' SR.ArgumentOutOfRange_NeedNonNegNum); " is 120.
Long Statement,System.IO,SyncTextReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\TextReader.cs,ReadAsync,The length of the statement  "                    throw new ArgumentOutOfRangeException((index < 0 ? nameof(index) : nameof(count))' SR.ArgumentOutOfRange_NeedNonNegNum); " is 120.
Long Statement,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,Flush,The length of the statement  "                // However' if we do not forward the Flush to the underlying stream' we may have problems when chaining several streams. " is 120.
Long Statement,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,FlushAsyncInternal,The length of the statement  "                    // However' if we do not forward the Flush to the underlying stream' we may have problems when chaining several streams. " is 120.
Long Statement,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,FlushWrite,The length of the statement  "                            "BufferedStream: Write buffer must be allocated and write position must be in the bounds of the buffer in FlushWrite!"); " is 120.
Long Statement,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,FlushWriteAsync,The length of the statement  "                            "BufferedStream: Write buffer must be allocated and write position must be in the bounds of the buffer in FlushWrite!"); " is 120.
Long Statement,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,ReadAsync,The length of the statement  "            return ReadFromUnderlyingStreamAsync(destination.Slice(bytesFromBuffer)' cancellationToken' bytesFromBuffer' semaphoreLockTask); " is 128.
Long Statement,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,WriteByte,The length of the statement  "            // We should not be flushing here' but only writing to the underlying stream' but previous version flushed' so we keep this. " is 124.
Long Statement,System.IO,BufferedStream,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\BufferedStream.cs,Seek,The length of the statement  "            // If the seek destination is still within the data currently in the buffer' we want to keep the buffer data and continue using it. " is 131.
Long Statement,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlDecode,The length of the statement  "                                parsedSuccessfully = uint.TryParse(value.Substring(entityOffset + 2' entityLength - 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out parsedValue); " is 167.
Long Statement,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlDecode,The length of the statement  "                                parsedSuccessfully = uint.TryParse(value.Substring(entityOffset + 1' entityLength - 1)' NumberStyles.Integer' CultureInfo.InvariantCulture' out parsedValue); " is 157.
Long Statement,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlDecode,The length of the statement  "                                parsedSuccessfully = ((parsedValue < HIGH_SURROGATE_START) || (LOW_SURROGATE_END < parsedValue && parsedValue <= UNICODE_PLANE16_END)); " is 135.
Long Statement,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,GetNextUnicodeScalarValueFromUtf16Surrogate,The length of the statement  "                return (((leadingSurrogate - HIGH_SURROGATE_START) * 0x400) + (trailingSurrogate - LOW_SURROGATE_START) + UNICODE_PLANE01_START); " is 129.
Long Statement,System.Runtime.Versioning,VersioningHelper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Runtime\Versioning\VersioningHelper.cs,GetRequirements,The length of the statement  "                            throw new ArgumentException(SR.Format(SR.Argument_BadResourceScopeVisibilityBits' consumeAsScope)' nameof(consumeAsScope)); " is 123.
Long Statement,System.Runtime.Versioning,VersioningHelper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Runtime\Versioning\VersioningHelper.cs,GetRequirements,The length of the statement  "                Debug.Assert(requires == SxSRequirements.None' "Computed a strange set of required resource scoping.  It's probably wrong."); " is 125.
Long Statement,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,Clear,The length of the statement  "                Array.Clear(_items' 0' _size); // Don't need to doc this but we clear the elements so that the gc can reclaim the references. " is 125.
Long Statement,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,IndexOf,The length of the statement  "            if (count < 0 || startIndex > _size - count) throw new ArgumentOutOfRangeException(nameof(count)' SR.ArgumentOutOfRange_Count); " is 127.
Long Statement,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,Insert,The length of the statement  "            if (index < 0 || index > _size) throw new ArgumentOutOfRangeException(nameof(index)' SR.ArgumentOutOfRange_ArrayListInsert); " is 124.
Long Statement,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,LastIndexOf,The length of the statement  "                throw new ArgumentOutOfRangeException(startIndex < 0 ? nameof(startIndex) : nameof(count)' SR.ArgumentOutOfRange_NeedNonNegNum); " is 128.
Long Statement,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,LastIndexOf,The length of the statement  "                throw new ArgumentOutOfRangeException(startIndex >= _size ? nameof(startIndex) : nameof(count)' SR.ArgumentOutOfRange_BiggerThanCollection); " is 140.
Long Statement,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,SetRange,The length of the statement  "            if (index < 0 || index > _size - count) throw new ArgumentOutOfRangeException(nameof(index)' SR.ArgumentOutOfRange_Index); " is 122.
Long Statement,System.Collections,IListWrapper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,CopyTo,The length of the statement  "                    throw new ArgumentOutOfRangeException(index < 0 ? nameof(index) : nameof(arrayIndex)' SR.ArgumentOutOfRange_NeedNonNegNum); " is 123.
Long Statement,System.Collections,IListWrapper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,IndexOf,The length of the statement  "                if (startIndex < 0 || startIndex > Count) throw new ArgumentOutOfRangeException(nameof(startIndex)' SR.ArgumentOutOfRange_Index); " is 129.
Long Statement,System.Collections,IListWrapper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,IndexOf,The length of the statement  "                if (count < 0 || startIndex > Count - count) throw new ArgumentOutOfRangeException(nameof(count)' SR.ArgumentOutOfRange_Count); " is 127.
Long Statement,System.Collections,IListWrapper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,LastIndexOf,The length of the statement  "                if (startIndex < 0 || startIndex >= _list.Count) throw new ArgumentOutOfRangeException(nameof(startIndex)' SR.ArgumentOutOfRange_Index); " is 136.
Long Statement,System.Collections,IListWrapper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,LastIndexOf,The length of the statement  "                if (count < 0 || count > startIndex + 1) throw new ArgumentOutOfRangeException(nameof(count)' SR.ArgumentOutOfRange_Count); " is 123.
Long Statement,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Clear,The length of the statement  "            Debug.Assert(!_isWriterInProgress' "Race condition detected in usages of Hashtable - multiple threads appear to be writing to a Hashtable instance simultaneously!  Don't do that - use Hashtable.Synchronized."); " is 210.
Long Statement,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Insert,The length of the statement  "                if (emptySlotNumber == -1 && (_buckets[bucketNumber].key == _buckets) && (_buckets[bucketNumber].hash_coll < 0))//(((buckets[bucketNumber].hash_coll & unchecked(0x80000000))!=0))) " is 179.
Long Statement,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Remove,The length of the statement  "            Debug.Assert(!_isWriterInProgress' "Race condition detected in usages of Hashtable - multiple threads appear to be writing to a Hashtable instance simultaneously!  Don't do that - use Hashtable.Synchronized."); " is 210.
Long Statement,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,Escape,The length of the statement  "            int newIndex = 0; // Pointer into the string that indicates the start index of the "remaining" string (that still needs to be processed). " is 137.
Long Statement,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,Unescape,The length of the statement  "            int newIndex = 0; // Pointer into the string that indicates the start index of the "remainging" string (that still needs to be processed). " is 138.
Long Statement,System.Threading.Tasks,TaskToApm,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Threading\Tasks\TaskToApm.cs,Begin,The length of the statement  "                asyncResult = task.AsyncState == state ? (IAsyncResult)task : new TaskWrapperAsyncResult(task' state' completedSynchronously: false); " is 133.
Complex Conditional,System,ApplicationId,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\ApplicationId.cs,Equals,The conditional expression  "!(Equals(Name' other.Name) &&                    Equals(Version' other.Version) &&                    Equals(ProcessorArchitecture' other.ProcessorArchitecture) &&                    Equals(Culture' other.Culture))"  is complex.
Complex Conditional,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The conditional expression  "_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF"  is complex.
Complex Conditional,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The conditional expression  "_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF"  is complex.
Complex Conditional,System.IO,PathInternal,C:\selectedRepos\dotnet_corefx\src\Common\src\System\IO\PathInternal.cs,EqualStartingCharacterCount,The conditional expression  "l != leftEnd && r != rightEnd                      && (*l == *r || (ignoreCase && char.ToUpperInvariant((*l)) == char.ToUpperInvariant((*r))))"  is complex.
Virtual Method Call from Constructor,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,ArrayList,The constructor "ArrayList" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Hashtable,The constructor "Hashtable" calls a virtual method "Add".
Virtual Method Call from Constructor,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Hashtable,The constructor "Hashtable" calls a virtual method "Add".
Empty Catch Block,System.Collections.Generic,LowLevelDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LowLevelDictionary.cs,ExpandBuckets,The method has an empty catch block.
Magic Number,System,ApplicationId,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\ApplicationId.cs,EncodeHexString,The following statement contains a magic number: if (sArray != null)              {                  char[] hexOrder = new char[sArray.Length * 2];                                int digit;                  for(int i = 0' j = 0; i < sArray.Length; i++) {                      digit = (int)((sArray[i] & 0xf0) >> 4);                      hexOrder[j++] = HexDigit(digit);                      digit = (int)(sArray[i] & 0x0f);                      hexOrder[j++] = HexDigit(digit);                  }                  result = new string(hexOrder);              }
Magic Number,System,ApplicationId,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\ApplicationId.cs,EncodeHexString,The following statement contains a magic number: if (sArray != null)              {                  char[] hexOrder = new char[sArray.Length * 2];                                int digit;                  for(int i = 0' j = 0; i < sArray.Length; i++) {                      digit = (int)((sArray[i] & 0xf0) >> 4);                      hexOrder[j++] = HexDigit(digit);                      digit = (int)(sArray[i] & 0x0f);                      hexOrder[j++] = HexDigit(digit);                  }                  result = new string(hexOrder);              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteLen < 2)              {                  return;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,DetectEncoding,The following statement contains a magic number: if (_byteBuffer[0] == 0xFE && _byteBuffer[1] == 0xFF)              {                  // Big Endian Unicode                    _encoding = Encoding.BigEndianUnicode;                  CompressBuffer(2);                  changedEncoding = true;              }                else if (_byteBuffer[0] == 0xFF && _byteBuffer[1] == 0xFE)              {                  // Little Endian Unicode' or possibly little endian UTF32                  if (_byteLen < 4 || _byteBuffer[2] != 0 || _byteBuffer[3] != 0)                  {                      _encoding = Encoding.Unicode;                      CompressBuffer(2);                      changedEncoding = true;                  }                  else                  {                      _encoding = Encoding.UTF32;                      CompressBuffer(4);                      changedEncoding = true;                  }              }                else if (_byteLen >= 3 && _byteBuffer[0] == 0xEF && _byteBuffer[1] == 0xBB && _byteBuffer[2] == 0xBF)              {                  // UTF-8                  _encoding = Encoding.UTF8;                  CompressBuffer(3);                  changedEncoding = true;              }              else if (_byteLen >= 4 && _byteBuffer[0] == 0 && _byteBuffer[1] == 0 &&                  _byteBuffer[2] == 0xFE && _byteBuffer[3] == 0xFF)              {                  // Big Endian UTF32                  _encoding = new UTF32Encoding(bigEndian: true' byteOrderMark: true);                  CompressBuffer(4);                  changedEncoding = true;              }              else if (_byteLen == 2)              {                  _detectEncoding = true;              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The following statement contains a magic number: do              {                  if (_checkPreamble)                  {                      Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble.  Are two threads using this StreamReader at the same time?");                      int len = _stream.Read(_byteBuffer' _bytePos' _byteBuffer.Length - _bytePos);                      Debug.Assert(len >= 0' "Stream.Read returned a negative number!  This is a bug in your stream class.");                        if (len == 0)                      {                          // EOF but we might have buffered bytes from previous                           // attempt to detect preamble that needs to be decoded now                          if (_byteLen > 0)                          {                              _charLen += _decoder.GetChars(_byteBuffer' 0' _byteLen' _charBuffer' _charLen);                              // Need to zero out the byteLen after we consume these bytes so that we don't keep infinitely hitting this code path                              _bytePos = _byteLen = 0;                          }                            return _charLen;                      }                        _byteLen += len;                  }                  else                  {                      Debug.Assert(_bytePos == 0' "bytePos can be non zero only when we are trying to _checkPreamble.  Are two threads using this StreamReader at the same time?");                      _byteLen = _stream.Read(_byteBuffer' 0' _byteBuffer.Length);                      Debug.Assert(_byteLen >= 0' "Stream.Read returned a negative number!  This is a bug in your stream class.");                        if (_byteLen == 0)  // We're at EOF                      {                          return _charLen;                      }                  }                    // _isBlocked == whether we read fewer bytes than we asked for.                  // Note we must check it here because CompressBuffer or                   // DetectEncoding will change byteLen.                  _isBlocked = (_byteLen < _byteBuffer.Length);                    // Check for preamble before detect encoding. This is not to override the                  // user supplied Encoding for the one we implicitly detect. The user could                  // customize the encoding which we will loose' such as ThrowOnError on UTF8                  if (IsPreamble())                  {                      continue;                  }                    // If we're supposed to detect the encoding and haven't done so yet'                  // do it.  Note this may need to be called more than once.                  if (_detectEncoding && _byteLen >= 2)                  {                      DetectEncoding();                  }                    _charLen += _decoder.GetChars(_byteBuffer' 0' _byteLen' _charBuffer' _charLen);              } while (_charLen == 0);
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBuffer,The following statement contains a magic number: do              {                  Debug.Assert(charsRead == 0);                    if (_checkPreamble)                  {                      Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble.  Are two threads using this StreamReader at the same time?");                      int len = _stream.Read(_byteBuffer' _bytePos' _byteBuffer.Length - _bytePos);                      Debug.Assert(len >= 0' "Stream.Read returned a negative number!  This is a bug in your stream class.");                        if (len == 0)                      {                          // EOF but we might have buffered bytes from previous                           // attempt to detect preamble that needs to be decoded now                          if (_byteLen > 0)                          {                              if (readToUserBuffer)                              {                                  charsRead = _decoder.GetChars(new ReadOnlySpan<byte>(_byteBuffer' 0' _byteLen)' userBuffer.Slice(charsRead)' flush: false);                                  _charLen = 0;  // StreamReader's buffer is empty.                              }                              else                              {                                  charsRead = _decoder.GetChars(_byteBuffer' 0' _byteLen' _charBuffer' charsRead);                                  _charLen += charsRead;  // Number of chars in StreamReader's buffer.                              }                          }                            return charsRead;                      }                        _byteLen += len;                  }                  else                  {                      Debug.Assert(_bytePos == 0' "bytePos can be non zero only when we are trying to _checkPreamble.  Are two threads using this StreamReader at the same time?");                        _byteLen = _stream.Read(_byteBuffer' 0' _byteBuffer.Length);                        Debug.Assert(_byteLen >= 0' "Stream.Read returned a negative number!  This is a bug in your stream class.");                        if (_byteLen == 0)  // EOF                      {                          break;                      }                  }                    // _isBlocked == whether we read fewer bytes than we asked for.                  // Note we must check it here because CompressBuffer or                   // DetectEncoding will change byteLen.                  _isBlocked = (_byteLen < _byteBuffer.Length);                    // Check for preamble before detect encoding. This is not to override the                  // user supplied Encoding for the one we implicitly detect. The user could                  // customize the encoding which we will loose' such as ThrowOnError on UTF8                  // Note: we don't need to recompute readToUserBuffer optimization as IsPreamble                  // doesn't change the encoding or affect _maxCharsPerBuffer                  if (IsPreamble())                  {                      continue;                  }                    // On the first call to ReadBuffer' if we're supposed to detect the encoding' do it.                  if (_detectEncoding && _byteLen >= 2)                  {                      DetectEncoding();                      // DetectEncoding changes some buffer state.  Recompute this.                      readToUserBuffer = userBuffer.Length >= _maxCharsPerBuffer;                  }                    _charPos = 0;                  if (readToUserBuffer)                  {                      charsRead += _decoder.GetChars(new ReadOnlySpan<byte>(_byteBuffer' 0' _byteLen)' userBuffer.Slice(charsRead)' flush:false);                      _charLen = 0;  // StreamReader's buffer is empty.                  }                  else                  {                      charsRead = _decoder.GetChars(_byteBuffer' 0' _byteLen' _charBuffer' charsRead);                      _charLen += charsRead;  // Number of chars in StreamReader's buffer.                  }              } while (charsRead == 0);
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadLine,The following statement contains a magic number: do              {                  int i = _charPos;                  do                  {                      char ch = _charBuffer[i];                      // Note the following common line feed chars:                      // \n - UNIX   \r\n - DOS   \r - Mac                      if (ch == '\r' || ch == '\n')                      {                          string s;                          if (sb != null)                          {                              sb.Append(_charBuffer' _charPos' i - _charPos);                              s = sb.ToString();                          }                          else                          {                              s = new string(_charBuffer' _charPos' i - _charPos);                          }                          _charPos = i + 1;                          if (ch == '\r' && (_charPos < _charLen || ReadBuffer() > 0))                          {                              if (_charBuffer[_charPos] == '\n')                              {                                  _charPos++;                              }                          }                          return s;                      }                      i++;                  } while (i < _charLen);                  i = _charLen - _charPos;                  if (sb == null)                  {                      sb = new StringBuilder(i + 80);                  }                  sb.Append(_charBuffer' _charPos' i);              } while (ReadBuffer() > 0);
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadLineAsyncInternal,The following statement contains a magic number: do              {                  char[] tmpCharBuffer = _charBuffer;                  int tmpCharLen = _charLen;                  int tmpCharPos = _charPos;                  int i = tmpCharPos;                    do                  {                      char ch = tmpCharBuffer[i];                        // Note the following common line feed chars:                      // \n - UNIX   \r\n - DOS   \r - Mac                      if (ch == '\r' || ch == '\n')                      {                          string s;                            if (sb != null)                          {                              sb.Append(tmpCharBuffer' tmpCharPos' i - tmpCharPos);                              s = sb.ToString();                          }                          else                          {                              s = new string(tmpCharBuffer' tmpCharPos' i - tmpCharPos);                          }                            _charPos = tmpCharPos = i + 1;                            if (ch == '\r' && (tmpCharPos < tmpCharLen || (await ReadBufferAsync().ConfigureAwait(false)) > 0))                          {                              tmpCharPos = _charPos;                              if (_charBuffer[tmpCharPos] == '\n')                              {                                  _charPos = ++tmpCharPos;                              }                          }                            return s;                      }                        i++;                  } while (i < tmpCharLen);                    i = tmpCharLen - tmpCharPos;                  if (sb == null)                  {                      sb = new StringBuilder(i + 80);                  }                  sb.Append(tmpCharBuffer' tmpCharPos' i);              } while (await ReadBufferAsync().ConfigureAwait(false) > 0);
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadAsyncInternal,The following statement contains a magic number: while (count > 0)              {                  // n is the characters available in _charBuffer                  int n = _charLen - _charPos;                    // charBuffer is empty' let's read from the stream                  if (n == 0)                  {                      _charLen = 0;                      _charPos = 0;                        if (!_checkPreamble)                      {                          _byteLen = 0;                      }                        readToUserBuffer = count >= _maxCharsPerBuffer;                        // We loop here so that we read in enough bytes to yield at least 1 char.                      // We break out of the loop if the stream is blocked (EOF is reached).                      do                      {                          Debug.Assert(n == 0);                            if (_checkPreamble)                          {                              Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble.  Are two threads using this StreamReader at the same time?");                              int tmpBytePos = _bytePos;                              int len = await tmpStream.ReadAsync(tmpByteBuffer' tmpBytePos' tmpByteBuffer.Length - tmpBytePos' cancellationToken).ConfigureAwait(false);                              Debug.Assert(len >= 0' "Stream.Read returned a negative number!  This is a bug in your stream class.");                                if (len == 0)                              {                                  // EOF but we might have buffered bytes from previous                                   // attempts to detect preamble that needs to be decoded now                                  if (_byteLen > 0)                                  {                                      if (readToUserBuffer)                                      {                                          n = _decoder.GetChars(new ReadOnlySpan<byte>(tmpByteBuffer' 0' _byteLen)' buffer.Span.Slice(charsRead)' flush: false);                                          _charLen = 0;  // StreamReader's buffer is empty.                                      }                                      else                                      {                                          n = _decoder.GetChars(tmpByteBuffer' 0' _byteLen' _charBuffer' 0);                                          _charLen += n;  // Number of chars in StreamReader's buffer.                                      }                                  }                                    // How can part of the preamble yield any chars?                                  Debug.Assert(n == 0);                                    _isBlocked = true;                                  break;                              }                              else                              {                                  _byteLen += len;                              }                          }                          else                          {                              Debug.Assert(_bytePos == 0' "_bytePos can be non zero only when we are trying to _checkPreamble.  Are two threads using this StreamReader at the same time?");                                _byteLen = await tmpStream.ReadAsync(tmpByteBuffer' 0' tmpByteBuffer.Length' cancellationToken).ConfigureAwait(false);                                Debug.Assert(_byteLen >= 0' "Stream.Read returned a negative number!  This is a bug in your stream class.");                                if (_byteLen == 0)  // EOF                              {                                  _isBlocked = true;                                  break;                              }                          }                            // _isBlocked == whether we read fewer bytes than we asked for.                          // Note we must check it here because CompressBuffer or                           // DetectEncoding will change _byteLen.                          _isBlocked = (_byteLen < tmpByteBuffer.Length);                            // Check for preamble before detect encoding. This is not to override the                          // user supplied Encoding for the one we implicitly detect. The user could                          // customize the encoding which we will loose' such as ThrowOnError on UTF8                          // Note: we don't need to recompute readToUserBuffer optimization as IsPreamble                          // doesn't change the encoding or affect _maxCharsPerBuffer                          if (IsPreamble())                          {                              continue;                          }                            // On the first call to ReadBuffer' if we're supposed to detect the encoding' do it.                          if (_detectEncoding && _byteLen >= 2)                          {                              DetectEncoding();                              // DetectEncoding changes some buffer state.  Recompute this.                              readToUserBuffer = count >= _maxCharsPerBuffer;                          }                            Debug.Assert(n == 0);                            _charPos = 0;                          if (readToUserBuffer)                          {                              n += _decoder.GetChars(new ReadOnlySpan<byte>(tmpByteBuffer' 0' _byteLen)' buffer.Span.Slice(charsRead)' flush: false);                                // Why did the bytes yield no chars?                              Debug.Assert(n > 0);                                _charLen = 0;  // StreamReader's buffer is empty.                          }                          else                          {                              n = _decoder.GetChars(tmpByteBuffer' 0' _byteLen' _charBuffer' 0);                                // Why did the bytes yield no chars?                              Debug.Assert(n > 0);                                _charLen += n;  // Number of chars in StreamReader's buffer.                          }                      } while (n == 0);                        if (n == 0)                      {                          break;  // We're at EOF                      }                  }  // if (n == 0)                    // Got more chars in charBuffer than the user requested                  if (n > count)                  {                      n = count;                  }                    if (!readToUserBuffer)                  {                      new Span<char>(_charBuffer' _charPos' n).CopyTo(buffer.Span.Slice(charsRead));                      _charPos += n;                  }                    charsRead += n;                  count -= n;                    // This function shouldn't block for an indefinite amount of time'                  // or reading from a network stream won't work right.  If we got                  // fewer bytes than we requested' then we want to break right here.                  if (_isBlocked)                  {                      break;                  }              }
Magic Number,System.IO,StreamReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamReader.cs,ReadBufferAsync,The following statement contains a magic number: do              {                  if (_checkPreamble)                  {                      Debug.Assert(_bytePos <= _encoding.Preamble.Length' "possible bug in _compressPreamble. Are two threads using this StreamReader at the same time?");                      int tmpBytePos = _bytePos;                      int len = await tmpStream.ReadAsync(tmpByteBuffer' tmpBytePos' tmpByteBuffer.Length - tmpBytePos).ConfigureAwait(false);                      Debug.Assert(len >= 0' "Stream.Read returned a negative number!  This is a bug in your stream class.");                        if (len == 0)                      {                          // EOF but we might have buffered bytes from previous                           // attempt to detect preamble that needs to be decoded now                          if (_byteLen > 0)                          {                              _charLen += _decoder.GetChars(tmpByteBuffer' 0' _byteLen' _charBuffer' _charLen);                              // Need to zero out the _byteLen after we consume these bytes so that we don't keep infinitely hitting this code path                              _bytePos = 0; _byteLen = 0;                          }                            return _charLen;                      }                        _byteLen += len;                  }                  else                  {                      Debug.Assert(_bytePos == 0' "_bytePos can be non zero only when we are trying to _checkPreamble. Are two threads using this StreamReader at the same time?");                      _byteLen = await tmpStream.ReadAsync(tmpByteBuffer' 0' tmpByteBuffer.Length).ConfigureAwait(false);                      Debug.Assert(_byteLen >= 0' "Stream.Read returned a negative number!  Bug in stream class.");                        if (_byteLen == 0)  // We're at EOF                      {                          return _charLen;                      }                  }                    // _isBlocked == whether we read fewer bytes than we asked for.                  // Note we must check it here because CompressBuffer or                   // DetectEncoding will change _byteLen.                  _isBlocked = (_byteLen < tmpByteBuffer.Length);                    // Check for preamble before detect encoding. This is not to override the                  // user supplied Encoding for the one we implicitly detect. The user could                  // customize the encoding which we will loose' such as ThrowOnError on UTF8                  if (IsPreamble())                  {                      continue;                  }                    // If we're supposed to detect the encoding and haven't done so yet'                  // do it.  Note this may need to be called more than once.                  if (_detectEncoding && _byteLen >= 2)                  {                      DetectEncoding();                  }                    _charLen += _decoder.GetChars(tmpByteBuffer' 0' _byteLen' _charBuffer' _charLen);              } while (_charLen == 0);
Magic Number,System.IO,StreamWriter,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\StreamWriter.cs,WriteCore,The following statement contains a magic number: if (buffer.Length <= 4 && // Threshold of 4 chosen based on perf experimentation                  buffer.Length <= _charLen - _charPos)              {                  // For very short buffers and when we don't need to worry about running out of space                  // in the char buffer' just copy the chars individually.                  fixed (char* bufferPtr = &buffer.DangerousGetPinnableReference())                  {                      Span<char> bufferSpan = new Span<char>(bufferPtr' buffer.Length);                      for (int i = 0; i < buffer.Length; i++)                      {                          _charBuffer[_charPos++] = bufferSpan[i];                      }                  }              }              else              {                  // For larger buffers or when we may run out of room in the internal char buffer' copy in chunks.                  // Use unsafe code until https://github.com/dotnet/coreclr/issues/13827 is addressed' as spans are                  // resulting in significant overhead (even when the if branch above is taken rather than this                  // else) due to temporaries that need to be cleared.  Given the use of unsafe code' we also                  // make local copies of instance state to protect against potential concurrent misuse.                    char[] charBuffer = _charBuffer;                  if (charBuffer == null)                  {                      throw new ObjectDisposedException(null' SR.ObjectDisposed_WriterClosed);                  }                    fixed (char* bufferPtr = &buffer.DangerousGetPinnableReference())                  fixed (char* dstPtr = &charBuffer[0])                  {                      char* srcPtr = bufferPtr;                      int count = buffer.Length;                      int dstPos = _charPos; // use a local copy of _charPos for safety                      while (count > 0)                      {                          if (dstPos == charBuffer.Length)                          {                              Flush(false' false);                              dstPos = 0;                          }                            int n = Math.Min(charBuffer.Length - dstPos' count);                          int bytesToCopy = n * sizeof(char);                            Buffer.MemoryCopy(srcPtr' dstPtr + dstPos' bytesToCopy' bytesToCopy);                            _charPos += n;                          dstPos += n;                          srcPtr += n;                          count -= n;                      }                  }              }
Magic Number,System.IO,TextReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\TextReader.cs,ReadToEnd,The following statement contains a magic number: char[] chars = new char[4096];
Magic Number,System.IO,TextReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\TextReader.cs,ReadToEnd,The following statement contains a magic number: StringBuilder sb = new StringBuilder(4096);
Magic Number,System.IO,TextReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\TextReader.cs,ReadToEndAsync,The following statement contains a magic number: var sb = new StringBuilder(4096);
Magic Number,System.IO,TextReader,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\IO\TextReader.cs,ReadToEndAsync,The following statement contains a magic number: char[] chars = ArrayPool<char>.Shared.Rent(4096);
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlEncode,The following statement contains a magic number: fixed (char* str = value)              {                  char* pch = str;                  while (index-- > 0)                  {                      output.Append(*pch++);                  }                    for (; cch > 0; cch--' pch++)                  {                      char ch = *pch;                      if (ch <= '>')                      {                          switch (ch)                          {                              case '<':                                  output.Append("&lt;");                                  break;                              case '>':                                  output.Append("&gt;");                                  break;                              case '"':                                  output.Append("&quot;");                                  break;                              case '\'':                                  output.Append("&#39;");                                  break;                              case '&':                                  output.Append("&amp;");                                  break;                              default:                                  output.Append(ch);                                  break;                          }                      }                      else                      {                          int valueToEncode = -1; // set to >= 0 if needs to be encoded    #if ENTITY_ENCODE_HIGH_ASCII_CHARS                          if (ch >= 160 && ch < 256)                          {                              // The seemingly arbitrary 160 comes from RFC                              valueToEncode = ch;                          }                          else  #endif // ENTITY_ENCODE_HIGH_ASCII_CHARS                          if (Char.IsSurrogate(ch))                          {                              int scalarValue = GetNextUnicodeScalarValueFromUtf16Surrogate(ref pch' ref cch);                              if (scalarValue >= UNICODE_PLANE01_START)                              {                                  valueToEncode = scalarValue;                              }                              else                              {                                  // Don't encode BMP characters (like U+FFFD) since they wouldn't have                                  // been encoded if explicitly present in the string anyway.                                  ch = (char)scalarValue;                              }                          }                            if (valueToEncode >= 0)                          {                              // value needs to be encoded                              output.Append("&#");                              output.Append(valueToEncode.ToString(CultureInfo.InvariantCulture));                              output.Append(';');                          }                          else                          {                              // write out the character directly                              output.Append(ch);                          }                      }                  }              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlEncode,The following statement contains a magic number: fixed (char* str = value)              {                  char* pch = str;                  while (index-- > 0)                  {                      output.Append(*pch++);                  }                    for (; cch > 0; cch--' pch++)                  {                      char ch = *pch;                      if (ch <= '>')                      {                          switch (ch)                          {                              case '<':                                  output.Append("&lt;");                                  break;                              case '>':                                  output.Append("&gt;");                                  break;                              case '"':                                  output.Append("&quot;");                                  break;                              case '\'':                                  output.Append("&#39;");                                  break;                              case '&':                                  output.Append("&amp;");                                  break;                              default:                                  output.Append(ch);                                  break;                          }                      }                      else                      {                          int valueToEncode = -1; // set to >= 0 if needs to be encoded    #if ENTITY_ENCODE_HIGH_ASCII_CHARS                          if (ch >= 160 && ch < 256)                          {                              // The seemingly arbitrary 160 comes from RFC                              valueToEncode = ch;                          }                          else  #endif // ENTITY_ENCODE_HIGH_ASCII_CHARS                          if (Char.IsSurrogate(ch))                          {                              int scalarValue = GetNextUnicodeScalarValueFromUtf16Surrogate(ref pch' ref cch);                              if (scalarValue >= UNICODE_PLANE01_START)                              {                                  valueToEncode = scalarValue;                              }                              else                              {                                  // Don't encode BMP characters (like U+FFFD) since they wouldn't have                                  // been encoded if explicitly present in the string anyway.                                  ch = (char)scalarValue;                              }                          }                            if (valueToEncode >= 0)                          {                              // value needs to be encoded                              output.Append("&#");                              output.Append(valueToEncode.ToString(CultureInfo.InvariantCulture));                              output.Append(';');                          }                          else                          {                              // write out the character directly                              output.Append(ch);                          }                      }                  }              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < l; i++)              {                  char ch = value[i];                    if (ch == '&')                  {                      // We found a '&'. Now look for the next ';' or '&'. The idea is that                      // if we find another '&' before finding a ';'' then this is not an entity'                      // and the next '&' might start a real entity (VSWhidbey 275184)                      int index = value.IndexOfAny(s_htmlEntityEndingChars' i + 1);                      if (index > 0 && value[index] == ';')                      {                          int entityOffset = i + 1;                          int entityLength = index - entityOffset;                            if (entityLength > 1 && value[entityOffset] == '#')                          {                              // The # syntax can be in decimal or hex' e.g.                              //      &#229;  --> decimal                              //      &#xE5;  --> same char in hex                              // See http://www.w3.org/TR/REC-html40/charset.html#entities                                bool parsedSuccessfully;                              uint parsedValue;                              if (value[entityOffset + 1] == 'x' || value[entityOffset + 1] == 'X')                              {                                  parsedSuccessfully = uint.TryParse(value.Substring(entityOffset + 2' entityLength - 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out parsedValue);                              }                              else                              {                                  parsedSuccessfully = uint.TryParse(value.Substring(entityOffset + 1' entityLength - 1)' NumberStyles.Integer' CultureInfo.InvariantCulture' out parsedValue);                              }                                if (parsedSuccessfully)                              {                                  // decoded character must be U+0000 .. U+10FFFF' excluding surrogates                                  parsedSuccessfully = ((parsedValue < HIGH_SURROGATE_START) || (LOW_SURROGATE_END < parsedValue && parsedValue <= UNICODE_PLANE16_END));                              }                                if (parsedSuccessfully)                              {                                  if (parsedValue <= UNICODE_PLANE00_END)                                  {                                      // single character                                      output.Append((char)parsedValue);                                  }                                  else                                  {                                      // multi-character                                      char leadingSurrogate' trailingSurrogate;                                      ConvertSmpToUtf16(parsedValue' out leadingSurrogate' out trailingSurrogate);                                      output.Append(leadingSurrogate);                                      output.Append(trailingSurrogate);                                  }                                    i = index; // already looked at everything until semicolon                                  continue;                              }                          }                          else                          {                              string entity = value.Substring(entityOffset' entityLength);                              i = index; // already looked at everything until semicolon                                char entityChar = HtmlEntities.Lookup(entity);                              if (entityChar != (char)0)                              {                                  ch = entityChar;                              }                              else                              {                                  output.Append('&');                                  output.Append(entity);                                  output.Append(';');                                  continue;                              }                          }                      }                  }                    output.Append(ch);              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HtmlDecode,The following statement contains a magic number: for (int i = 0; i < l; i++)              {                  char ch = value[i];                    if (ch == '&')                  {                      // We found a '&'. Now look for the next ';' or '&'. The idea is that                      // if we find another '&' before finding a ';'' then this is not an entity'                      // and the next '&' might start a real entity (VSWhidbey 275184)                      int index = value.IndexOfAny(s_htmlEntityEndingChars' i + 1);                      if (index > 0 && value[index] == ';')                      {                          int entityOffset = i + 1;                          int entityLength = index - entityOffset;                            if (entityLength > 1 && value[entityOffset] == '#')                          {                              // The # syntax can be in decimal or hex' e.g.                              //      &#229;  --> decimal                              //      &#xE5;  --> same char in hex                              // See http://www.w3.org/TR/REC-html40/charset.html#entities                                bool parsedSuccessfully;                              uint parsedValue;                              if (value[entityOffset + 1] == 'x' || value[entityOffset + 1] == 'X')                              {                                  parsedSuccessfully = uint.TryParse(value.Substring(entityOffset + 2' entityLength - 2)' NumberStyles.AllowHexSpecifier' CultureInfo.InvariantCulture' out parsedValue);                              }                              else                              {                                  parsedSuccessfully = uint.TryParse(value.Substring(entityOffset + 1' entityLength - 1)' NumberStyles.Integer' CultureInfo.InvariantCulture' out parsedValue);                              }                                if (parsedSuccessfully)                              {                                  // decoded character must be U+0000 .. U+10FFFF' excluding surrogates                                  parsedSuccessfully = ((parsedValue < HIGH_SURROGATE_START) || (LOW_SURROGATE_END < parsedValue && parsedValue <= UNICODE_PLANE16_END));                              }                                if (parsedSuccessfully)                              {                                  if (parsedValue <= UNICODE_PLANE00_END)                                  {                                      // single character                                      output.Append((char)parsedValue);                                  }                                  else                                  {                                      // multi-character                                      char leadingSurrogate' trailingSurrogate;                                      ConvertSmpToUtf16(parsedValue' out leadingSurrogate' out trailingSurrogate);                                      output.Append(leadingSurrogate);                                      output.Append(trailingSurrogate);                                  }                                    i = index; // already looked at everything until semicolon                                  continue;                              }                          }                          else                          {                              string entity = value.Substring(entityOffset' entityLength);                              i = index; // already looked at everything until semicolon                                char entityChar = HtmlEntities.Lookup(entity);                              if (entityChar != (char)0)                              {                                  ch = entityChar;                              }                              else                              {                                  output.Append('&');                                  output.Append(entity);                                  output.Append(';');                                  continue;                              }                          }                      }                  }                    output.Append(ch);              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,IndexOfHtmlEncodingChars,The following statement contains a magic number: fixed (char* str = s)              {                  for (char* pch = &str[startPos]; cch > 0; pch++' cch--)                  {                      char ch = *pch;                      if (ch <= '>')                      {                          switch (ch)                          {                              case '<':                              case '>':                              case '"':                              case '\'':                              case '&':                                  return s.Length - cch;                          }                      }  #if ENTITY_ENCODE_HIGH_ASCII_CHARS                      else if (ch >= 160 && ch < 256)                      {                          return s.Length - cch;                      }  #endif // ENTITY_ENCODE_HIGH_ASCII_CHARS                      else if (Char.IsSurrogate(ch))                      {                          return s.Length - cch;                      }                  }              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,IndexOfHtmlEncodingChars,The following statement contains a magic number: fixed (char* str = s)              {                  for (char* pch = &str[startPos]; cch > 0; pch++' cch--)                  {                      char ch = *pch;                      if (ch <= '>')                      {                          switch (ch)                          {                              case '<':                              case '>':                              case '"':                              case '\'':                              case '&':                                  return s.Length - cch;                          }                      }  #if ENTITY_ENCODE_HIGH_ASCII_CHARS                      else if (ch >= 160 && ch < 256)                      {                          return s.Length - cch;                      }  #endif // ENTITY_ENCODE_HIGH_ASCII_CHARS                      else if (Char.IsSurrogate(ch))                      {                          return s.Length - cch;                      }                  }              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,GetEncodedBytes,The following statement contains a magic number: for (int i = offset; i < end; i++)              {  #if DEBUG                  // Make sure we never overwrite any bytes if originalBytes and                  // expandedBytes refer to the same array                  if (originalBytes == expandedBytes)                  {                      Debug.Assert(i >= pos);                  }  #endif                    byte b = originalBytes[i];                  char ch = (char)b;                  if (IsUrlSafeChar(ch))                  {                      expandedBytes[pos++] = b;                  }                  else if (ch == ' ')                  {                      expandedBytes[pos++] = (byte)'+';                  }                  else                  {                      expandedBytes[pos++] = (byte)'%';                      expandedBytes[pos++] = (byte)IntToHex((b >> 4) & 0xf);                      expandedBytes[pos++] = (byte)IntToHex(b & 0x0f);                  }              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlEncode,The following statement contains a magic number: int byteIndex = unsafeByteCount * 2;
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlEncodeToBytes,The following statement contains a magic number: byte[] expandedBytes = new byte[count + unsafeCount * 2];
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      needsDecodingSpaces = true;                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          needsDecodingUnsafe = true;                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      needsDecodingSpaces = true;                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          needsDecodingUnsafe = true;                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      needsDecodingSpaces = true;                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          needsDecodingUnsafe = true;                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int pos = 0; pos < count; pos++)              {                  char ch = value[pos];                    if (ch == '+')                  {                      needsDecodingSpaces = true;                      ch = ' ';                  }                  else if (ch == '%' && pos < count - 2)                  {                      int h1 = HexToInt(value[pos + 1]);                      int h2 = HexToInt(value[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          byte b = (byte)((h1 << 4) | h2);                          pos += 2;                            // don't add as char                          helper.AddByte(b);                          needsDecodingUnsafe = true;                          continue;                      }                  }                    if ((ch & 0xFF80) == 0)                      helper.AddByte((byte)ch); // 7 bit have to go as bytes because of Unicode                  else                      helper.AddChar(ch);              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int pos = offset + i;                  byte b = bytes[pos];                    if (b == '+')                  {                      b = (byte)' ';                  }                  else if (b == '%' && i < count - 2)                  {                      int h1 = HexToInt((char)bytes[pos + 1]);                      int h2 = HexToInt((char)bytes[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          b = (byte)((h1 << 4) | h2);                          i += 2;                      }                  }                    decodedBytes[decodedBytesCount++] = b;              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int pos = offset + i;                  byte b = bytes[pos];                    if (b == '+')                  {                      b = (byte)' ';                  }                  else if (b == '%' && i < count - 2)                  {                      int h1 = HexToInt((char)bytes[pos + 1]);                      int h2 = HexToInt((char)bytes[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          b = (byte)((h1 << 4) | h2);                          i += 2;                      }                  }                    decodedBytes[decodedBytesCount++] = b;              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int pos = offset + i;                  byte b = bytes[pos];                    if (b == '+')                  {                      b = (byte)' ';                  }                  else if (b == '%' && i < count - 2)                  {                      int h1 = HexToInt((char)bytes[pos + 1]);                      int h2 = HexToInt((char)bytes[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          b = (byte)((h1 << 4) | h2);                          i += 2;                      }                  }                    decodedBytes[decodedBytesCount++] = b;              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,UrlDecodeInternal,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  int pos = offset + i;                  byte b = bytes[pos];                    if (b == '+')                  {                      b = (byte)' ';                  }                  else if (b == '%' && i < count - 2)                  {                      int h1 = HexToInt((char)bytes[pos + 1]);                      int h2 = HexToInt((char)bytes[pos + 2]);                        if (h1 >= 0 && h2 >= 0)                      {     // valid 2 hex chars                          b = (byte)((h1 << 4) | h2);                          i += 2;                      }                  }                    decodedBytes[decodedBytesCount++] = b;              }
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HexToInt,The following statement contains a magic number: return (h >= '0' && h <= '9') ? h - '0' :              (h >= 'a' && h <= 'f') ? h - 'a' + 10 :              (h >= 'A' && h <= 'F') ? h - 'A' + 10 :              -1;
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,HexToInt,The following statement contains a magic number: return (h >= '0' && h <= '9') ? h - '0' :              (h >= 'a' && h <= 'f') ? h - 'a' + 10 :              (h >= 'A' && h <= 'F') ? h - 'A' + 10 :              -1;
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,IntToHex,The following statement contains a magic number: if (n <= 9)                  return (char)(n + (int)'0');              else                  return (char)(n - 10 + (int)'A');
Magic Number,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,IntToHex,The following statement contains a magic number: if (n <= 9)                  return (char)(n + (int)'0');              else                  return (char)(n - 10 + (int)'A');
Magic Number,System.Runtime.Versioning,FrameworkName,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Runtime\Versioning\FrameworkName.cs,FrameworkName,The following statement contains a magic number: if (components.Length < 2 || components.Length > 3)              {                  throw new ArgumentException(SR.Argument_FrameworkNameTooShort' nameof(frameworkName));              }
Magic Number,System.Runtime.Versioning,FrameworkName,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Runtime\Versioning\FrameworkName.cs,FrameworkName,The following statement contains a magic number: if (components.Length < 2 || components.Length > 3)              {                  throw new ArgumentException(SR.Argument_FrameworkNameTooShort' nameof(frameworkName));              }
Magic Number,System.Runtime.Versioning,VersioningHelper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Runtime\Versioning\VersioningHelper.cs,GetCLRInstanceString,The following statement contains a magic number: int id = 3;
Magic Number,System.Collections,ArrayList,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,EnsureCapacity,The following statement contains a magic number: if (_items.Length < min)              {                  int newCapacity = _items.Length == 0 ? _defaultCapacity : _items.Length * 2;                  // Allow the list to grow to maximum possible capacity (~2G elements) before encountering overflow.                  // Note that this check works even when _items.Length overflowed thanks to the (uint) cast                  if ((uint)newCapacity > MaxArrayLength) newCapacity = MaxArrayLength;                  if (newCapacity < min) newCapacity = min;                  Capacity = newCapacity;              }
Magic Number,System.Collections,IListWrapper,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\ArrayList.cs,BinarySearch,The following statement contains a magic number: while (lo <= hi)                  {                      mid = (lo + hi) / 2;                      int r = comparer.Compare(value' _list[mid]);                      if (r == 0)                          return mid;                      if (r < 0)                          hi = mid - 1;                      else                          lo = mid + 1;                  }
Magic Number,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Hashtable,The following statement contains a magic number: if (!(loadFactor >= 0.1f && loadFactor <= 1.0f))                  throw new ArgumentOutOfRangeException(nameof(loadFactor)' SR.Format(SR.ArgumentOutOfRange_HashtableLoadFactor' .1' 1.0));
Magic Number,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,Insert,The following statement contains a magic number: if (_count >= _loadsize)              {                  expand();              }              else if (_occupancy > _loadsize && _count > 100)              {                  rehash();              }
Magic Number,System.Collections,HashHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,IsPrime,The following statement contains a magic number: if ((candidate & 1) != 0)              {                  int limit = (int)Math.Sqrt(candidate);                  for (int divisor = 3; divisor <= limit; divisor += 2)                  {                      if ((candidate % divisor) == 0)                          return false;                  }                  return true;              }
Magic Number,System.Collections,HashHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,IsPrime,The following statement contains a magic number: if ((candidate & 1) != 0)              {                  int limit = (int)Math.Sqrt(candidate);                  for (int divisor = 3; divisor <= limit; divisor += 2)                  {                      if ((candidate % divisor) == 0)                          return false;                  }                  return true;              }
Magic Number,System.Collections,HashHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,IsPrime,The following statement contains a magic number: return (candidate == 2);
Magic Number,System.Collections,HashHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,GetPrime,The following statement contains a magic number: for (int i = (min | 1); i < Int32.MaxValue; i += 2)              {                  if (IsPrime(i) && ((i - 1) % Hashtable.HashPrime != 0))                      return i;              }
Magic Number,System.Collections,HashHelpers,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,ExpandPrime,The following statement contains a magic number: int newSize = 2 * oldSize;
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,AddAttributeSafe,The following statement contains a magic number: if (_attributes == null)              {                  _attributes = new ArrayList(AttributesTypical);              }              else              {                  int iMax = _attributes.Count;                  Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");                    for (int i = 0; i < iMax; i += 2)                  {                      string strAttrName = (string)_attributes[i];                        if (string.Equals(strAttrName' name))                          throw new ArgumentException(SR.Argument_AttributeNamesMustBeUnique);                  }              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,AddAttributeSafe,The following statement contains a magic number: if (_attributes == null)              {                  _attributes = new ArrayList(AttributesTypical);              }              else              {                  int iMax = _attributes.Count;                  Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");                    for (int i = 0; i < iMax; i += 2)                  {                      string strAttrName = (string)_attributes[i];                        if (string.Equals(strAttrName' name))                          throw new ArgumentException(SR.Argument_AttributeNamesMustBeUnique);                  }              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,Equal,The following statement contains a magic number: if (_attributes == null || other._attributes == null)              {                  if (_attributes != other._attributes)                      return false;              }              else              {                  int iMax = _attributes.Count;                  Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");                    // Maybe we can get away by only checking the number of attributes                  if (iMax != other._attributes.Count)                      return false;                    for (int i = 0; i < iMax; i++)                  {                      string lhs = (string)_attributes[i];                      string rhs = (string)other._attributes[i];                        if (!string.Equals(lhs' rhs))                          return false;                  }              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,GetEscapeSequence,The following statement contains a magic number: Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,GetEscapeSequence,The following statement contains a magic number: for (int i = 0; i < iMax; i += 2)              {                  string strEscSeq = s_escapeStringPairs[i];                  string strEscValue = s_escapeStringPairs[i + 1];                    if (strEscSeq[0] == c)                      return strEscValue;              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,GetUnescapeSequence,The following statement contains a magic number: Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,GetUnescapeSequence,The following statement contains a magic number: for (int i = 0; i < iMax; i += 2)              {                  string strEscSeq = s_escapeStringPairs[i];                  string strEscValue = s_escapeStringPairs[i + 1];                    int length = strEscValue.Length;                    if (length <= maxCompareLength && string.Compare(strEscValue' 0' str' index' length' StringComparison.Ordinal) == 0)                  {                      newIndex = index + strEscValue.Length;                      return strEscSeq;                  }              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,ToString,The following statement contains a magic number: if (_attributes != null && _attributes.Count > 0)              {                  write(obj' " ");                    int iMax = _attributes.Count;                  Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");                    for (int i = 0; i < iMax; i += 2)                  {                      string strAttrName = (string)_attributes[i];                      string strAttrValue = (string)_attributes[i + 1];                        write(obj' strAttrName);                      write(obj' "=\"");                      write(obj' strAttrValue);                      write(obj' "\"");                        if (i != _attributes.Count - 2)                      {                          write(obj' Environment.NewLine);                      }                  }              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,ToString,The following statement contains a magic number: if (_attributes != null && _attributes.Count > 0)              {                  write(obj' " ");                    int iMax = _attributes.Count;                  Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");                    for (int i = 0; i < iMax; i += 2)                  {                      string strAttrName = (string)_attributes[i];                      string strAttrValue = (string)_attributes[i + 1];                        write(obj' strAttrName);                      write(obj' "=\"");                      write(obj' strAttrValue);                      write(obj' "\"");                        if (i != _attributes.Count - 2)                      {                          write(obj' Environment.NewLine);                      }                  }              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,ToString,The following statement contains a magic number: if (_attributes != null && _attributes.Count > 0)              {                  write(obj' " ");                    int iMax = _attributes.Count;                  Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");                    for (int i = 0; i < iMax; i += 2)                  {                      string strAttrName = (string)_attributes[i];                      string strAttrValue = (string)_attributes[i + 1];                        write(obj' strAttrName);                      write(obj' "=\"");                      write(obj' strAttrValue);                      write(obj' "\"");                        if (i != _attributes.Count - 2)                      {                          write(obj' Environment.NewLine);                      }                  }              }
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,Attribute,The following statement contains a magic number: Debug.Assert(iMax % 2 == 0' "Odd number of strings means the attr/value pairs were not added correctly");
Magic Number,System.Security,SecurityElement,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Security\SecurityElement.cs,Attribute,The following statement contains a magic number: for (int i = 0; i < iMax; i += 2)              {                  string strAttrName = (string)_attributes[i];                    if (string.Equals(strAttrName' name))                  {                      string strAttrValue = (string)_attributes[i + 1];                        return Unescape(strAttrValue);                  }              }
Magic Number,System.Collections.Generic,LowLevelDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LowLevelDictionary.cs,UncheckedAdd,The following statement contains a magic number: if (_numEntries > (_buckets.Length * 2))                  ExpandBuckets();
Magic Number,System.Collections.Generic,LowLevelDictionary<TKey;TValue>,C:\selectedRepos\dotnet_corefx\src\Common\src\System\Collections\Generic\LowLevelDictionary.cs,ExpandBuckets,The following statement contains a magic number: try              {                  int newNumBuckets = _buckets.Length * 2 + 1;                  Entry[] newBuckets = new Entry[newNumBuckets];                  for (int i = 0; i < _buckets.Length; i++)                  {                      Entry entry = _buckets[i];                      while (entry != null)                      {                          Entry nextEntry = entry._next;                            int bucket = GetBucket(entry._key' newNumBuckets);                          entry._next = newBuckets[bucket];                          newBuckets[bucket] = entry;                            entry = nextEntry;                      }                  }                  _buckets = newBuckets;              }              catch (OutOfMemoryException)              {              }
Missing Default,System.Net,WebUtility,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Net\WebUtility.cs,IndexOfHtmlEncodingChars,The following switch statement is missing a default case: switch (ch)                          {                              case '<':                              case '>':                              case '"':                              case '\'':                              case '&':                                  return s.Length - cch;                          }
Missing Default,System.Collections,Comparer,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Comparer.cs,Comparer,The following switch statement is missing a default case: switch (enumerator.Name)                  {                      case CompareInfoName:                          _compareInfo = (CompareInfo)info.GetValue(CompareInfoName' typeof(CompareInfo));                          break;                  }
Missing Default,System.Collections,Hashtable,C:\selectedRepos\dotnet_corefx\src\System.Runtime.Extensions\src\System\Collections\Hashtable.cs,OnDeserialization,The following switch statement is missing a default case: switch (enumerator.Name)                  {                      case LoadFactorName:                          _loadFactor = siInfo.GetSingle(LoadFactorName);                          break;                      case HashSizeName:                          hashsize = siInfo.GetInt32(HashSizeName);                          break;                      case KeyComparerName:                          _keycomparer = (IEqualityComparer)siInfo.GetValue(KeyComparerName' typeof(IEqualityComparer));                          break;                      case ComparerName:                          c = (IComparer)siInfo.GetValue(ComparerName' typeof(IComparer));                          break;                      case HashCodeProviderName:  #pragma warning disable 618                          hcp = (IHashCodeProvider)siInfo.GetValue(HashCodeProviderName' typeof(IHashCodeProvider));  #pragma warning restore 618                          break;                      case KeysName:                          serKeys = (Object[])siInfo.GetValue(KeysName' typeof(Object[]));                          break;                      case ValuesName:                          serValues = (Object[])siInfo.GetValue(ValuesName' typeof(Object[]));                          break;                  }
