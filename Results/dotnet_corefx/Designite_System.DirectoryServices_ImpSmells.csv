Implementation smell,Namespace,Class,File,Method,Description
Long Method,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,SetSearchPreferences,The method has 210 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,Save,The method has 136 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertiesFromSchemaContainer,The method has 102 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,Save,The method has 133 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The method has 116 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,Save,The method has 119 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The method has 172 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The method has 165 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Save,The method has 152 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The method has 178 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The method has 143 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustsHelper,The method has 178 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetDomainControllerInfo,The method has 103 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,The method has 225 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,GetForestTrustInfoHelper,The method has 115 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,SetTrustedDomainInfoStatus,The method has 113 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrust,The method has 100 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrust,The method has 109 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrustDirection,The method has 120 lines of code.
Long Method,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The method has 512 lines of code.
Long Method,System.DirectoryServices.Interop,AdsValueHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\AdsValueHelper2.cs,GetValue,The method has 103 lines of code.
Complex Method,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,RefreshCache,Cyclomatic complexity of the method is 9
Complex Method,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,SetSearchPreferences,Cyclomatic complexity of the method is 20
Complex Method,System.DirectoryServices,ResultsEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\SearchResultCollection.cs,MoveNext,Cyclomatic complexity of the method is 15
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchema,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,Save,Cyclomatic complexity of the method is 11
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertyValuesRecursively,Cyclomatic complexity of the method is 13
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,Save,Cyclomatic complexity of the method is 11
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,Cyclomatic complexity of the method is 19
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetDomains,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLink,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLink.cs,ValidateArgument,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkBridge,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkBridge.cs,ValidateArgument,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,Cyclomatic complexity of the method is 13
Complex Method,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Save,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,ValidateApplicationPartitionParameters,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetReplicationInfoHelper,Cyclomatic complexity of the method is 9
Complex Method,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomain,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustsHelper,Cyclomatic complexity of the method is 23
Complex Method,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetDomainControllerInfo,Cyclomatic complexity of the method is 9
Complex Method,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetForest,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetTrustsHelper,Cyclomatic complexity of the method is 11
Complex Method,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,Cyclomatic complexity of the method is 12
Complex Method,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsQueryWrapper,Cyclomatic complexity of the method is 8
Complex Method,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,Cyclomatic complexity of the method is 33
Long Parameter List,System.DirectoryServices,ActiveDirectorySecurity,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,AccessRuleFactory,The method has 6 parameters. Parameters: identityReference' accessMask' isInherited' inheritanceFlags' propagationFlags' type
Long Parameter List,System.DirectoryServices,ActiveDirectorySecurity,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,AccessRuleFactory,The method has 8 parameters. Parameters: identityReference' accessMask' isInherited' inheritanceFlags' propagationFlags' type' objectGuid' inheritedObjectGuid
Long Parameter List,System.DirectoryServices,ActiveDirectorySecurity,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,AuditRuleFactory,The method has 6 parameters. Parameters: identityReference' accessMask' isInherited' inheritanceFlags' propagationFlags' flags
Long Parameter List,System.DirectoryServices,ActiveDirectorySecurity,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,AuditRuleFactory,The method has 8 parameters. Parameters: identityReference' accessMask' isInherited' inheritanceFlags' propagationFlags' flags' objectGuid' inheritedObjectGuid
Long Parameter List,System.DirectoryServices,ActiveDirectoryAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAccessRule,The method has 5 parameters. Parameters: identity' adRights' type' objectType' inheritanceType
Long Parameter List,System.DirectoryServices,ActiveDirectoryAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAccessRule,The method has 5 parameters. Parameters: identity' adRights' type' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,ActiveDirectoryAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAccessRule,The method has 6 parameters. Parameters: identity' adRights' type' objectType' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,ActiveDirectoryAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAccessRule,The method has 8 parameters. Parameters: identity' accessMask' type' objectType' isInherited' inheritanceFlags' propagationFlags' inheritedObjectType
Long Parameter List,System.DirectoryServices,CreateChildAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,CreateChildAccessRule,The method has 5 parameters. Parameters: identity' type' childType' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,DeleteChildAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,DeleteChildAccessRule,The method has 5 parameters. Parameters: identity' type' childType' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,PropertyAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,PropertyAccessRule,The method has 5 parameters. Parameters: identity' type' access' propertyType' inheritanceType
Long Parameter List,System.DirectoryServices,PropertyAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,PropertyAccessRule,The method has 5 parameters. Parameters: identity' type' access' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,PropertyAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,PropertyAccessRule,The method has 6 parameters. Parameters: identity' type' access' propertyType' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,PropertySetAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,PropertySetAccessRule,The method has 5 parameters. Parameters: identity' type' access' propertySetType' inheritanceType
Long Parameter List,System.DirectoryServices,PropertySetAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,PropertySetAccessRule,The method has 6 parameters. Parameters: identity' type' access' propertySetType' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,ExtendedRightAccessRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ExtendedRightAccessRule,The method has 5 parameters. Parameters: identity' type' extendedRightType' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,ActiveDirectoryAuditRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAuditRule,The method has 5 parameters. Parameters: identity' adRights' auditFlags' objectType' inheritanceType
Long Parameter List,System.DirectoryServices,ActiveDirectoryAuditRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAuditRule,The method has 5 parameters. Parameters: identity' adRights' auditFlags' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,ActiveDirectoryAuditRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAuditRule,The method has 6 parameters. Parameters: identity' adRights' auditFlags' objectType' inheritanceType' inheritedObjectType
Long Parameter List,System.DirectoryServices,ActiveDirectoryAuditRule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,ActiveDirectoryAuditRule,The method has 8 parameters. Parameters: identity' accessMask' auditFlags' objectGuid' isInherited' inheritanceFlags' propagationFlags' inheritedObjectType
Long Parameter List,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,DirectoryEntry,The method has 5 parameters. Parameters: path' useCache' username' password' authenticationType
Long Parameter List,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,DirectoryEntry,The method has 5 parameters. Parameters: adsObject' useCache' username' password' authenticationType
Long Parameter List,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,DirectoryEntry,The method has 6 parameters. Parameters: adsObject' useCache' username' password' authenticationType' AdsObjIsExternal
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The method has 5 parameters. Parameters: day' fromHour' fromMinute' toHour' toMinute
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The method has 5 parameters. Parameters: days' fromHour' fromMinute' toHour' toMinute
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,ActiveDirectorySchemaClass,The method has 5 parameters. Parameters: context' commonName' ldapDisplayName' classEntry' schemaEntry
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClassCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClassCollection.cs,ActiveDirectorySchemaClassCollection,The method has 6 parameters. Parameters: context' schemaClass' isBound' propertyName' classNames' onlyNames
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClassCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClassCollection.cs,ActiveDirectorySchemaClassCollection,The method has 5 parameters. Parameters: context' schemaClass' isBound' propertyName' classes
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,ActiveDirectorySchemaProperty,The method has 5 parameters. Parameters: context' commonName' ldapDisplayName' propertyEntry' schemaEntry
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaPropertyCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaPropertyCollection.cs,ActiveDirectorySchemaPropertyCollection,The method has 6 parameters. Parameters: context' schemaClass' isBound' propertyName' propertyNames' onlyNames
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaPropertyCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaPropertyCollection.cs,ActiveDirectorySchemaPropertyCollection,The method has 5 parameters. Parameters: context' schemaClass' isBound' propertyName' properties
Long Parameter List,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLink,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLink.cs,ActiveDirectorySiteLink,The method has 5 parameters. Parameters: context' siteLinkName' transport' existing' entry
Long Parameter List,System.DirectoryServices.ActiveDirectory,ADSearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADSearcher.cs,ADSearcher,The method has 6 parameters. Parameters: searchRoot' filter' propertiesToLoad' scope' pagedSearch' cacheResults
Long Parameter List,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,ApplicationPartition,The method has 5 parameters. Parameters: context' distinguishedName' dnsName' appType' directoryEntryMgr
Long Parameter List,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetReplicationInfoHelper,The method has 7 parameters. Parameters: dsHandle' type' secondaryType' partition' advanced' context' libHandle
Long Parameter List,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,ConstructReplicationCursors,The method has 6 parameters. Parameters: dsHandle' advanced' info' partition' server' libHandle
Long Parameter List,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,SyncReplicaAllHelper,The method has 6 parameters. Parameters: handle' syncAllFunctionPointer' partition' option' callback' libHandle
Long Parameter List,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,SyncReplicaHelper,The method has 6 parameters. Parameters: dsHandle' isADAM' partition' sourceServer' option' libHandle
Long Parameter List,System.DirectoryServices.ActiveDirectory,SyncFromAllServersErrorInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,SyncFromAllServersErrorInformation,The method has 5 parameters. Parameters: category' errorCode' errorMessage' sourceServer' targetServer
Long Parameter List,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DsGetDcNameWrapper,The method has 5 parameters. Parameters: computerName' domainName' siteName' flags' domainControllerInfo
Long Parameter List,System.DirectoryServices.ActiveDirectory,NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\NativeMethods.cs,DsGetDcName,The method has 6 parameters. Parameters: computerName' domainName' domainGuid' siteName' flags' domainControllerInfo
Long Parameter List,System.DirectoryServices.ActiveDirectory,NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\NativeMethods.cs,DsGetDcOpen,The method has 7 parameters. Parameters: dnsName' optionFlags' siteName' domainGuid' dnsForestName' dcFlags' retGetDcContext
Long Parameter List,System.DirectoryServices.ActiveDirectory,NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\NativeMethods.cs,DnsQuery,The method has 6 parameters. Parameters: recordName' recordType' options' servers' dnsResultList' reserved
Long Parameter List,System.DirectoryServices.ActiveDirectory,NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\NativeMethods.cs,LsaCallAuthenticationPackage,The method has 7 parameters. Parameters: lsaHandle' authenticationPackage' protocolSubmitBuffer' submitBufferLength' protocolReturnBuffer' returnBufferLength' protocolStatus
Long Parameter List,System.DirectoryServices.ActiveDirectory,NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\NativeMethods.cs,CompareString,The method has 6 parameters. Parameters: locale' dwCmpFlags' lpString1' cchCount1' lpString2' cchCount2
Long Parameter List,System.DirectoryServices.ActiveDirectory,ReplicationConnection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnection.cs,ReplicationConnection,The method has 5 parameters. Parameters: context' name' sourceServer' schedule' transport
Long Parameter List,System.DirectoryServices.ActiveDirectory,ReplicationCursor,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationCursor.cs,ReplicationCursor,The method has 6 parameters. Parameters: server' partition' guid' filter' time' dn
Long Parameter List,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,GetTrustedDomainInfoStatus,The method has 5 parameters. Parameters: context' sourceName' targetName' attribute' isForest
Long Parameter List,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,SetTrustedDomainInfoStatus,The method has 6 parameters. Parameters: context' sourceName' targetName' attribute' status' isForest
Long Parameter List,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,VerifyTrust,The method has 7 parameters. Parameters: context' sourceName' targetName' isForest' direction' forceSecureChannelReset' preferredTargetServer
Long Parameter List,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrust,The method has 7 parameters. Parameters: sourceContext' sourceName' targetContext' targetName' isForest' direction' password
Long Parameter List,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrust,The method has 5 parameters. Parameters: context' sourceName' targetName' password' isForest
Long Parameter List,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrustDirection,The method has 6 parameters. Parameters: context' sourceName' targetName' password' isForest' newTrustDirection
Long Parameter List,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrust,The method has 7 parameters. Parameters: handle' trustedDomainName' sourceName' targetName' isForest' direction' serverName
Long Parameter List,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,FormatMessageW,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' arguments
Long Parameter List,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,LogonUserW,The method has 6 parameters. Parameters: lpszUsername' lpszDomain' lpszPassword' dwLogonType' dwLogonProvider' phToken
Long Parameter List,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,LsaSetForestTrustInformation,The method has 5 parameters. Parameters: handle' target' forestTrustInfo' checkOnly' collisionInfo
Long Parameter List,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,I_NetLogonControl2,The method has 5 parameters. Parameters: serverName' FunctionCode' QueryLevel' data' buffer
Long Parameter List,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,LsaCreateTrustedDomainEx,The method has 5 parameters. Parameters: handle' domainEx' authInfo' classInfo' domainHandle
Long Parameter List,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,GetTokenInformation,The method has 5 parameters. Parameters: tokenHandle' tokenInformationClass' buffer' bufferSize' returnLength
Long Parameter List,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,LsaLookupSids,The method has 5 parameters. Parameters: policyHandle' count' sids' referencedDomains' names
Long Parameter List,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The method has 5 parameters. Parameters: searchRootEntry' filter' propertiesWithRangeRetrieval' propertiesWithoutRangeRetrieval' searchScope
Long Parameter List,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The method has 6 parameters. Parameters: context' partitionName' siteName' isDefaultNC' isADAM' isGC
Long Parameter List,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,Compare,The method has 6 parameters. Parameters: s1' offset1' length1' s2' offset2' length2
Long Parameter List,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,Compare,The method has 7 parameters. Parameters: s1' offset1' length1' s2' offset2' length2' compareFlags
Long Parameter List,System.DirectoryServices.Interop,SafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\SafeNativeMethods.cs,ADsGetLastError,The method has 5 parameters. Parameters: error' errorBuffer' errorBufferLength' nameBuffer' nameBufferLength
Long Parameter List,System.DirectoryServices.Interop,SafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\SafeNativeMethods.cs,FormatMessageW,The method has 7 parameters. Parameters: dwFlags' lpSource' dwMessageId' dwLanguageId' lpBuffer' nSize' arguments
Long Parameter List,System.DirectoryServices.Interop,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\UnsafeNativeMethods.cs,IntADsOpenObject,The method has 6 parameters. Parameters: path' userName' password' flags' iid' ppObject
Long Parameter List,System.DirectoryServices.Interop,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\UnsafeNativeMethods.cs,ADsOpenObject,The method has 6 parameters. Parameters: path' userName' password' flags' iid' ppObject
Long Identifier,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,,The length of the parameter directorySynchronizationSpecified is 33.
Long Identifier,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,,The length of the parameter directoryVirtualListViewSpecified is 33.
Long Identifier,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,Save,The length of the parameter alreadyUsingSchemaRoleOwnerContext is 34.
Long Identifier,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertiesFromSchemaContainer,The length of the parameter propertyNamesWithRangeRetrieval is 31.
Long Identifier,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertiesFromSchemaContainer,The length of the parameter propertyNamesWithoutRangeRetrieval is 34.
Long Identifier,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,,The length of the parameter _propertiesFromSchemaContainerInitialized is 41.
Long Identifier,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,Save,The length of the parameter alreadyUsingSchemaRoleOwnerContext is 34.
Long Identifier,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,,The length of the parameter _propertiesFromSchemaContainerInitialized is 41.
Long Identifier,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,,The length of the parameter s_presentationAddressOMObjectClass is 34.
Long Identifier,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,,The length of the parameter DS_REPSYNC_ASYNCHRONOUS_OPERATION is 33.
Long Identifier,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,,The length of the parameter DS_REPSYNCALL_ID_SERVERS_BY_DN is 30.
Long Identifier,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,,The length of the parameter DS_REPL_INFO_FLAG_IMPROVE_LINKED_ATTRS is 38.
Long Identifier,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,,The length of the parameter _cachedInfrastructureRoleOwner is 30.
Long Identifier,System.DirectoryServices.ActiveDirectory,NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\NativeMethods.cs,,The length of the parameter ERROR_INVALID_DOMAIN_NAME_FORMAT is 32.
Long Identifier,System.DirectoryServices.ActiveDirectory,NativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\NativeMethods.cs,,The length of the parameter DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING is 36.
Long Identifier,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,,The length of the parameter s_STATUS_OBJECT_NAME_NOT_FOUND is 30.
Long Identifier,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,,The length of the parameter s_NETLOGON_VERIFY_STATUS_RETURNED is 33.
Long Identifier,System.DirectoryServices.ActiveDirectory,DS_REPL_NEIGHBOR,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter uuidAsyncIntersiteTransportObjGuid is 34.
Long Identifier,System.DirectoryServices.ActiveDirectory,DS_REPL_ATTR_META_DATA_2,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter uuidLastOriginatingDsaInvocationID is 34.
Long Identifier,System.DirectoryServices.ActiveDirectory,DS_REPL_ATTR_META_DATA,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter uuidLastOriginatingDsaInvocationID is 34.
Long Identifier,System.DirectoryServices.ActiveDirectory,TRUSTED_DOMAIN_AUTH_INFORMATION,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter IncomingAuthenticationInformation is 33.
Long Identifier,System.DirectoryServices.ActiveDirectory,TRUSTED_DOMAIN_AUTH_INFORMATION,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter IncomingPreviousAuthenticationInformation is 41.
Long Identifier,System.DirectoryServices.ActiveDirectory,TRUSTED_DOMAIN_AUTH_INFORMATION,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter OutgoingAuthenticationInformation is 33.
Long Identifier,System.DirectoryServices.ActiveDirectory,TRUSTED_DOMAIN_AUTH_INFORMATION,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter OutgoingPreviousAuthenticationInformation is 41.
Long Identifier,System.DirectoryServices.ActiveDirectory,UnsafeNativeMethods,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\UnsafeNativeMethods.cs,,The length of the parameter FORMAT_MESSAGE_ALLOCATE_BUFFER is 30.
Long Identifier,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The length of the parameter propertiesWithoutRangeRetrieval is 31.
Long Identifier,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,,The length of the parameter s_LOGON32_LOGON_NEW_CREDENTIALS is 31.
Long Identifier,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,,The length of the parameter s_POLICY_VIEW_LOCAL_INFORMATION is 31.
Long Statement,System.DirectoryServices,ActiveDirectoryInheritanceTranslator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,GetInheritanceFlags,The length of the statement  "            if (inheritanceType < ActiveDirectorySecurityInheritance.None || inheritanceType > ActiveDirectorySecurityInheritance.Children) " is 127.
Long Statement,System.DirectoryServices,ActiveDirectoryInheritanceTranslator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,GetInheritanceFlags,The length of the statement  "                throw new InvalidEnumArgumentException("inheritanceType"' (int)inheritanceType' typeof(ActiveDirectorySecurityInheritance)); " is 124.
Long Statement,System.DirectoryServices,ActiveDirectoryInheritanceTranslator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,GetPropagationFlags,The length of the statement  "            if (inheritanceType < ActiveDirectorySecurityInheritance.None || inheritanceType > ActiveDirectorySecurityInheritance.Children) " is 127.
Long Statement,System.DirectoryServices,ActiveDirectoryInheritanceTranslator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectorySecurity.cs,GetPropagationFlags,The length of the statement  "                throw new InvalidEnumArgumentException("inheritanceType"' (int)inheritanceType' typeof(ActiveDirectorySecurityInheritance)); " is 124.
Long Statement,System.DirectoryServices,DirectoryEntries,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntries.cs,Add,The length of the statement  "            DirectoryEntry entry = new DirectoryEntry(newChild' _container.UsePropertyCache' _container.GetUsername()' _container.GetPassword()' _container.AuthenticationType); " is 164.
Long Statement,System.DirectoryServices,DirectoryEntries,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntries.cs,Find,The length of the statement  "            return new DirectoryEntry(o' _container.UsePropertyCache' _container.GetUsername()' _container.GetPassword()' _container.AuthenticationType); " is 141.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,Bind,The length of the statement  "                int hr = UnsafeNativeMethods.ADsOpenObject(pathToUse' GetUsername()' GetPassword()' (int)_authenticationType' ref g' out value); " is 128.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,CloneBrowsable,The length of the statement  "            DirectoryEntry newEntry = new DirectoryEntry(this.Path' this.UsePropertyCache' this.GetUsername()' this.GetPassword()' this.AuthenticationType); " is 144.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,Exists,The length of the statement  "                     e.ErrorCode == unchecked((int)0x80070003) ||   // ERROR_DS_NO_SUCH_OBJECT and path not found (not found in strict sense) " is 120.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,MoveTo,The length of the statement  "                    // get the ADsPath instead of using Path as ADsPath for the case that "WinNT://computername" is passed in while we need "WinNT://domain/computer" " is 145.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,MoveTo,The length of the statement  "                    // we know ADsPath does not end with object type qualifier like "'computer" so it is fine to compare with whole newparent's adspath " is 131.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,MoveTo,The length of the statement  "                    // for the case that child has different components from newparent in the aspects other than case' we don't do any processing' just let ADSI decide in case future adsi change " is 174.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,MoveTo,The length of the statement  "                    if (System.DirectoryServices.ActiveDirectory.Utils.Compare(childPath' 0' parentPath.Length' parentPath' 0' parentPath.Length) == 0) " is 131.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,MoveTo,The length of the statement  "                        if (System.DirectoryServices.ActiveDirectory.Utils.Compare(childPath' 0' parentPath.Length' parentPath' 0' parentPath.Length' compareFlags) != 0) " is 145.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,GetObjectSecurityFromCache,The length of the statement  "                    UnsafeNativeMethods.IAdsPropertyEntry propertyEntry = (UnsafeNativeMethods.IAdsPropertyEntry)list.GetPropertyItem(s_securityDescriptorProperty' (int)AdsType.ADSTYPE_OCTET_STRING); " is 179.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,SetObjectSecurityInCache,The length of the statement  "                UnsafeNativeMethods.IAdsPropertyValue sDValue = (UnsafeNativeMethods.IAdsPropertyValue)new UnsafeNativeMethods.PropertyValue(); " is 127.
Long Statement,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,SetObjectSecurityInCache,The length of the statement  "                UnsafeNativeMethods.IAdsPropertyEntry newSDEntry = (UnsafeNativeMethods.IAdsPropertyEntry)new UnsafeNativeMethods.PropertyEntry(); " is 130.
Long Statement,System.DirectoryServices,DirectoryEntryConfiguration,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntryConfiguration.cs,GetCurrentServerName,The length of the statement  "            // underneath it uses the same handle and binds to the same object' so no permission is required as it has been done in Bind call             " is 129.
Long Statement,System.DirectoryServices,DirectoryEntryConfiguration,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntryConfiguration.cs,GetCurrentServerName,The length of the statement  "            return (string)((UnsafeNativeMethods.IAdsObjectOptions)_entry.AdsObject).GetOption((int)AdsOptions.ADS_OPTION_SERVERNAME); " is 122.
Long Statement,System.DirectoryServices,DirectoryEntryConfiguration,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntryConfiguration.cs,IsMutuallyAuthenticated,The length of the statement  "                int val = (int)((UnsafeNativeMethods.IAdsObjectOptions)_entry.AdsObject).GetOption((int)AdsOptions.ADS_OPTION_MUTUAL_AUTH_STATUS); " is 130.
Long Statement,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,FindAll,The length of the statement  "            // this is a little bit hacky' but we need to perform a bind here' so we make sure the LDAP connection that we hold has more than " is 129.
Long Statement,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,FindAll,The length of the statement  "            // one reference count' one by SearchResultCollection object' one by DirectorySearcher object. In this way' when user calls " is 123.
Long Statement,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,FindAll,The length of the statement  "            // Dispose on SearchResultCollection' the connection is still there instead of reference count dropping to zero and being closed. " is 129.
Long Statement,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,FindAll,The length of the statement  "            // It is especially important for virtuallistview case' in order to reuse the vlv response' the search must be performed on the same ldap connection " is 148.
Long Statement,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,SetSearchPreferences,The length of the statement  "                info.vValue = new AdsValueHelper(DirectorySynchronization.GetDirectorySynchronizationCookie()' AdsType.ADSTYPE_PROV_SPECIFIC).GetStruct(); " is 138.
Long Statement,System.DirectoryServices,PropertyValueCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\PropertyValueCollection.cs,Remove,The length of the statement  "                    // exception is thrown because value does not exist in the current cache' but it actually might do exist just because it is a very " is 130.
Long Statement,System.DirectoryServices,SearchResult,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\SearchResult.cs,GetDirectoryEntry,The length of the statement  "                return new DirectoryEntry(Path' true' _parentCredentials.UserName' _parentCredentials.Password' _parentAuthenticationType); " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The length of the statement  "            if (fromMinute != MinuteOfHour.Zero && fromMinute != MinuteOfHour.Fifteen && fromMinute != MinuteOfHour.Thirty && fromMinute != MinuteOfHour.FortyFive) " is 151.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The length of the statement  "            if (toMinute != MinuteOfHour.Zero && toMinute != MinuteOfHour.Fifteen && toMinute != MinuteOfHour.Thirty && toMinute != MinuteOfHour.FortyFive) " is 143.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchema,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.ContextNotAssociatedWithDomain' typeof(ActiveDirectorySchema)' null); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchema,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ServerNotFound ' context.Name)' typeof(ActiveDirectorySchema)' null); " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchema,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ServerNotFound ' context.Name)' typeof(ActiveDirectorySchema)' null); " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchema,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ServerNotFound ' context.Name)' typeof(ActiveDirectorySchema)' null); " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,FindDefunctClass,The length of the statement  "            Hashtable propertiesFromServer = ActiveDirectorySchemaClass.GetPropertiesFromSchemaContainer(context' _schemaEntry' commonName' true /* isDefunctOnServer */); " is 158.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,FindDefunctClass,The length of the statement  "            ActiveDirectorySchemaClass schemaClass = new ActiveDirectorySchemaClass(context' commonName' propertiesFromServer' _schemaEntry); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,FindDefunctProperty,The length of the statement  "            SearchResult propertiesFromServer = ActiveDirectorySchemaProperty.GetPropertiesFromSchemaContainer(context' _schemaEntry' commonName' true /* isDefunctOnServer */); " is 164.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,FindDefunctProperty,The length of the statement  "            ActiveDirectorySchemaProperty schemaProperty = new ActiveDirectorySchemaProperty(context' commonName' propertiesFromServer' _schemaEntry); " is 138.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchemaRoleOwner,The length of the statement  "                    string adamInstName = Utils.GetAdamDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' _schemaEntry' PropertyManager.FsmoRoleOwner)); " is 161.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchemaRoleOwner,The length of the statement  "                    DirectoryContext adamInstContext = Utils.GetNewDirectoryContext(adamInstName' DirectoryContextType.DirectoryServer' context); " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchemaRoleOwner,The length of the statement  "                        string dcName = Utils.GetDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' _schemaEntry' PropertyManager.FsmoRoleOwner)); " is 151.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchemaRoleOwner,The length of the statement  "                        string adamInstName = Utils.GetAdamDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' _schemaEntry' PropertyManager.FsmoRoleOwner)); " is 161.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetSchemaRoleOwner,The length of the statement  "                        DirectoryContext adamInstContext = Utils.GetNewDirectoryContext(adamInstName' DirectoryContextType.DirectoryServer' context); " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,Save,The length of the statement  "                            DirectoryContext schemaRoleOwnerContext = Utils.GetNewDirectoryContext(schemaRoleOwner.Name' DirectoryContextType.DirectoryServer' _context); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,InitializePropertiesFromSchemaContainer,The length of the statement  "                _propertyValuesFromServer = GetPropertiesFromSchemaContainer(_context' _schemaEntry' (_isDefunctOnServer) ? _commonName : _ldapDisplayName' _isDefunctOnServer); " is 160.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertiesFromSchemaContainer,The length of the statement  "                propertyValuesFromServer = Utils.GetValuesWithRangeRetrieval(schemaEntry' str.ToString()' propertyNamesWithRangeRetrieval' propertyNamesWithoutRangeRetrieval' SearchScope.OneLevel); " is 181.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetSchemaClassDirectoryEntry,The length of the statement  "                _classEntry = DirectoryEntryManager.GetDirectoryEntry(_context' (string)GetValueFromCache(PropertyManager.DistinguishedName' true)); " is 132.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetClasses,The length of the statement  "                string filter = "(&(" + PropertyManager.ObjectCategory + "=classSchema)" + str.ToString() + "(!(" + PropertyManager.IsDefunct + "=TRUE)))"; " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetProperties,The length of the statement  "                string filter = "(&(" + PropertyManager.ObjectCategory + "=attributeSchema)" + str.ToString() + "(!(" + PropertyManager.IsDefunct + "=TRUE)))"; " is 143.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetProperties,The length of the statement  "                    ActiveDirectorySchemaProperty schemaProperty = new ActiveDirectorySchemaProperty(_context' ldapDisplayName' de' _schemaEntry); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertyValuesRecursively,The length of the statement  "                    ActiveDirectorySchemaClass auxSchemaClass = new ActiveDirectorySchemaClass(_context' auxSchemaClassName' (DirectoryEntry)null' null); " is 133.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertyValuesRecursively,The length of the statement  "                    ActiveDirectorySchemaClass auxSchemaClass = new ActiveDirectorySchemaClass(_context' auxSchemaClassName' (DirectoryEntry)null' null); " is 133.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,Save,The length of the statement  "                            DirectoryContext schemaRoleOwnerContext = Utils.GetNewDirectoryContext(schemaRoleOwner.Name' DirectoryContextType.DirectoryServer' _context); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,InitializePropertiesFromSchemaContainer,The length of the statement  "                _propertyValuesFromServer = GetPropertiesFromSchemaContainer(_context' _schemaEntry' (_isDefunctOnServer) ? _commonName : _ldapDisplayName' _isDefunctOnServer); " is 160.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The length of the statement  "            ADSearcher searcher = new ADSearcher(schemaEntry' str.ToString()' propertiesToLoad' SearchScope.OneLevel' false /* paged search */' false /* cache results */); " is 159.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetSchemaPropertyDirectoryEntry,The length of the statement  "                _propertyEntry = DirectoryEntryManager.GetDirectoryEntry(_context' (string)GetValueFromCache(PropertyManager.DistinguishedName' true)); " is 135.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaPropertyCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaPropertyCollection.cs,OnValidate,The length of the statement  "                throw new InvalidOperationException(SR.Format(SR.SchemaObjectNotCommitted ' ((ActiveDirectorySchemaProperty)value).Name)); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,FindByName,The length of the statement  "                sitedn = "CN=Sites'" + (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.ConfigurationNamingContext); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetComputerSite,The length of the statement  "                    string forestName = Locator.GetDomainControllerInfo(null' null' null' (long)PrivateLocatorFlags.DirectoryServicesRequired).DnsForestName; " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,Save,The length of the statement  "                            string ntdsaName = (server is DomainController) ? ((DomainController)server).NtdsaObjectName : ((AdamInstance)server).NtdsaObjectName; " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,Save,The length of the statement  "                            string ntdsaName = (replica is DomainController) ? ((DomainController)replica).NtdsaObjectName : ((AdamInstance)replica).NtdsaObjectName; " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The length of the statement  "                string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName); " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The length of the statement  "                                hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName)); " is 196.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The length of the statement  "                                string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2); " is 140.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The length of the statement  "                                string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4); " is 133.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The length of the statement  "                        replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The length of the statement  "                        replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,ValidateArgument,The length of the statement  "            // if target is not specified' then we determin the target from the logon credential' so if it is a local user context' it should fail " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetSubnets,The length of the statement  "                                                  "(&(objectClass=subnet)(objectCategory=subnet)(siteObject=" + Utils.GetEscapedFilterValue((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName)) + "))"' " is 196.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetAdjacentSites,The length of the statement  "                                                  "(&(objectClass=siteLink)(objectCategory=SiteLink)(siteList=" + Utils.GetEscapedFilterValue((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName)) + "))"' " is 198.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetLinks,The length of the statement  "                                                  "(&(objectClass=siteLink)(objectCategory=SiteLink)(siteList=" + Utils.GetEscapedFilterValue((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName)) + "))"' " is 198.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetLinks,The length of the statement  "                    string transport = Utils.GetDNComponents((string)PropertyManager.GetSearchResultPropertyValue(result' PropertyManager.DistinguishedName))[1].Value; " is 147.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetDomains,The length of the statement  "                DomainController dc = DomainController.GetDomainController(Utils.GetNewDirectoryContext(serverName' DirectoryContextType.DirectoryServer' context)); " is 148.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetDomains,The length of the statement  "                UnsafeNativeMethods.DsListDomainsInSiteW dsListDomainsInSiteW = (UnsafeNativeMethods.DsListDomainsInSiteW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsListDomainsInSiteW)); " is 207.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetDomains,The length of the statement  "                int result = dsListDomainsInSiteW(handle' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName)' ref info); " is 151.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetDomains,The length of the statement  "                            if (nameResult.status == DS_NAME_ERROR.DS_NAME_NO_ERROR || nameResult.status == DS_NAME_ERROR.DS_NAME_ERROR_DOMAIN_ONLY) " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetDomains,The length of the statement  "                    UnsafeNativeMethods.DsFreeNameResultW dsFreeNameResultW = (UnsafeNativeMethods.DsFreeNameResultW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsFreeNameResultW)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetServers,The length of the statement  "                        replica = new AdamInstance(Utils.GetNewDirectoryContext(fullHostName' DirectoryContextType.DirectoryServer' context)' fullHostName); " is 132.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetServers,The length of the statement  "                        replica = new DomainController(Utils.GetNewDirectoryContext(hostName' DirectoryContextType.DirectoryServer' context)' hostName); " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetPreferredBridgeheadServers,The length of the statement  "            string serverContainerDN = "CN=Servers'" + PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName); " is 133.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetPreferredBridgeheadServers,The length of the statement  "                                                  "(&(objectClass=server)(objectCategory=Server)(bridgeheadTransportList=" + Utils.GetEscapedFilterValue(transportDN) + "))"' " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetPreferredBridgeheadServers,The length of the statement  "                        replica = new AdamInstance(Utils.GetNewDirectoryContext(fullHostName' DirectoryContextType.DirectoryServer' context)' fullHostName); " is 132.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetPreferredBridgeheadServers,The length of the statement  "                        replica = new DomainController(Utils.GetNewDirectoryContext(hostName' DirectoryContextType.DirectoryServer' context)' hostName); " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,Contains,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(site.context' site.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,Contains,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,IndexOf,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(site.context' site.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,IndexOf,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,Remove,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(site.context' site.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,Remove,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,OnInsertComplete,The length of the statement  "                string dn = (string)PropertyManager.GetPropertyValue(site.context' site.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,OnRemoveComplete,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(site.context' site.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteCollection.cs,OnSetComplete,The length of the statement  "            string newdn = (string)PropertyManager.GetPropertyValue(newsite.context' newsite.cachedEntry' PropertyManager.DistinguishedName); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLink,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLink.cs,FindByName,The length of the statement  "                    if (Utils.CheckCapability(tmpDE' Capability.ActiveDirectoryApplicationMode) && transport == ActiveDirectoryTransportType.Smtp) " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLink,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLink.cs,ValidateArgument,The length of the statement  "            // if target is not specified' then we determin the target from the logon credential' so if it is a local user context' it should fail " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkBridge,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkBridge.cs,FindByName,The length of the statement  "                    Exception e = new ActiveDirectoryObjectNotFoundException(SR.DSNotFound' typeof(ActiveDirectorySiteLinkBridge)' bridgeName); " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkBridge,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkBridge.cs,FindByName,The length of the statement  "                    if (Utils.CheckCapability(tmpDE' Capability.ActiveDirectoryApplicationMode) && transport == ActiveDirectoryTransportType.Smtp) " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkBridge,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkBridge.cs,ValidateArgument,The length of the statement  "            // if target is not specified' then we determin the target from the logon credential' so if it is a local user context' it should fail " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,Contains,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(link.context' link.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,Contains,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,IndexOf,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(link.context' link.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,IndexOf,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,Remove,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(link.context' link.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,Remove,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,OnInsertComplete,The length of the statement  "                string dn = (string)PropertyManager.GetPropertyValue(link.context' link.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,OnRemoveComplete,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(link.context' link.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkCollection.cs,OnSetComplete,The length of the statement  "            string newdn = (string)PropertyManager.GetPropertyValue(newLink.context' newLink.cachedEntry' PropertyManager.DistinguishedName); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnet.cs,ValidateArgument,The length of the statement  "            // if target is not specified' then we determin the target from the logon credential' so if it is a local user context' it should fail " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,Contains,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(subnet.context' subnet.cachedEntry' PropertyManager.DistinguishedName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,Contains,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,IndexOf,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(subnet.context' subnet.cachedEntry' PropertyManager.DistinguishedName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,IndexOf,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,Remove,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(subnet.context' subnet.cachedEntry' PropertyManager.DistinguishedName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,Remove,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,OnInsertComplete,The length of the statement  "                string dn = (string)PropertyManager.GetPropertyValue(subnet.context' subnet.cachedEntry' PropertyManager.DistinguishedName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnetCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnetCollection.cs,OnRemoveComplete,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(subnet.context' subnet.cachedEntry' PropertyManager.DistinguishedName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,Syntax,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySyntax.cs,Equals,The length of the statement  "                    || ((this.oMObjectClass != null) && (syntax.oMObjectClass != null) && (!this.oMObjectClass.Equals(syntax.oMObjectClass)))) " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetAdamInstance,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.AINotFound ' context.Name)' typeof(AdamInstance)' context.Name); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetAdamInstance,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.AINotFound ' context.Name)' typeof(AdamInstance)' context.Name); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetAdamInstance,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.AINotFound ' context.Name)' typeof(AdamInstance)' context.Name); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetReplicationCursors,The length of the statement  "            info = GetReplicationInfoHelper(_ADAMHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_CURSORS_3_FOR_NC' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_CURSORS_FOR_NC' partition' ref advanced' context' DirectoryContext.ADAMHandle); " is 214.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetReplicationOperationInformation,The length of the statement  "            info = GetReplicationInfoHelper(_ADAMHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_PENDING_OPS' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_PENDING_OPS' null' ref advanced' 0' DirectoryContext.ADAMHandle); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetReplicationNeighbors,The length of the statement  "            info = GetReplicationInfoHelper(_ADAMHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' partition' ref advanced' 0' DirectoryContext.ADAMHandle); " is 196.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetAllReplicationNeighbors,The length of the statement  "            info = GetReplicationInfoHelper(_ADAMHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' null' ref advanced' 0' DirectoryContext.ADAMHandle); " is 191.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,GetReplicationMetadata,The length of the statement  "            info = GetReplicationInfoHelper(_ADAMHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_METADATA_2_FOR_OBJ' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_METADATA_FOR_OBJ' objectPath' ref advanced' 0' DirectoryContext.ADAMHandle); " is 213.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,TriggerSyncReplicaFromNeighbors,The length of the statement  "            SyncReplicaHelper(_ADAMHandle' true' partition' null' DS_REPSYNC_ASYNCHRONOUS_OPERATION | DS_REPSYNC_ALL_SOURCES' DirectoryContext.ADAMHandle); " is 143.
Long Statement,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,SyncReplicaFromAllServers,The length of the statement  "            SyncReplicaAllHelper(_ADAMHandle' _syncAllFunctionPointer' partition' options' SyncFromAllServersCallback' DirectoryContext.ADAMHandle); " is 136.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,GetApplicationPartition,The length of the statement  "            return new ApplicationPartition(context' distinguishedName' context.Name' ApplicationPartitionType.ADApplicationPartition' directoryEntryMgr); " is 142.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The length of the statement  "                partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The length of the statement  "            ADSearcher searcher = new ADSearcher(partitionsEntry' filter' propertiesToLoad' SearchScope.OneLevel' false /*not paged search*/' false /*no cached results*/); " is 159.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The length of the statement  "                appNCDnsName = (res.Properties[PropertyManager.DnsRoot].Count > 0) ? (string)res.Properties[PropertyManager.DnsRoot][0] : null; " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The length of the statement  "                    errorCode = Locator.DsGetDcNameWrapper(null' appNCDnsName' null' (long)PrivateLocatorFlags.OnlyLDAPNeeded' out domainControllerInfo); " is 133.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The length of the statement  "                    Debug.Assert(domainControllerInfo.DomainControllerName.Length > 2' "ApplicationPartition:FindByName - domainControllerInfo.DomainControllerName.Length <= 2"); " is 158.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The length of the statement  "            partition = new ApplicationPartition(appNCContext' (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.NCName)' appNCDnsName' appType' directoryEntryMgr); " is 176.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Delete,The length of the statement  "            DirectoryEntry partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 152.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Save,The length of the statement  "                string primaryServerNtdsaName = (string)PropertyManager.GetPropertyValue(context' rootDSE' PropertyManager.DsServiceName); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Save,The length of the statement  "                string crossRefDN = (string)PropertyManager.GetPropertyValue(context' _crossRefEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Save,The length of the statement  "                DirectoryContext fsmoContext = Utils.GetNewDirectoryContext(GetNamingRoleOwner()' DirectoryContextType.DirectoryServer' context); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Save,The length of the statement  "                        _crossRefEntry.Properties[PropertyManager.MsDSNCReplicaLocations].AddRange(_cachedDirectoryServers.GetMultiValuedProperty()); " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,Save,The length of the statement  "                        Debug.Assert(_crossRefEntry != null' "ApplicationPartition::Save - crossRefEntry on already committed partition which is being modified is null."); " is 147.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,ValidateApplicationPartitionParameters,The length of the statement  "            // Utils.GetDnsNameFromDN will throw an ArgumentException if the dn is not valid (cannot be syntactically converted to dns name) " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,CreateApplicationPartition,The length of the statement  "                    tempEntry = new DirectoryEntry("LDAP://" + context.GetServerName() + "/" + distinguishedName' context.UserName' context.Password' authType); " is 140.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,CreateApplicationPartition,The length of the statement  "                    _domainDNSEntry.Properties[PropertyManager.InstanceType].Value = NCFlags.InstanceTypeIsNCHead | NCFlags.InstanceTypeIsWriteable; " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,CreateApplicationPartition,The length of the statement  "                        tempEntry = new DirectoryEntry("LDAP://" + context.Name + "/" + distinguishedName' context.UserName' context.Password' authType); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,CreateApplicationPartition,The length of the statement  "                        _domainDNSEntry.Properties[PropertyManager.InstanceType].Value = NCFlags.InstanceTypeIsNCHead | NCFlags.InstanceTypeIsWriteable; " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,InitializeCrossRef,The length of the statement  "                DirectoryContext roleOwnerContext = Utils.GetNewDirectoryContext(namingFsmoName' DirectoryContextType.DirectoryServer' context); " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,GetCrossRefEntry,The length of the statement  "            DirectoryEntry partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 152.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,GetNamingRoleOwner,The length of the statement  "            DirectoryEntry partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 152.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,GetNamingRoleOwner,The length of the statement  "                    namingFsmo = Utils.GetDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' partitionsEntry' PropertyManager.FsmoRoleOwner)); " is 151.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,GetNamingRoleOwner,The length of the statement  "                    namingFsmo = Utils.GetAdamDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' partitionsEntry' PropertyManager.FsmoRoleOwner)); " is 155.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindDirectoryServerInternal,The length of the statement  "            errorCode = Locator.DsGetDcNameWrapper(null' _dnsName' siteName' (long)flag | (long)PrivateLocatorFlags.OnlyLDAPNeeded' out domainControllerInfo); " is 146.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindDirectoryServerInternal,The length of the statement  "            Debug.Assert(domainControllerInfo.DomainControllerName.Length > 2' "ApplicationPartition:FindDirectoryServerInternal - domainControllerInfo.DomainControllerName.Length <= 2"); " is 175.
Long Statement,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindAllDirectoryServersInternal,The length of the statement  "            foreach (string dcName in Utils.GetReplicaList(context' Name' siteName' false /* isDefaultNC */' false /* isADAM */' false /* mustBeGC */)) " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetConfigurationSet,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.AINotFound ' context.Name)' typeof(ConfigurationSet)' null); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetConfigurationSet,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.AINotFound ' context.Name)' typeof(ConfigurationSet)' null); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetConfigurationSet,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.AINotFound ' context.Name)' typeof(ConfigurationSet)' null); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetSecurityLevel,The length of the statement  "                _cachedSecurityLevel = (ReplicationSecurityLevel)((int)PropertyManager.GetPropertyValue(_context' configEntry' PropertyManager.MsDSReplAuthenticationMode)); " is 156.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,SetSecurityLevel,The length of the statement  "            if (securityLevel < ReplicationSecurityLevel.NegotiatePassThrough || securityLevel > ReplicationSecurityLevel.MutualAuthentication) " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetSearchRootEntry,The length of the statement  "                string isGCReady = (string)PropertyManager.GetPropertyValue(forestContext' rootDSE' PropertyManager.IsGlobalCatalogReady); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetSearchRootEntry,The length of the statement  "                    rootEntry = new DirectoryEntry("GC://" + forestContext.GetServerName()' forestContext.UserName' forestContext.Password' authType); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetSearchRootEntry,The length of the statement  "                    rootEntry = new DirectoryEntry("LDAP://" + forestContext.GetServerName()' forestContext.UserName' forestContext.Password' authType); " is 132.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAnyAdamInstance,The length of the statement  "                ADSearcher searcher = new ADSearcher(rootEntry' filter' propertiesToLoad' SearchScope.Subtree' false /*not paged search*/' false /*no cached results*/); " is 152.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAnyAdamInstance,The length of the statement  "                            if ((bindingInfo.Length > prefix.Length) && (String.Compare(bindingInfo.Substring(0' prefix.Length)' prefix' StringComparison.OrdinalIgnoreCase) == 0)) " is 151.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindOneAdamInstance,The length of the statement  "            ArrayList ntdsaNames = Utils.GetReplicaList(context' partitionName' siteName' false /* isDefaultNC */' true /* isADAM */' false /* mustBeGC */); " is 144.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAdamInstances,The length of the statement  "            foreach (string adamInstanceName in Utils.GetReplicaList(context' partitionName' siteName' false /* isDefaultNC */' true /* isADAM */' false /* mustBeGC */)) " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAdamInstances,The length of the statement  "                DirectoryContext adamInstContext = Utils.GetNewDirectoryContext(adamInstanceName' DirectoryContextType.DirectoryServer' context); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAliveAdamInstance,The length of the statement  "                DirectoryContext adamInstContext = Utils.GetNewDirectoryContext(adamInstanceName' DirectoryContextType.DirectoryServer' context); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAliveAdamInstance,The length of the statement  "                    // if this is server down /server busy / server unavailable / timeout  exception we should just eat this up and try the next one " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAliveAdamInstance,The length of the statement  "                            throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ADAMInstanceNotFoundInConfigSet ' (configSetName != null) ? configSetName : context.Name)' typeof(AdamInstance)' null); " is 181.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAliveAdamInstance,The length of the statement  "            throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ADAMInstanceNotFoundInConfigSet ' (configSetName != null) ? configSetName : context.Name)' typeof(AdamInstance)' null); " is 181.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetRoleOwner,The length of the statement  "                adamInstName = Utils.GetAdamDnsHostNameFromNTDSA(_context' (string)PropertyManager.GetPropertyValue(_context' entry' PropertyManager.FsmoRoleOwner)); " is 149.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetRoleOwner,The length of the statement  "            DirectoryContext adamInstContext = Utils.GetNewDirectoryContext(adamInstName' DirectoryContextType.DirectoryServer' _context); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetSites,The length of the statement  "                    sites.Add(new ActiveDirectorySite(_context' (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.Cn)' true)); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetApplicationPartitions,The length of the statement  "                string schemaNamingContext = (string)PropertyManager.GetPropertyValue(_context' rootDSE' PropertyManager.SchemaNamingContext); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetApplicationPartitions,The length of the statement  "                string configurationNamingContext = (string)PropertyManager.GetPropertyValue(_context' rootDSE' PropertyManager.ConfigurationNamingContext); " is 140.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetApplicationPartitions,The length of the statement  "                            string replicaName = Utils.GetAdamDnsHostNameFromNTDSA(_context' (string)replicaLocations[Utils.GetRandomIndex(replicaLocations.Count)]); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetApplicationPartitions,The length of the statement  "                            DirectoryContext appNCContext = Utils.GetNewDirectoryContext(replicaName' DirectoryContextType.DirectoryServer' _context); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetApplicationPartitions,The length of the statement  "                            appNCs.Add(new ApplicationPartition(appNCContext' nCName' null' ApplicationPartitionType.ADAMApplicationPartition' new DirectoryEntryManager(appNCContext))); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "            if ((contextType == DirectoryContextType.Domain) || ((contextType == DirectoryContextType.Forest) && (context.Name == null))) " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                    errorCode = Locator.DsGetDcNameWrapper(null' tmpTarget' null' (long)PrivateLocatorFlags.DirectoryServicesRequired' out domainControllerInfo); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                        errorCode = Locator.DsGetDcNameWrapper(null' tmpTarget' null' (long)PrivateLocatorFlags.DirectoryServicesRequired | (long)LocatorOptions.ForceRediscovery' out domainControllerInfo); " is 181.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                errorCode = Locator.DsGetDcNameWrapper(null' context.Name' null' (long)(PrivateLocatorFlags.GCRequired | PrivateLocatorFlags.DirectoryServicesRequired)' out domainControllerInfo); " is 179.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                    errorCode = Locator.DsGetDcNameWrapper(null' context.Name' null' (long)((PrivateLocatorFlags.GCRequired | PrivateLocatorFlags.DirectoryServicesRequired)) | (long)LocatorOptions.ForceRediscovery' out domainControllerInfo); " is 221.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                errorCode = Locator.DsGetDcNameWrapper(null' context.Name' null' (long)PrivateLocatorFlags.OnlyLDAPNeeded' out domainControllerInfo); " is 133.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                    errorCode = Locator.DsGetDcNameWrapper(null' context.Name' null' (long)PrivateLocatorFlags.OnlyLDAPNeeded | (long)LocatorOptions.ForceRediscovery' out domainControllerInfo); " is 173.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                DirectoryEntry de = new DirectoryEntry("WinNT://" + tempServerName + "'computer"' context.UserName' context.Password' Utils.DefaultAuthType); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,IsContextValid,The length of the statement  "                    if ((e.ErrorCode == unchecked((int)0x80070035)) || (e.ErrorCode == unchecked((int)0x80070033)) || (e.ErrorCode == unchecked((int)0x80005000))) " is 142.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,isCurrentForest,The length of the statement  "            DomainControllerInfo domainControllerInfo = Locator.GetDomainControllerInfo(null' _name' null' (long)(PrivateLocatorFlags.DirectoryServicesRequired | PrivateLocatorFlags.ReturnDNSName)); " is 186.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,isCurrentForest,The length of the statement  "            int errorCode = Locator.DsGetDcNameWrapper(null' loggedOnDomain' null' (long)(PrivateLocatorFlags.DirectoryServicesRequired | PrivateLocatorFlags.ReturnDNSName)' out currentDomainControllerInfo); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,useServerBind,The length of the statement  "            return ((ContextType == DirectoryContextType.DirectoryServer) || (ContextType == DirectoryContextType.ConfigurationSet)); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,GetLoggedOnDomain,The length of the statement  "                result = NativeMethods.LsaCallAuthenticationPackage(lsaHandle' 0' requestBuffer' requestBufferLength' out pResponseBuffer' out responseBufferLength' out protocolStatus); " is 169.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,GetLoggedOnDomain,The length of the statement  "                        Debug.Assert((responseBuffer.callerName != null)' "NativeMethods.LsaCallAuthenticationPackage returned null callerName."); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,GetLoggedOnDomain,The length of the statement  "                        Debug.Assert((index != -1)' "NativeMethods.LsaCallAuthenticationPackage returned callerName not in domain\\username format."); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,GetLoggedOnDomain,The length of the statement  "                        else if ((result == 0) && (UnsafeNativeMethods.LsaNtStatusToWinError(protocolStatus) == NativeMethods.ERROR_NO_SUCH_LOGON_SESSION)) " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,GetLoggedOnDomain,The length of the statement  "                            throw ExceptionHelper.GetExceptionFromErrorCode(UnsafeNativeMethods.LsaNtStatusToWinError((result != 0) ? result : protocolStatus)); " is 132.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,GetDnsDomainName,The length of the statement  "            errorCode = Locator.DsGetDcNameWrapper(null' domainName' null' (long)PrivateLocatorFlags.DirectoryServicesRequired' out domainControllerInfo); " is 142.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryContext,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryContext.cs,GetDnsDomainName,The length of the statement  "                errorCode = Locator.DsGetDcNameWrapper(null' domainName' null' (long)((long)PrivateLocatorFlags.DirectoryServicesRequired | (long)LocatorOptions.ForceRediscovery)' out domainControllerInfo); " is 190.
Long Statement,System.DirectoryServices.ActiveDirectory,DistinguishedName,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryEntryManager.cs,GetHashCode,The length of the statement  "                hashCode = hashCode + Components[i].Name.ToUpperInvariant().GetHashCode() + Components[i].Value.ToUpperInvariant().GetHashCode(); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryEntryManager,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryEntryManager.cs,ExpandWellKnownDN,The length of the statement  "                        distinguishedName = (string)PropertyManager.GetPropertyValue(_context' rootDSE' PropertyManager.RootDomainNamingContext); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryEntryManager,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryEntryManager.cs,ExpandWellKnownDN,The length of the statement  "                        distinguishedName = (string)PropertyManager.GetPropertyValue(_context' rootDSE' PropertyManager.ConfigurationNamingContext); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryEntryManager,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryEntryManager.cs,ExpandWellKnownDN,The length of the statement  "                            distinguishedName = (string)PropertyManager.GetPropertyValue(context' rootDSE' PropertyManager.RootDomainNamingContext); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryEntryManager,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryEntryManager.cs,ExpandWellKnownDN,The length of the statement  "                            distinguishedName = (string)PropertyManager.GetPropertyValue(context' rootDSE' PropertyManager.ConfigurationNamingContext); " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,MoveToAnotherSite,The length of the statement  "                    string serverName = (this is DomainController) ? ((DomainController)this).ServerObjectName : ((AdamInstance)this).ServerObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetDirectoryEntry,The length of the statement  "            string serverName = (this is DomainController) ? ((DomainController)this).ServerObjectName : ((AdamInstance)this).ServerObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetPartitions,The length of the statement  "                string ntdsaName = (this is DomainController) ? ((DomainController)this).NtdsaObjectName : ((AdamInstance)this).NtdsaObjectName; " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetPartitions,The length of the statement  "                ArrayList readOnlyPartitions = (ArrayList)values[PropertyManager.HasPartialReplicaNCs.ToLower(CultureInfo.InvariantCulture)]; " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,CheckConsistencyHelper,The length of the statement  "            UnsafeNativeMethods.DsReplicaConsistencyCheck replicaConsistencyCheck = (UnsafeNativeMethods.DsReplicaConsistencyCheck)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsReplicaConsistencyCheck)); " is 225.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetReplicationInfoHelper,The length of the statement  "                UnsafeNativeMethods.DsReplicaGetInfoW dsReplicaGetInfoW = (UnsafeNativeMethods.DsReplicaGetInfoW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsReplicaGetInfoW)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetReplicationInfoHelper,The length of the statement  "                UnsafeNativeMethods.DsReplicaGetInfo2W dsReplicaGetInfo2W = (UnsafeNativeMethods.DsReplicaGetInfo2W)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsReplicaGetInfo2W)); " is 199.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetReplicationInfoHelper,The length of the statement  "                UnsafeNativeMethods.DsReplicaGetInfoW dsReplicaGetInfoW = (UnsafeNativeMethods.DsReplicaGetInfoW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsReplicaGetInfoW)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,ConstructReplicationCursors,The length of the statement  "                    info = GetReplicationInfoHelper(dsHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_CURSORS_3_FOR_NC' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_CURSORS_FOR_NC' partition' ref advanced' context' libHandle); " is 193.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,SyncReplicaAllHelper,The length of the statement  "            UnsafeNativeMethods.DsReplicaSyncAllW dsReplicaSyncAllW = (UnsafeNativeMethods.DsReplicaSyncAllW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsReplicaSyncAllW)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,SyncReplicaAllHelper,The length of the statement  "            int result = dsReplicaSyncAllW(handle' partition' (int)option | DS_REPSYNCALL_ID_SERVERS_BY_DN' syncAllFunctionPointer' (IntPtr)0' ref errorInfo); " is 146.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,FreeReplicaInfo,The length of the statement  "                UnsafeNativeMethods.DsReplicaFreeInfo dsReplicaFreeInfo = (UnsafeNativeMethods.DsReplicaFreeInfo)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsReplicaFreeInfo)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,SyncReplicaHelper,The length of the statement  "                    DirectoryContext newContext = Utils.GetNewDirectoryContext(sourceServer' DirectoryContextType.DirectoryServer' context); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,SyncReplicaHelper,The length of the statement  "                UnsafeNativeMethods.DsReplicaSyncW dsReplicaSyncW = (UnsafeNativeMethods.DsReplicaSyncW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsReplicaSyncW)); " is 183.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetInboundConnectionsHelper,The length of the statement  "                string serverName = (this is DomainController) ? ((DomainController)this).ServerObjectName : ((AdamInstance)this).ServerObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetInboundConnectionsHelper,The length of the statement  "                DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(Utils.GetNewDirectoryContext(Name' DirectoryContextType.DirectoryServer' context)' srchDN); " is 151.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetInboundConnectionsHelper,The length of the statement  "                        ReplicationConnection con = new ReplicationConnection(newContext' r.GetDirectoryEntry()' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.Cn)); " is 166.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetOutboundConnectionsHelper,The length of the statement  "                string siteName = (this is DomainController) ? ((DomainController)this).SiteObjectName : ((AdamInstance)this).SiteObjectName; " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetOutboundConnectionsHelper,The length of the statement  "                DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(Utils.GetNewDirectoryContext(Name' DirectoryContextType.DirectoryServer' context)' siteName); " is 153.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetOutboundConnectionsHelper,The length of the statement  "                string serverName = (this is DomainController) ? ((DomainController)this).ServerObjectName : ((AdamInstance)this).ServerObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServer,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServer.cs,GetOutboundConnectionsHelper,The length of the statement  "                        ReplicationConnection con = new ReplicationConnection(newContext' result.GetDirectoryEntry()' (string)result.Properties["cn"][0]); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,Add,The length of the statement  "                string siteName = (server is DomainController) ? ((DomainController)server).SiteObjectName : ((AdamInstance)server).SiteObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,Insert,The length of the statement  "                string siteName = (server is DomainController) ? ((DomainController)server).SiteObjectName : ((AdamInstance)server).SiteObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,OnInsertComplete,The length of the statement  "                        string ntdsaName = (server is DomainController) ? ((DomainController)server).NtdsaObjectName : ((AdamInstance)server).NtdsaObjectName; " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,OnInsertComplete,The length of the statement  "                string serverName = (server is DomainController) ? ((DomainController)server).ServerObjectName : ((AdamInstance)server).ServerObjectName; " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,OnRemoveComplete,The length of the statement  "                        string ntdsaName = (value is DomainController) ? ((DomainController)value).NtdsaObjectName : ((AdamInstance)value).NtdsaObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,OnRemoveComplete,The length of the statement  "                string serverName = (server is DomainController) ? ((DomainController)server).ServerObjectName : ((AdamInstance)server).ServerObjectName; " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,GetMultiValuedProperty,The length of the statement  "                string ntdsaName = (ds is DomainController) ? ((DomainController)ds).NtdsaObjectName : ((AdamInstance)ds).NtdsaObjectName; " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionalityLevel,The length of the statement  "                domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext)); " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The length of the statement  "                domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext)); " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDirectoryEntry,The length of the statement  "            return DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext)); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustRelationship,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' Name' targetDomainName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetSelectiveAuthenticationStatus,The length of the statement  "            return TrustHelper.GetTrustedDomainInfoStatus(context' Name' targetDomainName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_CROSS_ORGANIZATION' false); " is 138.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,SetSelectiveAuthenticationStatus,The length of the statement  "            TrustHelper.SetTrustedDomainInfoStatus(context' Name' targetDomainName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_CROSS_ORGANIZATION' enable' false); " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetSidFilteringStatus,The length of the statement  "            return TrustHelper.GetTrustedDomainInfoStatus(context' Name' targetDomainName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_QUARANTINED_DOMAIN' false); " is 138.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,SetSidFilteringStatus,The length of the statement  "            TrustHelper.SetTrustedDomainInfoStatus(context' Name' targetDomainName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_QUARANTINED_DOMAIN' enable' false); " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,VerifyOutboundTrustRelationship,The length of the statement  "            TrustHelper.VerifyTrust(context' Name' targetDomainName' false/*not forest*/' TrustDirection.Outbound' false/*just TC verification*/' null /* no need to go to specific server*/); " is 178.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,VerifyTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(context' Name' targetDomain.Name' false/*not forest*/' TrustDirection.Outbound' false/*just TC verification*/' null /* no need to go to specific server*/); " is 179.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,VerifyTrustRelationship,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetDomain.Name' direction)' typeof(TrustRelationshipInformation)' null); " is 165.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,VerifyTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(targetDomain.GetDirectoryContext()' targetDomain.Name' Name' false/*not forest*/' TrustDirection.Outbound' false/*just TC verification*/' null /* no need to go to specific server*/); " is 206.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,VerifyTrustRelationship,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetDomain.Name' direction)' typeof(TrustRelationshipInformation)' null); " is 165.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,CreateTrustRelationship,The length of the statement  "            TrustHelper.CreateTrust(context' Name' targetDomain.GetDirectoryContext()' targetDomain.Name' false' direction' password); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,CreateTrustRelationship,The length of the statement  "            TrustHelper.CreateTrust(targetDomain.GetDirectoryContext()' targetDomain.Name' context' Name' false' (TrustDirection)reverseDirection' password); " is 145.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,UpdateLocalSideOfTrustRelationship,The length of the statement  "            TrustHelper.UpdateTrustDirection(context' Name' targetDomainName' newTrustPassword' false /*not a forest*/' newTrustDirection); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,UpdateTrustRelationship,The length of the statement  "            TrustHelper.UpdateTrustDirection(context' Name' targetDomain.Name' password' false /* not a forest */' newTrustDirection); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,UpdateTrustRelationship,The length of the statement  "            TrustHelper.UpdateTrustDirection(targetDomain.GetDirectoryContext()' targetDomain.Name' Name' password' false /* not a forest */' reverseDirection); " is 148.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(context' Name' targetDomain.Name' false /*not forest*/' TrustDirection.Outbound' true /*reset secure channel*/' null /* no need to go to specific server*/); " is 180.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(targetDomain.GetDirectoryContext()' targetDomain.Name' Name' false /*not forest*/' TrustDirection.Outbound' true/*reset secure channel*/' null /* no need to go to specific server*/); " is 206.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustRelationship,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetDomain.Name' direction)' typeof(TrustRelationshipInformation)' null); " is 165.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomainModeLevel,The length of the statement  "                    domainFunctionality = Int32.Parse((string)PropertyManager.GetPropertyValue(context' rootDSE' PropertyManager.DomainFunctionality)' NumberFormatInfo.InvariantInfo); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomainMode,The length of the statement  "                            domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext)); " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetRoleOwner,The length of the statement  "                            entry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext)); " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetRoleOwner,The length of the statement  "                            entry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.Infrastructure)); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetRoleOwner,The length of the statement  "                dcName = Utils.GetDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' entry' PropertyManager.FsmoRoleOwner)); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,LoadCrossRefAttributes,The length of the statement  "                partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,LoadCrossRefAttributes,The length of the statement  "                ADSearcher searcher = new ADSearcher(partitionsEntry' filter' propertiesToLoad' SearchScope.OneLevel' false /*not paged search*/' false /*no cached results*/); " is 159.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetChildDomains,The length of the statement  "                partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustsHelper,The length of the statement  "                    error = UnsafeNativeMethods.DsEnumerateDomainTrustsW(serverName' (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_IN_FOREST | (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_OUTBOUND | (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_INBOUND' out domains' out count); " is 240.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustsHelper,The length of the statement  "                        if ((unmanagedTrust.Flags & (int)(DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY | DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_INBOUND)) == 0) " is 174.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustsHelper,The length of the statement  "                                // only if either the local domain or tmpObject is the tree root' will this trust relationship be a Root' otherwise it is cross link " is 132.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustHelper,The length of the statement  "            string targetServerName = TrustHelper.UpdateTrust(targetDomain.GetDirectoryContext()' targetDomain.Name' Name' password' false); " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustHelper,The length of the statement  "                    TrustHelper.VerifyTrust(context' Name' targetDomain.Name' false /*not forest*/' TrustDirection.Outbound' true /*reset secure channel*/' targetServerName /* need to specify which target server */); " is 196.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustHelper,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetDomain.Name' direction)' typeof(TrustRelationshipInformation)' null); " is 165.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustHelper,The length of the statement  "                    TrustHelper.VerifyTrust(targetDomain.GetDirectoryContext()' targetDomain.Name' Name' false /*not forest*/' TrustDirection.Outbound' true/*reset secure channel*/' sourceServerName /* need to specify which target server */); " is 222.
Long Statement,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RepairTrustHelper,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetDomain.Name' direction)' typeof(TrustRelationshipInformation)' null); " is 165.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetDomainController,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DCNotFound ' context.Name)' typeof(DomainController)' context.Name); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetDomainController,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DCNotFound ' context.Name)' typeof(DomainController)' context.Name); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetDomainController,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DCNotFound ' context.Name)' typeof(DomainController)' context.Name); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,SeizeRoleOwnership,The length of the statement  "                    System.DirectoryServices.Interop.UnsafeNativeMethods.IADsLargeInteger ridPool = (System.DirectoryServices.Interop.UnsafeNativeMethods.IADsLargeInteger)roleObjectEntry.Properties[PropertyManager.RIDAvailablePool].Value; " is 218.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetReplicationCursors,The length of the statement  "            info = GetReplicationInfoHelper(_dsHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_CURSORS_3_FOR_NC' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_CURSORS_FOR_NC' partition' ref advanced' context' DirectoryContext.ADHandle); " is 210.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetReplicationOperationInformation,The length of the statement  "            info = GetReplicationInfoHelper(_dsHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_PENDING_OPS' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_PENDING_OPS' null' ref advanced' 0' DirectoryContext.ADHandle); " is 191.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetReplicationNeighbors,The length of the statement  "            info = GetReplicationInfoHelper(_dsHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' partition' ref advanced' 0' DirectoryContext.ADHandle); " is 192.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetAllReplicationNeighbors,The length of the statement  "            info = GetReplicationInfoHelper(_dsHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_NEIGHBORS' null' ref advanced' 0' DirectoryContext.ADHandle); " is 187.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetReplicationMetadata,The length of the statement  "            info = GetReplicationInfoHelper(_dsHandle' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_METADATA_2_FOR_OBJ' (int)DS_REPL_INFO_TYPE.DS_REPL_INFO_METADATA_FOR_OBJ' objectPath' ref advanced' 0' DirectoryContext.ADHandle); " is 209.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,TriggerSyncReplicaFromNeighbors,The length of the statement  "            SyncReplicaHelper(_dsHandle' false' partition' null' DS_REPSYNC_ASYNCHRONOUS_OPERATION | DS_REPSYNC_ALL_SOURCES' DirectoryContext.ADHandle); " is 140.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,SyncReplicaFromAllServers,The length of the statement  "            SyncReplicaAllHelper(_dsHandle' syncAllFunctionPointer' partition' options' SyncFromAllServersCallback' DirectoryContext.ADHandle); " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ValidateCredential,The length of the statement  "            de = new DirectoryEntry("LDAP://" + dc.Name + "/RootDSE"' context.UserName' context.Password' Utils.DefaultAuthType | AuthenticationTypes.ServerBind); " is 150.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneWithCredentialValidation,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DCNotFoundInDomain ' context.Name)' typeof(DomainController)' null); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneWithCredentialValidation,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DCNotFoundInDomain ' context.Name)' typeof(DomainController)' null); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneInternal,The length of the statement  "            if (((long)flag & (~((long)LocatorOptions.AvoidSelf | (long)LocatorOptions.ForceRediscovery | (long)LocatorOptions.KdcRequired | (long)LocatorOptions.TimeServerRequired | (long)LocatorOptions.WriteableRequired))) != 0) " is 218.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneInternal,The length of the statement  "            errorCode = Locator.DsGetDcNameWrapper(null' domainName' siteName' (long)flag | (long)PrivateLocatorFlags.DirectoryServicesRequired' out domainControllerInfo); " is 159.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneInternal,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DCNotFoundInDomain ' domainName)' typeof(DomainController)' null); " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneInternal,The length of the statement  "            DirectoryContext dcContext = Utils.GetNewDirectoryContext(domainControllerName' DirectoryContextType.DirectoryServer' context); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindAllInternal,The length of the statement  "                int errorCode = Locator.DsGetDcNameWrapper(null' (domainName != null) ? domainName : DirectoryContext.GetLoggedOnDomain()' null' (long)PrivateLocatorFlags.DirectoryServicesRequired' out domainControllerInfo); " is 208.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindAllInternal,The length of the statement  "            foreach (string dcName in Utils.GetReplicaList(context' Utils.GetDNFromDnsName(domainName)' siteName' true /* isDefaultNC */' false /* isADAM */' false /* mustBeGC */)) " is 168.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetDomainControllerInfo,The length of the statement  "            NativeMethods.DsGetDomainControllerInfo dsGetDomainControllerInfo = (NativeMethods.DsGetDomainControllerInfo)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsGetDomainControllerInfo)); " is 209.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetDomainControllerInfo,The length of the statement  "                        NativeMethods.DsFreeDomainControllerInfo dsFreeDomainControllerInfo = (NativeMethods.DsFreeDomainControllerInfo)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsFreeDomainControllerInfo)); " is 213.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetRoles,The length of the statement  "            NativeMethods.DsListRoles dsListRoles = (NativeMethods.DsListRoles)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsListRoles)); " is 153.
Long Statement,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,GetRoles,The length of the statement  "                        UnsafeNativeMethods.DsFreeNameResultW dsFreeNameResult = (UnsafeNativeMethods.DsFreeNameResultW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsFreeNameResultW)); " is 194.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetExceptionFromCOMException,The length of the statement  "            else if ((errorCode == unchecked((int)0x8007203a)) || (errorCode == unchecked((int)0x8007200e)) || (errorCode == unchecked((int)0x8007200f))) " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetExceptionFromErrorCode,The length of the statement  "            else if ((errorCode == s_ERROR_NOT_ENOUGH_MEMORY) || (errorCode == s_ERROR_OUTOFMEMORY) || (errorCode == s_ERROR_DS_DRA_OUT_OF_MEM) || (errorCode == s_RPC_S_OUT_OF_RESOURCES)) " is 175.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetExceptionFromErrorCode,The length of the statement  "            else if ((errorCode == s_ERROR_NO_LOGON_SERVERS) || (errorCode == s_ERROR_NO_SUCH_DOMAIN) || (errorCode == RPC_S_SERVER_UNAVAILABLE) || (errorCode == RPC_S_CALL_FAILED)) " is 169.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,CreateSyncAllException,The length of the statement  "                    // this is a special case. the failure is because user specifies SyncAllOptions.CheckServerAlivenessOnly' ignore it here " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,CreateSyncAllException,The length of the statement  "                    SyncFromAllServersErrorInformation managedError = new SyncFromAllServersErrorInformation(error.error' error.dwWin32Err' message' source' target); " is 145.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,CreateSyncAllException,The length of the statement  "                    return new SyncFromAllServersOperationException(SR.DSSyncAllFailure' null' new SyncFromAllServersErrorInformation[] { managedError }); " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,CreateSyncAllException,The length of the statement  "                    // this is a special case. the failure is because user specifies SyncAllOptions.CheckServerAlivenessOnly' ignore it here " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,CreateSyncAllException,The length of the statement  "                        SyncFromAllServersErrorInformation managedError = new SyncFromAllServersErrorInformation(error.error' error.dwWin32Err' message' source' target); " is 145.
Long Statement,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,CreateSyncAllException,The length of the statement  "                    info[j] = new SyncFromAllServersErrorInformation(tmp.ErrorCategory' tmp.ErrorCode' tmp.ErrorMessage' tmp.SourceServer' tmp.TargetServer); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RaiseForestFunctionalityLevel,The length of the statement  "            DirectoryEntry partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(_context' _directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 154.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetTrustRelationship,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' Name' targetForestName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetSelectiveAuthenticationStatus,The length of the statement  "            return TrustHelper.GetTrustedDomainInfoStatus(_context' Name' targetForestName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_CROSS_ORGANIZATION' true); " is 138.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,SetSelectiveAuthenticationStatus,The length of the statement  "            TrustHelper.SetTrustedDomainInfoStatus(_context' Name' targetForestName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_CROSS_ORGANIZATION' enable' true); " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetSidFilteringStatus,The length of the statement  "            return TrustHelper.GetTrustedDomainInfoStatus(_context' Name' targetForestName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL' true); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,SetSidFilteringStatus,The length of the statement  "            TrustHelper.SetTrustedDomainInfoStatus(_context' Name' targetForestName' TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_TREAT_AS_EXTERNAL' enable' true); " is 138.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,VerifyOutboundTrustRelationship,The length of the statement  "            TrustHelper.VerifyTrust(_context' Name' targetForestName' true/*forest*/' TrustDirection.Outbound' false /*just TC verification*/' null /* no need to go to specific server*/); " is 175.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,VerifyTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(_context' Name' targetForest.Name' true/*forest*/' TrustDirection.Outbound' false/*just TC verification*/' null /* no need to go to specific server*/); " is 175.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,VerifyTrustRelationship,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetForest.Name' direction)' typeof(ForestTrustRelationshipInformation)' null); " is 171.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,VerifyTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(targetForest.GetDirectoryContext()' targetForest.Name' Name' true/*forest*/' TrustDirection.Outbound' false/*just TC verification*/' null /* no need to go to specific server*/); " is 201.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,VerifyTrustRelationship,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetForest.Name' direction)' typeof(ForestTrustRelationshipInformation)' null); " is 171.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,CreateLocalSideOfTrustRelationship,The length of the statement  "            Locator.GetDomainControllerInfo(null' targetForestName' null' (long)(PrivateLocatorFlags.DirectoryServicesRequired | PrivateLocatorFlags.GCRequired)); " is 150.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,CreateTrustRelationship,The length of the statement  "            TrustHelper.CreateTrust(_context' Name' targetForest.GetDirectoryContext()' targetForest.Name' true' direction' password); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,CreateTrustRelationship,The length of the statement  "            TrustHelper.CreateTrust(targetForest.GetDirectoryContext()' targetForest.Name' _context' Name' true' (TrustDirection)reverseDirection' password); " is 145.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,UpdateLocalSideOfTrustRelationship,The length of the statement  "            TrustHelper.UpdateTrustDirection(_context' Name' targetForestName' newTrustPassword' true /*is forest*/' newTrustDirection); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,UpdateTrustRelationship,The length of the statement  "            TrustHelper.UpdateTrustDirection(targetForest.GetDirectoryContext()' targetForest.Name' Name' password' true /*is forest*/' reverseDirection); " is 142.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(_context' Name' targetForest.Name' true /*is forest*/' TrustDirection.Outbound' true/*reset secure channel*/' null /* no need to go to specific server*/); " is 178.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustRelationship,The length of the statement  "                    TrustHelper.VerifyTrust(targetForest.GetDirectoryContext()' targetForest.Name' Name' true/*is forest*/' TrustDirection.Outbound' true/*reset secure channel*/' null /* no need to go to specific server*/); " is 203.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustRelationship,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetForest.Name' direction)' typeof(ForestTrustRelationshipInformation)' null); " is 171.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetForestModeLevel,The length of the statement  "                    forestModeValue = Int32.Parse((string)rootDSE.Properties[PropertyManager.ForestFunctionality].Value' NumberFormatInfo.InvariantInfo); " is 133.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetRoleOwner,The length of the statement  "                            entry = DirectoryEntryManager.GetDirectoryEntry(_context' _directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.SchemaNamingContext)); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetRoleOwner,The length of the statement  "                            entry = DirectoryEntryManager.GetDirectoryEntry(_context' _directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetRoleOwner,The length of the statement  "                dcName = Utils.GetDnsHostNameFromNTDSA(_context' (string)PropertyManager.GetPropertyValue(_context' entry' PropertyManager.FsmoRoleOwner)); " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetSites,The length of the statement  "                NativeMethods.DsListSites dsListSites = (NativeMethods.DsListSites)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsListSites)); " is 153.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetSites,The length of the statement  "                            UnsafeNativeMethods.DsFreeNameResultW dsFreeNameResultW = (UnsafeNativeMethods.DsFreeNameResultW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsFreeNameResultW)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetApplicationPartitions,The length of the statement  "            DirectoryEntry partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(_context' _directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 154.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetApplicationPartitions,The length of the statement  "                        DirectoryContext appNCContext = Utils.GetNewDirectoryContext(dnsName' DirectoryContextType.ApplicationPartition' _context); " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetApplicationPartitions,The length of the statement  "                        appNCs.Add(new ApplicationPartition(appNCContext' nCName' (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsRoot)' ApplicationPartitionType.ADApplicationPartition' new DirectoryEntryManager(appNCContext))); " is 233.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetDomains,The length of the statement  "            DirectoryEntry partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(_context' _directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer)); " is 154.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetTrustsHelper,The length of the statement  "                    error = UnsafeNativeMethods.DsEnumerateDomainTrustsW(serverName' (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY | (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_OUTBOUND | (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_INBOUND' out domains' out count); " is 238.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetTrustsHelper,The length of the statement  "                        if (unmanagedTrust.TrustType == TrustHelper.TRUST_TYPE_UPLEVEL && ((unmanagedTrust.TrustAttributes & (int)TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0)) " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetTrustsHelper,The length of the statement  "                            TrustRelationshipInformation trust = new ForestTrustRelationshipInformation(_context' Name' unmanagedTrust' TrustType.Forest); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustHelper,The length of the statement  "            string targetServerName = TrustHelper.UpdateTrust(targetForest.GetDirectoryContext()' targetForest.Name' Name' password' true /*is forest*/); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustHelper,The length of the statement  "                    TrustHelper.VerifyTrust(_context' Name' targetForest.Name' true /*is forest*/' TrustDirection.Outbound' true/*reset secure channel*/' targetServerName /* need to specify which target server */); " is 194.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustHelper,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetForest.Name' direction)' typeof(ForestTrustRelationshipInformation)' null); " is 171.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustHelper,The length of the statement  "                    TrustHelper.VerifyTrust(targetForest.GetDirectoryContext()' targetForest.Name' Name' true/*is forest*/' TrustDirection.Outbound' true/*reset secure channel*/' sourceServerName /* need to specify which target server */); " is 219.
Long Statement,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,RepairTrustHelper,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' Name' targetForest.Name' direction)' typeof(ForestTrustRelationshipInformation)' null); " is 171.
Long Statement,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,The length of the statement  "                        record.DomainInfo.DNSNameLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);             // sizeof(WCHAR) " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,The length of the statement  "                    int error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 1' out collisionInfo); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,GetGlobalCatalog,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.GCNotFound ' context.Name)' typeof(GlobalCatalog)' context.Name); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,GetGlobalCatalog,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.GCNotFound ' context.Name)' typeof(GlobalCatalog)' context.Name); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,GetGlobalCatalog,The length of the statement  "                isGlobalCatalog = (bool)Boolean.Parse((string)PropertyManager.GetPropertyValue(context' rootDSE' PropertyManager.IsGlobalCatalogReady)); " is 136.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,GetGlobalCatalog,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.GCNotFound ' context.Name)' typeof(GlobalCatalog)' context.Name); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,GetGlobalCatalog,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.GCNotFound ' context.Name)' typeof(GlobalCatalog)' context.Name); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneWithCredentialValidation,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.GCNotFoundInForest ' context.Name)' typeof(GlobalCatalog)' null); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneWithCredentialValidation,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.GCNotFoundInForest ' context.Name)' typeof(GlobalCatalog)' null); " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneInternal,The length of the statement  "            if (((long)flag & (~((long)LocatorOptions.AvoidSelf | (long)LocatorOptions.ForceRediscovery | (long)LocatorOptions.KdcRequired | (long)LocatorOptions.TimeServerRequired | (long)LocatorOptions.WriteableRequired))) != 0) " is 218.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneInternal,The length of the statement  "                int error = Locator.DsGetDcNameWrapper(null' DirectoryContext.GetLoggedOnDomain()' null' (long)PrivateLocatorFlags.DirectoryServicesRequired' out tempDomainControllerInfo); " is 172.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneInternal,The length of the statement  "            errorCode = Locator.DsGetDcNameWrapper(null' forestName' siteName' (long)flag | (long)(PrivateLocatorFlags.GCRequired | PrivateLocatorFlags.DirectoryServicesRequired)' out domainControllerInfo); " is 194.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneInternal,The length of the statement  "                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.GCNotFoundInForest ' forestName)' typeof(GlobalCatalog)' null); " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneInternal,The length of the statement  "            DirectoryContext gcContext = Utils.GetNewDirectoryContext(globalCatalogName' DirectoryContextType.DirectoryServer' context); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindAllInternal,The length of the statement  "            foreach (string gcName in Utils.GetReplicaList(context' null /* not specific to any partition */' siteName' false /* isDefaultNC */' false /* isADAM */' true /* mustBeGC */)) " is 174.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DsGetDcNameWrapper,The length of the statement  "            result = NativeMethods.DsGetDcName(computerName' domainName' IntPtr.Zero' siteName' (int)(flags | (long)PrivateLocatorFlags.ReturnDNSName)' out pDomainControllerInfo); " is 167.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,EnumerateDomainControllers,The length of the statement  "            // non site specific records for the domain/forest are returned. Additonally DCs/GCs that have registered site specific records " is 127.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,EnumerateDomainControllers,The length of the statement  "                // if the site name is not specified then we get the site specific records for the local machine's site (in the context of the domain/forest/application partition that is specified) " is 181.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,EnumerateDomainControllers,The length of the statement  "                // (sitename could still be null if the machine is not in any site for the specified domain/forest' in that case we don't look for any site specific records) " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,EnumerateDomainControllers,The length of the statement  "                int errorCode = DsGetDcNameWrapper(null' domainName' null' dcFlags & (long)(PrivateLocatorFlags.GCRequired | PrivateLocatorFlags.DSWriteableRequired | PrivateLocatorFlags.OnlyLDAPNeeded)' out domainControllerInfo); " is 214.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsGetDcWrapper,The length of the statement  "            result = NativeMethods.DsGetDcOpen(domainName' (int)optionFlags' siteName' IntPtr.Zero' null' (int)dcFlags' out retGetDcContext); " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsGetDcWrapper,The length of the statement  "                    result = NativeMethods.DsGetDcNext(retGetDcContext' ref sockAddressCountPtr' out sockAddressList' out dcDnsHostNamePtr); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsGetDcWrapper,The length of the statement  "                    if (result != 0 && result != NativeMethods.ERROR_FILE_MARK_DETECTED && result != NativeMethods.DNS_ERROR_RCODE_NAME_ERROR && result != NativeMethods.ERROR_NO_MORE_ITEMS) " is 169.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsGetDcWrapper,The length of the statement  "                        result = NativeMethods.DsGetDcNext(retGetDcContext' ref sockAddressCountPtr' out sockAddressList' out dcDnsHostNamePtr); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsGetDcWrapper,The length of the statement  "                        if (result != 0 && result != NativeMethods.ERROR_FILE_MARK_DETECTED && result != NativeMethods.DNS_ERROR_RCODE_NAME_ERROR && result != NativeMethods.ERROR_NO_MORE_ITEMS) " is 169.
Long Statement,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsQueryWrapper,The length of the statement  "            result = NativeMethods.DnsQuery(recordName' NativeMethods.DnsSrvData' options' IntPtr.Zero' out dnsResults' IntPtr.Zero); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,PropertyManager,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\PropertyManager.cs,GetPropertyValue,The length of the statement  "                        throw new ActiveDirectoryOperationException(SR.Format(SR.PropertyNotFoundOnObject ' propertyName' directoryEntry.Properties[PropertyManager.DistinguishedName].Value)); " is 167.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteCollection.cs,Contains,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(site.context' site.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteCollection.cs,Contains,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteCollection.cs,IndexOf,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(site.context' site.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteCollection.cs,IndexOf,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkBridgeCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkBridgeCollection.cs,Contains,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(bridge.context' bridge.cachedEntry' PropertyManager.DistinguishedName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkBridgeCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkBridgeCollection.cs,Contains,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkBridgeCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkBridgeCollection.cs,IndexOf,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(bridge.context' bridge.cachedEntry' PropertyManager.DistinguishedName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkBridgeCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkBridgeCollection.cs,IndexOf,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkCollection.cs,Contains,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(link.context' link.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkCollection.cs,Contains,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkCollection.cs,IndexOf,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(link.context' link.cachedEntry' PropertyManager.DistinguishedName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,ReadOnlySiteLinkCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlySiteLinkCollection.cs,IndexOf,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedEntry' PropertyManager.DistinguishedName); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnection.cs,ValidateTargetAndSourceServer,The length of the statement  "                    string targetRoot = (string)PropertyManager.GetPropertyValue(context' targetDE' PropertyManager.RootDomainNamingContext); " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnection.cs,ValidateTargetAndSourceServer,The length of the statement  "                    string sourceRoot = (string)PropertyManager.GetPropertyValue(sourceServer.Context' sourceDE' PropertyManager.RootDomainNamingContext); " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnection.cs,ValidateTargetAndSourceServer,The length of the statement  "                    string targetRoot = (string)PropertyManager.GetPropertyValue(context' targetDE' PropertyManager.ConfigurationNamingContext); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnection.cs,ValidateTargetAndSourceServer,The length of the statement  "                    string sourceRoot = (string)PropertyManager.GetPropertyValue(sourceServer.Context' sourceDE' PropertyManager.ConfigurationNamingContext); " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnectionCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnectionCollection.cs,Contains,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(connection.context' connection.cachedDirectoryEntry' PropertyManager.DistinguishedName); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnectionCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnectionCollection.cs,Contains,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedDirectoryEntry' PropertyManager.DistinguishedName); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnectionCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnectionCollection.cs,IndexOf,The length of the statement  "            string dn = (string)PropertyManager.GetPropertyValue(connection.context' connection.cachedDirectoryEntry' PropertyManager.DistinguishedName); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,ReplicationConnectionCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationConnectionCollection.cs,IndexOf,The length of the statement  "                string tmpDn = (string)PropertyManager.GetPropertyValue(tmp.context' tmp.cachedDirectoryEntry' PropertyManager.DistinguishedName); " is 130.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectoryInterSiteTransport,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectoryInterSiteTransport.cs,FindByTransportType,The length of the statement  "            // if target is not specified' then we determin the target from the logon credential' so if it is a local user context' it should fail " is 134.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectoryInterSiteTransport,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectoryInterSiteTransport.cs,FindByTransportType,The length of the statement  "                    if (Utils.CheckCapability(tmpDE' Capability.ActiveDirectoryApplicationMode) && transport == ActiveDirectoryTransportType.Smtp) " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,ActiveDirectoryInterSiteTransport,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectoryInterSiteTransport.cs,FindByTransportType,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.TransportNotFound ' transport.ToString())' typeof(ActiveDirectoryInterSiteTransport)' transport.ToString()); " is 170.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,GetTrustedDomainInfoStatus,The length of the statement  "                    int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainInformationEx' ref buffer); " is 158.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,GetTrustedDomainInfoStatus,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,GetTrustedDomainInfoStatus,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,SetTrustedDomainInfoStatus,The length of the statement  "                    int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainInformationEx' ref buffer); " is 158.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,SetTrustedDomainInfoStatus,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,SetTrustedDomainInfoStatus,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,SetTrustedDomainInfoStatus,The length of the statement  "                    result = UnsafeNativeMethods.LsaSetTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainInformationEx' newInfo); " is 149.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,DeleteTrust,The length of the statement  "                    int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(policyHandle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainInformationEx' ref buffer); " is 164.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,DeleteTrust,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,DeleteTrust,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,VerifyTrust,The length of the statement  "                    ValidateTrust(policyHandle' trustedDomainName' sourceName' targetName' isForest' (int)direction' policyServerName);  // need to verify direction                 " is 144.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,VerifyTrust,The length of the statement  "                        // this is the case that we need to specifically go to a particular server. This is the way to tell netlogon to do that. " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,VerifyTrust,The length of the statement  "                        win32Error = UnsafeNativeMethods.I_NetLogonControl2(policyServerName' s_NETLOGON_CONTROL_TC_VERIFY' NETLOGON_QUERY_LEVEL' ptr' out buffer1); " is 140.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,VerifyTrust,The length of the statement  "                        win32Error = UnsafeNativeMethods.I_NetLogonControl2(policyServerName' NETLOGON_CONTROL_REDISCOVER' NETLOGON_QUERY_LEVEL' ptr' out buffer2); " is 139.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrust,The length of the statement  "                    int result = UnsafeNativeMethods.LsaCreateTrustedDomainEx(policyHandle' tdi' AuthInfoEx' s_TRUSTED_SET_POSIX | s_TRUSTED_SET_AUTH' out domainHandle); " is 149.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrust,The length of the statement  "                    int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' ref buffer); " is 160.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrust,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrust,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrust,The length of the statement  "                    result = UnsafeNativeMethods.LsaSetTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' newBuffer); " is 153.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrustDirection,The length of the statement  "                    int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' ref buffer); " is 160.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrustDirection,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrustDirection,The length of the statement  "                                throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrustDirection,The length of the statement  "                    result = UnsafeNativeMethods.LsaSetTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' newBuffer); " is 153.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrust,The length of the statement  "            int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainInformationEx' ref buffer); " is 158.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrust,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrust,The length of the statement  "                        throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrust,The length of the statement  "                            throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' sourceName' targetName' (TrustDirection)direction)' typeof(ForestTrustRelationshipInformation)' null); " is 186.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrust,The length of the statement  "                            throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongTrustDirection ' sourceName' targetName' (TrustDirection)direction)' typeof(TrustRelationshipInformation)' null); " is 180.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrustAttribute,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,ValidateTrustAttribute,The length of the statement  "                    throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.WrongForestTrust ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null); " is 150.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDnsNameFromDN,The length of the statement  "            NativeMethods.DsCrackNames dsCrackNames = (NativeMethods.DsCrackNames)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsCrackNames)); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDnsNameFromDN,The length of the statement  "                        UnsafeNativeMethods.DsFreeNameResultW dsFreeNameResultW = (UnsafeNativeMethods.DsFreeNameResultW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsFreeNameResultW)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDNFromDnsName,The length of the statement  "            NativeMethods.DsCrackNames dsCrackNames = (NativeMethods.DsCrackNames)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsCrackNames)); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDNFromDnsName,The length of the statement  "                        UnsafeNativeMethods.DsFreeNameResultW dsFreeNameResultW = (UnsafeNativeMethods.DsFreeNameResultW)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(UnsafeNativeMethods.DsFreeNameResultW)); " is 195.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The length of the statement  "            string filter = "(|(&(" + PropertyManager.ObjectCategory + "=server)(" + PropertyManager.DistinguishedName + "=" + GetEscapedFilterValue(serverDn) + "))" + " is 155.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The length of the statement  "                            "(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.DistinguishedName + "=" + GetEscapedFilterValue(ntdsaDn) + ")))"; " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The length of the statement  "            ADSearcher searcher = new ADSearcher(serversEntry' filter' propertiesToLoad' SearchScope.Subtree' true /* paged search */' true /* cache results */); " is 149.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The length of the statement  "                    if ((objectCategoryValue.Length >= ntdsdsa.Length) && (Utils.Compare(objectCategoryValue' 0' ntdsdsa.Length' ntdsdsa' 0' ntdsdsa.Length) == 0)) " is 143.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The length of the statement  "            string filter = "(|(&(" + PropertyManager.ObjectCategory + "=server)(" + PropertyManager.DistinguishedName + "=" + GetEscapedFilterValue(serverDn) + "))" + " is 155.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The length of the statement  "                            "(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.DistinguishedName + "=" + GetEscapedFilterValue(ntdsaDn) + ")))"; " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The length of the statement  "            ADSearcher searcher = new ADSearcher(serversEntry' filter' propertiesToLoad' SearchScope.Subtree' true /* paged search */' true /* cache results */); " is 149.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The length of the statement  "                    if ((objectCategoryValue.Length >= ntdsdsa.Length) && (Utils.Compare(objectCategoryValue' 0' ntdsdsa.Length' ntdsdsa' 0' ntdsdsa.Length) == 0)) " is 143.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAuthIdentity,The length of the statement  "            NativeMethods.DsMakePasswordCredentials dsMakePasswordCredentials = (NativeMethods.DsMakePasswordCredentials)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsMakePasswordCredentials)); " is 209.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,FreeAuthIdentity,The length of the statement  "                NativeMethods.DsFreePasswordCredentials dsFreePasswordCredentials = (NativeMethods.DsFreePasswordCredentials)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsFreePasswordCredentials)); " is 209.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDSHandle,The length of the statement  "            Debug.Assert((domainControllerName != null && domainName == null) || (domainName != null && domainControllerName == null)); " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDSHandle,The length of the statement  "            NativeMethods.DsBindWithCred bindWithCred = (NativeMethods.DsBindWithCred)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsBindWithCred)); " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDSHandle,The length of the statement  "                throw ExceptionHelper.GetExceptionFromErrorCode(result' (domainControllerName != null) ? domainControllerName : domainName); " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,FreeDSHandle,The length of the statement  "                NativeMethods.DsUnBind dsUnBind = (NativeMethods.DsUnBind)Marshal.GetDelegateForFunctionPointer(functionPtr' typeof(NativeMethods.DsUnBind)); " is 141.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetCrossRefEntry,The length of the statement  "            ADSearcher searcher = new ADSearcher(partitionsEntry' filter' propertiesToLoad' SearchScope.OneLevel' false /*not paged search*/' false /*no cached results*/); " is 159.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetServerNameFromInvocationID,The length of the statement  "                string siteName = (server is DomainController) ? ((DomainController)server).SiteObjectName : ((AdamInstance)server).SiteObjectName; " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetServerNameFromInvocationID,The length of the statement  "                        originatingServerName = (string)PropertyManager.GetPropertyValue(server.Context' srvEntry' PropertyManager.DnsHostName); " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,Impersonate,The length of the statement  "            int result = UnsafeNativeMethods.LogonUserW(userName' domainName' context.Password' s_LOGON32_LOGON_NEW_CREDENTIALS' s_LOGON32_PROVIDER_WINNT50' ref hToken); " is 157.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetPolicyServerName,The length of the statement  "                            string rootNamingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.RootDomainNamingContext); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The length of the statement  "            ADSearcher searcher = new ADSearcher(searchRootEntry' filter' new string[] { }' searchScope' false /* paged search */' false /* cache results */); " is 146.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The length of the statement  "            // For each property in the propertiesWithRangeRetrieval we add the range as 0-*' e.g. member would be "member;range=0-*" " is 121.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The length of the statement  "            // When the results are returned if the property name is not present or is still "member;range=0-*"' then we got the last batch and so we  " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The length of the statement  "            // will not retrieve this property in the next round. However' if the property comes back as "member;range=0-1499" this means " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The length of the statement  "            // Properties in the propertiesWithoutRangeRetrieval arraylist' we only include the properties in the first search without any range info " is 137.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetValuesWithRangeRetrieval,The length of the statement  "                            if ((propertyNameWithRangeInfo.Length >= propertyToLoad.Length) && (Utils.Compare(propertyToLoad' 0' propertyToLoad.Length' propertyNameWithRangeInfo' 0' propertyToLoad.Length) != 0)) " is 183.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "            // 2. Search for the ntdsa objects of these replicas which have the partition in the Has-MasterNCs attribute (if partition name is specified " is 140.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "            // 3. For each replica in the resulting set' check if the msDS-Has-InstantiatedNCs attribute is of the form B:8:00000005:<DN of partition> " is 138.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "            //     where the second nibble from the least significant side is 0' B:8:00000015 would signify that the partition is still being replicated in " is 143.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "            //     and B:8:00000025 would indicate the partition is being replicated out (replica deletion) (again' this is only if partitionName is specified). " is 148.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "            //     This step is needed only for application partitions. This will be ignored for read-only NCs as it will ONLY be populated locally to each RODC. " is 149.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                        fsmoRoleOwnerName = Utils.GetAdamDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' partitionsEntry' PropertyManager.FsmoRoleOwner)); " is 162.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                        fsmoRoleOwnerName = Utils.GetDnsHostNameFromNTDSA(context' (string)PropertyManager.GetPropertyValue(context' partitionsEntry' PropertyManager.FsmoRoleOwner)); " is 158.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                    DirectoryContext fsmoContext = Utils.GetNewDirectoryContext(fsmoRoleOwnerName' DirectoryContextType.DirectoryServer' context); " is 126.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                    fsmoPartitionsEntry = DirectoryEntryManager.GetDirectoryEntry(fsmoContext' "CN=Partitions'" + configurationNamingContext); " is 122.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                    string filter = "(&(" + PropertyManager.ObjectCategory + "=crossRef)(" + PropertyManager.NCName + "=" + Utils.GetEscapedFilterValue(partitionName) + "))"; " is 154.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                    ArrayList replicaLocations = (ArrayList)values[PropertyManager.MsDSNCReplicaLocations.ToLower(CultureInfo.InvariantCulture)]; " is 125.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                    ArrayList roReplicaLocations = (ArrayList)values[PropertyManager.MsDSNCROReplicaLocations.ToLower(CultureInfo.InvariantCulture)]; " is 129.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                            //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options + " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))"; " is 128.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                            //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))" " is 191.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))" " is 191.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                            if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0)) " is 181.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                    if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0)) " is 189.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                            if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0)) " is 245.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                        if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0)) " is 153.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                    if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0))) " is 213.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later " is 123.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                    serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)' " is 131.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                            if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0) " is 163.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                        if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0)) " is 153.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                                    if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0))) " is 217.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                    Debug.Fail(string.Format(CultureInfo.InvariantCulture' "ConfigurationSet::GetReplicaList - no dnsHostName information for replica {0}"' ntdsaName)); " is 148.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The length of the statement  "                        Debug.Fail(string.Format(CultureInfo.InvariantCulture' "ConfigurationSet::GetReplicaList - no port number  information for replica {0}"' ntdsaName)); " is 149.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,IsSamUser,The length of the statement  "            //      Get machine domain SID (via LsaOpenPolicy/LsaQueryInformationPolicy for PolicyAccountDomainInformation/LsaClose) " is 120.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,IsSamUser,The length of the statement  "                    // If user SID is the same domain as the machine domain' and the machine is not a DC then the user is a local (machine) user " is 124.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,IsMachineDC,The length of the statement  "                    err = UnsafeNativeMethods.DsRoleGetPrimaryDomainInformation(IntPtr.Zero' DSROLE_PRIMARY_DOMAIN_INFO_LEVEL.DsRolePrimaryDomainInfoBasic' out dsRoleInfoPtr); " is 155.
Long Statement,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,IsMachineDC,The length of the statement  "                    err = UnsafeNativeMethods.DsRoleGetPrimaryDomainInformation(computerName' DSROLE_PRIMARY_DOMAIN_INFO_LEVEL.DsRolePrimaryDomainInfoBasic' out dsRoleInfoPtr); " is 156.
Long Statement,System.DirectoryServices.Interop,AdsValueHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\AdsValueHelper2.cs,GetValue,The length of the statement  "                    return new ArgumentException(SR.Format(SR.DSConvertFailed ' "0x" + Convert.ToString(LowInt64' 16)' "0x" + Convert.ToString(adsvalue.dwType' 16))); " is 146.
Complex Conditional,System.DirectoryServices,PropertyValueCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\PropertyValueCollection.cs,OnClearComplete,The conditional expression  "_needNewBehavior && !_allowMultipleChange && _updateType != UpdateType.None && _updateType != UpdateType.Update"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The conditional expression  "fromMinute != MinuteOfHour.Zero && fromMinute != MinuteOfHour.Fifteen && fromMinute != MinuteOfHour.Thirty && fromMinute != MinuteOfHour.FortyFive"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The conditional expression  "toMinute != MinuteOfHour.Zero && toMinute != MinuteOfHour.Fifteen && toMinute != MinuteOfHour.Thirty && toMinute != MinuteOfHour.FortyFive"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,Syntax,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySyntax.cs,Equals,The conditional expression  "((this.oMObjectClass != null) && (syntax.oMObjectClass == null))                      || ((this.oMObjectClass == null) && (syntax.oMObjectClass != null))                      || ((this.oMObjectClass != null) && (syntax.oMObjectClass != null) && (!this.oMObjectClass.Equals(syntax.oMObjectClass)))"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAliveAdamInstance,The conditional expression  "(e.ErrorCode == unchecked((int)0x8007203a)) ||                          (e.ErrorCode == unchecked((int)0x8007200e)) ||                          (e.ErrorCode == unchecked((int)0x8007200f)) ||                          (e.ErrorCode == unchecked((int)0x800705b4))"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetExceptionFromErrorCode,The conditional expression  "(errorCode == s_ERROR_NOT_ENOUGH_MEMORY) || (errorCode == s_ERROR_OUTOFMEMORY) || (errorCode == s_ERROR_DS_DRA_OUT_OF_MEM) || (errorCode == s_RPC_S_OUT_OF_RESOURCES)"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetExceptionFromErrorCode,The conditional expression  "(errorCode == s_ERROR_NO_LOGON_SERVERS) || (errorCode == s_ERROR_NO_SUCH_DOMAIN) || (errorCode == RPC_S_SERVER_UNAVAILABLE) || (errorCode == RPC_S_CALL_FAILED)"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsGetDcWrapper,The conditional expression  "result != 0 && result != NativeMethods.ERROR_FILE_MARK_DETECTED && result != NativeMethods.DNS_ERROR_RCODE_NAME_ERROR && result != NativeMethods.ERROR_NO_MORE_ITEMS"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,Locator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Locator.cs,DnsGetDcWrapper,The conditional expression  "result != 0 && result != NativeMethods.ERROR_FILE_MARK_DETECTED && result != NativeMethods.DNS_ERROR_RCODE_NAME_ERROR && result != NativeMethods.ERROR_NO_MORE_ITEMS"  is complex.
Complex Conditional,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,ClassifySID,The conditional expression  "!(identAuth.b1 == 0) &&                    (identAuth.b2 == 0) &&                    (identAuth.b3 == 0) &&                    (identAuth.b4 == 0) &&                    (identAuth.b5 == 0) &&                    (identAuth.b6 == 5)"  is complex.
Virtual Method Call from Constructor,System.DirectoryServices,ResultPropertyValueCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ResultPropertyValueCollection.cs,ResultPropertyValueCollection,The constructor "ResultPropertyValueCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClassCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClassCollection.cs,ActiveDirectorySchemaClassCollection,The constructor "ActiveDirectorySchemaClassCollection" calls a virtual method "Add".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClassCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClassCollection.cs,ActiveDirectorySchemaClassCollection,The constructor "ActiveDirectorySchemaClassCollection" calls a virtual method "Add".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaPropertyCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaPropertyCollection.cs,ActiveDirectorySchemaPropertyCollection,The constructor "ActiveDirectorySchemaPropertyCollection" calls a virtual method "Add".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaPropertyCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaPropertyCollection.cs,ActiveDirectorySchemaPropertyCollection,The constructor "ActiveDirectorySchemaPropertyCollection" calls a virtual method "Add".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,AdamInstanceCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstanceCollection.cs,AdamInstanceCollection,The constructor "AdamInstanceCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ApplicationPartitionCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartitionCollection.cs,ApplicationPartitionCollection,The constructor "ApplicationPartitionCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,DirectoryServerCollection,The constructor "DirectoryServerCollection" calls a virtual method "Add".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,DomainControllerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainControllerCollection.cs,DomainControllerCollection,The constructor "DomainControllerCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,GlobalCatalogCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalogCollection.cs,GlobalCatalogCollection,The constructor "GlobalCatalogCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ReadOnlyActiveDirectorySchemaClassCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlyActiveDirectorySchemaClassCollection.cs,ReadOnlyActiveDirectorySchemaClassCollection,The constructor "ReadOnlyActiveDirectorySchemaClassCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ReadOnlyActiveDirectorySchemaPropertyCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlyActiveDirectorySchemaPropertyCollection.cs,ReadOnlyActiveDirectorySchemaPropertyCollection,The constructor "ReadOnlyActiveDirectorySchemaPropertyCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ReadOnlyStringCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReadOnlyStringCollection.cs,ReadOnlyStringCollection,The constructor "ReadOnlyStringCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,ActiveDirectoryRoleCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\RoleOwnerCollection.cs,ActiveDirectoryRoleCollection,The constructor "ActiveDirectoryRoleCollection" calls a virtual method "AddRange".
Virtual Method Call from Constructor,System.DirectoryServices.ActiveDirectory,AdamRoleCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\RoleOwnerCollection.cs,AdamRoleCollection,The constructor "AdamRoleCollection" calls a virtual method "AddRange".
Empty Catch Block,System.DirectoryServices,SearchResultCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\SearchResultCollection.cs,RetrieveDirectorySynchronizationCookie,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices,SearchResultCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\SearchResultCollection.cs,RetrieveVLVResponse,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices,ResultsEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\SearchResultCollection.cs,GetCurrentResult,The method has an empty catch block.
Empty Catch Block,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,SplitServerNameAndPortNumber,The method has an empty catch block.
Magic Number,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,InitADsObjectOptions,The following statement contains a magic number: if (_adsObject is UnsafeNativeMethods.IAdsObjectOptions2)              {                  //--------------------------------------------                  // Check if ACCUMULATE_MODIFICATION is available                  //--------------------------------------------                  object o = null;                  int unmanagedResult = 0;                  // check whether the new option is available                    // 8 is ADS_OPTION_ACCUMULATIVE_MODIFICATION                  unmanagedResult = ((UnsafeNativeMethods.IAdsObjectOptions2)_adsObject).GetOption(8' out o);                  if (unmanagedResult != 0)                  {                      // rootdse does not support this option and invalid parameter due to without accumulative change fix in ADSI                      if ((unmanagedResult == unchecked((int)0x80004001)) || (unmanagedResult == unchecked((int)0x80005008)))                      {                          return;                      }                      else                      {                          throw COMExceptionHelper.CreateFormattedComException(unmanagedResult);                      }                  }                    // the new option is available' set it so we get the new PutEx behavior that will allow multiple changes                  Variant value = new Variant();                  value.varType = 11; //VT_BOOL                  value.boolvalue = -1;                  ((UnsafeNativeMethods.IAdsObjectOptions2)_adsObject).SetOption(8' value);                    allowMultipleChange = true;              }
Magic Number,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,InitADsObjectOptions,The following statement contains a magic number: if (_adsObject is UnsafeNativeMethods.IAdsObjectOptions2)              {                  //--------------------------------------------                  // Check if ACCUMULATE_MODIFICATION is available                  //--------------------------------------------                  object o = null;                  int unmanagedResult = 0;                  // check whether the new option is available                    // 8 is ADS_OPTION_ACCUMULATIVE_MODIFICATION                  unmanagedResult = ((UnsafeNativeMethods.IAdsObjectOptions2)_adsObject).GetOption(8' out o);                  if (unmanagedResult != 0)                  {                      // rootdse does not support this option and invalid parameter due to without accumulative change fix in ADSI                      if ((unmanagedResult == unchecked((int)0x80004001)) || (unmanagedResult == unchecked((int)0x80005008)))                      {                          return;                      }                      else                      {                          throw COMExceptionHelper.CreateFormattedComException(unmanagedResult);                      }                  }                    // the new option is available' set it so we get the new PutEx behavior that will allow multiple changes                  Variant value = new Variant();                  value.varType = 11; //VT_BOOL                  value.boolvalue = -1;                  ((UnsafeNativeMethods.IAdsObjectOptions2)_adsObject).SetOption(8' value);                    allowMultipleChange = true;              }
Magic Number,System.DirectoryServices,DirectoryEntry,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryEntry.cs,InitADsObjectOptions,The following statement contains a magic number: if (_adsObject is UnsafeNativeMethods.IAdsObjectOptions2)              {                  //--------------------------------------------                  // Check if ACCUMULATE_MODIFICATION is available                  //--------------------------------------------                  object o = null;                  int unmanagedResult = 0;                  // check whether the new option is available                    // 8 is ADS_OPTION_ACCUMULATIVE_MODIFICATION                  unmanagedResult = ((UnsafeNativeMethods.IAdsObjectOptions2)_adsObject).GetOption(8' out o);                  if (unmanagedResult != 0)                  {                      // rootdse does not support this option and invalid parameter due to without accumulative change fix in ADSI                      if ((unmanagedResult == unchecked((int)0x80004001)) || (unmanagedResult == unchecked((int)0x80005008)))                      {                          return;                      }                      else                      {                          throw COMExceptionHelper.CreateFormattedComException(unmanagedResult);                      }                  }                    // the new option is available' set it so we get the new PutEx behavior that will allow multiple changes                  Variant value = new Variant();                  value.varType = 11; //VT_BOOL                  value.boolvalue = -1;                  ((UnsafeNativeMethods.IAdsObjectOptions2)_adsObject).SetOption(8' value);                    allowMultipleChange = true;              }
Magic Number,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,DoSetSearchPrefs,The following statement contains a magic number: try              {                  IntPtr tempPtr = ptr;                  for (int i = 0; i < prefs.Length; i++)                  {                      Marshal.StructureToPtr(prefs[i]' tempPtr' false);                      tempPtr = IntPtr.Add(tempPtr' structSize);                  }                    adsSearch.SetSearchPreference(ptr' prefs.Length);                    // Check for the result status for all preferences                  tempPtr = ptr;                  for (int i = 0; i < prefs.Length; i++)                  {                      int status = Marshal.ReadInt32(tempPtr' 32);                      if (status != 0)                      {                          int prefIndex = prefs[i].dwSearchPref;                          string property = "";                          switch (prefIndex)                          {                              case (int)AdsSearchPreferences.SEARCH_SCOPE:                                  property = "SearchScope";                                  break;                              case (int)AdsSearchPreferences.SIZE_LIMIT:                                  property = "SizeLimit";                                  break;                              case (int)AdsSearchPreferences.TIME_LIMIT:                                  property = "ServerTimeLimit";                                  break;                              case (int)AdsSearchPreferences.ATTRIBTYPES_ONLY:                                  property = "PropertyNamesOnly";                                  break;                              case (int)AdsSearchPreferences.TIMEOUT:                                  property = "ClientTimeout";                                  break;                              case (int)AdsSearchPreferences.PAGESIZE:                                  property = "PageSize";                                  break;                              case (int)AdsSearchPreferences.PAGED_TIME_LIMIT:                                  property = "ServerPageTimeLimit";                                  break;                              case (int)AdsSearchPreferences.CHASE_REFERRALS:                                  property = "ReferralChasing";                                  break;                              case (int)AdsSearchPreferences.SORT_ON:                                  property = "Sort";                                  break;                              case (int)AdsSearchPreferences.CACHE_RESULTS:                                  property = "CacheResults";                                  break;                              case (int)AdsSearchPreferences.ASYNCHRONOUS:                                  property = "Asynchronous";                                  break;                              case (int)AdsSearchPreferences.TOMBSTONE:                                  property = "Tombstone";                                  break;                              case (int)AdsSearchPreferences.ATTRIBUTE_QUERY:                                  property = "AttributeScopeQuery";                                  break;                              case (int)AdsSearchPreferences.DEREF_ALIASES:                                  property = "DerefAlias";                                  break;                              case (int)AdsSearchPreferences.SECURITY_MASK:                                  property = "SecurityMasks";                                  break;                              case (int)AdsSearchPreferences.EXTENDED_DN:                                  property = "ExtendedDn";                                  break;                              case (int)AdsSearchPreferences.DIRSYNC:                                  property = "DirectorySynchronization";                                  break;                              case (int)AdsSearchPreferences.DIRSYNC_FLAG:                                  property = "DirectorySynchronizationFlag";                                  break;                              case (int)AdsSearchPreferences.VLV:                                  property = "VirtualListView";                                  break;                          }                          throw new InvalidOperationException(SR.Format(SR.DSSearchPreferencesNotAccepted ' property));                      }                        tempPtr = IntPtr.Add(tempPtr' structSize);                  }              }              finally              {                  Marshal.FreeHGlobal(ptr);              }
Magic Number,System.DirectoryServices,ResultsEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\SearchResultCollection.cs,MoveNext,The following statement contains a magic number: while (true)                  {                      // clear the last error first                      CleanLastError();                      errorCode = 0;                        int hr = _results.SearchObject.GetNextRow(_results.Handle);                      //  SIZE_LIMIT_EXCEEDED occurs when we supply too generic filter or small SizeLimit value.                      if (hr == UnsafeNativeMethods.S_ADS_NOMORE_ROWS || hr == UnsafeNativeMethods.SIZE_LIMIT_EXCEEDED)                      {                          // need to make sure this is not the case that server actually still has record not returned yet                          if (hr == UnsafeNativeMethods.S_ADS_NOMORE_ROWS)                          {                              hr = GetLastError(ref errorCode);                              // get last error call failed' we need to bail out                              if (hr != 0)                                  throw COMExceptionHelper.CreateFormattedComException(hr);                          }                            // not the case that server still has result' we are done here                          if (errorCode != SafeNativeMethods.ERROR_MORE_DATA)                          {                              // get the dirsync cookie as we finished all the rows                              if (_results.srch.directorySynchronizationSpecified)                                  tempsync = _results.srch.DirectorySynchronization;                                // get the vlv response as we finished all the rows                              if (_results.srch.directoryVirtualListViewSpecified)                                  tempvlv = _results.srch.VirtualListView;                                _results.srch.searchResult = null;                                _eof = true;                              _initialized = false;                              return false;                          }                          else                          {                              // if user chooses to wait to continue the search                              if (_waitForResult)                              {                                  continue;                              }                              else                              {                                  uint temp = (uint)errorCode;                                  temp = ((((temp) & 0x0000FFFF) | (7 << 16) | 0x80000000));                                  throw COMExceptionHelper.CreateFormattedComException((int)temp);                              }                          }                      }                      //throw a clearer exception if the filter was invalid                      if (hr == UnsafeNativeMethods.INVALID_FILTER)                          throw new ArgumentException(SR.Format(SR.DSInvalidSearchFilter ' _results.Filter));                      if (hr != 0)                          throw COMExceptionHelper.CreateFormattedComException(hr);                        _eof = false;                      return true;                  }
Magic Number,System.DirectoryServices,ResultsEnumerator,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\SearchResultCollection.cs,MoveNext,The following statement contains a magic number: while (true)                  {                      // clear the last error first                      CleanLastError();                      errorCode = 0;                        int hr = _results.SearchObject.GetNextRow(_results.Handle);                      //  SIZE_LIMIT_EXCEEDED occurs when we supply too generic filter or small SizeLimit value.                      if (hr == UnsafeNativeMethods.S_ADS_NOMORE_ROWS || hr == UnsafeNativeMethods.SIZE_LIMIT_EXCEEDED)                      {                          // need to make sure this is not the case that server actually still has record not returned yet                          if (hr == UnsafeNativeMethods.S_ADS_NOMORE_ROWS)                          {                              hr = GetLastError(ref errorCode);                              // get last error call failed' we need to bail out                              if (hr != 0)                                  throw COMExceptionHelper.CreateFormattedComException(hr);                          }                            // not the case that server still has result' we are done here                          if (errorCode != SafeNativeMethods.ERROR_MORE_DATA)                          {                              // get the dirsync cookie as we finished all the rows                              if (_results.srch.directorySynchronizationSpecified)                                  tempsync = _results.srch.DirectorySynchronization;                                // get the vlv response as we finished all the rows                              if (_results.srch.directoryVirtualListViewSpecified)                                  tempvlv = _results.srch.VirtualListView;                                _results.srch.searchResult = null;                                _eof = true;                              _initialized = false;                              return false;                          }                          else                          {                              // if user chooses to wait to continue the search                              if (_waitForResult)                              {                                  continue;                              }                              else                              {                                  uint temp = (uint)errorCode;                                  temp = ((((temp) & 0x0000FFFF) | (7 << 16) | 0x80000000));                                  throw COMExceptionHelper.CreateFormattedComException((int)temp);                              }                          }                      }                      //throw a clearer exception if the filter was invalid                      if (hr == UnsafeNativeMethods.INVALID_FILTER)                          throw new ArgumentException(SR.Format(SR.DSInvalidSearchFilter ' _results.Filter));                      if (hr != 0)                          throw COMExceptionHelper.CreateFormattedComException(hr);                        _eof = false;                      return true;                  }
Magic Number,System.DirectoryServices,COMExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryServicesCOMException.cs,CreateFormattedComException,The following statement contains a magic number: StringBuilder sb = new StringBuilder(256);
Magic Number,System.DirectoryServices,COMExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryServicesCOMException.cs,CreateFormattedComException,The following statement contains a magic number: if (result != 0)              {                  errorMsg = sb.ToString(0' result);              }              else              {                  errorMsg = SR.Format(SR.DSUnknown ' Convert.ToString(hr' 16));              }
Magic Number,System.DirectoryServices,COMExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryServicesCOMException.cs,CreateFormattedComException,The following statement contains a magic number: StringBuilder errorBuffer = new StringBuilder(256);
Magic Number,System.DirectoryServices,COMExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectoryServicesCOMException.cs,CreateFormattedComException,The following statement contains a magic number: SafeNativeMethods.ADsGetLastError(out error' errorBuffer' 256' nameBuffer' 0);
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectoryReplicationMetadata,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectoryReplicationMetaData.cs,AddHelper,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  if (advanced)                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_ATTR_META_DATA_2)));                        AttributeMetadata managedMetaData = new AttributeMetadata(addr' true' _server' _nameTable);                      Add(managedMetaData.Name' managedMetaData);                  }                  else                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_ATTR_META_DATA)));                        AttributeMetadata managedMetaData = new AttributeMetadata(addr' false' _server' _nameTable);                      Add(managedMetaData.Name' managedMetaData);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectoryReplicationMetadata,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectoryReplicationMetaData.cs,AddHelper,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  if (advanced)                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_ATTR_META_DATA_2)));                        AttributeMetadata managedMetaData = new AttributeMetadata(addr' true' _server' _nameTable);                      Add(managedMetaData.Name' managedMetaData);                  }                  else                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_ATTR_META_DATA)));                        AttributeMetadata managedMetaData = new AttributeMetadata(addr' false' _server' _nameTable);                      Add(managedMetaData.Name' managedMetaData);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ActiveDirectorySchedule,The following statement contains a magic number: for (int i = 0; i < 672; i++)                  _scheduleArray[i] = tmpSchedule[i];
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ActiveDirectorySchedule,The following statement contains a magic number: for (int i = 0; i < 672; i++)                  _scheduleArray[i] = schedule[i];
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: if ((int)fromHour * 60 + (int)fromMinute > (int)toHour * 60 + (int)toMinute)                  throw new ArgumentException(SR.InvalidTime);
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: if ((int)fromHour * 60 + (int)fromMinute > (int)toHour * 60 + (int)toMinute)                  throw new ArgumentException(SR.InvalidTime);
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int startPoint = (int)day * 24 * 4 + (int)fromHour * 4 + (int)fromMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int startPoint = (int)day * 24 * 4 + (int)fromHour * 4 + (int)fromMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int startPoint = (int)day * 24 * 4 + (int)fromHour * 4 + (int)fromMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int startPoint = (int)day * 24 * 4 + (int)fromHour * 4 + (int)fromMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int endPoint = (int)day * 24 * 4 + (int)toHour * 4 + (int)toMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int endPoint = (int)day * 24 * 4 + (int)toHour * 4 + (int)toMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int endPoint = (int)day * 24 * 4 + (int)toHour * 4 + (int)toMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetSchedule,The following statement contains a magic number: int endPoint = (int)day * 24 * 4 + (int)toHour * 4 + (int)toMinute / 15;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetDailySchedule,The following statement contains a magic number: for (int i = 0; i < 7; i++)              {                  SetSchedule((DayOfWeek)i' fromHour' fromMinute' toHour' toMinute);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ResetSchedule,The following statement contains a magic number: for (int i = 0; i < 672; i++)                  _scheduleArray[i] = false;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ValidateRawArray,The following statement contains a magic number: if (array.Length != 672)                  throw new ArgumentException("value");
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ValidateRawArray,The following statement contains a magic number: int len3 = array.GetLength(2);
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ValidateRawArray,The following statement contains a magic number: if (len1 != 7 || len2 != 24 || len3 != 4)                  throw new ArgumentException("value");
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ValidateRawArray,The following statement contains a magic number: if (len1 != 7 || len2 != 24 || len3 != 4)                  throw new ArgumentException("value");
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,ValidateRawArray,The following statement contains a magic number: if (len1 != 7 || len2 != 24 || len3 != 4)                  throw new ArgumentException("value");
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: byte[] unmanagedSchedule = new byte[188];
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: unmanagedSchedule[0] = 188;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: unmanagedSchedule[8] = 1;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: unmanagedSchedule[16] = 20;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: unmanagedSchedule[16] = 20;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,GetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    if (_scheduleArray[index])                      val |= 1;                  if (_scheduleArray[index + 1])                      val |= 2;                  if (_scheduleArray[index + 2])                      val |= 4;                  if (_scheduleArray[index + 3])                      val |= 8;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  unmanagedSchedule[unmanagedScheduleIndex] = val;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchedule,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchedule.cs,SetUnmanagedSchedule,The following statement contains a magic number: for (int i = 20; i < 188; i++)              {                  val = 0;                  index = (i - 20) * 4;                    //recalculate index position taking utc offset into account                  //ensure circular array in both directions (with index from 20 to 187)                  unmanagedScheduleIndex = i - (int)_utcOffSet;                  if (unmanagedScheduleIndex >= 188)                  {                      // falling off higher end (move back)                      unmanagedScheduleIndex = unmanagedScheduleIndex - 188 + 20;                  }                  else if (unmanagedScheduleIndex < 20)                  {                      // falling off lower end (move forward)                      unmanagedScheduleIndex = 188 - (20 - unmanagedScheduleIndex);                  }                  val = unmanagedSchedule[unmanagedScheduleIndex];                  if ((val & 1) != 0)                      _scheduleArray[index] = true;                    if ((val & 2) != 0)                      _scheduleArray[index + 1] = true;                    if ((val & 4) != 0)                      _scheduleArray[index + 2] = true;                    if ((val & 8) != 0)                      _scheduleArray[index + 3] = true;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,FindAllProperties,The following statement contains a magic number: StringBuilder str = new StringBuilder(25);
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetAllProperties,The following statement contains a magic number: string[] propertiesToLoad = new string[3];
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetAllProperties,The following statement contains a magic number: propertiesToLoad[2] = PropertyManager.IsDefunct;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetAllClasses,The following statement contains a magic number: string[] propertiesToLoad = new string[3];
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchema,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchema.cs,GetAllClasses,The following statement contains a magic number: propertiesToLoad[2] = PropertyManager.IsDefunct;
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: StringBuilder str = new StringBuilder(15);
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetClasses,The following statement contains a magic number: try              {                  if (ldapDisplayNames.Count < 1)                  {                      return classes;                  }                    if (_schemaEntry == null)                  {                      _schemaEntry = DirectoryEntryManager.GetDirectoryEntry(_context' WellKnownDN.SchemaNamingContext);                  }                    // constructing the filter                  StringBuilder str = new StringBuilder(100);                    if (ldapDisplayNames.Count > 1)                  {                      str.Append("(|");                  }                  foreach (string ldapDisplayName in ldapDisplayNames)                  {                      str.Append("(");                      str.Append(PropertyManager.LdapDisplayName);                      str.Append("=");                      str.Append(Utils.GetEscapedFilterValue(ldapDisplayName));                      str.Append(")");                  }                  if (ldapDisplayNames.Count > 1)                  {                      str.Append(")");                  }                    string filter = "(&(" + PropertyManager.ObjectCategory + "=classSchema)" + str.ToString() + "(!(" + PropertyManager.IsDefunct + "=TRUE)))";                    string[] propertiesToLoad = new String[1];                  propertiesToLoad[0] = PropertyManager.LdapDisplayName;                    ADSearcher searcher = new ADSearcher(_schemaEntry' filter' propertiesToLoad' SearchScope.OneLevel);                  resCol = searcher.FindAll();                    foreach (SearchResult res in resCol)                  {                      string ldapDisplayName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.LdapDisplayName);                      DirectoryEntry de = res.GetDirectoryEntry();                        de.AuthenticationType = Utils.DefaultAuthType;                      de.Username = _context.UserName;                      de.Password = _context.Password;                        ActiveDirectorySchemaClass schemaClass = new ActiveDirectorySchemaClass(_context' ldapDisplayName' de' _schemaEntry);                        classes.Add(schemaClass);                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(_context' e);              }              finally              {                  if (resCol != null)                  {                      resCol.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaClass,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaClass.cs,GetProperties,The following statement contains a magic number: try              {                  if (ldapDisplayNames.Count < 1)                  {                      return properties;                  }                    if (_schemaEntry == null)                  {                      _schemaEntry = DirectoryEntryManager.GetDirectoryEntry(_context' WellKnownDN.SchemaNamingContext);                  }                    // constructing the filter                  StringBuilder str = new StringBuilder(100);                    if (ldapDisplayNames.Count > 1)                  {                      str.Append("(|");                  }                  foreach (string ldapDisplayName in ldapDisplayNames)                  {                      str.Append("(");                      str.Append(PropertyManager.LdapDisplayName);                      str.Append("=");                      str.Append(Utils.GetEscapedFilterValue(ldapDisplayName));                      str.Append(")");                  }                  if (ldapDisplayNames.Count > 1)                  {                      str.Append(")");                  }                    string filter = "(&(" + PropertyManager.ObjectCategory + "=attributeSchema)" + str.ToString() + "(!(" + PropertyManager.IsDefunct + "=TRUE)))";                    string[] propertiesToLoad = new String[1];                  propertiesToLoad[0] = PropertyManager.LdapDisplayName;                    ADSearcher searcher = new ADSearcher(_schemaEntry' filter' propertiesToLoad' SearchScope.OneLevel);                  resCol = searcher.FindAll();                    foreach (SearchResult res in resCol)                  {                      string ldapDisplayName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.LdapDisplayName);                      DirectoryEntry de = res.GetDirectoryEntry();                        de.AuthenticationType = Utils.DefaultAuthType;                      de.Username = _context.UserName;                      de.Password = _context.Password;                        ActiveDirectorySchemaProperty schemaProperty = new ActiveDirectorySchemaProperty(_context' ldapDisplayName' de' _schemaEntry);                        properties.Add(schemaProperty);                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(_context' e);              }              finally              {                  if (resCol != null)                  {                      resCol.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: StringBuilder str = new StringBuilder(15);
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySchemaProperty,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySchemaProperty.cs,GetPropertiesFromSchemaContainer,The following statement contains a magic number: if (!isDefunctOnServer)              {                  propertiesToLoad = new string[12];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.RangeLower;                  propertiesToLoad[11] = PropertyManager.RangeUpper;              }              else              {                  propertiesToLoad = new string[15];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.Cn;                  propertiesToLoad[2] = PropertyManager.AttributeSyntax;                  propertiesToLoad[3] = PropertyManager.OMSyntax;                  propertiesToLoad[4] = PropertyManager.OMObjectClass;                  propertiesToLoad[5] = PropertyManager.Description;                  propertiesToLoad[6] = PropertyManager.SearchFlags;                  propertiesToLoad[7] = PropertyManager.IsMemberOfPartialAttributeSet;                  propertiesToLoad[8] = PropertyManager.LinkID;                  propertiesToLoad[9] = PropertyManager.SchemaIDGuid;                  propertiesToLoad[10] = PropertyManager.AttributeID;                  propertiesToLoad[11] = PropertyManager.IsSingleValued;                  propertiesToLoad[12] = PropertyManager.RangeLower;                  propertiesToLoad[13] = PropertyManager.RangeUpper;                  propertiesToLoad[14] = PropertyManager.LdapDisplayName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetBridgeheadServers,The following statement contains a magic number: if (existing)              {                  Hashtable bridgeHeadTable = new Hashtable();                  Hashtable nonBridgHeadTable = new Hashtable();                  Hashtable hostNameTable = new Hashtable();                  const string ocValue = "CN=Server";                    // get destination bridgehead servers                    // first go to the servers container under the current site and then do a search to get the all server objects.                  string serverContainer = "CN=Servers'" + (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.DistinguishedName);                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' serverContainer);                    try                  {                      // go through connection objects and find out its fromServer property.                       ADSearcher adSearcher = new ADSearcher(de'                                                            "(|(objectCategory=server)(objectCategory=NTDSConnection))"'                                                            new string[] { "fromServer"' "distinguishedName"' "dNSHostName"' "objectCategory" }'                                                            SearchScope.Subtree'                                                            true' /* need paged search */                                                            true /* need cached result as we need to go back to the first record */);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          // find out whether fromServer indicates replicating from a server in another site.                          foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) == 0)                              {                                  hostNameTable.Add((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DnsHostName));                              }                          }                            foreach (SearchResult r in conResults)                          {                              string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.ObjectCategory);                              if (Utils.Compare(objectCategoryValue' 0' ocValue.Length' ocValue' 0' ocValue.Length) != 0)                              {                                  string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                                    // escaping manipulation                                                                  string fromSite = Utils.GetPartialDN(fromServer' 3);                                  pathCracker.Set(fromSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  fromSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(fromSite != null && Utils.Compare(fromSite' 0' 3' "CN="' 0' 3) == 0);                                  fromSite = fromSite.Substring(3);                                    string serverObjectName = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 2);                                  // don't know whether it is a bridgehead server yet.                                  if (!bridgeHeadTable.Contains(serverObjectName))                                  {                                      string hostName = (string)hostNameTable[serverObjectName];                                      // add if not yet done                                      if (!nonBridgHeadTable.Contains(serverObjectName))                                          nonBridgHeadTable.Add(serverObjectName' hostName);                                        // check whether from different site                                      if (Utils.Compare((string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)' fromSite) != 0)                                      {                                          // the server is a bridgehead server                                          bridgeHeadTable.Add(serverObjectName' hostName);                                          nonBridgHeadTable.Remove(serverObjectName);                                      }                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                      }                  }                  finally                  {                      de.Dispose();                  }                    // get source bridgehead server                  if (nonBridgHeadTable.Count != 0)                  {                      // go to sites container to get all the connecdtion object that replicates from servers in the current sites that have                      // not been determined whether it is a bridgehead server or not.                      DirectoryEntry serverEntry = DirectoryEntryManager.GetDirectoryEntry(context' _siteDN);                      // constructing the filter                      StringBuilder str = new StringBuilder(100);                      if (nonBridgHeadTable.Count > 1)                          str.Append("(|");                      foreach (DictionaryEntry val in nonBridgHeadTable)                      {                          str.Append("(fromServer=");                          str.Append("CN=NTDS Settings'");                          str.Append(Utils.GetEscapedFilterValue((string)val.Key));                          str.Append(")");                      }                      if (nonBridgHeadTable.Count > 1)                          str.Append(")");                      ADSearcher adSearcher = new ADSearcher(serverEntry'                                                            "(&(objectClass=nTDSConnection)(objectCategory=NTDSConnection)" + str.ToString() + ")"'                                                            new string[] { "fromServer"' "distinguishedName" }'                                                            SearchScope.Subtree);                      SearchResultCollection conResults = null;                      try                      {                          conResults = adSearcher.FindAll();                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        try                      {                          foreach (SearchResult r in conResults)                          {                              string fromServer = (string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.FromServer);                              string serverObject = fromServer.Substring(17);                                if (nonBridgHeadTable.Contains(serverObject))                              {                                  string otherSite = Utils.GetPartialDN((string)PropertyManager.GetSearchResultPropertyValue(r' PropertyManager.DistinguishedName)' 4);                                  // escaping manipulation                                  pathCracker.Set(otherSite' NativeComInterfaces.ADS_SETTYPE_DN);                                  otherSite = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                                  Debug.Assert(otherSite != null && Utils.Compare(otherSite' 0' 3' "CN="' 0' 3) == 0);                                  otherSite = otherSite.Substring(3);                                    // check whether from different sites                                  if (Utils.Compare(otherSite' (string)PropertyManager.GetPropertyValue(context' cachedEntry' PropertyManager.Cn)) != 0)                                  {                                      string val = (string)nonBridgHeadTable[serverObject];                                      nonBridgHeadTable.Remove(serverObject);                                      bridgeHeadTable.Add(serverObject' val);                                  }                              }                          }                      }                      finally                      {                          conResults.Dispose();                          serverEntry.Dispose();                      }                  }                    DirectoryEntry ADAMEntry = null;                  foreach (DictionaryEntry e in bridgeHeadTable)                  {                      DirectoryServer replica = null;                      string host = (string)e.Value;                      // construct directoryreplica                      if (IsADAM)                      {                          ADAMEntry = DirectoryEntryManager.GetDirectoryEntry(context' "CN=NTDS Settings'" + e.Key);                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullhost = host;                          if (port != 389)                          {                              fullhost = host + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullhost' DirectoryContextType.DirectoryServer' context)' fullhost);                      }                      else                      {                          replica = new DomainController(Utils.GetNewDirectoryContext(host' DirectoryContextType.DirectoryServer' context)' host);                      }                        collection.Add(replica);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetServers,The following statement contains a magic number: try              {                  foreach (SearchResult result in results)                  {                      string hostName = (string)PropertyManager.GetSearchResultPropertyValue(result' PropertyManager.DnsHostName);                      DirectoryEntry de = result.GetDirectoryEntry();                      DirectoryEntry child = null;                      DirectoryServer replica = null;                      // make sure that the server is not demoted                      try                      {                          child = de.Children.Find("CN=NTDS Settings"' "nTDSDSA");                      }                      catch (COMException e)                      {                          if (e.ErrorCode == unchecked((int)0x80072030))                          {                              continue;                          }                          else                              throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                      if (IsADAM)                      {                          int port = (int)PropertyManager.GetPropertyValue(context' child' PropertyManager.MsDSPortLDAP);                          string fullHostName = hostName;                          if (port != 389)                          {                              fullHostName = hostName + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullHostName' DirectoryContextType.DirectoryServer' context)' fullHostName);                      }                      else                          replica = new DomainController(Utils.GetNewDirectoryContext(hostName' DirectoryContextType.DirectoryServer' context)' hostName);                        _servers.Add(replica);                  }              }              finally              {                  results.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySite,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySite.cs,GetPreferredBridgeheadServers,The following statement contains a magic number: try              {                  DirectoryEntry ADAMEntry = null;                  foreach (SearchResult result in results)                  {                      string hostName = (string)PropertyManager.GetSearchResultPropertyValue(result' PropertyManager.DnsHostName);                      DirectoryEntry resultEntry = result.GetDirectoryEntry();                      DirectoryServer replica = null;                        try                      {                          ADAMEntry = resultEntry.Children.Find("CN=NTDS Settings"' "nTDSDSA");                      }                      catch (COMException e)                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                        if (IsADAM)                      {                          int port = (int)PropertyManager.GetPropertyValue(context' ADAMEntry' PropertyManager.MsDSPortLDAP);                          string fullHostName = hostName;                          if (port != 389)                          {                              fullHostName = hostName + ":" + port;                          }                          replica = new AdamInstance(Utils.GetNewDirectoryContext(fullHostName' DirectoryContextType.DirectoryServer' context)' fullHostName);                      }                      else                          replica = new DomainController(Utils.GetNewDirectoryContext(hostName' DirectoryContextType.DirectoryServer' context)' hostName);                        if (transport == ActiveDirectoryTransportType.Smtp)                          _SMTPBridgeheadServers.Add(replica);                      else                          _RPCBridgeheadServers.Add(replica);                  }              }              finally              {                  de.Dispose();                  results.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLink,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLink.cs,GetSites,The following statement contains a magic number: for (int i = 0; i < siteLists.Count; i++)              {                  string dn = (string)siteLists[i];                    // escaping manipulation                  pathCracker.Set(dn' NativeComInterfaces.ADS_SETTYPE_DN);                  string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                  Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                  rdn = rdn.Substring(3);                  ActiveDirectorySite site = new ActiveDirectorySite(context' rdn' true);                    // add to the collection                  _sites.Add(site);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLink,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLink.cs,GetSites,The following statement contains a magic number: for (int i = 0; i < siteLists.Count; i++)              {                  string dn = (string)siteLists[i];                    // escaping manipulation                  pathCracker.Set(dn' NativeComInterfaces.ADS_SETTYPE_DN);                  string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                  Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                  rdn = rdn.Substring(3);                  ActiveDirectorySite site = new ActiveDirectorySite(context' rdn' true);                    // add to the collection                  _sites.Add(site);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLink,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLink.cs,GetSites,The following statement contains a magic number: for (int i = 0; i < siteLists.Count; i++)              {                  string dn = (string)siteLists[i];                    // escaping manipulation                  pathCracker.Set(dn' NativeComInterfaces.ADS_SETTYPE_DN);                  string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                  Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                  rdn = rdn.Substring(3);                  ActiveDirectorySite site = new ActiveDirectorySite(context' rdn' true);                    // add to the collection                  _sites.Add(site);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkBridge,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkBridge.cs,GetLinks,The following statement contains a magic number: for (int i = 0; i < siteLinkLists.Count; i++)              {                  string dn = (string)siteLinkLists[i];                  // escaping manipulation                  pathCracker.Set(dn' NativeComInterfaces.ADS_SETTYPE_DN);                  string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                  Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                  rdn = rdn.Substring(3);                  DirectoryEntry entry = DirectoryEntryManager.GetDirectoryEntry(context' dn);                  ActiveDirectorySiteLink link = new ActiveDirectorySiteLink(context' rdn' _transport' true' entry);                    _links.Add(link);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkBridge,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkBridge.cs,GetLinks,The following statement contains a magic number: for (int i = 0; i < siteLinkLists.Count; i++)              {                  string dn = (string)siteLinkLists[i];                  // escaping manipulation                  pathCracker.Set(dn' NativeComInterfaces.ADS_SETTYPE_DN);                  string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                  Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                  rdn = rdn.Substring(3);                  DirectoryEntry entry = DirectoryEntryManager.GetDirectoryEntry(context' dn);                  ActiveDirectorySiteLink link = new ActiveDirectorySiteLink(context' rdn' _transport' true' entry);                    _links.Add(link);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySiteLinkBridge,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySiteLinkBridge.cs,GetLinks,The following statement contains a magic number: for (int i = 0; i < siteLinkLists.Count; i++)              {                  string dn = (string)siteLinkLists[i];                  // escaping manipulation                  pathCracker.Set(dn' NativeComInterfaces.ADS_SETTYPE_DN);                  string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                  Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                  rdn = rdn.Substring(3);                  DirectoryEntry entry = DirectoryEntryManager.GetDirectoryEntry(context' dn);                  ActiveDirectorySiteLink link = new ActiveDirectorySiteLink(context' rdn' _transport' true' entry);                    _links.Add(link);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnet.cs,FindByName,The following statement contains a magic number: try              {                  ADSearcher adSearcher = new ADSearcher(de'                                                        "(&(objectClass=subnet)(objectCategory=subnet)(name=" + Utils.GetEscapedFilterValue(subnetName) + "))"'                                                        new string[] { "distinguishedName" }'                                                        SearchScope.OneLevel'                                                        false' /* don't need paged search */                                                        false /* don't need to cache result */);                  SearchResult srchResult = adSearcher.FindOne();                  if (srchResult == null)                  {                      // no such subnet object                      Exception e = new ActiveDirectoryObjectNotFoundException(SR.DSNotFound' typeof(ActiveDirectorySubnet)' subnetName);                      throw e;                  }                  else                  {                      string siteName = null;                      DirectoryEntry connectionEntry = srchResult.GetDirectoryEntry();                      // try to get the site that this subnet lives in                      if (connectionEntry.Properties.Contains("siteObject"))                      {                          NativeComInterfaces.IAdsPathname pathCracker = (NativeComInterfaces.IAdsPathname)new NativeComInterfaces.Pathname();                          // need to turn off the escaping for name                          pathCracker.EscapedMode = NativeComInterfaces.ADS_ESCAPEDMODE_OFF_EX;                            string tmp = (string)connectionEntry.Properties["siteObject"][0];                          // escaping manipulation                          pathCracker.Set(tmp' NativeComInterfaces.ADS_SETTYPE_DN);                          string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                          Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                          siteName = rdn.Substring(3);                      }                        // it is an existing subnet object                      ActiveDirectorySubnet subnet = null;                      if (siteName == null)                          subnet = new ActiveDirectorySubnet(context' subnetName' null' true);                      else                          subnet = new ActiveDirectorySubnet(context' subnetName' siteName' true);                        subnet.cachedEntry = connectionEntry;                      return subnet;                  }              }              catch (COMException e)              {                  if (e.ErrorCode == unchecked((int)0x80072030))                  {                      // object is not found since we cannot even find the container in which to search                      throw new ActiveDirectoryObjectNotFoundException(SR.DSNotFound' typeof(ActiveDirectorySubnet)' subnetName);                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (de != null)                      de.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnet.cs,FindByName,The following statement contains a magic number: try              {                  ADSearcher adSearcher = new ADSearcher(de'                                                        "(&(objectClass=subnet)(objectCategory=subnet)(name=" + Utils.GetEscapedFilterValue(subnetName) + "))"'                                                        new string[] { "distinguishedName" }'                                                        SearchScope.OneLevel'                                                        false' /* don't need paged search */                                                        false /* don't need to cache result */);                  SearchResult srchResult = adSearcher.FindOne();                  if (srchResult == null)                  {                      // no such subnet object                      Exception e = new ActiveDirectoryObjectNotFoundException(SR.DSNotFound' typeof(ActiveDirectorySubnet)' subnetName);                      throw e;                  }                  else                  {                      string siteName = null;                      DirectoryEntry connectionEntry = srchResult.GetDirectoryEntry();                      // try to get the site that this subnet lives in                      if (connectionEntry.Properties.Contains("siteObject"))                      {                          NativeComInterfaces.IAdsPathname pathCracker = (NativeComInterfaces.IAdsPathname)new NativeComInterfaces.Pathname();                          // need to turn off the escaping for name                          pathCracker.EscapedMode = NativeComInterfaces.ADS_ESCAPEDMODE_OFF_EX;                            string tmp = (string)connectionEntry.Properties["siteObject"][0];                          // escaping manipulation                          pathCracker.Set(tmp' NativeComInterfaces.ADS_SETTYPE_DN);                          string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                          Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                          siteName = rdn.Substring(3);                      }                        // it is an existing subnet object                      ActiveDirectorySubnet subnet = null;                      if (siteName == null)                          subnet = new ActiveDirectorySubnet(context' subnetName' null' true);                      else                          subnet = new ActiveDirectorySubnet(context' subnetName' siteName' true);                        subnet.cachedEntry = connectionEntry;                      return subnet;                  }              }              catch (COMException e)              {                  if (e.ErrorCode == unchecked((int)0x80072030))                  {                      // object is not found since we cannot even find the container in which to search                      throw new ActiveDirectoryObjectNotFoundException(SR.DSNotFound' typeof(ActiveDirectorySubnet)' subnetName);                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (de != null)                      de.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,ActiveDirectorySubnet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ActiveDirectorySubnet.cs,FindByName,The following statement contains a magic number: try              {                  ADSearcher adSearcher = new ADSearcher(de'                                                        "(&(objectClass=subnet)(objectCategory=subnet)(name=" + Utils.GetEscapedFilterValue(subnetName) + "))"'                                                        new string[] { "distinguishedName" }'                                                        SearchScope.OneLevel'                                                        false' /* don't need paged search */                                                        false /* don't need to cache result */);                  SearchResult srchResult = adSearcher.FindOne();                  if (srchResult == null)                  {                      // no such subnet object                      Exception e = new ActiveDirectoryObjectNotFoundException(SR.DSNotFound' typeof(ActiveDirectorySubnet)' subnetName);                      throw e;                  }                  else                  {                      string siteName = null;                      DirectoryEntry connectionEntry = srchResult.GetDirectoryEntry();                      // try to get the site that this subnet lives in                      if (connectionEntry.Properties.Contains("siteObject"))                      {                          NativeComInterfaces.IAdsPathname pathCracker = (NativeComInterfaces.IAdsPathname)new NativeComInterfaces.Pathname();                          // need to turn off the escaping for name                          pathCracker.EscapedMode = NativeComInterfaces.ADS_ESCAPEDMODE_OFF_EX;                            string tmp = (string)connectionEntry.Properties["siteObject"][0];                          // escaping manipulation                          pathCracker.Set(tmp' NativeComInterfaces.ADS_SETTYPE_DN);                          string rdn = pathCracker.Retrieve(NativeComInterfaces.ADS_FORMAT_LEAF);                          Debug.Assert(rdn != null && Utils.Compare(rdn' 0' 3' "CN="' 0' 3) == 0);                          siteName = rdn.Substring(3);                      }                        // it is an existing subnet object                      ActiveDirectorySubnet subnet = null;                      if (siteName == null)                          subnet = new ActiveDirectorySubnet(context' subnetName' null' true);                      else                          subnet = new ActiveDirectorySubnet(context' subnetName' siteName' true);                        subnet.cachedEntry = connectionEntry;                      return subnet;                  }              }              catch (COMException e)              {                  if (e.ErrorCode == unchecked((int)0x80072030))                  {                      // object is not found since we cannot even find the container in which to search                      throw new ActiveDirectoryObjectNotFoundException(SR.DSNotFound' typeof(ActiveDirectorySubnet)' subnetName);                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (de != null)                      de.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,AdamInstance,The following statement contains a magic number: _becomeRoleOwnerAttrs = new String[2];
Magic Number,System.DirectoryServices.ActiveDirectory,AdamInstance,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADAMInstance.cs,AdamInstance,The following statement contains a magic number: _becomeRoleOwnerAttrs = new String[2];
Magic Number,System.DirectoryServices.ActiveDirectory,ADSearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADSearcher.cs,ADSearcher,The following statement contains a magic number: _searcher.PageSize = 512;
Magic Number,System.DirectoryServices.ActiveDirectory,ADSearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ADSearcher.cs,ADSearcher,The following statement contains a magic number: if (pagedSearch)              {                  _searcher.PageSize = 512;                  _searcher.ServerPageTimeLimit = s_defaultTimeSpan;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The following statement contains a magic number: StringBuilder str = new StringBuilder(15);
Magic Number,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The following statement contains a magic number: string[] propertiesToLoad = new string[2];
Magic Number,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The following statement contains a magic number: if (context.ContextType == DirectoryContextType.DirectoryServer)              {                  bool hostsCurrentPartition = false;                  DistinguishedName appNCDN = new DistinguishedName(distinguishedName);                  DirectoryEntry rootDSE = DirectoryEntryManager.GetDirectoryEntry(context' WellKnownDN.RootDSE);                    try                  {                      foreach (string namingContext in rootDSE.Properties[PropertyManager.NamingContexts])                      {                          DistinguishedName dn = new DistinguishedName(namingContext);                            if (dn.Equals(appNCDN))                          {                              hostsCurrentPartition = true;                              break;                          }                      }                  }                  catch (COMException e)                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }                  finally                  {                      rootDSE.Dispose();                  }                    if (!hostsCurrentPartition)                  {                      throw new ActiveDirectoryObjectNotFoundException(SR.AppNCNotFound' typeof(ApplicationPartition)' distinguishedName);                  }                    appNCContext = context;              }              else              {                  // we need to find a server which hosts this application partition                  if (appType == ApplicationPartitionType.ADApplicationPartition)                  {                      int errorCode = 0;                      DomainControllerInfo domainControllerInfo;                        errorCode = Locator.DsGetDcNameWrapper(null' appNCDnsName' null' (long)PrivateLocatorFlags.OnlyLDAPNeeded' out domainControllerInfo);                        if (errorCode == NativeMethods.ERROR_NO_SUCH_DOMAIN)                      {                          throw new ActiveDirectoryObjectNotFoundException(SR.AppNCNotFound' typeof(ApplicationPartition)' distinguishedName);                      }                      else if (errorCode != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(errorCode);                      }                        Debug.Assert(domainControllerInfo.DomainControllerName.Length > 2' "ApplicationPartition:FindByName - domainControllerInfo.DomainControllerName.Length <= 2");                      string serverName = domainControllerInfo.DomainControllerName.Substring(2);                      appNCContext = Utils.GetNewDirectoryContext(serverName' DirectoryContextType.DirectoryServer' context);                  }                  else                  {                      // this will find an adam instance that hosts this partition and which is alive and responding.                      string adamInstName = ConfigurationSet.FindOneAdamInstance(context.Name' context' distinguishedName' null).Name;                      appNCContext = Utils.GetNewDirectoryContext(adamInstName' DirectoryContextType.DirectoryServer' context);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindByName,The following statement contains a magic number: if (context.ContextType == DirectoryContextType.DirectoryServer)              {                  bool hostsCurrentPartition = false;                  DistinguishedName appNCDN = new DistinguishedName(distinguishedName);                  DirectoryEntry rootDSE = DirectoryEntryManager.GetDirectoryEntry(context' WellKnownDN.RootDSE);                    try                  {                      foreach (string namingContext in rootDSE.Properties[PropertyManager.NamingContexts])                      {                          DistinguishedName dn = new DistinguishedName(namingContext);                            if (dn.Equals(appNCDN))                          {                              hostsCurrentPartition = true;                              break;                          }                      }                  }                  catch (COMException e)                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }                  finally                  {                      rootDSE.Dispose();                  }                    if (!hostsCurrentPartition)                  {                      throw new ActiveDirectoryObjectNotFoundException(SR.AppNCNotFound' typeof(ApplicationPartition)' distinguishedName);                  }                    appNCContext = context;              }              else              {                  // we need to find a server which hosts this application partition                  if (appType == ApplicationPartitionType.ADApplicationPartition)                  {                      int errorCode = 0;                      DomainControllerInfo domainControllerInfo;                        errorCode = Locator.DsGetDcNameWrapper(null' appNCDnsName' null' (long)PrivateLocatorFlags.OnlyLDAPNeeded' out domainControllerInfo);                        if (errorCode == NativeMethods.ERROR_NO_SUCH_DOMAIN)                      {                          throw new ActiveDirectoryObjectNotFoundException(SR.AppNCNotFound' typeof(ApplicationPartition)' distinguishedName);                      }                      else if (errorCode != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(errorCode);                      }                        Debug.Assert(domainControllerInfo.DomainControllerName.Length > 2' "ApplicationPartition:FindByName - domainControllerInfo.DomainControllerName.Length <= 2");                      string serverName = domainControllerInfo.DomainControllerName.Substring(2);                      appNCContext = Utils.GetNewDirectoryContext(serverName' DirectoryContextType.DirectoryServer' context);                  }                  else                  {                      // this will find an adam instance that hosts this partition and which is alive and responding.                      string adamInstName = ConfigurationSet.FindOneAdamInstance(context.Name' context' distinguishedName' null).Name;                      appNCContext = Utils.GetNewDirectoryContext(adamInstName' DirectoryContextType.DirectoryServer' context);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindDirectoryServerInternal,The following statement contains a magic number: Debug.Assert(domainControllerInfo.DomainControllerName.Length > 2' "ApplicationPartition:FindDirectoryServerInternal - domainControllerInfo.DomainControllerName.Length <= 2");
Magic Number,System.DirectoryServices.ActiveDirectory,ApplicationPartition,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ApplicationPartition.cs,FindDirectoryServerInternal,The following statement contains a magic number: string dcName = domainControllerInfo.DomainControllerName.Substring(2);
Magic Number,System.DirectoryServices.ActiveDirectory,AttributeMetadata,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\AttributeMetaData.cs,AttributeMetadata,The following statement contains a magic number: if (advanced)              {                  DS_REPL_ATTR_META_DATA_2 attrMetaData = new DS_REPL_ATTR_META_DATA_2();                  Marshal.PtrToStructure(info' attrMetaData);                  Debug.Assert(attrMetaData != null);                    Name = Marshal.PtrToStringUni(attrMetaData.pszAttributeName);                  Version = attrMetaData.dwVersion;                  long ftimeChangeValue = (long)((uint)attrMetaData.ftimeLastOriginatingChange1 + (((long)attrMetaData.ftimeLastOriginatingChange2) << 32));                  LastOriginatingChangeTime = DateTime.FromFileTime(ftimeChangeValue);                  LastOriginatingInvocationId = attrMetaData.uuidLastOriginatingDsaInvocationID;                  OriginatingChangeUsn = attrMetaData.usnOriginatingChange;                  LocalChangeUsn = attrMetaData.usnLocalChange;                  _pszLastOriginatingDsaDN = Marshal.PtrToStringUni(attrMetaData.pszLastOriginatingDsaDN);              }              else              {                  DS_REPL_ATTR_META_DATA attrMetaData = new DS_REPL_ATTR_META_DATA();                  Marshal.PtrToStructure(info' attrMetaData);                  Debug.Assert(attrMetaData != null);                    Name = Marshal.PtrToStringUni(attrMetaData.pszAttributeName);                  Version = attrMetaData.dwVersion;                  long ftimeChangeValue = (long)((uint)attrMetaData.ftimeLastOriginatingChange1 + (((long)attrMetaData.ftimeLastOriginatingChange2) << 32));                  LastOriginatingChangeTime = DateTime.FromFileTime(ftimeChangeValue);                  LastOriginatingInvocationId = attrMetaData.uuidLastOriginatingDsaInvocationID;                  OriginatingChangeUsn = attrMetaData.usnOriginatingChange;                  LocalChangeUsn = attrMetaData.usnLocalChange;              }
Magic Number,System.DirectoryServices.ActiveDirectory,AttributeMetadata,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\AttributeMetaData.cs,AttributeMetadata,The following statement contains a magic number: if (advanced)              {                  DS_REPL_ATTR_META_DATA_2 attrMetaData = new DS_REPL_ATTR_META_DATA_2();                  Marshal.PtrToStructure(info' attrMetaData);                  Debug.Assert(attrMetaData != null);                    Name = Marshal.PtrToStringUni(attrMetaData.pszAttributeName);                  Version = attrMetaData.dwVersion;                  long ftimeChangeValue = (long)((uint)attrMetaData.ftimeLastOriginatingChange1 + (((long)attrMetaData.ftimeLastOriginatingChange2) << 32));                  LastOriginatingChangeTime = DateTime.FromFileTime(ftimeChangeValue);                  LastOriginatingInvocationId = attrMetaData.uuidLastOriginatingDsaInvocationID;                  OriginatingChangeUsn = attrMetaData.usnOriginatingChange;                  LocalChangeUsn = attrMetaData.usnLocalChange;                  _pszLastOriginatingDsaDN = Marshal.PtrToStringUni(attrMetaData.pszLastOriginatingDsaDN);              }              else              {                  DS_REPL_ATTR_META_DATA attrMetaData = new DS_REPL_ATTR_META_DATA();                  Marshal.PtrToStructure(info' attrMetaData);                  Debug.Assert(attrMetaData != null);                    Name = Marshal.PtrToStringUni(attrMetaData.pszAttributeName);                  Version = attrMetaData.dwVersion;                  long ftimeChangeValue = (long)((uint)attrMetaData.ftimeLastOriginatingChange1 + (((long)attrMetaData.ftimeLastOriginatingChange2) << 32));                  LastOriginatingChangeTime = DateTime.FromFileTime(ftimeChangeValue);                  LastOriginatingInvocationId = attrMetaData.uuidLastOriginatingDsaInvocationID;                  OriginatingChangeUsn = attrMetaData.usnOriginatingChange;                  LocalChangeUsn = attrMetaData.usnLocalChange;              }
Magic Number,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,FindAnyAdamInstance,The following statement contains a magic number: try              {                  string entryName = (string)rootEntry.Properties["distinguishedName"].Value;                    // Search for computer "serviceConnectionObjects" where the keywords attribute                   // contains the specified keyword                  // set up the searcher object                    // build the filter                  StringBuilder str = new StringBuilder(15);                  str.Append("(&(");                  str.Append(PropertyManager.ObjectCategory);                  str.Append("=serviceConnectionPoint)");                  str.Append("(");                  str.Append(PropertyManager.Keywords);                  str.Append("=1.2.840.113556.1.4.1851)(");                  str.Append(PropertyManager.Keywords);                  str.Append("=");                  str.Append(Utils.GetEscapedFilterValue(context.Name)); // target = config set name                   str.Append("))");                    string filter = str.ToString();                  string[] propertiesToLoad = new string[1];                    propertiesToLoad[0] = PropertyManager.ServiceBindingInformation;                    ADSearcher searcher = new ADSearcher(rootEntry' filter' propertiesToLoad' SearchScope.Subtree' false /*not paged search*/' false /*no cached results*/);                  SearchResultCollection resCol = searcher.FindAll();                    try                  {                      foreach (SearchResult res in resCol)                      {                          // the binding info contains two values                          // "ldap://hostname:ldapport"                          // and "ldaps://hostname:sslport"                          // we need the "hostname:ldapport" value                          string prefix = "ldap://";                            foreach (string bindingInfo in res.Properties[PropertyManager.ServiceBindingInformation])                          {                              if ((bindingInfo.Length > prefix.Length) && (String.Compare(bindingInfo.Substring(0' prefix.Length)' prefix' StringComparison.OrdinalIgnoreCase) == 0))                              {                                  adamInstanceNames.Add(bindingInfo.Substring(prefix.Length));                              }                          }                      }                  }                  finally                  {                      resCol.Dispose();                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  rootEntry.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetApplicationPartitions,The following statement contains a magic number: StringBuilder str = new StringBuilder(100);
Magic Number,System.DirectoryServices.ActiveDirectory,ConfigurationSet,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ConfigSet.cs,GetApplicationPartitions,The following statement contains a magic number: string[] propertiesToLoad = new string[2];
Magic Number,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,Add,The following statement contains a magic number: if (_isForNC)              {                  if ((!_isADAM))                  {                      if (!(server is DomainController))                          throw new ArgumentException(SR.ServerShouldBeDC' "server");                        // verify that the version >= 5.2                      // DC should be Win 2003 or higher                      if (((DomainController)server).NumericOSVersion < 5.2)                      {                          throw new ArgumentException(SR.ServerShouldBeW2K3' "server");                      }                  }                    if (!Contains(server))                  {                      return List.Add(server);                  }                  else                  {                      throw new ArgumentException(SR.Format(SR.AlreadyExistingInCollection ' server)' "server");                  }              }              else              {                  string siteName = (server is DomainController) ? ((DomainController)server).SiteObjectName : ((AdamInstance)server).SiteObjectName;                  Debug.Assert(siteName != null);                  if (Utils.Compare(siteDN' siteName) != 0)                  {                      throw new ArgumentException(SR.NotWithinSite);                  }                    if (!Contains(server))                      return List.Add(server);                  else                      throw new ArgumentException(SR.Format(SR.AlreadyExistingInCollection ' server)' "server");              }
Magic Number,System.DirectoryServices.ActiveDirectory,DirectoryServerCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DirectoryServerCollection.cs,Insert,The following statement contains a magic number: if (_isForNC)              {                  if ((!_isADAM))                  {                      if (!(server is DomainController))                          throw new ArgumentException(SR.ServerShouldBeDC' "server");                        // verify that the version >= 5.2                      // DC should be Win 2003 or higher                      if (((DomainController)server).NumericOSVersion < 5.2)                      {                          throw new ArgumentException(SR.ServerShouldBeW2K3' "server");                      }                  }                    if (!Contains(server))                  {                      List.Insert(index' server);                  }                  else                  {                      throw new ArgumentException(SR.Format(SR.AlreadyExistingInCollection ' server)' "server");                  }              }              else              {                  // make sure that it is within the current site                  string siteName = (server is DomainController) ? ((DomainController)server).SiteObjectName : ((AdamInstance)server).SiteObjectName;                  Debug.Assert(siteName != null);                  if (Utils.Compare(siteDN' siteName) != 0)                  {                      throw new ArgumentException(SR.NotWithinSite' "server");                  }                    if (!Contains(server))                      List.Insert(index' server);                  else                      throw new ArgumentException(SR.Format(SR.AlreadyExistingInCollection ' server));              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionalityLevel,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    // set the new functional level                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = domainMode;                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == 2 || domainMode == 0)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode > 2) // new level should be less than or equal to Windows2003                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                              break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == 2) // only Windows2003 allowed                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        default:                          break;                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionalityLevel,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    // set the new functional level                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = domainMode;                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == 2 || domainMode == 0)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode > 2) // new level should be less than or equal to Windows2003                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                              break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == 2) // only Windows2003 allowed                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        default:                          break;                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionalityLevel,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    // set the new functional level                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = domainMode;                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == 2 || domainMode == 0)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode > 2) // new level should be less than or equal to Windows2003                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                              break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == 2) // only Windows2003 allowed                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        default:                          break;                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == DomainMode.Windows2000NativeDomain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode == DomainMode.Windows2003InterimDomain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 1;                              }                              else if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2000NativeDomain:                      case DomainMode.Windows2003Domain:                      case DomainMode.Windows2008Domain:                      case DomainMode.Windows2008R2Domain:                      case DomainMode.Windows8Domain:                      case DomainMode.Windows2012R2Domain:                          {                              if (existingDomainMode >= domainMode)                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else if (domainMode == DomainMode.Windows2008Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 3;                              }                              else if (domainMode == DomainMode.Windows2008R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 4;                              }                              else if (domainMode == DomainMode.Windows8Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 5;                              }                              else if (domainMode == DomainMode.Windows2012R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 6;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                          }                          break;                      default:                          {                              // should not happen                              throw new ActiveDirectoryOperationException();                          }                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == DomainMode.Windows2000NativeDomain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode == DomainMode.Windows2003InterimDomain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 1;                              }                              else if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2000NativeDomain:                      case DomainMode.Windows2003Domain:                      case DomainMode.Windows2008Domain:                      case DomainMode.Windows2008R2Domain:                      case DomainMode.Windows8Domain:                      case DomainMode.Windows2012R2Domain:                          {                              if (existingDomainMode >= domainMode)                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else if (domainMode == DomainMode.Windows2008Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 3;                              }                              else if (domainMode == DomainMode.Windows2008R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 4;                              }                              else if (domainMode == DomainMode.Windows8Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 5;                              }                              else if (domainMode == DomainMode.Windows2012R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 6;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                          }                          break;                      default:                          {                              // should not happen                              throw new ActiveDirectoryOperationException();                          }                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == DomainMode.Windows2000NativeDomain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode == DomainMode.Windows2003InterimDomain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 1;                              }                              else if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2000NativeDomain:                      case DomainMode.Windows2003Domain:                      case DomainMode.Windows2008Domain:                      case DomainMode.Windows2008R2Domain:                      case DomainMode.Windows8Domain:                      case DomainMode.Windows2012R2Domain:                          {                              if (existingDomainMode >= domainMode)                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else if (domainMode == DomainMode.Windows2008Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 3;                              }                              else if (domainMode == DomainMode.Windows2008R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 4;                              }                              else if (domainMode == DomainMode.Windows8Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 5;                              }                              else if (domainMode == DomainMode.Windows2012R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 6;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                          }                          break;                      default:                          {                              // should not happen                              throw new ActiveDirectoryOperationException();                          }                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == DomainMode.Windows2000NativeDomain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode == DomainMode.Windows2003InterimDomain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 1;                              }                              else if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2000NativeDomain:                      case DomainMode.Windows2003Domain:                      case DomainMode.Windows2008Domain:                      case DomainMode.Windows2008R2Domain:                      case DomainMode.Windows8Domain:                      case DomainMode.Windows2012R2Domain:                          {                              if (existingDomainMode >= domainMode)                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else if (domainMode == DomainMode.Windows2008Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 3;                              }                              else if (domainMode == DomainMode.Windows2008R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 4;                              }                              else if (domainMode == DomainMode.Windows8Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 5;                              }                              else if (domainMode == DomainMode.Windows2012R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 6;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                          }                          break;                      default:                          {                              // should not happen                              throw new ActiveDirectoryOperationException();                          }                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == DomainMode.Windows2000NativeDomain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode == DomainMode.Windows2003InterimDomain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 1;                              }                              else if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2000NativeDomain:                      case DomainMode.Windows2003Domain:                      case DomainMode.Windows2008Domain:                      case DomainMode.Windows2008R2Domain:                      case DomainMode.Windows8Domain:                      case DomainMode.Windows2012R2Domain:                          {                              if (existingDomainMode >= domainMode)                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else if (domainMode == DomainMode.Windows2008Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 3;                              }                              else if (domainMode == DomainMode.Windows2008R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 4;                              }                              else if (domainMode == DomainMode.Windows8Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 5;                              }                              else if (domainMode == DomainMode.Windows2012R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 6;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                          }                          break;                      default:                          {                              // should not happen                              throw new ActiveDirectoryOperationException();                          }                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == DomainMode.Windows2000NativeDomain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode == DomainMode.Windows2003InterimDomain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 1;                              }                              else if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2000NativeDomain:                      case DomainMode.Windows2003Domain:                      case DomainMode.Windows2008Domain:                      case DomainMode.Windows2008R2Domain:                      case DomainMode.Windows8Domain:                      case DomainMode.Windows2012R2Domain:                          {                              if (existingDomainMode >= domainMode)                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else if (domainMode == DomainMode.Windows2008Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 3;                              }                              else if (domainMode == DomainMode.Windows2008R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 4;                              }                              else if (domainMode == DomainMode.Windows8Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 5;                              }                              else if (domainMode == DomainMode.Windows2012R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 6;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                          }                          break;                      default:                          {                              // should not happen                              throw new ActiveDirectoryOperationException();                          }                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,RaiseDomainFunctionality,The following statement contains a magic number: try              {                  domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                    switch (existingDomainMode)                  {                      case DomainMode.Windows2000MixedDomain:                          {                              if (domainMode == DomainMode.Windows2000NativeDomain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                              }                              else if (domainMode == DomainMode.Windows2003InterimDomain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 1;                              }                              else if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2003InterimDomain:                          {                              if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.NTMixedDomain].Value = 0;                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                break;                          }                        case DomainMode.Windows2000NativeDomain:                      case DomainMode.Windows2003Domain:                      case DomainMode.Windows2008Domain:                      case DomainMode.Windows2008R2Domain:                      case DomainMode.Windows8Domain:                      case DomainMode.Windows2012R2Domain:                          {                              if (existingDomainMode >= domainMode)                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                                if (domainMode == DomainMode.Windows2003Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 2;                              }                              else if (domainMode == DomainMode.Windows2008Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 3;                              }                              else if (domainMode == DomainMode.Windows2008R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 4;                              }                              else if (domainMode == DomainMode.Windows8Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 5;                              }                              else if (domainMode == DomainMode.Windows2012R2Domain)                              {                                  domainEntry.Properties[PropertyManager.MsDSBehaviorVersion].Value = 6;                              }                              else                              {                                  throw new ArgumentException(SR.InvalidMode' "domainMode");                              }                          }                          break;                      default:                          {                              // should not happen                              throw new ActiveDirectoryOperationException();                          }                  }                    // NOTE:                   // If the domain controller we are talking to is W2K                   // (more specifically the schema is a W2K schema) then the                  // msDS-Behavior-Version attribute will not be present.                  // If that is the case' the domain functionality cannot be raised                  // to Windows2003InterimDomain or Windows2003Domain (which is when we would set this attribute)                  // since there are only W2K domain controllers                  // So' we catch that exception and throw a more meaningful one.                  domainEntry.CommitChanges();              }              catch (System.Runtime.InteropServices.COMException e)              {                  if (e.ErrorCode == unchecked((int)0x8007200A))                  {                      // attribute does not exist which means this is not a W2K3 DC                      // cannot raise domain functionality                      throw new ArgumentException(SR.NoW2K3DCs' "domainMode");                  }                  else                  {                      throw ExceptionHelper.GetExceptionFromCOMException(context' e);                  }              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomainMode,The following statement contains a magic number: try              {                  // If the "domainFunctionality" attribute is not set on the rootdse' then                   // this is a W2K domain (with W2K schema) so just check for mixed or native                  switch (domainFunctionality)                  {                      case 0:                          {                              domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                              int ntMixedDomain = (int)PropertyManager.GetPropertyValue(context' domainEntry' PropertyManager.NTMixedDomain);                                if (ntMixedDomain == 0)                              {                                  domainMode = DomainMode.Windows2000NativeDomain;                              }                              else                              {                                  domainMode = DomainMode.Windows2000MixedDomain;                              }                              break;                          }                        case 1:                          domainMode = DomainMode.Windows2003InterimDomain;                          break;                        case 2:                          domainMode = DomainMode.Windows2003Domain;                          break;                        case 3:                          domainMode = DomainMode.Windows2008Domain;                          break;                      case 4:                          domainMode = DomainMode.Windows2008R2Domain;                          break;                      case 5:                          domainMode = DomainMode.Windows8Domain;                          break;                      case 6:                          domainMode = DomainMode.Windows2012R2Domain;                          break;                      default:                          // unrecognized domain mode                          domainMode = DomainMode.Unknown;                          break;                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomainMode,The following statement contains a magic number: try              {                  // If the "domainFunctionality" attribute is not set on the rootdse' then                   // this is a W2K domain (with W2K schema) so just check for mixed or native                  switch (domainFunctionality)                  {                      case 0:                          {                              domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                              int ntMixedDomain = (int)PropertyManager.GetPropertyValue(context' domainEntry' PropertyManager.NTMixedDomain);                                if (ntMixedDomain == 0)                              {                                  domainMode = DomainMode.Windows2000NativeDomain;                              }                              else                              {                                  domainMode = DomainMode.Windows2000MixedDomain;                              }                              break;                          }                        case 1:                          domainMode = DomainMode.Windows2003InterimDomain;                          break;                        case 2:                          domainMode = DomainMode.Windows2003Domain;                          break;                        case 3:                          domainMode = DomainMode.Windows2008Domain;                          break;                      case 4:                          domainMode = DomainMode.Windows2008R2Domain;                          break;                      case 5:                          domainMode = DomainMode.Windows8Domain;                          break;                      case 6:                          domainMode = DomainMode.Windows2012R2Domain;                          break;                      default:                          // unrecognized domain mode                          domainMode = DomainMode.Unknown;                          break;                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomainMode,The following statement contains a magic number: try              {                  // If the "domainFunctionality" attribute is not set on the rootdse' then                   // this is a W2K domain (with W2K schema) so just check for mixed or native                  switch (domainFunctionality)                  {                      case 0:                          {                              domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                              int ntMixedDomain = (int)PropertyManager.GetPropertyValue(context' domainEntry' PropertyManager.NTMixedDomain);                                if (ntMixedDomain == 0)                              {                                  domainMode = DomainMode.Windows2000NativeDomain;                              }                              else                              {                                  domainMode = DomainMode.Windows2000MixedDomain;                              }                              break;                          }                        case 1:                          domainMode = DomainMode.Windows2003InterimDomain;                          break;                        case 2:                          domainMode = DomainMode.Windows2003Domain;                          break;                        case 3:                          domainMode = DomainMode.Windows2008Domain;                          break;                      case 4:                          domainMode = DomainMode.Windows2008R2Domain;                          break;                      case 5:                          domainMode = DomainMode.Windows8Domain;                          break;                      case 6:                          domainMode = DomainMode.Windows2012R2Domain;                          break;                      default:                          // unrecognized domain mode                          domainMode = DomainMode.Unknown;                          break;                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomainMode,The following statement contains a magic number: try              {                  // If the "domainFunctionality" attribute is not set on the rootdse' then                   // this is a W2K domain (with W2K schema) so just check for mixed or native                  switch (domainFunctionality)                  {                      case 0:                          {                              domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                              int ntMixedDomain = (int)PropertyManager.GetPropertyValue(context' domainEntry' PropertyManager.NTMixedDomain);                                if (ntMixedDomain == 0)                              {                                  domainMode = DomainMode.Windows2000NativeDomain;                              }                              else                              {                                  domainMode = DomainMode.Windows2000MixedDomain;                              }                              break;                          }                        case 1:                          domainMode = DomainMode.Windows2003InterimDomain;                          break;                        case 2:                          domainMode = DomainMode.Windows2003Domain;                          break;                        case 3:                          domainMode = DomainMode.Windows2008Domain;                          break;                      case 4:                          domainMode = DomainMode.Windows2008R2Domain;                          break;                      case 5:                          domainMode = DomainMode.Windows8Domain;                          break;                      case 6:                          domainMode = DomainMode.Windows2012R2Domain;                          break;                      default:                          // unrecognized domain mode                          domainMode = DomainMode.Unknown;                          break;                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetDomainMode,The following statement contains a magic number: try              {                  // If the "domainFunctionality" attribute is not set on the rootdse' then                   // this is a W2K domain (with W2K schema) so just check for mixed or native                  switch (domainFunctionality)                  {                      case 0:                          {                              domainEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.DefaultNamingContext));                              int ntMixedDomain = (int)PropertyManager.GetPropertyValue(context' domainEntry' PropertyManager.NTMixedDomain);                                if (ntMixedDomain == 0)                              {                                  domainMode = DomainMode.Windows2000NativeDomain;                              }                              else                              {                                  domainMode = DomainMode.Windows2000MixedDomain;                              }                              break;                          }                        case 1:                          domainMode = DomainMode.Windows2003InterimDomain;                          break;                        case 2:                          domainMode = DomainMode.Windows2003Domain;                          break;                        case 3:                          domainMode = DomainMode.Windows2008Domain;                          break;                      case 4:                          domainMode = DomainMode.Windows2008R2Domain;                          break;                      case 5:                          domainMode = DomainMode.Windows8Domain;                          break;                      case 6:                          domainMode = DomainMode.Windows2012R2Domain;                          break;                      default:                          // unrecognized domain mode                          domainMode = DomainMode.Unknown;                          break;                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (domainEntry != null)                  {                      domainEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,LoadCrossRefAttributes,The following statement contains a magic number: try              {                  partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer));                    // now within the partitions container search for the                   // crossRef object that has it's "dnsRoot" attribute equal to the                   // dns name of the current domain                    // build the filter                  StringBuilder str = new StringBuilder(15);                  str.Append("(&(");                  str.Append(PropertyManager.ObjectCategory);                  str.Append("=crossRef)(");                  str.Append(PropertyManager.SystemFlags);                  str.Append(":1.2.840.113556.1.4.804:=");                  str.Append((int)SystemFlag.SystemFlagNtdsNC);                  str.Append(")(");                  str.Append(PropertyManager.SystemFlags);                  str.Append(":1.2.840.113556.1.4.804:=");                  str.Append((int)SystemFlag.SystemFlagNtdsDomain);                  str.Append(")(");                  str.Append(PropertyManager.DnsRoot);                  str.Append("=");                  str.Append(Utils.GetEscapedFilterValue(partitionName));                  str.Append("))");                    string filter = str.ToString();                  string[] propertiesToLoad = new string[2];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.TrustParent;                    ADSearcher searcher = new ADSearcher(partitionsEntry' filter' propertiesToLoad' SearchScope.OneLevel' false /*not paged search*/' false /*no cached results*/);                  SearchResult res = searcher.FindOne();                    _crossRefDN = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                    // "trustParent" attribute may not be set                  if (res.Properties[PropertyManager.TrustParent].Count > 0)                  {                      _trustParent = (string)res.Properties[PropertyManager.TrustParent][0];                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (partitionsEntry != null)                  {                      partitionsEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,LoadCrossRefAttributes,The following statement contains a magic number: try              {                  partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer));                    // now within the partitions container search for the                   // crossRef object that has it's "dnsRoot" attribute equal to the                   // dns name of the current domain                    // build the filter                  StringBuilder str = new StringBuilder(15);                  str.Append("(&(");                  str.Append(PropertyManager.ObjectCategory);                  str.Append("=crossRef)(");                  str.Append(PropertyManager.SystemFlags);                  str.Append(":1.2.840.113556.1.4.804:=");                  str.Append((int)SystemFlag.SystemFlagNtdsNC);                  str.Append(")(");                  str.Append(PropertyManager.SystemFlags);                  str.Append(":1.2.840.113556.1.4.804:=");                  str.Append((int)SystemFlag.SystemFlagNtdsDomain);                  str.Append(")(");                  str.Append(PropertyManager.DnsRoot);                  str.Append("=");                  str.Append(Utils.GetEscapedFilterValue(partitionName));                  str.Append("))");                    string filter = str.ToString();                  string[] propertiesToLoad = new string[2];                    propertiesToLoad[0] = PropertyManager.DistinguishedName;                  propertiesToLoad[1] = PropertyManager.TrustParent;                    ADSearcher searcher = new ADSearcher(partitionsEntry' filter' propertiesToLoad' SearchScope.OneLevel' false /*not paged search*/' false /*no cached results*/);                  SearchResult res = searcher.FindOne();                    _crossRefDN = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                    // "trustParent" attribute may not be set                  if (res.Properties[PropertyManager.TrustParent].Count > 0)                  {                      _trustParent = (string)res.Properties[PropertyManager.TrustParent][0];                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (partitionsEntry != null)                  {                      partitionsEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetChildDomains,The following statement contains a magic number: try              {                  partitionsEntry = DirectoryEntryManager.GetDirectoryEntry(context' directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.PartitionsContainer));                  // search for all the "crossRef" objects that have the                   // ADS_SYSTEMFLAG_CR_NTDS_NC and SYSTEMFLAG_CR_NTDS_DOMAIN flags set                  // (one-level search is good enough)                    // setup the directory searcher object                    // build the filter                  StringBuilder str = new StringBuilder(15);                  str.Append("(&(");                  str.Append(PropertyManager.ObjectCategory);                  str.Append("=crossRef)(");                  str.Append(PropertyManager.SystemFlags);                  str.Append(":1.2.840.113556.1.4.804:=");                  str.Append((int)SystemFlag.SystemFlagNtdsNC);                  str.Append(")(");                  str.Append(PropertyManager.SystemFlags);                  str.Append(":1.2.840.113556.1.4.804:=");                  str.Append((int)SystemFlag.SystemFlagNtdsDomain);                  str.Append(")(");                  str.Append(PropertyManager.TrustParent);                  str.Append("=");                  str.Append(Utils.GetEscapedFilterValue(_crossRefDN));                  str.Append("))");                    string filter = str.ToString();                  string[] propertiesToLoad = new string[1];                  propertiesToLoad[0] = PropertyManager.DnsRoot;                    ADSearcher searcher = new ADSearcher(partitionsEntry' filter' propertiesToLoad' SearchScope.OneLevel);                  resCol = searcher.FindAll();                    foreach (SearchResult res in resCol)                  {                      string childDomainName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsRoot);                      DirectoryContext childContext = Utils.GetNewDirectoryContext(childDomainName' DirectoryContextType.Domain' context);                      childDomains.Add(new Domain(childContext' childDomainName));                  }              }              catch (COMException e)              {                  throw ExceptionHelper.GetExceptionFromCOMException(context' e);              }              finally              {                  if (resCol != null)                  {                      resCol.Dispose();                  }                  if (partitionsEntry != null)                  {                      partitionsEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustsHelper,The following statement contains a magic number: try              {                  // now enumerate through the collection                  if (domains != (IntPtr)0 && count != 0)                  {                      IntPtr addr = (IntPtr)0;                      int j = 0;                      for (int i = 0; i < count; i++)                      {                          // get the unmanaged trust object                          addr = IntPtr.Add(domains' +i * Marshal.SizeOf(typeof(DS_DOMAIN_TRUSTS)));                          DS_DOMAIN_TRUSTS unmanagedTrust = new DS_DOMAIN_TRUSTS();                          Marshal.PtrToStructure(addr' unmanagedTrust);                            unmanagedTrustList.Add(unmanagedTrust);                      }                        for (int i = 0; i < unmanagedTrustList.Count; i++)                      {                          DS_DOMAIN_TRUSTS unmanagedTrust = (DS_DOMAIN_TRUSTS)unmanagedTrustList[i];                            // make sure this is the trust object that we want                          if ((unmanagedTrust.Flags & (int)(DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY | DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_INBOUND)) == 0)                          {                              // Not interested in indirectly trusted domains.                              continue;                          }                            // we don't want to have the NT4 trust to be returned                          if (unmanagedTrust.TrustType == TrustHelper.TRUST_TYPE_DOWNLEVEL)                              continue;                            TrustObject obj = new TrustObject();                          obj.TrustType = TrustType.Unknown;                          if (unmanagedTrust.DnsDomainName != (IntPtr)0)                              obj.DnsDomainName = Marshal.PtrToStringUni(unmanagedTrust.DnsDomainName);                          if (unmanagedTrust.NetbiosDomainName != (IntPtr)0)                              obj.NetbiosDomainName = Marshal.PtrToStringUni(unmanagedTrust.NetbiosDomainName);                          obj.Flags = unmanagedTrust.Flags;                          obj.TrustAttributes = unmanagedTrust.TrustAttributes;                          obj.OriginalIndex = i;                          obj.ParentIndex = unmanagedTrust.ParentIndex;                            // check whether it is the case that we are only interested in the trust with target as specified                          if (targetDomainName != null)                          {                              bool sameTarget = false;                                // check whether it is the same target                              if (obj.DnsDomainName != null && Utils.Compare(targetDomainName' obj.DnsDomainName) == 0)                                  sameTarget = true;                              else if (obj.NetbiosDomainName != null && Utils.Compare(targetDomainName' obj.NetbiosDomainName) == 0)                                  sameTarget = true;                                // we only want to need local domain and specified target domain trusts                              if (!sameTarget && (obj.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY) == 0)                                  continue;                          }                            // local domain case                          if ((obj.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY) != 0)                          {                              localDomainIndex = j;                                // verify whether this is already the root                              if ((obj.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_TREE_ROOT) == 0)                              {                                  // get the parent domain name                                  DS_DOMAIN_TRUSTS parentTrust = (DS_DOMAIN_TRUSTS)unmanagedTrustList[obj.ParentIndex];                                  if (parentTrust.DnsDomainName != (IntPtr)0)                                      localDomainParent = Marshal.PtrToStringUni(parentTrust.DnsDomainName);                              }                                // this is the trust type SELF                              obj.TrustType = (TrustType)7;                          }                          // this is the case of MIT kerberos trust                          else if (unmanagedTrust.TrustType == 3)                          {                              obj.TrustType = TrustType.Kerberos;                          }                            j++;                          tmpTrustList.Add(obj);                      }                        // now determine the trust type                      for (int i = 0; i < tmpTrustList.Count; i++)                      {                          TrustObject tmpObject = (TrustObject)tmpTrustList[i];                          // local domain case' trust type has been determined                          if (i == localDomainIndex)                              continue;                            if (tmpObject.TrustType == TrustType.Kerberos)                              continue;                            // parent domain                          if (localDomainParent != null && Utils.Compare(localDomainParent' tmpObject.DnsDomainName) == 0)                          {                              tmpObject.TrustType = TrustType.ParentChild;                              continue;                          }                            if ((tmpObject.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_IN_FOREST) != 0)                          {                              // child domain                                                                if (tmpObject.ParentIndex == ((TrustObject)tmpTrustList[localDomainIndex]).OriginalIndex)                              {                                  tmpObject.TrustType = TrustType.ParentChild;                              }                              // tree root                              else if ((tmpObject.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_TREE_ROOT) != 0 &&                                (((TrustObject)tmpTrustList[localDomainIndex]).Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_TREE_ROOT) != 0)                              {                                  string tmpForestName = null;                                  string rootDomainNC = directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.RootDomainNamingContext);                                  tmpForestName = Utils.GetDnsNameFromDN(rootDomainNC);                                    // only if either the local domain or tmpObject is the tree root' will this trust relationship be a Root' otherwise it is cross link                                  DirectoryContext tmpContext = Utils.GetNewDirectoryContext(context.Name' DirectoryContextType.Forest' context);                                  if (tmpContext.isRootDomain() || Utils.Compare(tmpObject.DnsDomainName' tmpForestName) == 0)                                  {                                      tmpObject.TrustType = TrustType.TreeRoot;                                  }                                  else                                  {                                      tmpObject.TrustType = TrustType.CrossLink;                                  }                              }                              else                              {                                  tmpObject.TrustType = TrustType.CrossLink;                              }                                continue;                          }                            // external trust or forest trust                          if ((tmpObject.TrustAttributes & (int)TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0)                          {                              // should not happen as we specify DS_DOMAIN_IN_FOREST when enumerating the trust' so forest trust will not be returned                              tmpObject.TrustType = TrustType.Forest;                          }                          else                          {                              tmpObject.TrustType = TrustType.External;                          }                      }                  }                    return tmpTrustList;              }              finally              {                  if (domains != (IntPtr)0)                      UnsafeNativeMethods.NetApiBufferFree(domains);              }
Magic Number,System.DirectoryServices.ActiveDirectory,Domain,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Domain.cs,GetTrustsHelper,The following statement contains a magic number: try              {                  // now enumerate through the collection                  if (domains != (IntPtr)0 && count != 0)                  {                      IntPtr addr = (IntPtr)0;                      int j = 0;                      for (int i = 0; i < count; i++)                      {                          // get the unmanaged trust object                          addr = IntPtr.Add(domains' +i * Marshal.SizeOf(typeof(DS_DOMAIN_TRUSTS)));                          DS_DOMAIN_TRUSTS unmanagedTrust = new DS_DOMAIN_TRUSTS();                          Marshal.PtrToStructure(addr' unmanagedTrust);                            unmanagedTrustList.Add(unmanagedTrust);                      }                        for (int i = 0; i < unmanagedTrustList.Count; i++)                      {                          DS_DOMAIN_TRUSTS unmanagedTrust = (DS_DOMAIN_TRUSTS)unmanagedTrustList[i];                            // make sure this is the trust object that we want                          if ((unmanagedTrust.Flags & (int)(DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY | DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAINTRUST_FLAG.DS_DOMAIN_DIRECT_INBOUND)) == 0)                          {                              // Not interested in indirectly trusted domains.                              continue;                          }                            // we don't want to have the NT4 trust to be returned                          if (unmanagedTrust.TrustType == TrustHelper.TRUST_TYPE_DOWNLEVEL)                              continue;                            TrustObject obj = new TrustObject();                          obj.TrustType = TrustType.Unknown;                          if (unmanagedTrust.DnsDomainName != (IntPtr)0)                              obj.DnsDomainName = Marshal.PtrToStringUni(unmanagedTrust.DnsDomainName);                          if (unmanagedTrust.NetbiosDomainName != (IntPtr)0)                              obj.NetbiosDomainName = Marshal.PtrToStringUni(unmanagedTrust.NetbiosDomainName);                          obj.Flags = unmanagedTrust.Flags;                          obj.TrustAttributes = unmanagedTrust.TrustAttributes;                          obj.OriginalIndex = i;                          obj.ParentIndex = unmanagedTrust.ParentIndex;                            // check whether it is the case that we are only interested in the trust with target as specified                          if (targetDomainName != null)                          {                              bool sameTarget = false;                                // check whether it is the same target                              if (obj.DnsDomainName != null && Utils.Compare(targetDomainName' obj.DnsDomainName) == 0)                                  sameTarget = true;                              else if (obj.NetbiosDomainName != null && Utils.Compare(targetDomainName' obj.NetbiosDomainName) == 0)                                  sameTarget = true;                                // we only want to need local domain and specified target domain trusts                              if (!sameTarget && (obj.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY) == 0)                                  continue;                          }                            // local domain case                          if ((obj.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_PRIMARY) != 0)                          {                              localDomainIndex = j;                                // verify whether this is already the root                              if ((obj.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_TREE_ROOT) == 0)                              {                                  // get the parent domain name                                  DS_DOMAIN_TRUSTS parentTrust = (DS_DOMAIN_TRUSTS)unmanagedTrustList[obj.ParentIndex];                                  if (parentTrust.DnsDomainName != (IntPtr)0)                                      localDomainParent = Marshal.PtrToStringUni(parentTrust.DnsDomainName);                              }                                // this is the trust type SELF                              obj.TrustType = (TrustType)7;                          }                          // this is the case of MIT kerberos trust                          else if (unmanagedTrust.TrustType == 3)                          {                              obj.TrustType = TrustType.Kerberos;                          }                            j++;                          tmpTrustList.Add(obj);                      }                        // now determine the trust type                      for (int i = 0; i < tmpTrustList.Count; i++)                      {                          TrustObject tmpObject = (TrustObject)tmpTrustList[i];                          // local domain case' trust type has been determined                          if (i == localDomainIndex)                              continue;                            if (tmpObject.TrustType == TrustType.Kerberos)                              continue;                            // parent domain                          if (localDomainParent != null && Utils.Compare(localDomainParent' tmpObject.DnsDomainName) == 0)                          {                              tmpObject.TrustType = TrustType.ParentChild;                              continue;                          }                            if ((tmpObject.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_IN_FOREST) != 0)                          {                              // child domain                                                                if (tmpObject.ParentIndex == ((TrustObject)tmpTrustList[localDomainIndex]).OriginalIndex)                              {                                  tmpObject.TrustType = TrustType.ParentChild;                              }                              // tree root                              else if ((tmpObject.Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_TREE_ROOT) != 0 &&                                (((TrustObject)tmpTrustList[localDomainIndex]).Flags & (int)DS_DOMAINTRUST_FLAG.DS_DOMAIN_TREE_ROOT) != 0)                              {                                  string tmpForestName = null;                                  string rootDomainNC = directoryEntryMgr.ExpandWellKnownDN(WellKnownDN.RootDomainNamingContext);                                  tmpForestName = Utils.GetDnsNameFromDN(rootDomainNC);                                    // only if either the local domain or tmpObject is the tree root' will this trust relationship be a Root' otherwise it is cross link                                  DirectoryContext tmpContext = Utils.GetNewDirectoryContext(context.Name' DirectoryContextType.Forest' context);                                  if (tmpContext.isRootDomain() || Utils.Compare(tmpObject.DnsDomainName' tmpForestName) == 0)                                  {                                      tmpObject.TrustType = TrustType.TreeRoot;                                  }                                  else                                  {                                      tmpObject.TrustType = TrustType.CrossLink;                                  }                              }                              else                              {                                  tmpObject.TrustType = TrustType.CrossLink;                              }                                continue;                          }                            // external trust or forest trust                          if ((tmpObject.TrustAttributes & (int)TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_FOREST_TRANSITIVE) != 0)                          {                              // should not happen as we specify DS_DOMAIN_IN_FOREST when enumerating the trust' so forest trust will not be returned                              tmpObject.TrustType = TrustType.Forest;                          }                          else                          {                              tmpObject.TrustType = TrustType.External;                          }                      }                  }                    return tmpTrustList;              }              finally              {                  if (domains != (IntPtr)0)                      UnsafeNativeMethods.NetApiBufferFree(domains);              }
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,DomainController,The following statement contains a magic number: _becomeRoleOwnerAttrs = new String[5];
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,DomainController,The following statement contains a magic number: _becomeRoleOwnerAttrs[2] = PropertyManager.BecomePdc;
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,DomainController,The following statement contains a magic number: _becomeRoleOwnerAttrs[3] = PropertyManager.BecomeRidMaster;
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,DomainController,The following statement contains a magic number: _becomeRoleOwnerAttrs[4] = PropertyManager.BecomeInfrastructureMaster;
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneInternal,The following statement contains a magic number: Debug.Assert(domainControllerInfo.DomainControllerName.Length > 2);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,FindOneInternal,The following statement contains a magic number: string domainControllerName = domainControllerInfo.DomainControllerName.Substring(2);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int year = (int)Int32.Parse(dateTime.Substring(0' 4)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int month = (int)Int32.Parse(dateTime.Substring(4' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int month = (int)Int32.Parse(dateTime.Substring(4' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int day = (int)Int32.Parse(dateTime.Substring(6' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int day = (int)Int32.Parse(dateTime.Substring(6' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int hour = (int)Int32.Parse(dateTime.Substring(8' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int hour = (int)Int32.Parse(dateTime.Substring(8' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int min = (int)Int32.Parse(dateTime.Substring(10' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int min = (int)Int32.Parse(dateTime.Substring(10' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int sec = (int)Int32.Parse(dateTime.Substring(12' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,DomainController,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\DomainController.cs,ParseDateTime,The following statement contains a magic number: int sec = (int)Int32.Parse(dateTime.Substring(12' 2)' NumberFormatInfo.InvariantInfo);
Magic Number,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetErrorMessage,The following statement contains a magic number: if (!hresult)              {                  temp = ((((temp) & 0x0000FFFF) | (7 << 16) | 0x80000000));              }
Magic Number,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetErrorMessage,The following statement contains a magic number: if (!hresult)              {                  temp = ((((temp) & 0x0000FFFF) | (7 << 16) | 0x80000000));              }
Magic Number,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetErrorMessage,The following statement contains a magic number: StringBuilder sb = new StringBuilder(256);
Magic Number,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,GetErrorMessage,The following statement contains a magic number: if (result != 0)              {                  errorMsg = sb.ToString(0' result);              }              else              {                  errorMsg = SR.Format(SR.DSUnknown ' Convert.ToString(temp' 16));              }
Magic Number,System.DirectoryServices.ActiveDirectory,ExceptionHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Exception.cs,CreateForestTrustCollisionException,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  addr = Marshal.ReadIntPtr(collision.Entries' i * IntPtr.Size);                  LSA_FOREST_TRUST_COLLISION_RECORD record = new LSA_FOREST_TRUST_COLLISION_RECORD();                  Marshal.PtrToStructure(addr' record);                    ForestTrustCollisionType type = record.Type;                  string recordName = Marshal.PtrToStringUni(record.Name.Buffer' record.Name.Length / 2);                  TopLevelNameCollisionOptions TLNFlag = TopLevelNameCollisionOptions.None;                  DomainCollisionOptions domainFlag = DomainCollisionOptions.None;                  if (type == ForestTrustCollisionType.TopLevelName)                  {                      TLNFlag = (TopLevelNameCollisionOptions)record.Flags;                  }                  else if (type == ForestTrustCollisionType.Domain)                  {                      domainFlag = (DomainCollisionOptions)record.Flags;                  }                  ForestTrustRelationshipCollision tmp = new ForestTrustRelationshipCollision(type' TLNFlag' domainFlag' recordName);                  collection.Add(tmp);              }
Magic Number,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetApplicationPartitions,The following statement contains a magic number: StringBuilder str = new StringBuilder(15);
Magic Number,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetApplicationPartitions,The following statement contains a magic number: string[] propertiesToLoad = new string[2];
Magic Number,System.DirectoryServices.ActiveDirectory,Forest,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Forest.cs,GetDomains,The following statement contains a magic number: StringBuilder str = new StringBuilder(15);
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustDomainInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustDomainInformation.cs,ForestTrustDomainInformation,The following statement contains a magic number: DnsName = Marshal.PtrToStringUni(domainInfo.DNSNameBuffer' domainInfo.DNSNameLength / 2);
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustDomainInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustDomainInformation.cs,ForestTrustDomainInformation,The following statement contains a magic number: NetBiosName = Marshal.PtrToStringUni(domainInfo.NetBIOSNameBuffer' domainInfo.NetBIOSNameLength / 2);
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,The following statement contains a magic number: try              {                  try                  {                      IntPtr ptr = (IntPtr)0;                      fileTime = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(FileTime)));                      UnsafeNativeMethods.GetSystemTimeAsFileTime(fileTime);                        // set the time                      FileTime currentTime = new FileTime();                      Marshal.PtrToStructure(fileTime' currentTime);                        for (int i = 0; i < toplevelNamesCount; i++)                      {                          // now begin to construct top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_topLevelNames[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName;                          TopLevelName TLN = _topLevelNames[i];                          record.Time = TLN.time;                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(TLN.Name);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                            tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < excludedNamesCount; i++)                      {                          // now begin to construct excluded top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = 0;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx;                          if (_excludedNameTime.Contains(_excludedNames[i]))                          {                              record.Time = (LARGE_INTEGER)_excludedNameTime[i];                          }                          else                          {                              record.Time = new LARGE_INTEGER();                              record.Time.lowPart = currentTime.lower;                              record.Time.highPart = currentTime.higher;                          }                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(_excludedNames[i]);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < trustedDomainCount; i++)                      {                          // now begin to construct domain info record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_domainInfo[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo;                          ForestTrustDomainInformation tmp = _domainInfo[i];                          record.Time = tmp.time;                          IntPtr pSid = (IntPtr)0;                          IntPtr stringSid = (IntPtr)0;                          stringSid = Marshal.StringToHGlobalUni(tmp.DomainSid);                          ptrList.Add(stringSid);                          int result = UnsafeNativeMethods.ConvertStringSidToSidW(stringSid' ref pSid);                          if (result == 0)                          {                              throw ExceptionHelper.GetExceptionFromErrorCode(Marshal.GetLastWin32Error());                          }                          record.DomainInfo = new LSA_FOREST_TRUST_DOMAIN_INFO();                          record.DomainInfo.sid = pSid;                          sidList.Add(pSid);                          record.DomainInfo.DNSNameBuffer = Marshal.StringToHGlobalUni(tmp.DnsName);                          ptrList.Add(record.DomainInfo.DNSNameBuffer);                          record.DomainInfo.DNSNameLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);             // sizeof(WCHAR)                          record.DomainInfo.DNSNameMaximumLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);                          record.DomainInfo.NetBIOSNameBuffer = Marshal.StringToHGlobalUni(tmp.NetBiosName);                          ptrList.Add(record.DomainInfo.NetBIOSNameBuffer);                          record.DomainInfo.NetBIOSNameLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          record.DomainInfo.NetBIOSNameMaximumLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        if (binaryDataCount > 0)                      {                          // now begin to construct ForestTrustRecordTypeLast                          LSA_FOREST_TRUST_RECORD lastRecord = new LSA_FOREST_TRUST_RECORD();                          lastRecord.Flags = 0;                          lastRecord.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast;                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(lastRecord' tmpPtr' false);                          Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                          currentCount++;                            for (int i = 0; i < binaryDataCount; i++)                          {                              // now begin to construct excluded top leve name record                              LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                              record.Flags = 0;                              record.Time = (LARGE_INTEGER)_binaryDataTime[i];                              record.Data.Length = ((byte[])_binaryData[i]).Length;                              if (record.Data.Length == 0)                              {                                  record.Data.Buffer = (IntPtr)0;                              }                              else                              {                                  record.Data.Buffer = Marshal.AllocHGlobal(record.Data.Length);                                  ptrList.Add(record.Data.Buffer);                                  Marshal.Copy((byte[])_binaryData[i]' 0' record.Data.Buffer' record.Data.Length);                              }                              tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                              ptrList.Add(tmpPtr);                              Marshal.StructureToPtr(record' tmpPtr' false);                                Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                                currentCount++;                          }                      }                        // finally construct the LSA_FOREST_TRUST_INFORMATION                                      LSA_FOREST_TRUST_INFORMATION trustInformation = new LSA_FOREST_TRUST_INFORMATION();                      trustInformation.RecordCount = count;                      trustInformation.Entries = records;                      forestInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_INFORMATION)));                      Marshal.StructureToPtr(trustInformation' forestInfo' false);                        // get policy server name                      serverName = Utils.GetPolicyServerName(context' true' true' SourceName);                        // do impersonation first                      impersonated = Utils.Impersonate(context);                        // get the policy handle                                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        // get the target name                      trustedDomainName = new LSA_UNICODE_STRING();                      target = Marshal.StringToHGlobalUni(TargetName);                      UnsafeNativeMethods.RtlInitUnicodeString(trustedDomainName' target);                        // call the unmanaged function                      int error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 1' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(UnsafeNativeMethods.LsaNtStatusToWinError(error)' serverName);                      }                        // there is collision' throw proper exception so user can deal with it                      if (collisionInfo != (IntPtr)0)                      {                          throw ExceptionHelper.CreateForestTrustCollisionException(collisionInfo);                      }                        // commit the changes                      error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 0' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(error' serverName);                      }                        // now next time property is invoked' we need to go to the server                      retrieved = false;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        // release the memory                      for (int i = 0; i < ptrList.Count; i++)                      {                          Marshal.FreeHGlobal((IntPtr)ptrList[i]);                      }                        for (int i = 0; i < sidList.Count; i++)                      {                          UnsafeNativeMethods.LocalFree((IntPtr)sidList[i]);                      }                        if (records != (IntPtr)0)                      {                          Marshal.FreeHGlobal(records);                      }                        if (forestInfo != (IntPtr)0)                      {                          Marshal.FreeHGlobal(forestInfo);                      }                        if (collisionInfo != (IntPtr)0)                          UnsafeNativeMethods.LsaFreeMemory(collisionInfo);                        if (target != (IntPtr)0)                          Marshal.FreeHGlobal(target);                        if (fileTime != (IntPtr)0)                          Marshal.FreeHGlobal(fileTime);                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,The following statement contains a magic number: try              {                  try                  {                      IntPtr ptr = (IntPtr)0;                      fileTime = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(FileTime)));                      UnsafeNativeMethods.GetSystemTimeAsFileTime(fileTime);                        // set the time                      FileTime currentTime = new FileTime();                      Marshal.PtrToStructure(fileTime' currentTime);                        for (int i = 0; i < toplevelNamesCount; i++)                      {                          // now begin to construct top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_topLevelNames[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName;                          TopLevelName TLN = _topLevelNames[i];                          record.Time = TLN.time;                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(TLN.Name);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                            tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < excludedNamesCount; i++)                      {                          // now begin to construct excluded top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = 0;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx;                          if (_excludedNameTime.Contains(_excludedNames[i]))                          {                              record.Time = (LARGE_INTEGER)_excludedNameTime[i];                          }                          else                          {                              record.Time = new LARGE_INTEGER();                              record.Time.lowPart = currentTime.lower;                              record.Time.highPart = currentTime.higher;                          }                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(_excludedNames[i]);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < trustedDomainCount; i++)                      {                          // now begin to construct domain info record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_domainInfo[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo;                          ForestTrustDomainInformation tmp = _domainInfo[i];                          record.Time = tmp.time;                          IntPtr pSid = (IntPtr)0;                          IntPtr stringSid = (IntPtr)0;                          stringSid = Marshal.StringToHGlobalUni(tmp.DomainSid);                          ptrList.Add(stringSid);                          int result = UnsafeNativeMethods.ConvertStringSidToSidW(stringSid' ref pSid);                          if (result == 0)                          {                              throw ExceptionHelper.GetExceptionFromErrorCode(Marshal.GetLastWin32Error());                          }                          record.DomainInfo = new LSA_FOREST_TRUST_DOMAIN_INFO();                          record.DomainInfo.sid = pSid;                          sidList.Add(pSid);                          record.DomainInfo.DNSNameBuffer = Marshal.StringToHGlobalUni(tmp.DnsName);                          ptrList.Add(record.DomainInfo.DNSNameBuffer);                          record.DomainInfo.DNSNameLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);             // sizeof(WCHAR)                          record.DomainInfo.DNSNameMaximumLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);                          record.DomainInfo.NetBIOSNameBuffer = Marshal.StringToHGlobalUni(tmp.NetBiosName);                          ptrList.Add(record.DomainInfo.NetBIOSNameBuffer);                          record.DomainInfo.NetBIOSNameLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          record.DomainInfo.NetBIOSNameMaximumLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        if (binaryDataCount > 0)                      {                          // now begin to construct ForestTrustRecordTypeLast                          LSA_FOREST_TRUST_RECORD lastRecord = new LSA_FOREST_TRUST_RECORD();                          lastRecord.Flags = 0;                          lastRecord.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast;                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(lastRecord' tmpPtr' false);                          Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                          currentCount++;                            for (int i = 0; i < binaryDataCount; i++)                          {                              // now begin to construct excluded top leve name record                              LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                              record.Flags = 0;                              record.Time = (LARGE_INTEGER)_binaryDataTime[i];                              record.Data.Length = ((byte[])_binaryData[i]).Length;                              if (record.Data.Length == 0)                              {                                  record.Data.Buffer = (IntPtr)0;                              }                              else                              {                                  record.Data.Buffer = Marshal.AllocHGlobal(record.Data.Length);                                  ptrList.Add(record.Data.Buffer);                                  Marshal.Copy((byte[])_binaryData[i]' 0' record.Data.Buffer' record.Data.Length);                              }                              tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                              ptrList.Add(tmpPtr);                              Marshal.StructureToPtr(record' tmpPtr' false);                                Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                                currentCount++;                          }                      }                        // finally construct the LSA_FOREST_TRUST_INFORMATION                                      LSA_FOREST_TRUST_INFORMATION trustInformation = new LSA_FOREST_TRUST_INFORMATION();                      trustInformation.RecordCount = count;                      trustInformation.Entries = records;                      forestInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_INFORMATION)));                      Marshal.StructureToPtr(trustInformation' forestInfo' false);                        // get policy server name                      serverName = Utils.GetPolicyServerName(context' true' true' SourceName);                        // do impersonation first                      impersonated = Utils.Impersonate(context);                        // get the policy handle                                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        // get the target name                      trustedDomainName = new LSA_UNICODE_STRING();                      target = Marshal.StringToHGlobalUni(TargetName);                      UnsafeNativeMethods.RtlInitUnicodeString(trustedDomainName' target);                        // call the unmanaged function                      int error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 1' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(UnsafeNativeMethods.LsaNtStatusToWinError(error)' serverName);                      }                        // there is collision' throw proper exception so user can deal with it                      if (collisionInfo != (IntPtr)0)                      {                          throw ExceptionHelper.CreateForestTrustCollisionException(collisionInfo);                      }                        // commit the changes                      error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 0' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(error' serverName);                      }                        // now next time property is invoked' we need to go to the server                      retrieved = false;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        // release the memory                      for (int i = 0; i < ptrList.Count; i++)                      {                          Marshal.FreeHGlobal((IntPtr)ptrList[i]);                      }                        for (int i = 0; i < sidList.Count; i++)                      {                          UnsafeNativeMethods.LocalFree((IntPtr)sidList[i]);                      }                        if (records != (IntPtr)0)                      {                          Marshal.FreeHGlobal(records);                      }                        if (forestInfo != (IntPtr)0)                      {                          Marshal.FreeHGlobal(forestInfo);                      }                        if (collisionInfo != (IntPtr)0)                          UnsafeNativeMethods.LsaFreeMemory(collisionInfo);                        if (target != (IntPtr)0)                          Marshal.FreeHGlobal(target);                        if (fileTime != (IntPtr)0)                          Marshal.FreeHGlobal(fileTime);                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,The following statement contains a magic number: try              {                  try                  {                      IntPtr ptr = (IntPtr)0;                      fileTime = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(FileTime)));                      UnsafeNativeMethods.GetSystemTimeAsFileTime(fileTime);                        // set the time                      FileTime currentTime = new FileTime();                      Marshal.PtrToStructure(fileTime' currentTime);                        for (int i = 0; i < toplevelNamesCount; i++)                      {                          // now begin to construct top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_topLevelNames[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName;                          TopLevelName TLN = _topLevelNames[i];                          record.Time = TLN.time;                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(TLN.Name);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                            tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < excludedNamesCount; i++)                      {                          // now begin to construct excluded top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = 0;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx;                          if (_excludedNameTime.Contains(_excludedNames[i]))                          {                              record.Time = (LARGE_INTEGER)_excludedNameTime[i];                          }                          else                          {                              record.Time = new LARGE_INTEGER();                              record.Time.lowPart = currentTime.lower;                              record.Time.highPart = currentTime.higher;                          }                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(_excludedNames[i]);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < trustedDomainCount; i++)                      {                          // now begin to construct domain info record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_domainInfo[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo;                          ForestTrustDomainInformation tmp = _domainInfo[i];                          record.Time = tmp.time;                          IntPtr pSid = (IntPtr)0;                          IntPtr stringSid = (IntPtr)0;                          stringSid = Marshal.StringToHGlobalUni(tmp.DomainSid);                          ptrList.Add(stringSid);                          int result = UnsafeNativeMethods.ConvertStringSidToSidW(stringSid' ref pSid);                          if (result == 0)                          {                              throw ExceptionHelper.GetExceptionFromErrorCode(Marshal.GetLastWin32Error());                          }                          record.DomainInfo = new LSA_FOREST_TRUST_DOMAIN_INFO();                          record.DomainInfo.sid = pSid;                          sidList.Add(pSid);                          record.DomainInfo.DNSNameBuffer = Marshal.StringToHGlobalUni(tmp.DnsName);                          ptrList.Add(record.DomainInfo.DNSNameBuffer);                          record.DomainInfo.DNSNameLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);             // sizeof(WCHAR)                          record.DomainInfo.DNSNameMaximumLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);                          record.DomainInfo.NetBIOSNameBuffer = Marshal.StringToHGlobalUni(tmp.NetBiosName);                          ptrList.Add(record.DomainInfo.NetBIOSNameBuffer);                          record.DomainInfo.NetBIOSNameLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          record.DomainInfo.NetBIOSNameMaximumLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        if (binaryDataCount > 0)                      {                          // now begin to construct ForestTrustRecordTypeLast                          LSA_FOREST_TRUST_RECORD lastRecord = new LSA_FOREST_TRUST_RECORD();                          lastRecord.Flags = 0;                          lastRecord.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast;                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(lastRecord' tmpPtr' false);                          Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                          currentCount++;                            for (int i = 0; i < binaryDataCount; i++)                          {                              // now begin to construct excluded top leve name record                              LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                              record.Flags = 0;                              record.Time = (LARGE_INTEGER)_binaryDataTime[i];                              record.Data.Length = ((byte[])_binaryData[i]).Length;                              if (record.Data.Length == 0)                              {                                  record.Data.Buffer = (IntPtr)0;                              }                              else                              {                                  record.Data.Buffer = Marshal.AllocHGlobal(record.Data.Length);                                  ptrList.Add(record.Data.Buffer);                                  Marshal.Copy((byte[])_binaryData[i]' 0' record.Data.Buffer' record.Data.Length);                              }                              tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                              ptrList.Add(tmpPtr);                              Marshal.StructureToPtr(record' tmpPtr' false);                                Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                                currentCount++;                          }                      }                        // finally construct the LSA_FOREST_TRUST_INFORMATION                                      LSA_FOREST_TRUST_INFORMATION trustInformation = new LSA_FOREST_TRUST_INFORMATION();                      trustInformation.RecordCount = count;                      trustInformation.Entries = records;                      forestInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_INFORMATION)));                      Marshal.StructureToPtr(trustInformation' forestInfo' false);                        // get policy server name                      serverName = Utils.GetPolicyServerName(context' true' true' SourceName);                        // do impersonation first                      impersonated = Utils.Impersonate(context);                        // get the policy handle                                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        // get the target name                      trustedDomainName = new LSA_UNICODE_STRING();                      target = Marshal.StringToHGlobalUni(TargetName);                      UnsafeNativeMethods.RtlInitUnicodeString(trustedDomainName' target);                        // call the unmanaged function                      int error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 1' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(UnsafeNativeMethods.LsaNtStatusToWinError(error)' serverName);                      }                        // there is collision' throw proper exception so user can deal with it                      if (collisionInfo != (IntPtr)0)                      {                          throw ExceptionHelper.CreateForestTrustCollisionException(collisionInfo);                      }                        // commit the changes                      error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 0' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(error' serverName);                      }                        // now next time property is invoked' we need to go to the server                      retrieved = false;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        // release the memory                      for (int i = 0; i < ptrList.Count; i++)                      {                          Marshal.FreeHGlobal((IntPtr)ptrList[i]);                      }                        for (int i = 0; i < sidList.Count; i++)                      {                          UnsafeNativeMethods.LocalFree((IntPtr)sidList[i]);                      }                        if (records != (IntPtr)0)                      {                          Marshal.FreeHGlobal(records);                      }                        if (forestInfo != (IntPtr)0)                      {                          Marshal.FreeHGlobal(forestInfo);                      }                        if (collisionInfo != (IntPtr)0)                          UnsafeNativeMethods.LsaFreeMemory(collisionInfo);                        if (target != (IntPtr)0)                          Marshal.FreeHGlobal(target);                        if (fileTime != (IntPtr)0)                          Marshal.FreeHGlobal(fileTime);                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,Save,The following statement contains a magic number: try              {                  try                  {                      IntPtr ptr = (IntPtr)0;                      fileTime = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(FileTime)));                      UnsafeNativeMethods.GetSystemTimeAsFileTime(fileTime);                        // set the time                      FileTime currentTime = new FileTime();                      Marshal.PtrToStructure(fileTime' currentTime);                        for (int i = 0; i < toplevelNamesCount; i++)                      {                          // now begin to construct top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_topLevelNames[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName;                          TopLevelName TLN = _topLevelNames[i];                          record.Time = TLN.time;                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(TLN.Name);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                            tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < excludedNamesCount; i++)                      {                          // now begin to construct excluded top leve name record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = 0;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx;                          if (_excludedNameTime.Contains(_excludedNames[i]))                          {                              record.Time = (LARGE_INTEGER)_excludedNameTime[i];                          }                          else                          {                              record.Time = new LARGE_INTEGER();                              record.Time.lowPart = currentTime.lower;                              record.Time.highPart = currentTime.higher;                          }                          record.TopLevelName = new LSA_UNICODE_STRING();                          ptr = Marshal.StringToHGlobalUni(_excludedNames[i]);                          ptrList.Add(ptr);                          UnsafeNativeMethods.RtlInitUnicodeString(record.TopLevelName' ptr);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        for (int i = 0; i < trustedDomainCount; i++)                      {                          // now begin to construct domain info record                          LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                          record.Flags = (int)_domainInfo[i].Status;                          record.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo;                          ForestTrustDomainInformation tmp = _domainInfo[i];                          record.Time = tmp.time;                          IntPtr pSid = (IntPtr)0;                          IntPtr stringSid = (IntPtr)0;                          stringSid = Marshal.StringToHGlobalUni(tmp.DomainSid);                          ptrList.Add(stringSid);                          int result = UnsafeNativeMethods.ConvertStringSidToSidW(stringSid' ref pSid);                          if (result == 0)                          {                              throw ExceptionHelper.GetExceptionFromErrorCode(Marshal.GetLastWin32Error());                          }                          record.DomainInfo = new LSA_FOREST_TRUST_DOMAIN_INFO();                          record.DomainInfo.sid = pSid;                          sidList.Add(pSid);                          record.DomainInfo.DNSNameBuffer = Marshal.StringToHGlobalUni(tmp.DnsName);                          ptrList.Add(record.DomainInfo.DNSNameBuffer);                          record.DomainInfo.DNSNameLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);             // sizeof(WCHAR)                          record.DomainInfo.DNSNameMaximumLength = (short)(tmp.DnsName == null ? 0 : tmp.DnsName.Length * 2);                          record.DomainInfo.NetBIOSNameBuffer = Marshal.StringToHGlobalUni(tmp.NetBiosName);                          ptrList.Add(record.DomainInfo.NetBIOSNameBuffer);                          record.DomainInfo.NetBIOSNameLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          record.DomainInfo.NetBIOSNameMaximumLength = (short)(tmp.NetBiosName == null ? 0 : tmp.NetBiosName.Length * 2);                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(record' tmpPtr' false);                            Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                            currentCount++;                      }                        if (binaryDataCount > 0)                      {                          // now begin to construct ForestTrustRecordTypeLast                          LSA_FOREST_TRUST_RECORD lastRecord = new LSA_FOREST_TRUST_RECORD();                          lastRecord.Flags = 0;                          lastRecord.ForestTrustType = LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast;                          tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                          ptrList.Add(tmpPtr);                          Marshal.StructureToPtr(lastRecord' tmpPtr' false);                          Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                          currentCount++;                            for (int i = 0; i < binaryDataCount; i++)                          {                              // now begin to construct excluded top leve name record                              LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                              record.Flags = 0;                              record.Time = (LARGE_INTEGER)_binaryDataTime[i];                              record.Data.Length = ((byte[])_binaryData[i]).Length;                              if (record.Data.Length == 0)                              {                                  record.Data.Buffer = (IntPtr)0;                              }                              else                              {                                  record.Data.Buffer = Marshal.AllocHGlobal(record.Data.Length);                                  ptrList.Add(record.Data.Buffer);                                  Marshal.Copy((byte[])_binaryData[i]' 0' record.Data.Buffer' record.Data.Length);                              }                              tmpPtr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_RECORD)));                              ptrList.Add(tmpPtr);                              Marshal.StructureToPtr(record' tmpPtr' false);                                Marshal.WriteIntPtr(records' IntPtr.Size * currentCount' tmpPtr);                                currentCount++;                          }                      }                        // finally construct the LSA_FOREST_TRUST_INFORMATION                                      LSA_FOREST_TRUST_INFORMATION trustInformation = new LSA_FOREST_TRUST_INFORMATION();                      trustInformation.RecordCount = count;                      trustInformation.Entries = records;                      forestInfo = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_FOREST_TRUST_INFORMATION)));                      Marshal.StructureToPtr(trustInformation' forestInfo' false);                        // get policy server name                      serverName = Utils.GetPolicyServerName(context' true' true' SourceName);                        // do impersonation first                      impersonated = Utils.Impersonate(context);                        // get the policy handle                                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        // get the target name                      trustedDomainName = new LSA_UNICODE_STRING();                      target = Marshal.StringToHGlobalUni(TargetName);                      UnsafeNativeMethods.RtlInitUnicodeString(trustedDomainName' target);                        // call the unmanaged function                      int error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 1' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(UnsafeNativeMethods.LsaNtStatusToWinError(error)' serverName);                      }                        // there is collision' throw proper exception so user can deal with it                      if (collisionInfo != (IntPtr)0)                      {                          throw ExceptionHelper.CreateForestTrustCollisionException(collisionInfo);                      }                        // commit the changes                      error = UnsafeNativeMethods.LsaSetForestTrustInformation(handle' trustedDomainName' forestInfo' 0' out collisionInfo);                      if (error != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(error' serverName);                      }                        // now next time property is invoked' we need to go to the server                      retrieved = false;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        // release the memory                      for (int i = 0; i < ptrList.Count; i++)                      {                          Marshal.FreeHGlobal((IntPtr)ptrList[i]);                      }                        for (int i = 0; i < sidList.Count; i++)                      {                          UnsafeNativeMethods.LocalFree((IntPtr)sidList[i]);                      }                        if (records != (IntPtr)0)                      {                          Marshal.FreeHGlobal(records);                      }                        if (forestInfo != (IntPtr)0)                      {                          Marshal.FreeHGlobal(forestInfo);                      }                        if (collisionInfo != (IntPtr)0)                          UnsafeNativeMethods.LsaFreeMemory(collisionInfo);                        if (target != (IntPtr)0)                          Marshal.FreeHGlobal(target);                        if (fileTime != (IntPtr)0)                          Marshal.FreeHGlobal(fileTime);                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,GetForestTrustInfoHelper,The following statement contains a magic number: try              {                  try                  {                      // get the target name                      tmpName = new LSA_UNICODE_STRING();                      targetPtr = Marshal.StringToHGlobalUni(TargetName);                      UnsafeNativeMethods.RtlInitUnicodeString(tmpName' targetPtr);                        serverName = Utils.GetPolicyServerName(context' true' false' source);                        // do impersonation                      impersonated = Utils.Impersonate(context);                        // get the policy handle                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        int result = UnsafeNativeMethods.LsaQueryForestTrustInformation(handle' tmpName' ref forestTrustInfo);                      // check the result                      if (result != 0)                      {                          int win32Error = UnsafeNativeMethods.LsaNtStatusToWinError(result);                          if (win32Error != 0)                          {                              throw ExceptionHelper.GetExceptionFromErrorCode(win32Error' serverName);                          }                      }                        try                      {                          if (forestTrustInfo != (IntPtr)0)                          {                              LSA_FOREST_TRUST_INFORMATION trustInfo = new LSA_FOREST_TRUST_INFORMATION();                              Marshal.PtrToStructure(forestTrustInfo' trustInfo);                                int count = trustInfo.RecordCount;                              IntPtr addr = (IntPtr)0;                              for (int i = 0; i < count; i++)                              {                                  addr = Marshal.ReadIntPtr(trustInfo.Entries' i * IntPtr.Size);                                  LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                                  Marshal.PtrToStructure(addr' record);                                    if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName)                                  {                                      IntPtr myPtr = IntPtr.Add(addr' 16);                                      Marshal.PtrToStructure(myPtr' record.TopLevelName);                                      TopLevelName TLN = new TopLevelName(record.Flags' record.TopLevelName' record.Time);                                      tmpTLNs.Add(TLN);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx)                                  {                                      // get the excluded TLN and put it in our collection                                      IntPtr myPtr = IntPtr.Add(addr' 16);                                      Marshal.PtrToStructure(myPtr' record.TopLevelName);                                      string excludedName = Marshal.PtrToStringUni(record.TopLevelName.Buffer' record.TopLevelName.Length / 2);                                      tmpExcludedTLNs.Add(excludedName);                                      tmpExcludedNameTime.Add(excludedName' record.Time);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo)                                  {                                      ForestTrustDomainInformation dom = new ForestTrustDomainInformation(record.Flags' record.DomainInfo' record.Time);                                      tmpDomainInformation.Add(dom);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast)                                  {                                      // enumeration is done' but we might still have some unrecognized entries after that                                      continue;                                  }                                  else                                  {                                      int length = record.Data.Length;                                      byte[] byteArray = new byte[length];                                      if ((record.Data.Buffer != (IntPtr)0) && (length != 0))                                      {                                          Marshal.Copy(record.Data.Buffer' byteArray' 0' length);                                      }                                      tmpBinaryData.Add(byteArray);                                      tmpBinaryDataTime.Add(record.Time);                                  }                              }                          }                      }                      finally                      {                          UnsafeNativeMethods.LsaFreeMemory(forestTrustInfo);                      }                        _topLevelNames = tmpTLNs;                      _excludedNames = tmpExcludedTLNs;                      _domainInfo = tmpDomainInformation;                        _binaryData = tmpBinaryData;                      _excludedNameTime = tmpExcludedNameTime;                      _binaryDataTime = tmpBinaryDataTime;                        // mark it as retrieved                      retrieved = true;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        if (targetPtr != (IntPtr)0)                      {                          Marshal.FreeHGlobal(targetPtr);                      }                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,GetForestTrustInfoHelper,The following statement contains a magic number: try              {                  try                  {                      // get the target name                      tmpName = new LSA_UNICODE_STRING();                      targetPtr = Marshal.StringToHGlobalUni(TargetName);                      UnsafeNativeMethods.RtlInitUnicodeString(tmpName' targetPtr);                        serverName = Utils.GetPolicyServerName(context' true' false' source);                        // do impersonation                      impersonated = Utils.Impersonate(context);                        // get the policy handle                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        int result = UnsafeNativeMethods.LsaQueryForestTrustInformation(handle' tmpName' ref forestTrustInfo);                      // check the result                      if (result != 0)                      {                          int win32Error = UnsafeNativeMethods.LsaNtStatusToWinError(result);                          if (win32Error != 0)                          {                              throw ExceptionHelper.GetExceptionFromErrorCode(win32Error' serverName);                          }                      }                        try                      {                          if (forestTrustInfo != (IntPtr)0)                          {                              LSA_FOREST_TRUST_INFORMATION trustInfo = new LSA_FOREST_TRUST_INFORMATION();                              Marshal.PtrToStructure(forestTrustInfo' trustInfo);                                int count = trustInfo.RecordCount;                              IntPtr addr = (IntPtr)0;                              for (int i = 0; i < count; i++)                              {                                  addr = Marshal.ReadIntPtr(trustInfo.Entries' i * IntPtr.Size);                                  LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                                  Marshal.PtrToStructure(addr' record);                                    if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName)                                  {                                      IntPtr myPtr = IntPtr.Add(addr' 16);                                      Marshal.PtrToStructure(myPtr' record.TopLevelName);                                      TopLevelName TLN = new TopLevelName(record.Flags' record.TopLevelName' record.Time);                                      tmpTLNs.Add(TLN);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx)                                  {                                      // get the excluded TLN and put it in our collection                                      IntPtr myPtr = IntPtr.Add(addr' 16);                                      Marshal.PtrToStructure(myPtr' record.TopLevelName);                                      string excludedName = Marshal.PtrToStringUni(record.TopLevelName.Buffer' record.TopLevelName.Length / 2);                                      tmpExcludedTLNs.Add(excludedName);                                      tmpExcludedNameTime.Add(excludedName' record.Time);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo)                                  {                                      ForestTrustDomainInformation dom = new ForestTrustDomainInformation(record.Flags' record.DomainInfo' record.Time);                                      tmpDomainInformation.Add(dom);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast)                                  {                                      // enumeration is done' but we might still have some unrecognized entries after that                                      continue;                                  }                                  else                                  {                                      int length = record.Data.Length;                                      byte[] byteArray = new byte[length];                                      if ((record.Data.Buffer != (IntPtr)0) && (length != 0))                                      {                                          Marshal.Copy(record.Data.Buffer' byteArray' 0' length);                                      }                                      tmpBinaryData.Add(byteArray);                                      tmpBinaryDataTime.Add(record.Time);                                  }                              }                          }                      }                      finally                      {                          UnsafeNativeMethods.LsaFreeMemory(forestTrustInfo);                      }                        _topLevelNames = tmpTLNs;                      _excludedNames = tmpExcludedTLNs;                      _domainInfo = tmpDomainInformation;                        _binaryData = tmpBinaryData;                      _excludedNameTime = tmpExcludedNameTime;                      _binaryDataTime = tmpBinaryDataTime;                        // mark it as retrieved                      retrieved = true;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        if (targetPtr != (IntPtr)0)                      {                          Marshal.FreeHGlobal(targetPtr);                      }                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,ForestTrustRelationshipInformation,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ForestTrustRelationshipInformation.cs,GetForestTrustInfoHelper,The following statement contains a magic number: try              {                  try                  {                      // get the target name                      tmpName = new LSA_UNICODE_STRING();                      targetPtr = Marshal.StringToHGlobalUni(TargetName);                      UnsafeNativeMethods.RtlInitUnicodeString(tmpName' targetPtr);                        serverName = Utils.GetPolicyServerName(context' true' false' source);                        // do impersonation                      impersonated = Utils.Impersonate(context);                        // get the policy handle                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        int result = UnsafeNativeMethods.LsaQueryForestTrustInformation(handle' tmpName' ref forestTrustInfo);                      // check the result                      if (result != 0)                      {                          int win32Error = UnsafeNativeMethods.LsaNtStatusToWinError(result);                          if (win32Error != 0)                          {                              throw ExceptionHelper.GetExceptionFromErrorCode(win32Error' serverName);                          }                      }                        try                      {                          if (forestTrustInfo != (IntPtr)0)                          {                              LSA_FOREST_TRUST_INFORMATION trustInfo = new LSA_FOREST_TRUST_INFORMATION();                              Marshal.PtrToStructure(forestTrustInfo' trustInfo);                                int count = trustInfo.RecordCount;                              IntPtr addr = (IntPtr)0;                              for (int i = 0; i < count; i++)                              {                                  addr = Marshal.ReadIntPtr(trustInfo.Entries' i * IntPtr.Size);                                  LSA_FOREST_TRUST_RECORD record = new LSA_FOREST_TRUST_RECORD();                                  Marshal.PtrToStructure(addr' record);                                    if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelName)                                  {                                      IntPtr myPtr = IntPtr.Add(addr' 16);                                      Marshal.PtrToStructure(myPtr' record.TopLevelName);                                      TopLevelName TLN = new TopLevelName(record.Flags' record.TopLevelName' record.Time);                                      tmpTLNs.Add(TLN);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustTopLevelNameEx)                                  {                                      // get the excluded TLN and put it in our collection                                      IntPtr myPtr = IntPtr.Add(addr' 16);                                      Marshal.PtrToStructure(myPtr' record.TopLevelName);                                      string excludedName = Marshal.PtrToStringUni(record.TopLevelName.Buffer' record.TopLevelName.Length / 2);                                      tmpExcludedTLNs.Add(excludedName);                                      tmpExcludedNameTime.Add(excludedName' record.Time);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustDomainInfo)                                  {                                      ForestTrustDomainInformation dom = new ForestTrustDomainInformation(record.Flags' record.DomainInfo' record.Time);                                      tmpDomainInformation.Add(dom);                                  }                                  else if (record.ForestTrustType == LSA_FOREST_TRUST_RECORD_TYPE.ForestTrustRecordTypeLast)                                  {                                      // enumeration is done' but we might still have some unrecognized entries after that                                      continue;                                  }                                  else                                  {                                      int length = record.Data.Length;                                      byte[] byteArray = new byte[length];                                      if ((record.Data.Buffer != (IntPtr)0) && (length != 0))                                      {                                          Marshal.Copy(record.Data.Buffer' byteArray' 0' length);                                      }                                      tmpBinaryData.Add(byteArray);                                      tmpBinaryDataTime.Add(record.Time);                                  }                              }                          }                      }                      finally                      {                          UnsafeNativeMethods.LsaFreeMemory(forestTrustInfo);                      }                        _topLevelNames = tmpTLNs;                      _excludedNames = tmpExcludedTLNs;                      _domainInfo = tmpDomainInformation;                        _binaryData = tmpBinaryData;                      _excludedNameTime = tmpExcludedNameTime;                      _binaryDataTime = tmpBinaryDataTime;                        // mark it as retrieved                      retrieved = true;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        if (targetPtr != (IntPtr)0)                      {                          Marshal.FreeHGlobal(targetPtr);                      }                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneInternal,The following statement contains a magic number: Debug.Assert(domainControllerInfo.DomainControllerName.Length > 2);
Magic Number,System.DirectoryServices.ActiveDirectory,GlobalCatalog,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\GlobalCatalog.cs,FindOneInternal,The following statement contains a magic number: string globalCatalogName = domainControllerInfo.DomainControllerName.Substring(2);
Magic Number,System.DirectoryServices.ActiveDirectory,ReplicationCursorCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationCursorCollection.cs,AddHelper,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  if (advanced)                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_CURSOR_3)));                      DS_REPL_CURSOR_3 cursor = new DS_REPL_CURSOR_3();                      Marshal.PtrToStructure(addr' cursor);                        ReplicationCursor managedCursor = new ReplicationCursor(_server'                                                                           partition'                                                                           cursor.uuidSourceDsaInvocationID'                                                                           cursor.usnAttributeFilter'                                                                           cursor.ftimeLastSyncSuccess'                                                                           cursor.pszSourceDsaDN);                      Add(managedCursor);                  }                  else                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_CURSOR)));                      DS_REPL_CURSOR cursor = new DS_REPL_CURSOR();                      Marshal.PtrToStructure(addr' cursor);                        ReplicationCursor managedCursor = new ReplicationCursor(_server'                                                                           partition'                                                                           cursor.uuidSourceDsaInvocationID'                                                                           cursor.usnAttributeFilter);                      Add(managedCursor);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ReplicationCursorCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationCursorCollection.cs,AddHelper,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  if (advanced)                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_CURSOR_3)));                      DS_REPL_CURSOR_3 cursor = new DS_REPL_CURSOR_3();                      Marshal.PtrToStructure(addr' cursor);                        ReplicationCursor managedCursor = new ReplicationCursor(_server'                                                                           partition'                                                                           cursor.uuidSourceDsaInvocationID'                                                                           cursor.usnAttributeFilter'                                                                           cursor.ftimeLastSyncSuccess'                                                                           cursor.pszSourceDsaDN);                      Add(managedCursor);                  }                  else                  {                      addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_CURSOR)));                      DS_REPL_CURSOR cursor = new DS_REPL_CURSOR();                      Marshal.PtrToStructure(addr' cursor);                        ReplicationCursor managedCursor = new ReplicationCursor(_server'                                                                           partition'                                                                           cursor.uuidSourceDsaInvocationID'                                                                           cursor.usnAttributeFilter);                      Add(managedCursor);                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,ReplicationFailureCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationFailureCollection.cs,AddHelper,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_KCC_DSA_FAILURE)));                    ReplicationFailure managedFailure = new ReplicationFailure(addr' _server' _nameTable);                    // in certain scenario' KCC returns some failure records that we need to process it first before returning                  if (managedFailure.LastErrorCode == 0)                  {                      // we change the error code to some generic one                      managedFailure.lastResult = ExceptionHelper.ERROR_DS_UNKNOWN_ERROR;                  }                    Add(managedFailure);              }
Magic Number,System.DirectoryServices.ActiveDirectory,ReplicationNeighborCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\ReplicationNeighborCollection.cs,AddHelper,The following statement contains a magic number: for (int i = 0; i < count; i++)              {                  addr = IntPtr.Add(info' Marshal.SizeOf(typeof(int)) * 2 + i * Marshal.SizeOf(typeof(DS_REPL_NEIGHBOR)));                    ReplicationNeighbor managedNeighbor = new ReplicationNeighbor(addr' _server' _nameTable);                    Add(managedNeighbor);              }
Magic Number,System.DirectoryServices.ActiveDirectory,TopLevelName,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TopLevelName.cs,TopLevelName,The following statement contains a magic number: Name = Marshal.PtrToStringUni(val.Buffer' val.Length / 2);
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrust,The following statement contains a magic number: try              {                  try                  {                      POLICY_DNS_DOMAIN_INFO domainInfo = new POLICY_DNS_DOMAIN_INFO();                      Marshal.PtrToStructure(info' domainInfo);                        AuthData = new LSA_AUTH_INFORMATION();                      fileTime = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(FileTime)));                      UnsafeNativeMethods.GetSystemTimeAsFileTime(fileTime);                        // set the time                      FileTime tmp = new FileTime();                      Marshal.PtrToStructure(fileTime' tmp);                      AuthData.LastUpdateTime = new LARGE_INTEGER();                      AuthData.LastUpdateTime.lowPart = tmp.lower;                      AuthData.LastUpdateTime.highPart = tmp.higher;                        AuthData.AuthType = s_TRUST_AUTH_TYPE_CLEAR;                      unmanagedPassword = Marshal.StringToHGlobalUni(password);                      AuthData.AuthInfo = unmanagedPassword;                      AuthData.AuthInfoLength = password.Length * 2;          // sizeof(WCHAR)                        unmanagedAuthData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_AUTH_INFORMATION)));                      Marshal.StructureToPtr(AuthData' unmanagedAuthData' false);                        AuthInfoEx = new TRUSTED_DOMAIN_AUTH_INFORMATION();                      if ((direction & TrustDirection.Inbound) != 0)                      {                          AuthInfoEx.IncomingAuthInfos = 1;                          AuthInfoEx.IncomingAuthenticationInformation = unmanagedAuthData;                          AuthInfoEx.IncomingPreviousAuthenticationInformation = (IntPtr)0;                      }                        if ((direction & TrustDirection.Outbound) != 0)                      {                          AuthInfoEx.OutgoingAuthInfos = 1;                          AuthInfoEx.OutgoingAuthenticationInformation = unmanagedAuthData;                          AuthInfoEx.OutgoingPreviousAuthenticationInformation = (IntPtr)0;                      }                        tdi = new TRUSTED_DOMAIN_INFORMATION_EX();                      tdi.FlatName = domainInfo.Name;                      tdi.Name = domainInfo.DnsDomainName;                      tdi.Sid = domainInfo.Sid;                      tdi.TrustType = TRUST_TYPE_UPLEVEL;                      tdi.TrustDirection = (int)direction;                      if (isForest)                      {                          tdi.TrustAttributes = TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_FOREST_TRANSITIVE;                      }                      else                      {                          tdi.TrustAttributes = TRUST_ATTRIBUTE.TRUST_ATTRIBUTE_QUARANTINED_DOMAIN;                      }                        // get server name                      serverName = Utils.GetPolicyServerName(sourceContext' isForest' false' sourceName);                        // do impersonation and get policy handle                      impersonated = Utils.Impersonate(sourceContext);                      policyHandle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        int result = UnsafeNativeMethods.LsaCreateTrustedDomainEx(policyHandle' tdi' AuthInfoEx' s_TRUSTED_SET_POSIX | s_TRUSTED_SET_AUTH' out domainHandle);                      if (result != 0)                      {                          result = UnsafeNativeMethods.LsaNtStatusToWinError(result);                          if (result == s_ERROR_ALREADY_EXISTS)                          {                              if (isForest)                                  throw new ActiveDirectoryObjectExistsException(SR.Format(SR.AlreadyExistingForestTrust ' sourceName' targetName));                              else                                  throw new ActiveDirectoryObjectExistsException(SR.Format(SR.AlreadyExistingDomainTrust ' sourceName' targetName));                          }                          else                              throw ExceptionHelper.GetExceptionFromErrorCode(result' serverName);                      }                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        if (fileTime != (IntPtr)0)                          Marshal.FreeHGlobal(fileTime);                        if (domainHandle != (IntPtr)0)                          UnsafeNativeMethods.LsaClose(domainHandle);                        if (info != (IntPtr)0)                          UnsafeNativeMethods.LsaFreeMemory(info);                        if (unmanagedPassword != (IntPtr)0)                          Marshal.FreeHGlobal(unmanagedPassword);                        if (unmanagedAuthData != (IntPtr)0)                          Marshal.FreeHGlobal(unmanagedAuthData);                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrust,The following statement contains a magic number: try              {                  try                  {                      // get the policy handle first                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        // get the target name                      trustedDomainName = new LSA_UNICODE_STRING();                      target = Marshal.StringToHGlobalUni(targetName);                      UnsafeNativeMethods.RtlInitUnicodeString(trustedDomainName' target);                        // get the trusted domain information                                      int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' ref buffer);                      if (result != 0)                      {                          int win32Error = UnsafeNativeMethods.LsaNtStatusToWinError(result);                          // 2 ERROR_FILE_NOT_FOUND <--> 0xc0000034 STATUS_OBJECT_NAME_NOT_FOUND                          if (win32Error == s_STATUS_OBJECT_NAME_NOT_FOUND)                          {                              if (isForest)                                  throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null);                              else                                  throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null);                          }                          else                              throw ExceptionHelper.GetExceptionFromErrorCode(win32Error' serverName);                      }                        // get the managed structre representation                      TRUSTED_DOMAIN_FULL_INFORMATION domainInfo = new TRUSTED_DOMAIN_FULL_INFORMATION();                      Marshal.PtrToStructure(buffer' domainInfo);                        // validate the trust attribute first                      ValidateTrustAttribute(domainInfo.Information' isForest' sourceName' targetName);                        // get trust direction                      direction = (TrustDirection)domainInfo.Information.TrustDirection;                        // change the attribute value properly                      AuthData = new LSA_AUTH_INFORMATION();                      fileTime = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(FileTime)));                      UnsafeNativeMethods.GetSystemTimeAsFileTime(fileTime);                        // set the time                      FileTime tmp = new FileTime();                      Marshal.PtrToStructure(fileTime' tmp);                      AuthData.LastUpdateTime = new LARGE_INTEGER();                      AuthData.LastUpdateTime.lowPart = tmp.lower;                      AuthData.LastUpdateTime.highPart = tmp.higher;                        AuthData.AuthType = s_TRUST_AUTH_TYPE_CLEAR;                      unmanagedPassword = Marshal.StringToHGlobalUni(password);                      AuthData.AuthInfo = unmanagedPassword;                      AuthData.AuthInfoLength = password.Length * 2;                        unmanagedAuthData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_AUTH_INFORMATION)));                      Marshal.StructureToPtr(AuthData' unmanagedAuthData' false);                        AuthInfoEx = new TRUSTED_DOMAIN_AUTH_INFORMATION();                      if ((direction & TrustDirection.Inbound) != 0)                      {                          AuthInfoEx.IncomingAuthInfos = 1;                          AuthInfoEx.IncomingAuthenticationInformation = unmanagedAuthData;                          AuthInfoEx.IncomingPreviousAuthenticationInformation = (IntPtr)0;                      }                        if ((direction & TrustDirection.Outbound) != 0)                      {                          AuthInfoEx.OutgoingAuthInfos = 1;                          AuthInfoEx.OutgoingAuthenticationInformation = unmanagedAuthData;                          AuthInfoEx.OutgoingPreviousAuthenticationInformation = (IntPtr)0;                      }                        // reconstruct the unmanaged structure to set it back                                    domainInfo.AuthInformation = AuthInfoEx;                      newBuffer = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(TRUSTED_DOMAIN_FULL_INFORMATION)));                      Marshal.StructureToPtr(domainInfo' newBuffer' false);                        result = UnsafeNativeMethods.LsaSetTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' newBuffer);                      if (result != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(UnsafeNativeMethods.LsaNtStatusToWinError(result)' serverName);                      }                        return serverName;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        if (target != (IntPtr)0)                          Marshal.FreeHGlobal(target);                        if (buffer != (IntPtr)0)                          UnsafeNativeMethods.LsaFreeMemory(buffer);                        if (newBuffer != (IntPtr)0)                          Marshal.FreeHGlobal(newBuffer);                        if (fileTime != (IntPtr)0)                          Marshal.FreeHGlobal(fileTime);                        if (unmanagedPassword != (IntPtr)0)                          Marshal.FreeHGlobal(unmanagedPassword);                        if (unmanagedAuthData != (IntPtr)0)                          Marshal.FreeHGlobal(unmanagedAuthData);                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,UpdateTrustDirection,The following statement contains a magic number: try              {                  try                  {                      // get the policy handle first                      handle = new PolicySafeHandle(Utils.GetPolicyHandle(serverName));                        // get the target name                      trustedDomainName = new LSA_UNICODE_STRING();                      target = Marshal.StringToHGlobalUni(targetName);                      UnsafeNativeMethods.RtlInitUnicodeString(trustedDomainName' target);                        // get the trusted domain information                                      int result = UnsafeNativeMethods.LsaQueryTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' ref buffer);                      if (result != 0)                      {                          int win32Error = UnsafeNativeMethods.LsaNtStatusToWinError(result);                          // 2 ERROR_FILE_NOT_FOUND <--> 0xc0000034 STATUS_OBJECT_NAME_NOT_FOUND                          if (win32Error == s_STATUS_OBJECT_NAME_NOT_FOUND)                          {                              if (isForest)                                  throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.ForestTrustDoesNotExist ' sourceName' targetName)' typeof(ForestTrustRelationshipInformation)' null);                              else                                  throw new ActiveDirectoryObjectNotFoundException(SR.Format(SR.DomainTrustDoesNotExist ' sourceName' targetName)' typeof(TrustRelationshipInformation)' null);                          }                          else                              throw ExceptionHelper.GetExceptionFromErrorCode(win32Error' serverName);                      }                        // get the managed structre representation                      TRUSTED_DOMAIN_FULL_INFORMATION domainInfo = new TRUSTED_DOMAIN_FULL_INFORMATION();                      Marshal.PtrToStructure(buffer' domainInfo);                        // validate the trust attribute first                      ValidateTrustAttribute(domainInfo.Information' isForest' sourceName' targetName);                        // change the attribute value properly                      AuthData = new LSA_AUTH_INFORMATION();                      fileTime = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(FileTime)));                      UnsafeNativeMethods.GetSystemTimeAsFileTime(fileTime);                        // set the time                      FileTime tmp = new FileTime();                      Marshal.PtrToStructure(fileTime' tmp);                      AuthData.LastUpdateTime = new LARGE_INTEGER();                      AuthData.LastUpdateTime.lowPart = tmp.lower;                      AuthData.LastUpdateTime.highPart = tmp.higher;                        AuthData.AuthType = s_TRUST_AUTH_TYPE_CLEAR;                      unmanagedPassword = Marshal.StringToHGlobalUni(password);                      AuthData.AuthInfo = unmanagedPassword;                      AuthData.AuthInfoLength = password.Length * 2;                        unmanagedAuthData = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_AUTH_INFORMATION)));                      Marshal.StructureToPtr(AuthData' unmanagedAuthData' false);                        AuthInfoEx = new TRUSTED_DOMAIN_AUTH_INFORMATION();                      if ((newTrustDirection & TrustDirection.Inbound) != 0)                      {                          AuthInfoEx.IncomingAuthInfos = 1;                          AuthInfoEx.IncomingAuthenticationInformation = unmanagedAuthData;                          AuthInfoEx.IncomingPreviousAuthenticationInformation = (IntPtr)0;                      }                      else                      {                          AuthInfoEx.IncomingAuthInfos = 0;                          AuthInfoEx.IncomingAuthenticationInformation = (IntPtr)0;                          AuthInfoEx.IncomingPreviousAuthenticationInformation = (IntPtr)0;                      }                        if ((newTrustDirection & TrustDirection.Outbound) != 0)                      {                          AuthInfoEx.OutgoingAuthInfos = 1;                          AuthInfoEx.OutgoingAuthenticationInformation = unmanagedAuthData;                          AuthInfoEx.OutgoingPreviousAuthenticationInformation = (IntPtr)0;                      }                      else                      {                          AuthInfoEx.OutgoingAuthInfos = 0;                          AuthInfoEx.OutgoingAuthenticationInformation = (IntPtr)0;                          AuthInfoEx.OutgoingPreviousAuthenticationInformation = (IntPtr)0;                      }                        // reconstruct the unmanaged structure to set it back                                    domainInfo.AuthInformation = AuthInfoEx;                      // reset the trust direction                      domainInfo.Information.TrustDirection = (int)newTrustDirection;                        newBuffer = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(TRUSTED_DOMAIN_FULL_INFORMATION)));                      Marshal.StructureToPtr(domainInfo' newBuffer' false);                        result = UnsafeNativeMethods.LsaSetTrustedDomainInfoByName(handle' trustedDomainName' TRUSTED_INFORMATION_CLASS.TrustedDomainFullInformation' newBuffer);                      if (result != 0)                      {                          throw ExceptionHelper.GetExceptionFromErrorCode(UnsafeNativeMethods.LsaNtStatusToWinError(result)' serverName);                      }                        return;                  }                  finally                  {                      if (impersonated)                          Utils.Revert();                        if (target != (IntPtr)0)                          Marshal.FreeHGlobal(target);                        if (buffer != (IntPtr)0)                          UnsafeNativeMethods.LsaFreeMemory(buffer);                        if (newBuffer != (IntPtr)0)                          Marshal.FreeHGlobal(newBuffer);                        if (fileTime != (IntPtr)0)                          Marshal.FreeHGlobal(fileTime);                        if (unmanagedPassword != (IntPtr)0)                          Marshal.FreeHGlobal(unmanagedPassword);                        if (unmanagedAuthData != (IntPtr)0)                          Marshal.FreeHGlobal(unmanagedAuthData);                  }              }              catch { throw; }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrustPassword,The following statement contains a magic number: using (RandomNumberGenerator RNG = RandomNumberGenerator.Create())              {                  RNG.GetBytes(buf);                  for (int iter = 0; iter < s_PASSWORD_LENGTH; iter++)                  {                      int i = (int)(buf[iter] % 87);                      if (i < 10)                          cBuf[iter] = (char)('0' + i);                      else if (i < 36)                          cBuf[iter] = (char)('A' + i - 10);                      else if (i < 62)                          cBuf[iter] = (char)('a' + i - 36);                      else                          cBuf[iter] = s_punctuations[i - 62];                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrustPassword,The following statement contains a magic number: using (RandomNumberGenerator RNG = RandomNumberGenerator.Create())              {                  RNG.GetBytes(buf);                  for (int iter = 0; iter < s_PASSWORD_LENGTH; iter++)                  {                      int i = (int)(buf[iter] % 87);                      if (i < 10)                          cBuf[iter] = (char)('0' + i);                      else if (i < 36)                          cBuf[iter] = (char)('A' + i - 10);                      else if (i < 62)                          cBuf[iter] = (char)('a' + i - 36);                      else                          cBuf[iter] = s_punctuations[i - 62];                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrustPassword,The following statement contains a magic number: using (RandomNumberGenerator RNG = RandomNumberGenerator.Create())              {                  RNG.GetBytes(buf);                  for (int iter = 0; iter < s_PASSWORD_LENGTH; iter++)                  {                      int i = (int)(buf[iter] % 87);                      if (i < 10)                          cBuf[iter] = (char)('0' + i);                      else if (i < 36)                          cBuf[iter] = (char)('A' + i - 10);                      else if (i < 62)                          cBuf[iter] = (char)('a' + i - 36);                      else                          cBuf[iter] = s_punctuations[i - 62];                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrustPassword,The following statement contains a magic number: using (RandomNumberGenerator RNG = RandomNumberGenerator.Create())              {                  RNG.GetBytes(buf);                  for (int iter = 0; iter < s_PASSWORD_LENGTH; iter++)                  {                      int i = (int)(buf[iter] % 87);                      if (i < 10)                          cBuf[iter] = (char)('0' + i);                      else if (i < 36)                          cBuf[iter] = (char)('A' + i - 10);                      else if (i < 62)                          cBuf[iter] = (char)('a' + i - 36);                      else                          cBuf[iter] = s_punctuations[i - 62];                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrustPassword,The following statement contains a magic number: using (RandomNumberGenerator RNG = RandomNumberGenerator.Create())              {                  RNG.GetBytes(buf);                  for (int iter = 0; iter < s_PASSWORD_LENGTH; iter++)                  {                      int i = (int)(buf[iter] % 87);                      if (i < 10)                          cBuf[iter] = (char)('0' + i);                      else if (i < 36)                          cBuf[iter] = (char)('A' + i - 10);                      else if (i < 62)                          cBuf[iter] = (char)('a' + i - 36);                      else                          cBuf[iter] = s_punctuations[i - 62];                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrustPassword,The following statement contains a magic number: using (RandomNumberGenerator RNG = RandomNumberGenerator.Create())              {                  RNG.GetBytes(buf);                  for (int iter = 0; iter < s_PASSWORD_LENGTH; iter++)                  {                      int i = (int)(buf[iter] % 87);                      if (i < 10)                          cBuf[iter] = (char)('0' + i);                      else if (i < 36)                          cBuf[iter] = (char)('A' + i - 10);                      else if (i < 62)                          cBuf[iter] = (char)('a' + i - 36);                      else                          cBuf[iter] = s_punctuations[i - 62];                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustHelper.cs,CreateTrustPassword,The following statement contains a magic number: using (RandomNumberGenerator RNG = RandomNumberGenerator.Create())              {                  RNG.GetBytes(buf);                  for (int iter = 0; iter < s_PASSWORD_LENGTH; iter++)                  {                      int i = (int)(buf[iter] % 87);                      if (i < 10)                          cBuf[iter] = (char)('0' + i);                      else if (i < 36)                          cBuf[iter] = (char)('A' + i - 10);                      else if (i < 62)                          cBuf[iter] = (char)('a' + i - 36);                      else                          cBuf[iter] = s_punctuations[i - 62];                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,TrustRelationshipInformationCollection,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\TrustRelationshipInformationCollection.cs,TrustRelationshipInformationCollection,The following statement contains a magic number: for (int i = 0; i < trusts.Count; i++)              {                  TrustObject obj = (TrustObject)trusts[i];                  // we don't need self and forest trust                  if ((obj.TrustType == TrustType.Forest) || ((int)obj.TrustType == 7))                  {                      continue;                  }                    TrustRelationshipInformation info = new TrustRelationshipInformation(context' source' obj);                  Add(info);              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The following statement contains a magic number: string serversDn = GetPartialDN(dn' 2);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The following statement contains a magic number: string[] propertiesToLoad = new string[3];
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The following statement contains a magic number: propertiesToLoad[2] = PropertyManager.ObjectCategory;
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamDnsHostNameFromNTDSA,The following statement contains a magic number: try              {                  if (resCol.Count != 2)                  {                      throw new ActiveDirectoryOperationException(SR.Format(SR.NoHostNameOrPortNumber ' dn));                  }                    foreach (SearchResult res in resCol)                  {                      string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                      if ((objectCategoryValue.Length >= ntdsdsa.Length) && (Utils.Compare(objectCategoryValue' 0' ntdsdsa.Length' ntdsdsa' 0' ntdsdsa.Length) == 0))                      {                          // ntdsa object                          ldapPort = (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP);                      }                      else                      {                          // server object                          dnsHostName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName);                      }                  }              }              finally              {                  resCol.Dispose();                  serversEntry.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The following statement contains a magic number: string serversDn = GetPartialDN(dn' 2);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The following statement contains a magic number: string[] propertiesToLoad = new string[4];
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The following statement contains a magic number: propertiesToLoad[2] = PropertyManager.MsDSPortSSL;
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The following statement contains a magic number: propertiesToLoad[3] = PropertyManager.ObjectCategory;
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetAdamHostNameAndPortsFromNTDSA,The following statement contains a magic number: try              {                  if (resCol.Count != 2)                  {                      throw new ActiveDirectoryOperationException(SR.Format(SR.NoHostNameOrPortNumber ' dn));                  }                    foreach (SearchResult res in resCol)                  {                      string objectCategoryValue = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                      if ((objectCategoryValue.Length >= ntdsdsa.Length) && (Utils.Compare(objectCategoryValue' 0' ntdsdsa.Length' ntdsdsa' 0' ntdsdsa.Length) == 0))                      {                          // ntdsa object                          ldapPort = (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP);                          sslPort = (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortSSL);                      }                      else                      {                          // server object                          dnsHostName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName);                      }                  }              }              finally              {                  resCol.Dispose();                  serversEntry.Dispose();              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetDNComponents,The following statement contains a magic number: for (int i = 0; i < components.GetLength(0); i++)              {                  // split each component by '='                  string[] subComponents = Split(components[i]' '=');                  if (subComponents.GetLength(0) != 2)                  {                      throw new ArgumentException(SR.InvalidDNFormat' "distinguishedName");                  }                    dnComponents[i].Name = subComponents[0].Trim();                  if (dnComponents[i].Name.Length == 0)                  {                      throw new ArgumentException(SR.InvalidDNFormat' "distinguishedName");                  }                    dnComponents[i].Value = subComponents[1].Trim();                  if (dnComponents[i].Value.Length == 0)                  {                      throw new ArgumentException(SR.InvalidDNFormat' "distinguishedName");                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,IsValidDNFormat,The following statement contains a magic number: for (int i = 0; i < components.GetLength(0); i++)              {                  // split each component by '='                  string[] subComponents = Split(components[i]' '=');                  if (subComponents.GetLength(0) != 2)                  {                      return false;                  }                    dnComponents[i].Name = subComponents[0].Trim();                  if (dnComponents[i].Name.Length == 0)                  {                      return false;                  }                    dnComponents[i].Value = subComponents[1].Trim();                  if (dnComponents[i].Value.Length == 0)                  {                      return false;                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetCrossRefEntry,The following statement contains a magic number: StringBuilder str = new StringBuilder(15);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetServerNameFromInvocationID,The following statement contains a magic number: if (serverObjectDN == null)              {                  // this is the win2k case' we need to get the DSA address first                  string siteName = (server is DomainController) ? ((DomainController)server).SiteObjectName : ((AdamInstance)server).SiteObjectName;                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(server.Context' siteName);                    // get the string representation of the invocationID                  byte[] byteGuid = invocationID.ToByteArray();                  IntPtr ptr = (IntPtr)0;                  string stringGuid = null;                    // encode the byte arry into binary string representation                  int hr = UnsafeNativeMethods.ADsEncodeBinaryData(byteGuid' byteGuid.Length' ref ptr);                    if (hr == 0)                  {                      try                      {                          stringGuid = Marshal.PtrToStringUni(ptr);                      }                      finally                      {                          if (ptr != (IntPtr)0)                              UnsafeNativeMethods.FreeADsMem(ptr);                      }                  }                  else                  {                      // throw exception as the call failed                      throw ExceptionHelper.GetExceptionFromCOMException(new COMException(ExceptionHelper.GetErrorMessage(hr' true)' hr));                  }                    ADSearcher adSearcher = new ADSearcher(de'                                                             "(&(objectClass=nTDSDSA)(invocationID=" + stringGuid + "))"'                                                             new string[] { "distinguishedName" }'                                                             SearchScope.Subtree'                                                             false' /* don't need paged search */                                                             false /* don't need to cache result */);                  SearchResult srchResult = null;                    try                  {                      srchResult = adSearcher.FindOne();                      if (srchResult != null)                      {                          DirectoryEntry srvEntry = srchResult.GetDirectoryEntry().Parent;                          originatingServerName = (string)PropertyManager.GetPropertyValue(server.Context' srvEntry' PropertyManager.DnsHostName);                      }                  }                  catch (COMException e)                  {                      throw ExceptionHelper.GetExceptionFromCOMException(server.Context' e);                  }              }              else              {                  DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(server.Context' serverObjectDN);                    try                  {                      originatingServerName = (string)PropertyManager.GetPropertyValue(de.Parent' PropertyManager.DnsHostName);                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030))                          return null;                      else                          throw ExceptionHelper.GetExceptionFromCOMException(server.Context' e);                  }                  if (server is AdamInstance)                  {                      // we might need to add the port number                                                int portnumber = (int)PropertyManager.GetPropertyValue(server.Context' de' PropertyManager.MsDSPortLDAP);                        if (portnumber != 389)                          originatingServerName = originatingServerName + ":" + portnumber;                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetPolicyServerName,The following statement contains a magic number: if (context.isDomain())              {                  if (needPdc)                  {                      flag |= PrivateLocatorFlags.PdcRequired;                  }                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);              }              else              {                  // user could pass in non-root domain server name in the context' so need to find a dc in root domain                  if (isForest)                  {                      if (needPdc)                      {                          flag |= PrivateLocatorFlags.PdcRequired;                          serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                      }                      else                      {                          if (context.ContextType == DirectoryContextType.DirectoryServer)                          {                              // need first to decide whether this is a server in the root domain or not                              DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' WellKnownDN.RootDSE);                              string namingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.DefaultNamingContext);                              string rootNamingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.RootDomainNamingContext);                              if (Compare(namingContext' rootNamingContext) == 0)                              {                                  serverName = context.Name;                              }                              else                              {                                  // it is not a server in the root domain' so we need to do dc location                                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                              }                          }                          else                          {                              serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                          }                      }                  }                  else                  {                      serverName = context.Name;                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetPolicyServerName,The following statement contains a magic number: if (context.isDomain())              {                  if (needPdc)                  {                      flag |= PrivateLocatorFlags.PdcRequired;                  }                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);              }              else              {                  // user could pass in non-root domain server name in the context' so need to find a dc in root domain                  if (isForest)                  {                      if (needPdc)                      {                          flag |= PrivateLocatorFlags.PdcRequired;                          serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                      }                      else                      {                          if (context.ContextType == DirectoryContextType.DirectoryServer)                          {                              // need first to decide whether this is a server in the root domain or not                              DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' WellKnownDN.RootDSE);                              string namingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.DefaultNamingContext);                              string rootNamingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.RootDomainNamingContext);                              if (Compare(namingContext' rootNamingContext) == 0)                              {                                  serverName = context.Name;                              }                              else                              {                                  // it is not a server in the root domain' so we need to do dc location                                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                              }                          }                          else                          {                              serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                          }                      }                  }                  else                  {                      serverName = context.Name;                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetPolicyServerName,The following statement contains a magic number: if (context.isDomain())              {                  if (needPdc)                  {                      flag |= PrivateLocatorFlags.PdcRequired;                  }                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);              }              else              {                  // user could pass in non-root domain server name in the context' so need to find a dc in root domain                  if (isForest)                  {                      if (needPdc)                      {                          flag |= PrivateLocatorFlags.PdcRequired;                          serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                      }                      else                      {                          if (context.ContextType == DirectoryContextType.DirectoryServer)                          {                              // need first to decide whether this is a server in the root domain or not                              DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' WellKnownDN.RootDSE);                              string namingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.DefaultNamingContext);                              string rootNamingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.RootDomainNamingContext);                              if (Compare(namingContext' rootNamingContext) == 0)                              {                                  serverName = context.Name;                              }                              else                              {                                  // it is not a server in the root domain' so we need to do dc location                                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                              }                          }                          else                          {                              serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                          }                      }                  }                  else                  {                      serverName = context.Name;                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetPolicyServerName,The following statement contains a magic number: if (context.isDomain())              {                  if (needPdc)                  {                      flag |= PrivateLocatorFlags.PdcRequired;                  }                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);              }              else              {                  // user could pass in non-root domain server name in the context' so need to find a dc in root domain                  if (isForest)                  {                      if (needPdc)                      {                          flag |= PrivateLocatorFlags.PdcRequired;                          serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                      }                      else                      {                          if (context.ContextType == DirectoryContextType.DirectoryServer)                          {                              // need first to decide whether this is a server in the root domain or not                              DirectoryEntry de = DirectoryEntryManager.GetDirectoryEntry(context' WellKnownDN.RootDSE);                              string namingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.DefaultNamingContext);                              string rootNamingContext = (string)PropertyManager.GetPropertyValue(context' de' PropertyManager.RootDomainNamingContext);                              if (Compare(namingContext' rootNamingContext) == 0)                              {                                  serverName = context.Name;                              }                              else                              {                                  // it is not a server in the root domain' so we need to do dc location                                  serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                              }                          }                          else                          {                              serverName = Locator.GetDomainControllerInfo(null' source' null' (long)flag).DomainControllerName.Substring(2);                          }                      }                  }                  else                  {                      serverName = context.Name;                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: StringBuilder ntdsaFilter = new StringBuilder(10);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: StringBuilder serverFilter = new StringBuilder(10);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: StringBuilder roNtdsaFilter = new StringBuilder(10);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: StringBuilder roServerFilter = new StringBuilder(10);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetReplicaList,The following statement contains a magic number: try              {                  // check whether we can narrow down our search within a specific site                  if (siteName != null)                  {                      searchRootDN = "CN=Servers'CN=" + siteName + "'CN=Sites'" + configurationNamingContext;                  }                  else                  {                      searchRootDN = "CN=Sites'" + configurationNamingContext;                  }                  searchRootEntry = DirectoryEntryManager.GetDirectoryEntry(context' searchRootDN);                    // set up searcher object                  string filter2 = null;                  if (ntdsaFilter.ToString().Length == 0)                  {                      // either this is the case when we want all the servers (partitionName = null or partitionName is Configuration/Schema)                      // or this is the case when partitionName is the defaultNamingContext                      // for the latter we want to restrict the search to only that naming context                        if (isDefaultNC)                      {                          Debug.Assert(partitionName != null);                          Debug.Assert(!isGC);                            filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.HasMasterNCs +                              "=" + Utils.GetEscapedFilterValue(partitionName) + "))(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                              PropertyManager.MsDSHasFullReplicaNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + "))(" +                              PropertyManager.ObjectCategory + "=server))";                      }                      else                      {                          if (isGC)                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(&(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.Options + ":1.2.840.113556.1.4.804:=1))(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                          else                          {                              filter2 = "(|" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" +                                  PropertyManager.ObjectCategory + "=nTDSDSARO)(" +                                  PropertyManager.ObjectCategory + "=server))";                          }                      }                  }                  else                  {                      Debug.Assert(partitionName != null);                      // resctrict the search to the servers that were listed in the crossRef                      if (isGC)                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(|" + roNtdsaFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))" +                                  "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.Options +                                  ":1.2.840.113556.1.4.804:=1)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) +                                  ")(|" + ntdsaFilter.ToString() + "))" + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                      else                      {                          if (roNtdsaFilter.Length > 0)                          {                              //for read-only NCs' msDS-hasFullReplicaNCs is equivalent of msDS-hasMasterNCs. But since msDS-hasFullReplicaNCs will be                              //populated ONLY on each RODC' it can't be used. Since roNtdsaFilter is populated using input partitionName' we should                              //be fine.                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=nTDSDSARO)(|" + roNtdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + roServerFilter.ToString() + ")))";                          }                          else                          {                              filter2 = "(|(&(" + PropertyManager.ObjectCategory + "=nTDSDSA)(" + PropertyManager.MsDSHasMasterNCs + "=" + Utils.GetEscapedFilterValue(partitionName) + ")(|" + ntdsaFilter.ToString() + "))"                                  + "(&(" + PropertyManager.ObjectCategory + "=server)(|" + serverFilter.ToString() + ")))";                          }                      }                  }                    string[] propertiesToLoad2 = new string[5];                    ADSearcher searcher2 = new ADSearcher(searchRootEntry' filter2' new string[] { }' SearchScope.Subtree);                  SearchResultCollection resCol = null;                  bool needToContinueRangeRetrieval = false;                  ArrayList ntdsaNamesForRangeRetrieval = new ArrayList();                  int rangeStart = 0;                    string propertyWithRangeInfo = PropertyManager.MsDSHasInstantiatedNCs + ";range=0-*";                  searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                  searcher2.PropertiesToLoad.Add(PropertyManager.DnsHostName);                  searcher2.PropertiesToLoad.Add(propertyWithRangeInfo);                  searcher2.PropertiesToLoad.Add(PropertyManager.ObjectCategory);                  if (isADAM)                  {                      searcher2.PropertiesToLoad.Add(PropertyManager.MsDSPortLDAP);                  }                    try                  {                      string objectCategoryValue = "CN=NTDS-DSA";                      string roObjectCategoryValue = "CN=NTDS-DSA-RO";                        resCol = searcher2.FindAll();                        try                      {                          foreach (SearchResult res in resCol)                          {                              string objectCategory = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.ObjectCategory);                              if ((objectCategory.Length >= objectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' objectCategoryValue.Length' objectCategoryValue' 0' objectCategoryValue.Length) == 0))                              {                                  //                                  // ntdsa objects (return only those servers which have the partition fully instantiated)                                  //                                  string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                  if (useReplicaInfo)                                  {                                      if ((objectCategory.Length >= roObjectCategoryValue.Length) && (Utils.Compare(objectCategory' 0' roObjectCategoryValue.Length' roObjectCategoryValue' 0' roObjectCategoryValue.Length) == 0))                                      {                                          //for read-only NCs' msDS-HasInstantiatedNCs will be populated ONLY on each RODC and it will NOT be                                           //replicated to other DCs. So it can't be used' provided we connect to each RODC and verify it which is not                                          //really required as msDS-NC-RO-Replica-Locations should provide the correct information.                                          ntdsaNames.Add(ntdsaName);                                          if (isADAM)                                          {                                              serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                          }                                          continue;                                      }                                        // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                        string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if ((property.Length >= PropertyManager.MsDSHasInstantiatedNCs.Length) && (Utils.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length) == 0))                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              // found the entry that corresponds to this partition so even if we didn't get all the values of the                                               // multivalues attribute we can stop here.                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  // this server has the partition fully instantiated                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo.Length' propertyWithRangeInfo' 0' propertyWithRangeInfo.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart = valueCount;                                      }                                  }                                  else                                  {                                      // schema or configuration partition' so we add all the servers                                      ntdsaNames.Add(ntdsaName);                                      if (isADAM)                                      {                                          serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                      }                                  }                              }                              else                              {                                  // server objects' just keep infor regarding the dns name (to be used later)' if not available we will throw an error later                                  // when we try to retrieve this info for a valid DC/GC                                  if (res.Properties.Contains(PropertyManager.DnsHostName))                                  {                                      serverNames.Add("CN=NTDS Settings'" + (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName)'                                                  (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DnsHostName));                                  }                              }                          }                      }                      finally                      {                          if (resCol != null)                          {                              resCol.Dispose();                          }                      }                        if (needToContinueRangeRetrieval)                      {                          // Now continue with range retrieval if necessary for msDS-HasInstantiatedNCs                           do                          {                              // Here we only need the NTDS settings objects of the ntdsaNames that need range retrieval                                // this should be greater than 0' since needToContinueRangeRetrieval is true                              Debug.Assert(ntdsaNamesForRangeRetrieval.Count > 0);                                StringBuilder str = new StringBuilder(20);                              if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append("(|");                              }                                foreach (string name in ntdsaNamesForRangeRetrieval)                              {                                  str.Append("(");                                  str.Append(PropertyManager.NCName);                                  str.Append("=");                                  str.Append(Utils.GetEscapedFilterValue(name));                                  str.Append(")");                              }                                if (ntdsaNamesForRangeRetrieval.Count > 1)                              {                                  str.Append(")");                              }                                // Clear it for the next round of range retrieval                               ntdsaNamesForRangeRetrieval.Clear();                              needToContinueRangeRetrieval = false;                                searcher2.Filter = "(&" + "(" + PropertyManager.ObjectCategory + "=nTDSDSA)" + str.ToString() + ")";                                string propertyWithRangeInfo2 = PropertyManager.MsDSHasInstantiatedNCs + ";range=" + rangeStart + "-*";                              searcher2.PropertiesToLoad.Clear();                              searcher2.PropertiesToLoad.Add(propertyWithRangeInfo2);                              searcher2.PropertiesToLoad.Add(PropertyManager.DistinguishedName);                                SearchResultCollection resCol2 = searcher2.FindAll();                                try                              {                                  foreach (SearchResult res in resCol2)                                  {                                      string ntdsaName = (string)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.DistinguishedName);                                      // Here we need to check if we retrieved all the msDS-HasInstantiatedNCs values                                      // if not we need to continue with the range retrieval (in parallel for the various ntdsa objects)                                      string propertyName = null;                                      if (!res.Properties.Contains(propertyWithRangeInfo2))                                      {                                          // find the property name with the range info                                          foreach (string property in res.Properties.PropertyNames)                                          {                                              if (String.Compare(property' 0' PropertyManager.MsDSHasInstantiatedNCs' 0' PropertyManager.MsDSHasInstantiatedNCs.Length' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  propertyName = property;                                                  break;                                              }                                          }                                      }                                      else                                      {                                          propertyName = propertyWithRangeInfo2;                                      }                                        if (propertyName == null)                                      {                                          // property does not exist' possiblyno values' so continue                                          continue;                                      }                                        bool foundPartitionEntry = false;                                      int valueCount = 0;                                        foreach (string dnString in res.Properties[propertyName])                                      {                                          Debug.Assert(dnString.Length > 10' "ConfigurationSet::GetReplicaList - dnWithBinary is not in the expected format.");                                            if (((dnString.Length - 13) >= partitionName.Length) && (Utils.Compare(dnString' 13' partitionName.Length' partitionName' 0' partitionName.Length) == 0))                                          {                                              foundPartitionEntry = true;                                                if (String.Compare(dnString' 10' "0"' 0' 1' StringComparison.OrdinalIgnoreCase) == 0)                                              {                                                  ntdsaNames.Add(ntdsaName);                                                  if (isADAM)                                                  {                                                      serverPorts.Add(ntdsaName' (int)PropertyManager.GetSearchResultPropertyValue(res' PropertyManager.MsDSPortLDAP));                                                  }                                                  break;                                              }                                          }                                            valueCount++;                                      }                                        if ((!foundPartitionEntry) && ((propertyName.Length >= propertyWithRangeInfo2.Length) && (Utils.Compare(propertyName' 0' propertyWithRangeInfo2.Length' propertyWithRangeInfo2' 0' propertyWithRangeInfo2.Length) != 0)))                                      {                                          needToContinueRangeRetrieval = true;                                          ntdsaNamesForRangeRetrieval.Add(ntdsaName);                                          rangeStart += valueCount;                                      }                                  }                              }                              finally                              {                                  resCol2.Dispose();                              }                          } while (needToContinueRangeRetrieval);                      }                  }                  catch (COMException e)                  {                      if (e.ErrorCode == unchecked((int)0x80072030) && siteName != null)                      {                          // this means that the site object does not exist' so we return an empty collection                          return dnsNames;                      }                      else                      {                          throw ExceptionHelper.GetExceptionFromCOMException(context' e);                      }                  }              }              finally              {                  if (searchRootEntry != null)                  {                      searchRootEntry.Dispose();                  }              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetEscapedFilterValue,The following statement contains a magic number: if (index != -1)              {                  //                  // if it contains any of the special characters then we                   // need to escape those                  //                    StringBuilder str = new StringBuilder(2 * filterValue.Length);                    str.Append(filterValue.Substring(0' index));                    for (int i = index; i < filterValue.Length; i++)                  {                      switch (filterValue[i])                      {                          case ('('):                              {                                  str.Append("\\28");                                  break;                              }                            case (')'):                              {                                  str.Append("\\29");                                  break;                              }                            case ('*'):                              {                                  str.Append("\\2A");                                  break;                              }                            case ('\\'):                              {                                  str.Append("\\5C");                                  break;                              }                            default:                              {                                  str.Append(filterValue[i]);                                  break;                              }                      }                  }                    return str.ToString();              }              else              {                  //                  // just return the original string                  //                    return filterValue;              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,Compare,The following statement contains a magic number: return (result - 2);
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,SplitServerNameAndPortNumber,The following statement contains a magic number: if (isBrace == true)              {                  if (serverName.EndsWith("]"))                  {                      //[IPv6]                      serverName = serverName.Substring(1' serverName.Length - 2);//2 for []                      return serverName;                  }                  int closingBrace = serverName.LastIndexOf("]:");                  if ((closingBrace == -1) || (closingBrace + 1 != lastColon))                  {                      //error' return input string                      return serverName;                  }                  //[IPv6]:Port                  portNumber = serverName.Substring(lastColon + 1);                  serverName = serverName.Substring(1' closingBrace - 1);                  return serverName;              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetCurrentUserSid,The following statement contains a magic number: try              {                  //                  // Get the current user's SID                  //                  int error = 0;                    // Get the current thread's token                  if (!UnsafeNativeMethods.OpenThreadToken(                                  UnsafeNativeMethods.GetCurrentThread()'                                  0x8' // TOKEN_QUERY                                  true'                                  ref pTokenHandle                                  ))                  {                      if ((error = Marshal.GetLastWin32Error()) == 1008) // ERROR_NO_TOKEN                      {                          Debug.Assert(pTokenHandle == IntPtr.Zero);                            // Current thread doesn't have a token' try the process                          if (!UnsafeNativeMethods.OpenProcessToken(                                          UnsafeNativeMethods.GetCurrentProcess()'                                          0x8' // TOKEN_QUERY                                          ref pTokenHandle                                          ))                          {                              int lastError = Marshal.GetLastWin32Error();                              throw new InvalidOperationException(SR.Format(SR.UnableToOpenToken' lastError));                          }                      }                      else                      {                          throw new InvalidOperationException(SR.Format(SR.UnableToOpenToken' error));                      }                  }                    Debug.Assert(pTokenHandle != IntPtr.Zero);                    int neededBufferSize = 0;                    // Retrieve the user info from the current thread's token                  // First' determine how big a buffer we need.                  bool success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          IntPtr.Zero'                                          0'                                          ref neededBufferSize);                    int getTokenInfoError = 0;                  if ((getTokenInfoError = Marshal.GetLastWin32Error()) != 122) // ERROR_INSUFFICIENT_BUFFER                  {                      throw new InvalidOperationException(                                      SR.Format(SR.UnableToRetrieveTokenInfo' getTokenInfoError));                  }                    // Allocate the necessary buffer.                  Debug.Assert(neededBufferSize > 0);                  pBuffer = Marshal.AllocHGlobal(neededBufferSize);                    // Load the user info into the buffer                  success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          pBuffer'                                          neededBufferSize'                                          ref neededBufferSize);                    if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      throw new InvalidOperationException(                                      SR.Format(SR.UnableToRetrieveTokenInfo' lastError));                  }                    // Retrieve the user's SID from the user info                  TOKEN_USER tokenUser = (TOKEN_USER)Marshal.PtrToStructure(pBuffer' typeof(TOKEN_USER));                  IntPtr pUserSid = tokenUser.sidAndAttributes.pSid;   // this is a reference into the NATIVE memory (into pBuffer)                    Debug.Assert(UnsafeNativeMethods.IsValidSid(pUserSid));                    // Now we make a copy of the SID to return                  int userSidLength = UnsafeNativeMethods.GetLengthSid(pUserSid);                  IntPtr pCopyOfUserSid = Marshal.AllocHGlobal(userSidLength);                  success = UnsafeNativeMethods.CopySid(userSidLength' pCopyOfUserSid' pUserSid);                  if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      throw new InvalidOperationException(                                      SR.Format(SR.UnableToRetrieveTokenInfo' lastError));                  }                    return pCopyOfUserSid;              }              finally              {                  if (pTokenHandle != IntPtr.Zero)                      UnsafeNativeMethods.CloseHandle(pTokenHandle);                    if (pBuffer != IntPtr.Zero)                      Marshal.FreeHGlobal(pBuffer);              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetCurrentUserSid,The following statement contains a magic number: try              {                  //                  // Get the current user's SID                  //                  int error = 0;                    // Get the current thread's token                  if (!UnsafeNativeMethods.OpenThreadToken(                                  UnsafeNativeMethods.GetCurrentThread()'                                  0x8' // TOKEN_QUERY                                  true'                                  ref pTokenHandle                                  ))                  {                      if ((error = Marshal.GetLastWin32Error()) == 1008) // ERROR_NO_TOKEN                      {                          Debug.Assert(pTokenHandle == IntPtr.Zero);                            // Current thread doesn't have a token' try the process                          if (!UnsafeNativeMethods.OpenProcessToken(                                          UnsafeNativeMethods.GetCurrentProcess()'                                          0x8' // TOKEN_QUERY                                          ref pTokenHandle                                          ))                          {                              int lastError = Marshal.GetLastWin32Error();                              throw new InvalidOperationException(SR.Format(SR.UnableToOpenToken' lastError));                          }                      }                      else                      {                          throw new InvalidOperationException(SR.Format(SR.UnableToOpenToken' error));                      }                  }                    Debug.Assert(pTokenHandle != IntPtr.Zero);                    int neededBufferSize = 0;                    // Retrieve the user info from the current thread's token                  // First' determine how big a buffer we need.                  bool success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          IntPtr.Zero'                                          0'                                          ref neededBufferSize);                    int getTokenInfoError = 0;                  if ((getTokenInfoError = Marshal.GetLastWin32Error()) != 122) // ERROR_INSUFFICIENT_BUFFER                  {                      throw new InvalidOperationException(                                      SR.Format(SR.UnableToRetrieveTokenInfo' getTokenInfoError));                  }                    // Allocate the necessary buffer.                  Debug.Assert(neededBufferSize > 0);                  pBuffer = Marshal.AllocHGlobal(neededBufferSize);                    // Load the user info into the buffer                  success = UnsafeNativeMethods.GetTokenInformation(                                          pTokenHandle'                                          1'   // TokenUser                                          pBuffer'                                          neededBufferSize'                                          ref neededBufferSize);                    if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      throw new InvalidOperationException(                                      SR.Format(SR.UnableToRetrieveTokenInfo' lastError));                  }                    // Retrieve the user's SID from the user info                  TOKEN_USER tokenUser = (TOKEN_USER)Marshal.PtrToStructure(pBuffer' typeof(TOKEN_USER));                  IntPtr pUserSid = tokenUser.sidAndAttributes.pSid;   // this is a reference into the NATIVE memory (into pBuffer)                    Debug.Assert(UnsafeNativeMethods.IsValidSid(pUserSid));                    // Now we make a copy of the SID to return                  int userSidLength = UnsafeNativeMethods.GetLengthSid(pUserSid);                  IntPtr pCopyOfUserSid = Marshal.AllocHGlobal(userSidLength);                  success = UnsafeNativeMethods.CopySid(userSidLength' pCopyOfUserSid' pUserSid);                  if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      throw new InvalidOperationException(                                      SR.Format(SR.UnableToRetrieveTokenInfo' lastError));                  }                    return pCopyOfUserSid;              }              finally              {                  if (pTokenHandle != IntPtr.Zero)                      UnsafeNativeMethods.CloseHandle(pTokenHandle);                    if (pBuffer != IntPtr.Zero)                      Marshal.FreeHGlobal(pBuffer);              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,GetMachineDomainSid,The following statement contains a magic number: try              {                  LSA_OBJECT_ATTRIBUTES oa = new LSA_OBJECT_ATTRIBUTES();                    pOA = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(LSA_OBJECT_ATTRIBUTES)));                  Marshal.StructureToPtr(oa' pOA' false);                  int err = UnsafeNativeMethods.LsaOpenPolicy(                                  IntPtr.Zero'                                  pOA'                                  1'          // POLICY_VIEW_LOCAL_INFORMATION                                  ref pPolicyHandle);                    if (err != 0)                  {                      throw new InvalidOperationException(SR.Format(SR.UnableToRetrievePolicy' NativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pPolicyHandle != IntPtr.Zero);                  err = UnsafeNativeMethods.LsaQueryInformationPolicy(                                  pPolicyHandle'                                  5'              // PolicyAccountDomainInformation                                  ref pBuffer);                    if (err != 0)                  {                      throw new InvalidOperationException(SR.Format(SR.UnableToRetrievePolicy' NativeMethods.LsaNtStatusToWinError(err)));                  }                    Debug.Assert(pBuffer != IntPtr.Zero);                  POLICY_ACCOUNT_DOMAIN_INFO info = (POLICY_ACCOUNT_DOMAIN_INFO)                                      Marshal.PtrToStructure(pBuffer' typeof(POLICY_ACCOUNT_DOMAIN_INFO));                    Debug.Assert(UnsafeNativeMethods.IsValidSid(info.domainSid));                    // Now we make a copy of the SID to return                  int sidLength = UnsafeNativeMethods.GetLengthSid(info.domainSid);                  IntPtr pCopyOfSid = Marshal.AllocHGlobal(sidLength);                  bool success = UnsafeNativeMethods.CopySid(sidLength' pCopyOfSid' info.domainSid);                  if (!success)                  {                      int lastError = Marshal.GetLastWin32Error();                      throw new InvalidOperationException(                                      SR.Format(SR.UnableToRetrievePolicy' lastError));                  }                    return pCopyOfSid;              }              finally              {                  if (pPolicyHandle != IntPtr.Zero)                      UnsafeNativeMethods.LsaClose(pPolicyHandle);                    if (pBuffer != IntPtr.Zero)                      UnsafeNativeMethods.LsaFreeMemory(pBuffer);                    if (pOA != IntPtr.Zero)                      Marshal.FreeHGlobal(pOA);              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,ClassifySID,The following statement contains a magic number: if (!(identAuth.b1 == 0) &&                    (identAuth.b2 == 0) &&                    (identAuth.b3 == 0) &&                    (identAuth.b4 == 0) &&                    (identAuth.b5 == 0) &&                    (identAuth.b6 == 5))              {                  // No' so it can't be an account or builtin SID.                  // Probably something like \Everyone or \LOCAL.                  return SidType.FakeObject;              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,ClassifySID,The following statement contains a magic number: switch (rid)              {                  case 21:                      // Account SID                      return SidType.RealObject;                    case 32:                      // BUILTIN SID                      return SidType.RealObjectFakeDomain;                    default:                      return SidType.FakeObject;              }
Magic Number,System.DirectoryServices.ActiveDirectory,Utils,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\ActiveDirectory\Utils.cs,ClassifySID,The following statement contains a magic number: switch (rid)              {                  case 21:                      // Account SID                      return SidType.RealObject;                    case 32:                      // BUILTIN SID                      return SidType.RealObjectFakeDomain;                    default:                      return SidType.FakeObject;              }
Magic Number,System.DirectoryServices.Interop,AdsValueHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\AdsValueHelper2.cs,GetValue,The following statement contains a magic number: switch ((AdsType)adsvalue.dwType)              {                  // Common for DNS and LDAP.                  case AdsType.ADSTYPE_UTC_TIME:                      {                          var st = new SystemTime()                          {                              wYear = LowOfInt(adsvalue.generic.a)'                              wMonth = HighOfInt(adsvalue.generic.a)'                              wDayOfWeek = LowOfInt(adsvalue.generic.b)'                              wDay = HighOfInt(adsvalue.generic.b)'                              wHour = LowOfInt(adsvalue.generic.c)'                              wMinute = HighOfInt(adsvalue.generic.c)'                              wSecond = LowOfInt(adsvalue.generic.d)'                              wMilliseconds = HighOfInt(adsvalue.generic.d)                          };                            return new DateTime(st.wYear' st.wMonth' st.wDay' st.wHour' st.wMinute' st.wSecond' st.wMilliseconds);                      }                    case AdsType.ADSTYPE_DN_WITH_BINARY:                      {                          var dnb = new DnWithBinary();                          Marshal.PtrToStructure(adsvalue.pointer.value' dnb);                            byte[] bytes = new byte[dnb.dwLength];                          Marshal.Copy(dnb.lpBinaryValue' bytes' 0' dnb.dwLength);                            var strb = new StringBuilder();                          var binaryPart = new StringBuilder();                          for (int i = 0; i < bytes.Length; i++)                          {                              string s = bytes[i].ToString("X"' CultureInfo.InvariantCulture);                              if (s.Length == 1)                              {                                  binaryPart.Append("0");                              }                                binaryPart.Append(s);                          }                            strb.Append("B:");                          strb.Append(binaryPart.Length);                          strb.Append(":");                          strb.Append(binaryPart.ToString());                          strb.Append(":");                          strb.Append(Marshal.PtrToStringUni(dnb.pszDNString));                            return strb.ToString();                      }                    case AdsType.ADSTYPE_DN_WITH_STRING:                      {                          var dns = new DnWithString();                          Marshal.PtrToStructure(adsvalue.pointer.value' dns);                          string strValue = Marshal.PtrToStringUni(dns.pszStringValue) ?? string.Empty;                            var strb = new StringBuilder();                          strb.Append("S:");                          strb.Append(strValue.Length);                          strb.Append(":");                          strb.Append(strValue);                          strb.Append(":");                          strb.Append(Marshal.PtrToStringUni(dns.pszDNString));                            return strb.ToString();                      }                    case AdsType.ADSTYPE_DN_STRING:                  case AdsType.ADSTYPE_CASE_EXACT_STRING:                  case AdsType.ADSTYPE_CASE_IGNORE_STRING:                  case AdsType.ADSTYPE_PRINTABLE_STRING:                  case AdsType.ADSTYPE_NUMERIC_STRING:                  case AdsType.ADSTYPE_OBJECT_CLASS:                      // The value is a String.                      return Marshal.PtrToStringUni(adsvalue.pointer.value);                    case AdsType.ADSTYPE_BOOLEAN:                      // The value is a bool.                      return adsvalue.generic.a != 0;                    case AdsType.ADSTYPE_INTEGER:                      // The value is an int.                      return adsvalue.generic.a;                    case AdsType.ADSTYPE_NT_SECURITY_DESCRIPTOR:                  case AdsType.ADSTYPE_OCTET_STRING:                  case AdsType.ADSTYPE_PROV_SPECIFIC:                      // The value is a byte[].                      int len = adsvalue.octetString.length;                      byte[] value = new byte[len];                      Marshal.Copy(adsvalue.octetString.value' value' 0' len);                      return value;                    case AdsType.ADSTYPE_INVALID:                      throw new InvalidOperationException(SR.DSConvertTypeInvalid);                    case AdsType.ADSTYPE_LARGE_INTEGER:                      return LowInt64;                    // Not used in LDAP                  case AdsType.ADSTYPE_CASEIGNORE_LIST:                  case AdsType.ADSTYPE_OCTET_LIST:                  case AdsType.ADSTYPE_PATH:                  case AdsType.ADSTYPE_POSTALADDRESS:                  case AdsType.ADSTYPE_TIMESTAMP:                  case AdsType.ADSTYPE_NETADDRESS:                  case AdsType.ADSTYPE_FAXNUMBER:                  case AdsType.ADSTYPE_EMAIL:                    case AdsType.ADSTYPE_BACKLINK:                  case AdsType.ADSTYPE_HOLD:                  case AdsType.ADSTYPE_TYPEDNAME:                  case AdsType.ADSTYPE_REPLICAPOINTER:                  case AdsType.ADSTYPE_UNKNOWN:                      return new NotImplementedException(SR.Format(SR.DSAdsvalueTypeNYI ' "0x" + Convert.ToString(adsvalue.dwType' 16)));                    default:                      return new ArgumentException(SR.Format(SR.DSConvertFailed ' "0x" + Convert.ToString(LowInt64' 16)' "0x" + Convert.ToString(adsvalue.dwType' 16)));              }
Magic Number,System.DirectoryServices.Interop,AdsValueHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\AdsValueHelper2.cs,GetValue,The following statement contains a magic number: switch ((AdsType)adsvalue.dwType)              {                  // Common for DNS and LDAP.                  case AdsType.ADSTYPE_UTC_TIME:                      {                          var st = new SystemTime()                          {                              wYear = LowOfInt(adsvalue.generic.a)'                              wMonth = HighOfInt(adsvalue.generic.a)'                              wDayOfWeek = LowOfInt(adsvalue.generic.b)'                              wDay = HighOfInt(adsvalue.generic.b)'                              wHour = LowOfInt(adsvalue.generic.c)'                              wMinute = HighOfInt(adsvalue.generic.c)'                              wSecond = LowOfInt(adsvalue.generic.d)'                              wMilliseconds = HighOfInt(adsvalue.generic.d)                          };                            return new DateTime(st.wYear' st.wMonth' st.wDay' st.wHour' st.wMinute' st.wSecond' st.wMilliseconds);                      }                    case AdsType.ADSTYPE_DN_WITH_BINARY:                      {                          var dnb = new DnWithBinary();                          Marshal.PtrToStructure(adsvalue.pointer.value' dnb);                            byte[] bytes = new byte[dnb.dwLength];                          Marshal.Copy(dnb.lpBinaryValue' bytes' 0' dnb.dwLength);                            var strb = new StringBuilder();                          var binaryPart = new StringBuilder();                          for (int i = 0; i < bytes.Length; i++)                          {                              string s = bytes[i].ToString("X"' CultureInfo.InvariantCulture);                              if (s.Length == 1)                              {                                  binaryPart.Append("0");                              }                                binaryPart.Append(s);                          }                            strb.Append("B:");                          strb.Append(binaryPart.Length);                          strb.Append(":");                          strb.Append(binaryPart.ToString());                          strb.Append(":");                          strb.Append(Marshal.PtrToStringUni(dnb.pszDNString));                            return strb.ToString();                      }                    case AdsType.ADSTYPE_DN_WITH_STRING:                      {                          var dns = new DnWithString();                          Marshal.PtrToStructure(adsvalue.pointer.value' dns);                          string strValue = Marshal.PtrToStringUni(dns.pszStringValue) ?? string.Empty;                            var strb = new StringBuilder();                          strb.Append("S:");                          strb.Append(strValue.Length);                          strb.Append(":");                          strb.Append(strValue);                          strb.Append(":");                          strb.Append(Marshal.PtrToStringUni(dns.pszDNString));                            return strb.ToString();                      }                    case AdsType.ADSTYPE_DN_STRING:                  case AdsType.ADSTYPE_CASE_EXACT_STRING:                  case AdsType.ADSTYPE_CASE_IGNORE_STRING:                  case AdsType.ADSTYPE_PRINTABLE_STRING:                  case AdsType.ADSTYPE_NUMERIC_STRING:                  case AdsType.ADSTYPE_OBJECT_CLASS:                      // The value is a String.                      return Marshal.PtrToStringUni(adsvalue.pointer.value);                    case AdsType.ADSTYPE_BOOLEAN:                      // The value is a bool.                      return adsvalue.generic.a != 0;                    case AdsType.ADSTYPE_INTEGER:                      // The value is an int.                      return adsvalue.generic.a;                    case AdsType.ADSTYPE_NT_SECURITY_DESCRIPTOR:                  case AdsType.ADSTYPE_OCTET_STRING:                  case AdsType.ADSTYPE_PROV_SPECIFIC:                      // The value is a byte[].                      int len = adsvalue.octetString.length;                      byte[] value = new byte[len];                      Marshal.Copy(adsvalue.octetString.value' value' 0' len);                      return value;                    case AdsType.ADSTYPE_INVALID:                      throw new InvalidOperationException(SR.DSConvertTypeInvalid);                    case AdsType.ADSTYPE_LARGE_INTEGER:                      return LowInt64;                    // Not used in LDAP                  case AdsType.ADSTYPE_CASEIGNORE_LIST:                  case AdsType.ADSTYPE_OCTET_LIST:                  case AdsType.ADSTYPE_PATH:                  case AdsType.ADSTYPE_POSTALADDRESS:                  case AdsType.ADSTYPE_TIMESTAMP:                  case AdsType.ADSTYPE_NETADDRESS:                  case AdsType.ADSTYPE_FAXNUMBER:                  case AdsType.ADSTYPE_EMAIL:                    case AdsType.ADSTYPE_BACKLINK:                  case AdsType.ADSTYPE_HOLD:                  case AdsType.ADSTYPE_TYPEDNAME:                  case AdsType.ADSTYPE_REPLICAPOINTER:                  case AdsType.ADSTYPE_UNKNOWN:                      return new NotImplementedException(SR.Format(SR.DSAdsvalueTypeNYI ' "0x" + Convert.ToString(adsvalue.dwType' 16)));                    default:                      return new ArgumentException(SR.Format(SR.DSConvertFailed ' "0x" + Convert.ToString(LowInt64' 16)' "0x" + Convert.ToString(adsvalue.dwType' 16)));              }
Magic Number,System.DirectoryServices.Interop,AdsValueHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\AdsValueHelper2.cs,GetValue,The following statement contains a magic number: switch ((AdsType)adsvalue.dwType)              {                  // Common for DNS and LDAP.                  case AdsType.ADSTYPE_UTC_TIME:                      {                          var st = new SystemTime()                          {                              wYear = LowOfInt(adsvalue.generic.a)'                              wMonth = HighOfInt(adsvalue.generic.a)'                              wDayOfWeek = LowOfInt(adsvalue.generic.b)'                              wDay = HighOfInt(adsvalue.generic.b)'                              wHour = LowOfInt(adsvalue.generic.c)'                              wMinute = HighOfInt(adsvalue.generic.c)'                              wSecond = LowOfInt(adsvalue.generic.d)'                              wMilliseconds = HighOfInt(adsvalue.generic.d)                          };                            return new DateTime(st.wYear' st.wMonth' st.wDay' st.wHour' st.wMinute' st.wSecond' st.wMilliseconds);                      }                    case AdsType.ADSTYPE_DN_WITH_BINARY:                      {                          var dnb = new DnWithBinary();                          Marshal.PtrToStructure(adsvalue.pointer.value' dnb);                            byte[] bytes = new byte[dnb.dwLength];                          Marshal.Copy(dnb.lpBinaryValue' bytes' 0' dnb.dwLength);                            var strb = new StringBuilder();                          var binaryPart = new StringBuilder();                          for (int i = 0; i < bytes.Length; i++)                          {                              string s = bytes[i].ToString("X"' CultureInfo.InvariantCulture);                              if (s.Length == 1)                              {                                  binaryPart.Append("0");                              }                                binaryPart.Append(s);                          }                            strb.Append("B:");                          strb.Append(binaryPart.Length);                          strb.Append(":");                          strb.Append(binaryPart.ToString());                          strb.Append(":");                          strb.Append(Marshal.PtrToStringUni(dnb.pszDNString));                            return strb.ToString();                      }                    case AdsType.ADSTYPE_DN_WITH_STRING:                      {                          var dns = new DnWithString();                          Marshal.PtrToStructure(adsvalue.pointer.value' dns);                          string strValue = Marshal.PtrToStringUni(dns.pszStringValue) ?? string.Empty;                            var strb = new StringBuilder();                          strb.Append("S:");                          strb.Append(strValue.Length);                          strb.Append(":");                          strb.Append(strValue);                          strb.Append(":");                          strb.Append(Marshal.PtrToStringUni(dns.pszDNString));                            return strb.ToString();                      }                    case AdsType.ADSTYPE_DN_STRING:                  case AdsType.ADSTYPE_CASE_EXACT_STRING:                  case AdsType.ADSTYPE_CASE_IGNORE_STRING:                  case AdsType.ADSTYPE_PRINTABLE_STRING:                  case AdsType.ADSTYPE_NUMERIC_STRING:                  case AdsType.ADSTYPE_OBJECT_CLASS:                      // The value is a String.                      return Marshal.PtrToStringUni(adsvalue.pointer.value);                    case AdsType.ADSTYPE_BOOLEAN:                      // The value is a bool.                      return adsvalue.generic.a != 0;                    case AdsType.ADSTYPE_INTEGER:                      // The value is an int.                      return adsvalue.generic.a;                    case AdsType.ADSTYPE_NT_SECURITY_DESCRIPTOR:                  case AdsType.ADSTYPE_OCTET_STRING:                  case AdsType.ADSTYPE_PROV_SPECIFIC:                      // The value is a byte[].                      int len = adsvalue.octetString.length;                      byte[] value = new byte[len];                      Marshal.Copy(adsvalue.octetString.value' value' 0' len);                      return value;                    case AdsType.ADSTYPE_INVALID:                      throw new InvalidOperationException(SR.DSConvertTypeInvalid);                    case AdsType.ADSTYPE_LARGE_INTEGER:                      return LowInt64;                    // Not used in LDAP                  case AdsType.ADSTYPE_CASEIGNORE_LIST:                  case AdsType.ADSTYPE_OCTET_LIST:                  case AdsType.ADSTYPE_PATH:                  case AdsType.ADSTYPE_POSTALADDRESS:                  case AdsType.ADSTYPE_TIMESTAMP:                  case AdsType.ADSTYPE_NETADDRESS:                  case AdsType.ADSTYPE_FAXNUMBER:                  case AdsType.ADSTYPE_EMAIL:                    case AdsType.ADSTYPE_BACKLINK:                  case AdsType.ADSTYPE_HOLD:                  case AdsType.ADSTYPE_TYPEDNAME:                  case AdsType.ADSTYPE_REPLICAPOINTER:                  case AdsType.ADSTYPE_UNKNOWN:                      return new NotImplementedException(SR.Format(SR.DSAdsvalueTypeNYI ' "0x" + Convert.ToString(adsvalue.dwType' 16)));                    default:                      return new ArgumentException(SR.Format(SR.DSConvertFailed ' "0x" + Convert.ToString(LowInt64' 16)' "0x" + Convert.ToString(adsvalue.dwType' 16)));              }
Magic Number,System.DirectoryServices.Interop,AdsValueHelper,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\Interop\AdsValueHelper2.cs,SetValue,The following statement contains a magic number: switch (adsType)              {                  case AdsType.ADSTYPE_INTEGER:                      adsvalue.generic.a = (int)managedValue;                      adsvalue.generic.b = 0;                      break;                  case AdsType.ADSTYPE_LARGE_INTEGER:                      LowInt64 = (long)managedValue;                      break;                  case AdsType.ADSTYPE_BOOLEAN:                      LowInt64 = (bool)managedValue ? -1 : 0;                      break;                  case AdsType.ADSTYPE_CASE_IGNORE_STRING:                      _pinnedHandle = GCHandle.Alloc(managedValue' GCHandleType.Pinned);                      adsvalue.pointer.value = _pinnedHandle.AddrOfPinnedObject();                      break;                  case AdsType.ADSTYPE_PROV_SPECIFIC:                      byte[] bytes = (byte[])managedValue;                      // Filling in an ADS_PROV_SPECIFIC struct.                      // 1st dword (our member a) is DWORD dwLength.                      // 2nd dword (our member b) is byte *lpValue.                      adsvalue.octetString.length = bytes.Length;                      _pinnedHandle = GCHandle.Alloc(bytes' GCHandleType.Pinned);                      adsvalue.octetString.value = _pinnedHandle.AddrOfPinnedObject();                      break;                  default:                      throw new NotImplementedException(SR.Format(SR.DSAdsvalueTypeNYI ' "0x" + Convert.ToString((int)adsType' 16)));              }
Missing Default,System.DirectoryServices,DirectorySearcher,C:\selectedRepos\dotnet_corefx\src\System.DirectoryServices\src\System\DirectoryServices\DirectorySearcher.cs,DoSetSearchPrefs,The following switch statement is missing a default case: switch (prefIndex)                          {                              case (int)AdsSearchPreferences.SEARCH_SCOPE:                                  property = "SearchScope";                                  break;                              case (int)AdsSearchPreferences.SIZE_LIMIT:                                  property = "SizeLimit";                                  break;                              case (int)AdsSearchPreferences.TIME_LIMIT:                                  property = "ServerTimeLimit";                                  break;                              case (int)AdsSearchPreferences.ATTRIBTYPES_ONLY:                                  property = "PropertyNamesOnly";                                  break;                              case (int)AdsSearchPreferences.TIMEOUT:                                  property = "ClientTimeout";                                  break;                              case (int)AdsSearchPreferences.PAGESIZE:                                  property = "PageSize";                                  break;                              case (int)AdsSearchPreferences.PAGED_TIME_LIMIT:                                  property = "ServerPageTimeLimit";                                  break;                              case (int)AdsSearchPreferences.CHASE_REFERRALS:                                  property = "ReferralChasing";                                  break;                              case (int)AdsSearchPreferences.SORT_ON:                                  property = "Sort";                                  break;                              case (int)AdsSearchPreferences.CACHE_RESULTS:                                  property = "CacheResults";                                  break;                              case (int)AdsSearchPreferences.ASYNCHRONOUS:                                  property = "Asynchronous";                                  break;                              case (int)AdsSearchPreferences.TOMBSTONE:                                  property = "Tombstone";                                  break;                              case (int)AdsSearchPreferences.ATTRIBUTE_QUERY:                                  property = "AttributeScopeQuery";                                  break;                              case (int)AdsSearchPreferences.DEREF_ALIASES:                                  property = "DerefAlias";                                  break;                              case (int)AdsSearchPreferences.SECURITY_MASK:                                  property = "SecurityMasks";                                  break;                              case (int)AdsSearchPreferences.EXTENDED_DN:                                  property = "ExtendedDn";                                  break;                              case (int)AdsSearchPreferences.DIRSYNC:                                  property = "DirectorySynchronization";                                  break;                              case (int)AdsSearchPreferences.DIRSYNC_FLAG:                                  property = "DirectorySynchronizationFlag";                                  break;                              case (int)AdsSearchPreferences.VLV:                                  property = "VirtualListView";                                  break;                          }
