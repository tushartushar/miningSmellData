Implementation smell,Namespace,Class,File,Method,Description
Long Method,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The method has 101 lines of code.
Long Method,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The method has 106 lines of code.
Complex Method,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,Cyclomatic complexity of the method is 12
Long Parameter List,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,PasswordDeriveBytes,The method has 5 parameters. Parameters: strPassword' rgbSalt' strHashName' iterations' cspParams
Long Parameter List,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,PasswordDeriveBytes,The method has 5 parameters. Parameters: password' salt' hashName' iterations' cspParams
Long Statement,System.Security.Cryptography,MD5CryptoServiceProvider,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\MD5CryptoServiceProvider.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA1CryptoServiceProvider,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\SHA1CryptoServiceProvider.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA256CryptoServiceProvider,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\SHA256CryptoServiceProvider.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA384CryptoServiceProvider,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\SHA384CryptoServiceProvider.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,System.Security.Cryptography,SHA512CryptoServiceProvider,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\SHA512CryptoServiceProvider.cs,Initialize,The length of the statement  "            // reality that our native crypto providers (e.g. CNG) expose hash finalization and object reinitialization as an atomic operation. " is 131.
Long Statement,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The length of the statement  "            if (dsaParameters.P == null || dsaParameters.P.Length == 0 || dsaParameters.Q == null || dsaParameters.Q.Length != DSS_Q_LEN) " is 125.
Long Statement,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ReadKeyBlobHeader,The length of the statement  "            byte bType = br.ReadByte();    // BLOBHEADER.bType: Expected to be 0x6 (PUBLICKEYBLOB) or 0x7 (PRIVATEKEYBLOB)' though there's no check for backward compat reasons. " is 164.
Long Statement,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ReadKeyBlobHeader,The length of the statement  "            bVersion = br.ReadByte();      // BLOBHEADER.bVersion: Expected to be 0x2 or 0x3' though there's no check for backward compat reasons. " is 134.
Long Statement,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToRSAParameters,The length of the statement  "                byte bType = br.ReadByte();    // BLOBHEADER.bType: Expected to be 0x6 (PUBLICKEYBLOB) or 0x7 (PRIVATEKEYBLOB)' though there's no check for backward compat reasons.  " is 164.
Long Statement,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToRSAParameters,The length of the statement  "                byte bVersion = br.ReadByte(); // BLOBHEADER.bVersion: Expected to be 0x2' though there's no check for backward compat reasons. " is 127.
Long Statement,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToRSAParameters,The length of the statement  "                    throw new PlatformNotSupportedException();  // The FCall this code was ported from supports other algid's but we're only porting what we use. " is 141.
Complex Conditional,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The conditional expression  "dsaParameters.P == null || dsaParameters.P.Length == 0 || dsaParameters.Q == null || dsaParameters.Q.Length != DSS_Q_LEN"  is complex.
Complex Conditional,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,WriteKeyBlobHeader,The conditional expression  "((dsaParameters.Y != null) && isPrivate) ||                  ((dsaParameters.Y != null) && (dsaParameters.J != null))"  is complex.
Magic Number,System.Security.Cryptography,AesCryptoServiceProvider,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\AesCryptoServiceProvider.cs,AesCryptoServiceProvider,The following statement contains a magic number: _impl.FeedbackSize = 8;
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,ComputeBytes,The following statement contains a magic number: cbHash = _hash.HashSize / 8;
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,HashPrefix,The following statement contains a magic number: if (_prefix > 999)                  throw new CryptographicException(SR.Cryptography_PasswordDerivedBytes_TooManyBytes);
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,HashPrefix,The following statement contains a magic number: if (_prefix >= 100)              {                  rgb[0] += (byte)(_prefix / 100);                  cb += 1;              }
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,HashPrefix,The following statement contains a magic number: if (_prefix >= 100)              {                  rgb[0] += (byte)(_prefix / 100);                  cb += 1;              }
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,HashPrefix,The following statement contains a magic number: if (_prefix >= 10)              {                  rgb[cb] += (byte)((_prefix % 100) / 10);                  cb += 1;              }
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,HashPrefix,The following statement contains a magic number: if (_prefix >= 10)              {                  rgb[cb] += (byte)((_prefix % 100) / 10);                  cb += 1;              }
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,HashPrefix,The following statement contains a magic number: if (_prefix >= 10)              {                  rgb[cb] += (byte)((_prefix % 100) / 10);                  cb += 1;              }
Magic Number,System.Security.Cryptography,PasswordDeriveBytes,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\PasswordDeriveBytes.cs,HashPrefix,The following statement contains a magic number: if (_prefix > 0)              {                  rgb[cb] += (byte)(_prefix % 10);                  cb += 1;                  cs.Write(rgb' 0' cb);              }
Magic Number,System.Security.Cryptography,TripleDESCryptoServiceProvider,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\TripleDESCryptoServiceProvider.cs,TripleDESCryptoServiceProvider,The following statement contains a magic number: _impl.FeedbackSize = 8;
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: if (dsaParameters.Seed != null && dsaParameters.Seed.Length != 20)                  throw GetBadDataException();
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: uint bitLenP = (uint)dsaParameters.P.Length * 8;
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: uint bitLenJ = dsaParameters.J == null ? 0 : (uint)dsaParameters.J.Length * 8;
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: using (var ms = new MemoryStream())              using (var bw = new BinaryWriter(ms))              {                  // Write out the BLOBHEADER                  bool isV3;                  WriteKeyBlobHeader(dsaParameters' bw' isPrivate' out isV3);                    // Write out the DSA key                  if (isV3)                  {                      // We need to build a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                      //  DWORD           magic                      //  DWORD           bitlenP                      //  DWORD           bitlenQ                      //  DWORD           bitlenJ                      //  DWORD           bitlenX (if private)                      //  DWORD           counter (DSSSEED)                      //  BYTE[20]        seed (DSSSEED)                      //  BYTE[lenP]      P                      //  BYTE[lenQ]      Q                      //  BYTE[lenP]      G                      //  BYTE[lenJ]      J (optional)                      //  BYTE[lenP]      Y                      //  BYTE[lenX]      X (if private)                        bw.Write((int)(isPrivate ? DSS_PRIV_MAGIC_VER3 : DSS_PUB_MAGIC_VER3));                      bw.Write((uint)(bitLenP));                      bw.Write((uint)(dsaParameters.Q.Length * 8));                      bw.Write((uint)(bitLenJ));                        if (isPrivate)                      {                          bw.Write((uint)dsaParameters.X.Length * 8);                      }                        WriteDSSSeed(dsaParameters' bw);                        bw.WriteReversed(dsaParameters.P);                      bw.WriteReversed(dsaParameters.Q);                      bw.WriteReversed(dsaParameters.G);                        if (bitLenJ != 0)                      {                          bw.WriteReversed(dsaParameters.J);                      }                        bw.WriteReversed(dsaParameters.Y);                        if (isPrivate)                      {                          bw.WriteReversed(dsaParameters.X);                      }                  }                  else                  {                      // We need to build a key blob as follows:                      //  DWORD           magic (DSSPUBKEY)                      //  DWORD           bitlen (DSSPUBKEY)                      //  BYTE[len]       P                      //  BYTE[DSS_Q_LEN] Q                      //  BYTE[len]       G                      //  BYTE[20]        X (if private)                      //  BYTE[len]       Y (if public)                      //  DWORD           counter (DSSSEED)                      //  BYTE[20]        seed (DSSSEED)                        bw.Write((int)(isPrivate ? DSS_PRIVATE_MAGIC : DSS_MAGIC));                      bw.Write((uint)(bitLenP));                      bw.WriteReversed(dsaParameters.P);                      bw.WriteReversed(dsaParameters.Q);                      bw.WriteReversed(dsaParameters.G);                        if (isPrivate)                      {                          bw.WriteReversed(dsaParameters.X);                      }                      else                      {                          bw.WriteReversed(dsaParameters.Y);                      }                        WriteDSSSeed(dsaParameters' bw);                  }                    bw.Flush();                  byte[] key = ms.ToArray();                  return key;              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: using (var ms = new MemoryStream())              using (var bw = new BinaryWriter(ms))              {                  // Write out the BLOBHEADER                  bool isV3;                  WriteKeyBlobHeader(dsaParameters' bw' isPrivate' out isV3);                    // Write out the DSA key                  if (isV3)                  {                      // We need to build a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                      //  DWORD           magic                      //  DWORD           bitlenP                      //  DWORD           bitlenQ                      //  DWORD           bitlenJ                      //  DWORD           bitlenX (if private)                      //  DWORD           counter (DSSSEED)                      //  BYTE[20]        seed (DSSSEED)                      //  BYTE[lenP]      P                      //  BYTE[lenQ]      Q                      //  BYTE[lenP]      G                      //  BYTE[lenJ]      J (optional)                      //  BYTE[lenP]      Y                      //  BYTE[lenX]      X (if private)                        bw.Write((int)(isPrivate ? DSS_PRIV_MAGIC_VER3 : DSS_PUB_MAGIC_VER3));                      bw.Write((uint)(bitLenP));                      bw.Write((uint)(dsaParameters.Q.Length * 8));                      bw.Write((uint)(bitLenJ));                        if (isPrivate)                      {                          bw.Write((uint)dsaParameters.X.Length * 8);                      }                        WriteDSSSeed(dsaParameters' bw);                        bw.WriteReversed(dsaParameters.P);                      bw.WriteReversed(dsaParameters.Q);                      bw.WriteReversed(dsaParameters.G);                        if (bitLenJ != 0)                      {                          bw.WriteReversed(dsaParameters.J);                      }                        bw.WriteReversed(dsaParameters.Y);                        if (isPrivate)                      {                          bw.WriteReversed(dsaParameters.X);                      }                  }                  else                  {                      // We need to build a key blob as follows:                      //  DWORD           magic (DSSPUBKEY)                      //  DWORD           bitlen (DSSPUBKEY)                      //  BYTE[len]       P                      //  BYTE[DSS_Q_LEN] Q                      //  BYTE[len]       G                      //  BYTE[20]        X (if private)                      //  BYTE[len]       Y (if public)                      //  DWORD           counter (DSSSEED)                      //  BYTE[20]        seed (DSSSEED)                        bw.Write((int)(isPrivate ? DSS_PRIVATE_MAGIC : DSS_MAGIC));                      bw.Write((uint)(bitLenP));                      bw.WriteReversed(dsaParameters.P);                      bw.WriteReversed(dsaParameters.Q);                      bw.WriteReversed(dsaParameters.G);                        if (isPrivate)                      {                          bw.WriteReversed(dsaParameters.X);                      }                      else                      {                          bw.WriteReversed(dsaParameters.Y);                      }                        WriteDSSSeed(dsaParameters' bw);                  }                    bw.Flush();                  byte[] key = ms.ToArray();                  return key;              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToDSAParameters,The following statement contains a magic number: try              {                  using (var ms = new MemoryStream(cspBlob))                  using (var br = new BinaryReader(ms))                  {                      byte bVersion;                      ReadKeyBlobHeader(br' out bVersion);                        DSAParameters dsaParameters = new DSAParameters();                        if (bVersion > 2)                      {                          Debug.Assert(cspPublicBlob == null);                            // We need to read a key blob (DSSPUBKEY_VER3 or DSSPRIVKEY_VER3) as follows:                          //  DWORD           magic                          //  DWORD           bitlenP                          //  DWORD           bitlenQ                          //  DWORD           bitlenJ                          //  DWORD           bitlenX (if private)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                          //  BYTE[lenP]      P                          //  BYTE[lenQ]      Q                          //  BYTE[lenP]      G                          //  BYTE[lenJ]      J (optional)                          //  BYTE[lenP]      Y                          //  BYTE[lenX]      X (if private)                            int magic = br.ReadInt32(); // Expected to be DSS_PUB_MAGIC_VER3 or DSS_PRIV_MAGIC_VER3                          int lenP = (br.ReadInt32() + 7) / 8;                          int lenQ = (br.ReadInt32() + 7) / 8;                          int lenJ = (br.ReadInt32() + 7) / 8;                            int lenX = 0;                          if (includePrivateParameters)                          {                              lenX = (br.ReadInt32() + 7) / 8;                          }                            ReadDSSSeed(dsaParameters' br' true);                            dsaParameters.P = br.ReadReversed(lenP);                          dsaParameters.Q = br.ReadReversed(lenQ);                          dsaParameters.G = br.ReadReversed(lenP);                            if (lenJ > 0)                          {                              dsaParameters.J = br.ReadReversed(lenJ);                          }                            dsaParameters.Y = br.ReadReversed(lenP);                            if (includePrivateParameters)                          {                              dsaParameters.X = br.ReadReversed(lenX);                          }                      }                      else                      {                          // We need to read a key blob as follows:                          //  DWORD           magic (DSSPUBKEY)                          //  DWORD           bitlen (DSSPUBKEY)                          //  BYTE[len]       P                          //  BYTE[DSS_Q_LEN] Q                          //  BYTE[len]       G                          //  BYTE[20]        X (if private)                          //  BYTE[len]       Y (if public)                          //  DWORD           counter (DSSSEED)                          //  BYTE[20]        seed (DSSSEED)                            int magic = br.ReadInt32();    // Expected to be DSS_MAGIC or DSS_PRIVATE_MAGIC                          int len = (br.ReadInt32() + 7) / 8;                          dsaParameters.P = br.ReadReversed(len);                          dsaParameters.Q = br.ReadReversed(DSS_Q_LEN);                          dsaParameters.G = br.ReadReversed(len);                            long keyLocation = 0;                          if (includePrivateParameters)                          {                              // Save the position of the stream for later access to Y.                              keyLocation = br.BaseStream.Position;                              dsaParameters.X = br.ReadReversed(20);                          }                          else                              dsaParameters.Y = br.ReadReversed(len);                            ReadDSSSeed(dsaParameters' br' false);                            if (includePrivateParameters)                          {                              // If a previous call to CAPI returned a v2 private blob' which was then passed                              // to ImportCspBlob(byte[] keyBlob) under Unix then that is not supported.                              // Only Unix calls ToDSAParameters from ImportCspBlob; Windows imports directly via CAPI.                              // This can only happen if a v2 private blob was obtained directly through                              // CAPI and saved away for later use' because exporting a private blob with ExportCspBlob                              // will always export a v3 blob which contains both public and private keys.                              if (cspPublicBlob == null)                                  throw new CryptographicUnexpectedOperationException();                                // Since DSSPUBKEY is used for either public or private key' we got X                              // but not Y. To get Y' use the public key blob.                              using (var msPublicBlob = new MemoryStream(cspPublicBlob))                              using (var brPublicBlob = new BinaryReader(msPublicBlob))                              {                                  brPublicBlob.BaseStream.Position = keyLocation;                                  dsaParameters.Y = brPublicBlob.ReadReversed(len);                              }                          }                      }                        return dsaParameters;                  }              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ReadDSSSeed,The following statement contains a magic number: if (hasSeed)              {                  dsaParameters.Counter = counter;                  dsaParameters.Seed = br.ReadReversed(20);              }              else              {                  dsaParameters.Counter = 0;                  dsaParameters.Seed = null;                  br.BaseStream.Position += 20; // Advance past seed[20]              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ReadDSSSeed,The following statement contains a magic number: if (hasSeed)              {                  dsaParameters.Counter = counter;                  dsaParameters.Seed = br.ReadReversed(20);              }              else              {                  dsaParameters.Counter = 0;                  dsaParameters.Seed = null;                  br.BaseStream.Position += 20; // Advance past seed[20]              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,WriteDSSSeed,The following statement contains a magic number: if (dsaParameters.Seed == null || dsaParameters.Seed.Length == 0)              {                  bw.Write(0xFFFFFFFF); // counter                    // seed[20] needs to be all 0xFF                  for (int i = 0; i < 20; i += sizeof(uint))                  {                      bw.Write(0xFFFFFFFF);                  }              }              else              {                  bw.Write((int)dsaParameters.Counter);                  bw.WriteReversed(dsaParameters.Seed);              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: if (rsaParameters.Exponent == null || rsaParameters.Exponent.Length > 4)                  throw GetBadDataException();
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: int halfModulusLength = (modulusLength + 1) / 2;
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: bw.Write((uint)(modulusLength * 8));
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToKeyBlob,The following statement contains a magic number: for (int i = 0; i < rsaParameters.Exponent.Length; i++)              {                  expAsDword <<= 8;                  expAsDword |= rsaParameters.Exponent[i];              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToRSAParameters,The following statement contains a magic number: try              {                  BinaryReader br = new BinaryReader(new MemoryStream(cspBlob));                    byte bType = br.ReadByte();    // BLOBHEADER.bType: Expected to be 0x6 (PUBLICKEYBLOB) or 0x7 (PRIVATEKEYBLOB)' though there's no check for backward compat reasons.                   byte bVersion = br.ReadByte(); // BLOBHEADER.bVersion: Expected to be 0x2' though there's no check for backward compat reasons.                  br.ReadUInt16();               // BLOBHEADER.wReserved                  int algId = br.ReadInt32();    // BLOBHEADER.aiKeyAlg                  if (algId != CALG_RSA_KEYX && algId != CALG_RSA_SIGN)                      throw new PlatformNotSupportedException();  // The FCall this code was ported from supports other algid's but we're only porting what we use.                    int magic = br.ReadInt32();    // RSAPubKey.magic: Expected to be 0x31415352 ('RSA1') or 0x32415352 ('RSA2')                   int bitLen = br.ReadInt32();   // RSAPubKey.bitLen                    int modulusLength = bitLen / 8;                  int halfModulusLength = (modulusLength + 1) / 2;                    uint expAsDword = br.ReadUInt32();                    RSAParameters rsaParameters = new RSAParameters();                  rsaParameters.Exponent = ExponentAsBytes(expAsDword);                  rsaParameters.Modulus = br.ReadReversed(modulusLength);                  if (includePrivateParameters)                  {                      rsaParameters.P = br.ReadReversed(halfModulusLength);                      rsaParameters.Q = br.ReadReversed(halfModulusLength);                      rsaParameters.DP = br.ReadReversed(halfModulusLength);                      rsaParameters.DQ = br.ReadReversed(halfModulusLength);                      rsaParameters.InverseQ = br.ReadReversed(halfModulusLength);                      rsaParameters.D = br.ReadReversed(modulusLength);                  }                    return rsaParameters;              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ToRSAParameters,The following statement contains a magic number: try              {                  BinaryReader br = new BinaryReader(new MemoryStream(cspBlob));                    byte bType = br.ReadByte();    // BLOBHEADER.bType: Expected to be 0x6 (PUBLICKEYBLOB) or 0x7 (PRIVATEKEYBLOB)' though there's no check for backward compat reasons.                   byte bVersion = br.ReadByte(); // BLOBHEADER.bVersion: Expected to be 0x2' though there's no check for backward compat reasons.                  br.ReadUInt16();               // BLOBHEADER.wReserved                  int algId = br.ReadInt32();    // BLOBHEADER.aiKeyAlg                  if (algId != CALG_RSA_KEYX && algId != CALG_RSA_SIGN)                      throw new PlatformNotSupportedException();  // The FCall this code was ported from supports other algid's but we're only porting what we use.                    int magic = br.ReadInt32();    // RSAPubKey.magic: Expected to be 0x31415352 ('RSA1') or 0x32415352 ('RSA2')                   int bitLen = br.ReadInt32();   // RSAPubKey.bitLen                    int modulusLength = bitLen / 8;                  int halfModulusLength = (modulusLength + 1) / 2;                    uint expAsDword = br.ReadUInt32();                    RSAParameters rsaParameters = new RSAParameters();                  rsaParameters.Exponent = ExponentAsBytes(expAsDword);                  rsaParameters.Modulus = br.ReadReversed(modulusLength);                  if (includePrivateParameters)                  {                      rsaParameters.P = br.ReadReversed(halfModulusLength);                      rsaParameters.Q = br.ReadReversed(halfModulusLength);                      rsaParameters.DP = br.ReadReversed(halfModulusLength);                      rsaParameters.DQ = br.ReadReversed(halfModulusLength);                      rsaParameters.InverseQ = br.ReadReversed(halfModulusLength);                      rsaParameters.D = br.ReadReversed(modulusLength);                  }                    return rsaParameters;              }              catch (EndOfStreamException)              {                  // For compat reasons' we throw an E_FAIL CrytoException if CAPI returns a smaller blob than expected.                  // For compat reasons' we ignore the extra bits if the CAPI returns a larger blob than expected.                  throw GetEFailException();              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,GetKeyBlobHeaderVersion,The following statement contains a magic number: if (cspBlob.Length < 8)                  throw new EndOfStreamException();
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ExponentAsBytes,The following statement contains a magic number: if (exponent <= 0xFF)              {                  return new[] { (byte)exponent };              }              else if (exponent <= 0xFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else if (exponent <= 0xFFFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 16)'                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else              {                  return new[]                  {                      (byte)(exponent >> 24)'                      (byte)(exponent >> 16)'                      (byte)(exponent >> 8)'                      (byte)(exponent)                  };              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ExponentAsBytes,The following statement contains a magic number: if (exponent <= 0xFF)              {                  return new[] { (byte)exponent };              }              else if (exponent <= 0xFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else if (exponent <= 0xFFFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 16)'                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else              {                  return new[]                  {                      (byte)(exponent >> 24)'                      (byte)(exponent >> 16)'                      (byte)(exponent >> 8)'                      (byte)(exponent)                  };              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ExponentAsBytes,The following statement contains a magic number: if (exponent <= 0xFF)              {                  return new[] { (byte)exponent };              }              else if (exponent <= 0xFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else if (exponent <= 0xFFFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 16)'                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else              {                  return new[]                  {                      (byte)(exponent >> 24)'                      (byte)(exponent >> 16)'                      (byte)(exponent >> 8)'                      (byte)(exponent)                  };              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ExponentAsBytes,The following statement contains a magic number: if (exponent <= 0xFF)              {                  return new[] { (byte)exponent };              }              else if (exponent <= 0xFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else if (exponent <= 0xFFFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 16)'                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else              {                  return new[]                  {                      (byte)(exponent >> 24)'                      (byte)(exponent >> 16)'                      (byte)(exponent >> 8)'                      (byte)(exponent)                  };              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ExponentAsBytes,The following statement contains a magic number: if (exponent <= 0xFF)              {                  return new[] { (byte)exponent };              }              else if (exponent <= 0xFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else if (exponent <= 0xFFFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 16)'                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else              {                  return new[]                  {                      (byte)(exponent >> 24)'                      (byte)(exponent >> 16)'                      (byte)(exponent >> 8)'                      (byte)(exponent)                  };              }
Magic Number,Internal.NativeCrypto,CapiHelper,C:\selectedRepos\dotnet_corefx\src\System.Security.Cryptography.Csp\src\System\Security\Cryptography\CapiHelper.DSA.Shared.cs,ExponentAsBytes,The following statement contains a magic number: if (exponent <= 0xFF)              {                  return new[] { (byte)exponent };              }              else if (exponent <= 0xFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else if (exponent <= 0xFFFFFF)              {                  unchecked                  {                      return new[]                      {                          (byte)(exponent >> 16)'                          (byte)(exponent >> 8)'                          (byte)(exponent)                      };                  }              }              else              {                  return new[]                  {                      (byte)(exponent >> 24)'                      (byte)(exponent >> 16)'                      (byte)(exponent >> 8)'                      (byte)(exponent)                  };              }
